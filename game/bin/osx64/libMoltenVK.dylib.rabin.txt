0)), insert_bits(0u, 0xFFFFFFFF, (uint)max((int
0.0 && 2.0
0.0 / 0.0
0.0f / 0.0f
0.0lf / 0.0lf
0.4375
00  P
0000000
0000000)H
0000pp
0123456789
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789ABCDEF
03256:;89=>@BDFHJ
08^0u>D
0; spvDummy
0<\rtc<\n
0@0 000
0@000
0@0p0@ P0 P
0@P pP@P0
0A8\\$0
0A8\\$0L
0A8]0
0A8^0
0A8^0u"D
0A8^0u%D
0A8^0u&D
0A8^0u'D
0A8^0u+D
0A8^0u,D
0A8^0uRD
0A8_0u)D
0Extent2DFromCGSize
0GLSLToSPIRVConverter
0H+{0H
0I;]8tvL
0I;|$8t
0IntValueFromVkComponentSwizzle
0L;p\btD
0M;g\bs
0P@Ppp0
0UIntValueFromVkComponentSwizzle
0\rt\t
0`0 0
0`0 00
0`@ 0
0`` ` @0p
0ffff
0fffff
0ffffff
0pP 0
0pPppPPp
0u, 0u
0x%08x, Revision %d
0x%llx%s
0x8000000000000000u
1 - 32, 0
1 - 32, 0)), uint2(0
1 - 32, 0), (uint)max((int
1 << gl_SampleID
1), uint3(0
1, 0)), insert_bits(0u, 0xFFFFFFFF, (uint)max((int
1, 32u)), extract_bits(0xFFFFFFFF, 0, (uint)max((int
1, 32u)), uint2(0
1, 32u), (uint)max(32 - (int
1, 32u), (uint)max(min((int
1, 32u), 0)), uint2(0
1.#IND
1.#INF
1.0 / 0.0
1.0f / 0.0f
1.0lf / 0.0lf
1/4 stride is too large
10MVKCmdDraw
10MVKCommand
10MVKSampler
10MVKSurface
110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_1NS_9allocatorIS4_EEFbjEEE
11MVKCmdQuery
11MVKInstance
11MVKPipeline
11MVKResource
11TIntermNode
11TUniformMap
128 lanes in an SIMD-group
12MVKDXTnCodec
12MVKImageView
12MVKQueryPool
12MVKSemaphore
12MVKSwapchain
12MVKWatermark
13MVKBaseObject
13MVKBufferView
13MVKDescriptor
13MVKImagePlane
13MVKObjectPoolI10MVKCmdDrawE
13MVKObjectPoolI14MVKCmdDispatchE
13MVKObjectPoolI14MVKCmdEndQueryE
13MVKObjectPoolI14MVKCmdSetEventE
13MVKObjectPoolI15MVKCmdBlitImageILm1EEE
13MVKObjectPoolI15MVKCmdBlitImageILm4EEE
13MVKObjectPoolI15MVKCmdCopyImageILm1EEE
13MVKObjectPoolI15MVKCmdCopyImageILm4EEE
13MVKObjectPoolI16MVKCmdBeginQueryE
13MVKObjectPoolI16MVKCmdCopyBufferILm1EEE
13MVKObjectPoolI16MVKCmdCopyBufferILm4EEE
13MVKObjectPoolI16MVKCmdFillBufferE
13MVKObjectPoolI16MVKCmdResetEventE
13MVKObjectPoolI16MVKCmdSetScissorILm16EEE
13MVKObjectPoolI16MVKCmdSetScissorILm1EEE
13MVKObjectPoolI16MVKCmdWaitEventsILm1EEE
13MVKObjectPoolI16MVKCmdWaitEventsILm8EEE
13MVKObjectPoolI16MVKCommandBufferE
13MVKObjectPoolI17MVKCmdDrawIndexedE
13MVKObjectPoolI17MVKCmdNextSubpassE
13MVKObjectPoolI17MVKCmdSetViewportILm16EEE
13MVKObjectPoolI17MVKCmdSetViewportILm1EEE
13MVKObjectPoolI18MVKCmdDrawIndirectE
13MVKObjectPoolI18MVKCmdEndRenderingE
13MVKObjectPoolI18MVKCmdResolveImageILm1EEE
13MVKObjectPoolI18MVKCmdResolveImageILm4EEE
13MVKObjectPoolI18MVKCmdSetDepthBiasE
13MVKObjectPoolI18MVKCmdSetLineWidthE
13MVKObjectPoolI18MVKCmdUpdateBufferE
13MVKObjectPoolI19MVKCmdEndRenderPassE
13MVKObjectPoolI19MVKCmdPushConstantsILm128EEE
13MVKObjectPoolI19MVKCmdPushConstantsILm512EEE
13MVKObjectPoolI19MVKCmdPushConstantsILm64EEE
13MVKObjectPoolI20MVKCmdBeginRenderingILm1EEE
13MVKObjectPoolI20MVKCmdBeginRenderingILm2EEE
13MVKObjectPoolI20MVKCmdBeginRenderingILm4EEE
13MVKObjectPoolI20MVKCmdBeginRenderingILm8EEE
13MVKObjectPoolI20MVKCmdDebugMarkerEndE
13MVKObjectPoolI20MVKCmdResetQueryPoolE
13MVKObjectPoolI20MVKCmdSetDepthBoundsE
13MVKObjectPoolI20MVKCmdWriteTimestampE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm1ELm0EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm1ELm1EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm1ELm2EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm1ELm9EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm2ELm0EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm2ELm1EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm2ELm2EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm2ELm9EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm9ELm0EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm9ELm1EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm9ELm2EEE
13MVKObjectPoolI21MVKCmdBeginRenderPassILm9ELm9EEE
13MVKObjectPoolI21MVKCmdBindIndexBufferE
13MVKObjectPoolI21MVKCmdBufferImageCopyILm16EEE
13MVKObjectPoolI21MVKCmdBufferImageCopyILm1EEE
13MVKObjectPoolI21MVKCmdBufferImageCopyILm4EEE
13MVKObjectPoolI21MVKCmdBufferImageCopyILm8EEE
13MVKObjectPoolI21MVKCmdClearColorImageILm1EEE
13MVKObjectPoolI21MVKCmdClearColorImageILm4EEE
13MVKObjectPoolI21MVKCmdExecuteCommandsILm16EEE
13MVKObjectPoolI21MVKCmdExecuteCommandsILm1EEE
13MVKObjectPoolI21MVKCmdPipelineBarrierILm1EEE
13MVKObjectPoolI21MVKCmdPipelineBarrierILm32EEE
13MVKObjectPoolI21MVKCmdPipelineBarrierILm4EEE
13MVKObjectPoolI22MVKCmdDebugMarkerBeginE
13MVKObjectPoolI22MVKCmdDispatchIndirectE
13MVKObjectPoolI22MVKMTLBufferAllocationE
13MVKObjectPoolI23MVKCmdBindVertexBuffersILm1EEE
13MVKObjectPoolI23MVKCmdBindVertexBuffersILm2EEE
13MVKObjectPoolI23MVKCmdBindVertexBuffersILm8EEE
13MVKObjectPoolI23MVKCmdDebugMarkerInsertE
13MVKObjectPoolI23MVKCmdPushDescriptorSetE
13MVKObjectPoolI23MVKCmdSetBlendConstantsE
13MVKObjectPoolI24MVKCmdSetSampleLocationsE
13MVKObjectPoolI25MVKCmdBindComputePipelineE
13MVKObjectPoolI25MVKCmdDrawIndexedIndirectE
13MVKObjectPoolI25MVKCmdSetStencilReferenceE
13MVKObjectPoolI25MVKCmdSetStencilWriteMaskE
13MVKObjectPoolI26MVKCmdBindGraphicsPipelineE
13MVKObjectPoolI26MVKCmdCopyQueryPoolResultsE
13MVKObjectPoolI27MVKCmdClearMultiAttachmentsILm1EEE
13MVKObjectPoolI27MVKCmdClearMultiAttachmentsILm4EEE
13MVKObjectPoolI27MVKCmdClearSingleAttachmentILm1EEE
13MVKObjectPoolI27MVKCmdClearSingleAttachmentILm4EEE
13MVKObjectPoolI27MVKCmdSetStencilCompareMaskE
13MVKObjectPoolI28MVKCmdClearDepthStencilImageILm1EEE
13MVKObjectPoolI28MVKCmdClearDepthStencilImageILm4EEE
13MVKObjectPoolI30MVKCmdBindDescriptorSetsStaticILm1EEE
13MVKObjectPoolI30MVKCmdBindDescriptorSetsStaticILm4EEE
13MVKObjectPoolI30MVKCmdBindDescriptorSetsStaticILm8EEE
13MVKObjectPoolI31MVKCmdBindDescriptorSetsDynamicILm4EEE
13MVKObjectPoolI31MVKCmdBindDescriptorSetsDynamicILm8EEE
13MVKObjectPoolI35MVKCmdPushDescriptorSetWithTemplateE
13MVKRenderPass
13TShHandleBase
147<?ACEGIK
14MVKCmdDispatch
14MVKCmdEndQuery
14MVKCmdSetEvent
14MVKCommandPool
14MVKEventNative
14MVKFenceSitter
14MVKFramebuffer
14MVKQueueFamily
14TGenericLinker
15MVKCmdBlitImageILm1EE
15MVKCmdBlitImageILm4EE
15MVKCmdCopyImageILm1EE
15MVKCmdCopyImageILm4EE
15MVKDeviceMemory
15MVKLayerManager
15MVKPixelFormats
15MVKShaderModule
15printMSLVersionEjb
16) | (uint
16-bit  literal
16-bit arrays not supported
16-bit hexadecimal literal
16-bit integer literal
16-bit literal
16-bit octal literal
16-bit signed integer
16-bit signed integer vector
16-bit unsigned integer
16-bit unsigned integer literal
16-bit unsigned integer vector
16-bit vectors only take vector types
16@0:8
16MVKCmdBeginQuery
16MVKCmdClearImageILm1EE
16MVKCmdClearImageILm4EE
16MVKCmdCopyBufferILm1EE
16MVKCmdCopyBufferILm4EE
16MVKCmdFillBuffer
16MVKCmdResetEvent
16MVKCmdSetScissorILm16EE
16MVKCmdSetScissorILm1EE
16MVKCmdWaitEventsILm1EE
16MVKCmdWaitEventsILm8EE
16MVKCommandBuffer
16MVKDescriptorSet
16MVKEventEmulated
16MVKExtensionList
16MVKLinkableMixinI10MVKCommandE
16MVKLinkableMixinI16MVKCommandBufferE
16MVKLinkableMixinI22MVKMTLBufferAllocationE
16MVKMetalCompiler
16MVKPipelineCache
16MVKRenderSubpass
16MVKSemaphoreImpl
16MVKShaderLibrary
16TGenericCompiler
17MVKCmdDebugMarker
17MVKCmdDrawIndexed
17MVKCmdNextSubpass
17MVKCmdSetViewportILm16EE
17MVKCmdSetViewportILm1EE
17MVKCommandEncoder
17MVKDescriptorPool
17MVKImageViewPlane
17MVKPhysicalDevice
17MVKPipelineLayout
17MVKSwapchainImage
17TUniformLinkedMap
18MVKCmdBindPipeline
18MVKCmdDrawIndirect
18MVKCmdEndRendering
18MVKCmdResolveImageILm1EE
18MVKCmdResolveImageILm4EE
18MVKCmdSetDepthBias
18MVKCmdSetLineWidth
18MVKCmdUpdateBuffer
18MVKCommandTypePoolI10MVKCmdDrawE
18MVKCommandTypePoolI14MVKCmdDispatchE
18MVKCommandTypePoolI14MVKCmdEndQueryE
18MVKCommandTypePoolI14MVKCmdSetEventE
18MVKCommandTypePoolI15MVKCmdBlitImageILm1EEE
18MVKCommandTypePoolI15MVKCmdBlitImageILm4EEE
18MVKCommandTypePoolI15MVKCmdCopyImageILm1EEE
18MVKCommandTypePoolI15MVKCmdCopyImageILm4EEE
18MVKCommandTypePoolI16MVKCmdBeginQueryE
18MVKCommandTypePoolI16MVKCmdCopyBufferILm1EEE
18MVKCommandTypePoolI16MVKCmdCopyBufferILm4EEE
18MVKCommandTypePoolI16MVKCmdFillBufferE
18MVKCommandTypePoolI16MVKCmdResetEventE
18MVKCommandTypePoolI16MVKCmdSetScissorILm16EEE
18MVKCommandTypePoolI16MVKCmdSetScissorILm1EEE
18MVKCommandTypePoolI16MVKCmdWaitEventsILm1EEE
18MVKCommandTypePoolI16MVKCmdWaitEventsILm8EEE
18MVKCommandTypePoolI17MVKCmdDrawIndexedE
18MVKCommandTypePoolI17MVKCmdNextSubpassE
18MVKCommandTypePoolI17MVKCmdSetViewportILm16EEE
18MVKCommandTypePoolI17MVKCmdSetViewportILm1EEE
18MVKCommandTypePoolI18MVKCmdDrawIndirectE
18MVKCommandTypePoolI18MVKCmdEndRenderingE
18MVKCommandTypePoolI18MVKCmdResolveImageILm1EEE
18MVKCommandTypePoolI18MVKCmdResolveImageILm4EEE
18MVKCommandTypePoolI18MVKCmdSetDepthBiasE
18MVKCommandTypePoolI18MVKCmdSetLineWidthE
18MVKCommandTypePoolI18MVKCmdUpdateBufferE
18MVKCommandTypePoolI19MVKCmdEndRenderPassE
18MVKCommandTypePoolI19MVKCmdPushConstantsILm128EEE
18MVKCommandTypePoolI19MVKCmdPushConstantsILm512EEE
18MVKCommandTypePoolI19MVKCmdPushConstantsILm64EEE
18MVKCommandTypePoolI20MVKCmdBeginRenderingILm1EEE
18MVKCommandTypePoolI20MVKCmdBeginRenderingILm2EEE
18MVKCommandTypePoolI20MVKCmdBeginRenderingILm4EEE
18MVKCommandTypePoolI20MVKCmdBeginRenderingILm8EEE
18MVKCommandTypePoolI20MVKCmdDebugMarkerEndE
18MVKCommandTypePoolI20MVKCmdResetQueryPoolE
18MVKCommandTypePoolI20MVKCmdSetDepthBoundsE
18MVKCommandTypePoolI20MVKCmdWriteTimestampE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm1ELm0EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm1ELm1EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm1ELm2EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm1ELm9EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm2ELm0EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm2ELm1EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm2ELm2EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm2ELm9EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm9ELm0EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm9ELm1EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm9ELm2EEE
18MVKCommandTypePoolI21MVKCmdBeginRenderPassILm9ELm9EEE
18MVKCommandTypePoolI21MVKCmdBindIndexBufferE
18MVKCommandTypePoolI21MVKCmdBufferImageCopyILm16EEE
18MVKCommandTypePoolI21MVKCmdBufferImageCopyILm1EEE
18MVKCommandTypePoolI21MVKCmdBufferImageCopyILm4EEE
18MVKCommandTypePoolI21MVKCmdBufferImageCopyILm8EEE
18MVKCommandTypePoolI21MVKCmdClearColorImageILm1EEE
18MVKCommandTypePoolI21MVKCmdClearColorImageILm4EEE
18MVKCommandTypePoolI21MVKCmdExecuteCommandsILm16EEE
18MVKCommandTypePoolI21MVKCmdExecuteCommandsILm1EEE
18MVKCommandTypePoolI21MVKCmdPipelineBarrierILm1EEE
18MVKCommandTypePoolI21MVKCmdPipelineBarrierILm32EEE
18MVKCommandTypePoolI21MVKCmdPipelineBarrierILm4EEE
18MVKCommandTypePoolI22MVKCmdDebugMarkerBeginE
18MVKCommandTypePoolI22MVKCmdDispatchIndirectE
18MVKCommandTypePoolI23MVKCmdBindVertexBuffersILm1EEE
18MVKCommandTypePoolI23MVKCmdBindVertexBuffersILm2EEE
18MVKCommandTypePoolI23MVKCmdBindVertexBuffersILm8EEE
18MVKCommandTypePoolI23MVKCmdDebugMarkerInsertE
18MVKCommandTypePoolI23MVKCmdPushDescriptorSetE
18MVKCommandTypePoolI23MVKCmdSetBlendConstantsE
18MVKCommandTypePoolI24MVKCmdSetSampleLocationsE
18MVKCommandTypePoolI25MVKCmdBindComputePipelineE
18MVKCommandTypePoolI25MVKCmdDrawIndexedIndirectE
18MVKCommandTypePoolI25MVKCmdSetStencilReferenceE
18MVKCommandTypePoolI25MVKCmdSetStencilWriteMaskE
18MVKCommandTypePoolI26MVKCmdBindGraphicsPipelineE
18MVKCommandTypePoolI26MVKCmdCopyQueryPoolResultsE
18MVKCommandTypePoolI27MVKCmdClearMultiAttachmentsILm1EEE
18MVKCommandTypePoolI27MVKCmdClearMultiAttachmentsILm4EEE
18MVKCommandTypePoolI27MVKCmdClearSingleAttachmentILm1EEE
18MVKCommandTypePoolI27MVKCmdClearSingleAttachmentILm4EEE
18MVKCommandTypePoolI27MVKCmdSetStencilCompareMaskE
18MVKCommandTypePoolI28MVKCmdClearDepthStencilImageILm1EEE
18MVKCommandTypePoolI28MVKCmdClearDepthStencilImageILm4EEE
18MVKCommandTypePoolI30MVKCmdBindDescriptorSetsStaticILm1EEE
18MVKCommandTypePoolI30MVKCmdBindDescriptorSetsStaticILm4EEE
18MVKCommandTypePoolI30MVKCmdBindDescriptorSetsStaticILm8EEE
18MVKCommandTypePoolI31MVKCmdBindDescriptorSetsDynamicILm4EEE
18MVKCommandTypePoolI31MVKCmdBindDescriptorSetsDynamicILm8EEE
18MVKCommandTypePoolI35MVKCmdPushDescriptorSetWithTemplateE
18MVKComputePipeline
18MVKGPUCaptureScope
18MVKImageDescriptor
18MVKPrivateDataSlot
18MVKQueueSubmission
18MVKVulkanAPIObject
18MVKWatermarkRandom
19MVKBaseDeviceObject
19MVKBufferDescriptor
19MVKCmdEndRenderPass
19MVKCmdPushConstantsILm128EE
19MVKCmdPushConstantsILm512EE
19MVKCmdPushConstantsILm64EE
19MVKCmdSetResetEvent
19MVKDeviceObjectPoolI16MVKCommandBufferE
19MVKGraphicsPipeline
1; spvDummy
1DArray
1Format
1FromMTLPixelFormat
1Layer
1canReadFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
1d_array
1ffff
1fffff
1ffffff
1u, gl_SubgroupSize
1ytesPer
1ۋUԋM̋u
20MVKCmdBeginRenderingILm1EE
20MVKCmdBeginRenderingILm2EE
20MVKCmdBeginRenderingILm4EE
20MVKCmdBeginRenderingILm8EE
20MVKCmdDebugMarkerEnd
20MVKCmdResetQueryPool
20MVKCmdSetDepthBounds
20MVKCmdWriteTimestamp
20MVKConfigurableMixin
20MVKDeferredOperation
20MVKSamplerDescriptor
20MVKSemaphoreEmulated
20MVKSemaphoreMTLEvent
20MVKTimelineSemaphore
21MVKCmdBeginRenderPassILm1ELm0EE
21MVKCmdBeginRenderPassILm1ELm1EE
21MVKCmdBeginRenderPassILm1ELm2EE
21MVKCmdBeginRenderPassILm1ELm9EE
21MVKCmdBeginRenderPassILm2ELm0EE
21MVKCmdBeginRenderPassILm2ELm1EE
21MVKCmdBeginRenderPassILm2ELm2EE
21MVKCmdBeginRenderPassILm2ELm9EE
21MVKCmdBeginRenderPassILm9ELm0EE
21MVKCmdBeginRenderPassILm9ELm1EE
21MVKCmdBeginRenderPassILm9ELm2EE
21MVKCmdBeginRenderPassILm9ELm9EE
21MVKCmdBindIndexBuffer
21MVKCmdBufferImageCopyILm16EE
21MVKCmdBufferImageCopyILm1EE
21MVKCmdBufferImageCopyILm4EE
21MVKCmdBufferImageCopyILm8EE
21MVKCmdClearColorImageILm1EE
21MVKCmdClearColorImageILm4EE
21MVKCmdExecuteCommandsILm16EE
21MVKCmdExecuteCommandsILm1EE
21MVKCmdPipelineBarrierILm1EE
21MVKCmdPipelineBarrierILm32EE
21MVKCmdPipelineBarrierILm4EE
21MVKDescriptorTypePoolI20MVKSamplerDescriptorE
21MVKDescriptorTypePoolI25MVKSampledImageDescriptorE
21MVKDescriptorTypePoolI25MVKStorageImageDescriptorE
21MVKDescriptorTypePoolI26MVKStorageBufferDescriptorE
21MVKDescriptorTypePoolI26MVKUniformBufferDescriptorE
21MVKDescriptorTypePoolI28MVKInputAttachmentDescriptorE
21MVKDescriptorTypePoolI31MVKInlineUniformBlockDescriptorE
21MVKDescriptorTypePoolI31MVKStorageTexelBufferDescriptorE
21MVKDescriptorTypePoolI31MVKUniformTexelBufferDescriptorE
21MVKDescriptorTypePoolI33MVKCombinedImageSamplerDescriptorE
21MVKDescriptorTypePoolI33MVKStorageBufferDynamicDescriptorE
21MVKDescriptorTypePoolI33MVKUniformBufferDynamicDescriptorE
21MVKImageMemoryBinding
21MVKMTLBufferAllocator
21MVKOcclusionQueryPool
21MVKPeerSwapchainImage
21MVKShaderLibraryCache
21MVKTimestampQueryPool
22MVKCmdClearAttachmentsILm1EE
22MVKCmdClearAttachmentsILm4EE
22MVKCmdDebugMarkerBegin
22MVKCmdDispatchIndirect
22MVKCommandEncoderState
22MVKCommandEncodingPool
22MVKDebugReportCallback
22MVKDebugUtilsMessenger
22MVKDescriptorSetLayout
22MVKDeviceTrackingMixin
22MVKFunctionSpecializer
22MVKGPUCounterQueryPool
22MVKMTLBufferAllocation
23MVKCmdBindVertexBuffersILm1EE
23MVKCmdBindVertexBuffersILm2EE
23MVKCmdBindVertexBuffersILm8EE
23MVKCmdDebugMarkerInsert
23MVKCmdPushDescriptorSet
23MVKCmdSetBlendConstants
23MVKSemaphoreSingleQueue
23MVKUnsupportedQueryPool
24) | (uint
24@0:8:16
24@0:8@16
24@0:8@?16
24@0:8Q16
24MVKAttachmentDescription
24MVKCmdSetSampleLocations
24MVKShaderLibraryCompiler
24MVKTexelBufferDescriptor
24MVKVulkanAPIDeviceObject
24VkPhysicalDeviceFeatures
25MVKCmdBeginRenderPassBase
25MVKCmdBindComputePipeline
25MVKCmdDrawIndexedIndirect
25MVKCmdSetStencilReference
25MVKCmdSetStencilWriteMask
25MVKCommandResourceFactory
25MVKReferenceCountingMixinI13MVKBaseObjectE
25MVKRenderPipelineCompiler
25MVKSampledImageDescriptor
25MVKSamplerDescriptorMixin
25MVKSamplerYcbcrConversion
25MVKStorageImageDescriptor
25VkPhysicalDeviceFeatures2
26MVKCmdBindGraphicsPipeline
26MVKCmdCopyQueryPoolResults
26MVKComputePipelineCompiler
26MVKMTLBufferAllocationPool
26MVKStorageBufferDescriptor
26MVKUniformBufferDescriptor
27MVKCmdClearMultiAttachmentsILm1EE
27MVKCmdClearMultiAttachmentsILm4EE
27MVKCmdClearSingleAttachmentILm1EE
27MVKCmdClearSingleAttachmentILm4EE
27MVKCmdSetStencilCompareMask
27MVKDescriptorUpdateTemplate
28MVKCmdClearDepthStencilImageILm1EE
28MVKCmdClearDepthStencilImageILm4EE
28MVKInputAttachmentDescriptor
28MVKPresentableSwapchainImage
28MVKTimelineSemaphoreEmulated
28MVKTimelineSemaphoreMTLEvent
29MVKDescriptorSetLayoutBinding
29MVKScissorCommandEncoderState
2>FRZ*n
2DArray
2DRect
2Image
2IsSupported
2Properties
2Texel
2UsageFlagsFromMTLTextureUsage
2\nt\aH
2d_array
2ffff
2ffffff
30MVKCmdBindDescriptorSetsStaticILm1EE
30MVKCmdBindDescriptorSetsStaticILm4EE
30MVKCmdBindDescriptorSetsStaticILm8EE
30MVKDispatchableVulkanAPIObject
30MVKPipelineCommandEncoderState
30MVKPipelineStatisticsQueryPool
30MVKRenderingAttachmentIterator
30MVKViewportCommandEncoderState
31MVKCmdBindDescriptorSetsDynamicILm4EE
31MVKCmdBindDescriptorSetsDynamicILm8EE
31MVKDepthBiasCommandEncoderState
31MVKInlineUniformBlockDescriptor
31MVKQueueCommandBufferSubmission
31MVKResourcesCommandEncoderState
31MVKStorageTexelBufferDescriptor
31MVKUniformTexelBufferDescriptor
32 ? uint4(0, (1
32) - (int
32)), uint2(0)) : uint4(1
32, 0
32, 0)), uint2(0
32, 0), (uint)max((int
32-bit signed integer
32-bit signed integer vector
32-bit signed literal
32-bit unsigned integer
32-bit unsigned integer vector
32@0:8:16@24
32@0:8@16^@24
32@0:8Q16Q24
32MVKBlendColorCommandEncoderState
32MVKQueuePresentSurfaceSubmission
32VkPhysicalDeviceVulkan11Features
32VkPhysicalDeviceVulkan12Features
32u)), extract_bits(0xFFFFFFFF, 0, (uint)max((int
32u)), uint2(0
32u), (uint)max(32 - (int
32u), (uint)max(min((int
32u), 0)), uint2(0
3333333
33333333
33333333H
33333333H9
33333333I
33333333L
33MVKCombinedImageSamplerDescriptor
33MVKStorageBufferDynamicDescriptor
33MVKUniformBufferDynamicDescriptor
33VkPhysicalDeviceMultiviewFeatures
34MVKDepthStencilCommandEncoderState
35MVKCmdPushDescriptorSetWithTemplate
35MVKPushConstantsCommandEncoderState
35MVKQueueFullCommandBufferSubmissionILm128EE
35MVKQueueFullCommandBufferSubmissionILm16EE
35MVKQueueFullCommandBufferSubmissionILm1EE
35MVKQueueFullCommandBufferSubmissionILm256EE
35MVKQueueFullCommandBufferSubmissionILm32EE
35MVKQueueFullCommandBufferSubmissionILm512EE
35MVKQueueFullCommandBufferSubmissionILm64EE
35VkPhysicalDevice8BitStorageFeatures
35VkPhysicalDevicePrivateDataFeatures
36MVKOcclusionQueryCommandEncoderState
36VkPhysicalDevice16BitStorageFeatures
36markAllInterfaceVarsAndResourcesUsedEv
38MVKComputeResourcesCommandEncoderState
38VkPhysicalDevice4444FormatsFeaturesEXT
38VkPhysicalDeviceHostQueryResetFeatures
38VkPhysicalDeviceRobustness2FeaturesEXT
39MVKGraphicsResourcesCommandEncoderState
39VkPhysicalDeviceImageRobustnessFeatures
39VkPhysicalDeviceProtectedMemoryFeatures
3E;'s(H
3basic_filebufIcNS_11char_traitsIcEEEE
3ffff
3fffff
3ffffff
3haderStageFlagBitsFromMVKShaderStage
3pathExtensionERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
4 color [[color(0
4 color%u [[color(%u
4"1L'FE
4$fff
4.60 glslang Khronos. 12.3.1
40@0:8:16@24@32
40@0:8@16@24^@32
40@0:8@16Q24Q32
40@0:8@16^{__IOSurface=}24Q32
40@0:8@16q24^@32
40@0:8@?16@24@32
40@0:8r^v16Q24Q32
40VkPhysicalDeviceDynamicRenderingFeatures
40VkPhysicalDeviceVariablePointersFeatures
41VkPhysicalDeviceScalarBlockLayoutFeatures
41VkPhysicalDeviceShaderAtomicInt64Features
41VkPhysicalDeviceShaderFloat16Int8Features
41VkPhysicalDeviceTimelineSemaphoreFeatures
41VkPhysicalDeviceVulkanMemoryModelFeatures
422CositedEven
422Midpoint
42VkPhysicalDeviceDescriptorIndexingFeatures
42VkPhysicalDeviceInlineUniformBlockFeatures
43MVKStencilReferenceValueCommandEncoderState
43VkPhysicalDeviceBufferDeviceAddressFeatures
43VkPhysicalDeviceSubgroupSizeControlFeatures
444 = 0
44VkPhysicalDeviceImagelessFramebufferFeatures
44VkPhysicalDevicePortabilitySubsetFeaturesKHR
44VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
44VkPhysicalDeviceShaderDrawParametersFeatures
46VkPhysicalDeviceSamplerYcbcrConversionFeatures
47VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
48@0:8@16Q24^@32^@40
48@0:8^v16Q24Q32@?40
48VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT
49VkPhysicalDeviceTextureCompressionASTCHDRFeatures
49VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
4@>"uV1
4@fffff
4AHUUiq"UU
4DescriptorSets
4Memory
4\nH+4\v
4basic
4ffff
4ffffff
4isResourceUsedEN3spv14ExecutionModelEjj
4isShaderInputBuiltInUsedEN3spv7BuiltInE
4llocate
50VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
51VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
51VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
51VkPhysicalDeviceUniformBufferStandardLayoutFeatures
52VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
52VkPhysicalDevicePipelineCreationCacheControlFeatures
52VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
5BIV]j
5basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
5fffff
5ffffff
5isShaderInputLocationUsedEj
64-bit hexadecimal literal
64-bit integer
64-bit integer literal
64-bit integer vector
64-bit integers are only supported in MSL 2.2 and above
64-bit integers not supported in ES profile before version 310
64-bit literal
64-bit octal literal
64-bit unsigned integer
64-bit unsigned integer literal
64-bit unsigned integer vector
669JM^aru%\e
69JM^a
6A;0s(H
6A;0s^L
6ImageMemory
6MSLShaderInterfaceVariable7matchesERKS0
6Query
6_t);f16vec2   maxInvocationsNonUniformAMD(f16vec2);f16vec3   maxInvocationsNonUniformAMD(f16vec3);f16vec4   maxInvocationsNonUniformAMD(f16vec4);int16_t maxInvocationsNonUniformAMD(int16_t);i16vec2 maxInvocationsNonUniformAMD(i16vec2);i16vec3 maxInvocationsNonUniformAMD(i16vec3);i16vec4 maxInvocationsNonUniformAMD(i16vec4);uint16_t maxInvocationsNonUniformAMD(uint16_t);u16vec2  maxInvocationsNonUniformAMD(u16vec2);u16vec3  maxInvocationsNonUniformAMD(u16vec3);u16vec4  maxInvocationsNonUniformAMD(u16vec4);float maxInvocationsInclusiveScanNonUniformAMD(float);vec2  maxInvocationsInclusiveScanNonUniformAMD(vec2);vec3  maxInvocationsInclusiveScanNonUniformAMD(vec3);vec4  maxInvocationsInclusiveScanNonUniformAMD(vec4);int   maxInvocationsInclusiveScanNonUniformAMD(int);ivec2 maxInvocationsInclusiveScanNonUniformAMD(ivec2);ivec3 maxInvocationsInclusiveScanNonUniformAMD(ivec3);ivec4 maxInvocationsInclusiveScanNonUniformAMD(ivec4);uint  maxInvocationsInclusiveScanNonUniformAMD(uint);uvec2 maxInvocationsInclusiveScanNonUniformAMD(uvec2);uvec3 maxInvocationsInclusiveScanNonUniformAMD(uvec3);uvec4 maxInvocationsInclusiveScanNonUniformAMD(uvec4);double maxInvocationsInclusiveScanNonUniformAMD(double);dvec2  maxInvocationsInclusiveScanNonUniformAMD(dvec2);dvec3  maxInvocationsInclusiveScanNonUniformAMD(dvec3);dvec4  maxInvocationsInclusiveScanNonUniformAMD(dvec4);int64_t maxInvocationsInclusiveScanNonUniformAMD(int64_t);i64vec2 maxInvocationsInclusiveScanNonUniformAMD(i64vec2);i64vec3 maxInvocationsInclusiveScanNonUniformAMD(i64vec3);i64vec4 maxInvocationsInclusiveScanNonUniformAMD(i64vec4);uint64_t maxInvocationsInclusiveScanNonUniformAMD(uint64_t);u64vec2  maxInvocationsInclusiveScanNonUniformAMD(u64vec2);u64vec3  maxInvocationsInclusiveScanNonUniformAMD(u64vec3);u64vec4  maxInvocationsInclusiveScanNonUniformAMD(u64vec4);float16_t maxInvocationsInclusiveScanNonUniformAMD(float16_t);f16vec2   maxInvocationsInclusiveScanNonUniformAMD(f16vec2);f16vec3   maxInvocationsInclusiveScanNonUniformAMD(f16vec3);f16vec4   maxInvocationsInclusiveScanNonUniformAMD(f16vec4);int16_t maxInvocationsInclusiveScanNonUniformAMD(int16_t);i16vec2 maxInvocationsInclusiveScanNonUniformAMD(i16vec2);i16vec3 maxInvocationsInclusiveScanNonUniformAMD(i16vec3);i16vec4 maxInvocationsInclusiveScanNonUniformAMD(i16vec4);uint16_t maxInvocationsInclusiveScanNonUniformAMD(uint16_t);u16vec2  maxInvocationsInclusiveScanNonUniformAMD(u16vec2);u16vec3  maxInvocationsInclusiveScanNonUniformAMD(u16vec3);u16vec4  maxInvocationsInclusiveScanNonUniformAMD(u16vec4);float maxInvocationsExclusiveScanNonUniformAMD(float);vec2  maxInvocationsExclusiveScanNonUniformAMD(vec2);vec3  maxInvocationsExclusiveScanNonUniformAMD(vec3);vec4  maxInvocationsExclusiveScanNonUniformAMD(vec4);int   maxInvocationsExclusiveScanNonUniformAMD(int);ivec2 maxInvocationsExclusiveScanNonUniformAMD(ivec2);ivec3 maxInvocationsExclusiveScanNonUniformAMD(ivec3);ivec4 maxInvocationsExclusiveScanNonUniformAMD(ivec4);uint  maxInvocationsExclusiveScanNonUniformAMD(uint);uvec2 maxInvocationsExclusiveScanNonUniformAMD(uvec2);uvec3 maxInvocationsExclusiveScanNonUniformAMD(uvec3);uvec4 maxInvocationsExclusiveScanNonUniformAMD(uvec4);double maxInvocationsExclusiveScanNonUniformAMD(double);dvec2  maxInvocationsExclusiveScanNonUniformAMD(dvec2);dvec3  maxInvocationsExclusiveScanNonUniformAMD(dvec3);dvec4  maxInvocationsExclusiveScanNonUniformAMD(dvec4);int64_t maxInvocationsExclusiveScanNonUniformAMD(int64_t);i64vec2 maxInvocationsExclusiveScanNonUniformAMD(i64vec2);i64vec3 maxInvocationsExclusiveScanNonUniformAMD(i64vec3);i64vec4 maxInvocationsExclusiveScanNonUniformAMD(i64vec4);uint64_t maxInvocationsExclusiveScanNonUniformAMD(uint64_t);u64vec2  maxInvocationsExclusiveScanNonUniformAMD(u64vec2);u64vec3  maxInvocationsExclusiveScanNonUniformAMD(u64vec3);u64vec4  maxInvocationsExclusiveScanNonUniformAMD(u64vec4);float16_t maxInvocationsExclusiveScanNonUniformAMD(float16_t);f16vec2   maxInvocationsExclusiveScanNonUniformAMD(f16vec2);f16vec3   maxInvocationsExclusiveScanNonUniformAMD(f16vec3);f16vec4   maxInvocationsExcl
6isShaderOutputLocationUsedEj
6vec2);i16vec3 averageRounded(i16vec3, i16vec3);i16vec4 averageRounded(i16vec4, i16vec4);int64_t averageRounded(int64_t, int64_t);i64vec2 averageRounded(i64vec2, i64vec2);i64vec3 averageRounded(i64vec3, i64vec3);i64vec4 averageRounded(i64vec4, i64vec4);uint averageRounded(uint, uint);uvec2 averageRounded(uvec2, uvec2);uvec3 averageRounded(uvec3, uvec3);uvec4 averageRounded(uvec4, uvec4);uint16_t averageRounded(uint16_t, uint16_t);u16vec2 averageRounded(u16vec2, u16vec2);u16vec3 averageRounded(u16vec3, u16vec3);u16vec4 averageRounded(u16vec4, u16vec4);uint64_t averageRounded(uint64_t, uint64_t);u64vec2 averageRounded(u64vec2, u64vec2);u64vec3 averageRounded(u64vec3, u64vec3);u64vec4 averageRounded(u64vec4, u64vec4);int multiply32x16(int, int);ivec2 multiply32x16(ivec2, ivec2);ivec3 multiply32x16(ivec3, ivec3);ivec4 multiply32x16(ivec4, ivec4);uint multiply32x16(uint, uint);uvec2 multiply32x16(uvec2, uvec2);uvec3 multiply32x16(uvec3, uvec3);uvec4 multiply32x16(uvec4, uvec4);\n
6vec3   clamp(f16vec3,   float16_t, float16_t);f16vec4   clamp(f16vec4,   float16_t, float16_t);f16vec2   clamp(f16vec2,   f16vec2,   f16vec2);f16vec3   clamp(f16vec3,   f16vec3,   f16vec3);f16vec4   clamp(f16vec4,   f16vec4,   f16vec4);float16_t mix(float16_t, float16_t, float16_t);f16vec2   mix(f16vec2,   f16vec2,   float16_t);f16vec3   mix(f16vec3,   f16vec3,   float16_t);f16vec4   mix(f16vec4,   f16vec4,   float16_t);f16vec2   mix(f16vec2,   f16vec2,   f16vec2);f16vec3   mix(f16vec3,   f16vec3,   f16vec3);f16vec4   mix(f16vec4,   f16vec4,   f16vec4);float16_t mix(float16_t, float16_t, bool);f16vec2   mix(f16vec2,   f16vec2,   bvec2);f16vec3   mix(f16vec3,   f16vec3,   bvec3);f16vec4   mix(f16vec4,   f16vec4,   bvec4);float16_t step(float16_t, float16_t);f16vec2   step(f16vec2,   f16vec2);f16vec3   step(f16vec3,   f16vec3);f16vec4   step(f16vec4,   f16vec4);f16vec2   step(float16_t, f16vec2);f16vec3   step(float16_t, f16vec3);f16vec4   step(float16_t, f16vec4);float16_t smoothstep(float16_t, float16_t, float16_t);f16vec2   smoothstep(f16vec2,   f16vec2,   f16vec2);f16vec3   smoothstep(f16vec3,   f16vec3,   f16vec3);f16vec4   smoothstep(f16vec4,   f16vec4,   f16vec4);f16vec2   smoothstep(float16_t, float16_t, f16vec2);f16vec3   smoothstep(float16_t, float16_t, f16vec3);f16vec4   smoothstep(float16_t, float16_t, f16vec4);bool  isnan(float16_t);bvec2 isnan(f16vec2);bvec3 isnan(f16vec3);bvec4 isnan(f16vec4);bool  isinf(float16_t);bvec2 isinf(f16vec2);bvec3 isinf(f16vec3);bvec4 isinf(f16vec4);float16_t fma(float16_t, float16_t, float16_t);f16vec2   fma(f16vec2,   f16vec2,   f16vec2);f16vec3   fma(f16vec3,   f16vec3,   f16vec3);f16vec4   fma(f16vec4,   f16vec4,   f16vec4);float16_t frexp(float16_t, out int);f16vec2   frexp(f16vec2,   out ivec2);f16vec3   frexp(f16vec3,   out ivec3);f16vec4   frexp(f16vec4,   out ivec4);float16_t ldexp(float16_t, in int);f16vec2   ldexp(f16vec2,   in ivec2);f16vec3   ldexp(f16vec3,   in ivec3);f16vec4   ldexp(f16vec4,   in ivec4);uint    packFloat2x16(f16vec2);f16vec2 unpackFloat2x16(uint);float16_t length(float16_t);float16_t length(f16vec2);float16_t length(f16vec3);float16_t length(f16vec4);float16_t distance(float16_t, float16_t);float16_t distance(f16vec2,   f16vec2);float16_t distance(f16vec3,   f16vec3);float16_t distance(f16vec4,   f16vec4);float16_t dot(float16_t, float16_t);float16_t dot(f16vec2,   f16vec2);float16_t dot(f16vec3,   f16vec3);float16_t dot(f16vec4,   f16vec4);f16vec3 cross(f16vec3, f16vec3);float16_t normalize(float16_t);f16vec2   normalize(f16vec2);f16vec3   normalize(f16vec3);f16vec4   normalize(f16vec4);float16_t faceforward(float16_t, float16_t, float16_t);f16vec2   faceforward(f16vec2,   f16vec2,   f16vec2);f16vec3   faceforward(f16vec3,   f16vec3,   f16vec3);f16vec4   faceforward(f16vec4,   f16vec4,   f16vec4);float16_t reflect(float16_t, float16_t);f16vec2   reflect(f16vec2,   f16vec2);f16vec3   reflect(f16vec3,   f16vec3);f16vec4   reflect(f16vec4,   f16vec4);float16_t refract(float16_t, float16_t, float16_t);f16vec2   refract(f16vec2,   f16vec2,   float16_t);f16vec3   refract(f16vec3,   f16vec3,   float16_t);f16vec4   refract(f16vec4,   f16vec4,   float16_t);f16mat2   matrixCompMult(f16mat2,   f16mat2);f16mat3   matrixCompMult(f16mat3,   f16mat3);f16mat4   matrixCompMult(f16mat4,   f16mat4);f16mat2x3 matrixCompMult(f16mat2x3, f16mat2x3);f16mat2x4 matrixCompMult(f16mat2x4, f16mat2x4);f16mat3x2 matrixCompMult(f16mat3x2, f16mat3x2);f16mat3x4 matrixCompMult(f16mat3x4, f16mat3x4);f16mat4x2 matrixCompMult(f16mat4x2, f16mat4x2);f16mat4x3 matrixCompMult(f16mat4x3, f16mat4x3);f16mat2   outerProduct(f16vec2, f16vec2);f16mat3   outerProduct(f16vec3, f16vec3);f16mat4   outerProduct(f16vec4, f16vec4);f16mat2x3 outerProduct(f16vec3, f16vec2);f16mat3x2 outerProduct(f16vec2, f16vec3);f16mat2x4 outerProduct(f16vec4, f16vec2);f16mat4x2 outerProduct(f16vec2, f16vec4);f16mat3x4 outerProduct(f16vec4, f16vec3);f16mat4x3 outerProduct(f16vec3, f16vec4);f16mat2   transpose(f16mat2);f16mat3   transpose(f16mat3);f16mat4   transpose(f16mat4);f16mat2x3 transpose(f16mat3x2);f16mat3x2 tra
7:KN_b
7:KN_bsv
7DescriptorBinding7matchesERKS0
7Render
7TLinker
7\nt@H
7\ru#L
7bad_function_callE
7convertERNS_33SPIRVToMSLConversionConfigurationERNS_26SPIRVToMSLConversionResultEbbb
7ffff
7fffff
7matchesERKS0
7pathWithExtensionERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_bS6
7rOL9
8) | uint
8-bit arrays not supported
8-bit signed integer
8-bit signed integer vector
8-bit unsigned integer
8-bit unsigned integer vector
8-bit vectors only take vector types
8;LO`ctw
8A;9saL
8H#B\bt
8H#H\bH
8H#H\bt
8H#P\bH
8IndexBuffer
8M+g(L
8MSLResourceBindingC
8MVKCodec
8MVKEvent
8MVKFence
8MVKImage
8MVKLayer
8MVKQueue
8Pipeline
8VertexBuffers
8[A^A
8basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
8ffff
8fffff
8ffffff
8litImage
8setGLSLsERKNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE
8setSPIRVEPKjm
8tiE1
94:t_H
94\nt<9t\n
9=uvf
9C\fuQH
9ColorImage
9J\fu'L
9MVKBuffer
9MVKDevice
9O s$H
9Pp\bp
9SPIRVToMSLConverter
9T>\br$H
9TCompiler
9X`u+H
9\bfff
9basic
9countShaderInputsAtEj
9ffff
9reate
9stageSupportsVertexAttributesEv
A 3D texture used a compressed format that MoltenVK does not yet support
A ;A\bt\vI
A class corresponding to metal::sampler which holds sampler
A class which can hold up to three textures and a sampler, including
A descriptor set is being returned to a descriptor pool that did not allocate it
A memory declaration object must be used in ExecuteCallableKHR
A memory declaration object must be used in TraceRayKHR
A per vertex structure containing an array is not allowed as input in ES
A struct is used with different array strides. Cannot express this in MSL
A structure containing an array is not allowed as input in ES
A structure containing an struct is not allowed as input in ES
A#D$P\r
A#D$tH
A4v1H
A8^0u&D
A9E ~EE1
A9E0u.A
A9F\fuqH
A9L$\bL
A9T\e\bs
A9_hu(M
A;E<sOH
A;F@u\t
A;F\bu9H
A;Oxv6A
A;V\bu\a
AA9U\bt
AB?CᒱD
ABCDEF
ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz
ACCSTRUCTEXT
ACCSTRUCTNV
ADD_ASSIGN
AMPERSAND
AND_ASSIGN
AND_OP
ANGLE Shader Compiler
ARARAYARARAWAp\bSB
ARA\\ARARA\\A\\ARA`0AUE
ARA\\ARA\\ARA\\ARA\\AVA\\ARA
ARA`3ARA`6ARA`3ARA`6ARA`5ARA`7ARA` ARAUA[ASAWAUA`,E
ASASASDRAp
ASATARASAp
ASPSARR
ATAVATA[ATA[ATA[ATARARARARARARARARARARA[ATARAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAp\bSBRAVARAWA
ATAYAZATA
ATAYAZATARARARARARARBp
ATBRA
ATBSBVARARARARARARARARARARARARAUARATAp\bRAWAWAXARARAXARARARAWARARAWARAUAUARARA[ATARAWATAVATAUA
ATOMIC_UINT
ATTACHMENTEXT
ATTRIBUTE
AUARAWAWARARAZBp
AUAp\bUARAp\bRARA
AUpdateBuffer
AVAUAT
AVA\\ARA\\ARA\\Ap\bRA\\ASAp\b\\ARA\\ARA
AVBp\bRBTA
AWAVATS
AWAVATSA
AWAVATSD
AWAVATSE
AWAVATSH
AWAVATSI
AWAVATSL
AWAVATSM
AWAVAU
AWAVAUATH
AWAVAUATS
AWAVAUATSA
AWAVAUATSD
AWAVAUATSH
AWAVAUATSH9
AWAVAUATSI
AWAVAUATSL
AWAVAUATSP
AWAVAUATSPA
AWAVAUATSPD
AWAVAUATSPE
AWAVAUATSPE1
AWAVAUATSPH
AWAVAUATSPI
AWAVAUATSPL
AWAVAUATSPM
AWAVSA
AWAVSH
AWAVSL
AWAVSP
AWAVSP1
AWAVSPA
AWAVSPE
AWAVSPH
AWAVSPI
AWAVSPL
AWAVSPM
A\\ARA\\ARA\\ARA\\ARBSBWKp
A\t t$H
A\t tRH
A_MTLCommandBufferEncoderInfoErrorKey
A_MTLCommonCounterSetTimestamp
A_MTLCommonCounterTimestamp
A_OBJC_CLASS_$_CAEDRMetadata
A_OBJC_CLASS_$_MTLBlitPassDescriptor
A_OBJC_CLASS_$_MTLCaptureDescriptor
A_OBJC_CLASS_$_MTLCommandBufferDescriptor
A_OBJC_CLASS_$_MTLCounterSampleBufferDescriptor
A_OBJC_CLASS_$_MTLSharedEventListener
A_kCGColorSpaceExtendedLinearDisplayP3
A_kCGColorSpaceExtendedLinearITUR_2020
A_kCGColorSpaceITUR_2100_HLG
A_kCGColorSpaceITUR_2100_PQ
A`'A\\ARA\\ARA\\ARA\\ARB
A`<ASASAp\bp\bSAp\bSAp\bZAp\bRARAWAZAp\bRAp\bRARAZAp\bRAp\bZAp\bRAp\bZAp\bRAp\bZAp\bRAp\bZAp\bRAp\bSAYASA`-Ap\bRA`;ARARA\\ARB
AbsISubINTEL
AbsUSubINTEL
Absolute value
Acceleration Structure Type is supported in MSL 2.3 and above
Access MTLCommandQueue
Access chains have no default expression representation
Access chains that result in an array can not be flattened
AccessChain
Acquire
AcquireRelease
Address
AddressModeFromVkSamplerAddressMode
Addresses
AddressingModelPhysicalStorageBuffer64EXT must be used for PhysicalStorageBufferEXT
Adjust value of kMVKQueueFamilyCount
Affff
Affffff
AliasDomainDeclINTEL
AliasScopeDeclINTEL
AliasScopeINTEL
AliasScopeINTELMask
AliasScopeListDeclINTEL
Aliased
AliasedPointer
AliasedPointerEXT
Aliasing arrayed discrete descriptors is currently not supported
Aligned
Alignment
AlignmentId
All basic types in a flattened block must be the same
AllMemoryBarrierWithGroupSync
AllowContractFastINTEL
AllowReassocINTEL
AllowRecip
Annotations
Anonymous member name used for global variable or other anonymous member
AnyHitKHR
AnyHitNV
Ap\bRA
Ap\bp\bp
ArbitraryFloatACosINTEL
ArbitraryFloatACosPiINTEL
ArbitraryFloatASinINTEL
ArbitraryFloatASinPiINTEL
ArbitraryFloatATan2INTEL
ArbitraryFloatATanINTEL
ArbitraryFloatATanPiINTEL
ArbitraryFloatAddINTEL
ArbitraryFloatCastFromIntINTEL
ArbitraryFloatCastINTEL
ArbitraryFloatCastToIntINTEL
ArbitraryFloatCbrtINTEL
ArbitraryFloatCosINTEL
ArbitraryFloatCosPiINTEL
ArbitraryFloatDivINTEL
ArbitraryFloatEQINTEL
ArbitraryFloatExp10INTEL
ArbitraryFloatExp2INTEL
ArbitraryFloatExpINTEL
ArbitraryFloatExpm1INTEL
ArbitraryFloatGEINTEL
ArbitraryFloatGTINTEL
ArbitraryFloatHypotINTEL
ArbitraryFloatLEINTEL
ArbitraryFloatLTINTEL
ArbitraryFloatLog10INTEL
ArbitraryFloatLog1pINTEL
ArbitraryFloatLog2INTEL
ArbitraryFloatLogINTEL
ArbitraryFloatMulINTEL
ArbitraryFloatPowINTEL
ArbitraryFloatPowNINTEL
ArbitraryFloatPowRINTEL
ArbitraryFloatRSqrtINTEL
ArbitraryFloatRecipINTEL
ArbitraryFloatSinCosINTEL
ArbitraryFloatSinCosPiINTEL
ArbitraryFloatSinINTEL
ArbitraryFloatSinPiINTEL
ArbitraryFloatSqrtINTEL
ArbitraryFloatSubINTEL
ArbitraryPrecisionFixedPointINTEL
ArbitraryPrecisionFloatingPointINTEL
ArbitraryPrecisionIntegersINTEL
Argument buffer
Argument buffer resource base type could not be determined. When padding argument buffer elements, all descriptor set resources must be supplied with a base type by the app
Argument buffers can only be used with MSL 2.0 and up
ArgumentInfo
ArgumentPodPushConstant
ArgumentPodStorageBuffer
ArgumentPodUniform
ArgumentPointerPushConstant
ArgumentPointerUniform
ArgumentSampledImage
ArgumentSampler
ArgumentStorageBuffer
ArgumentStorageImage
ArgumentStorageTexelBuffer
ArgumentUniform
ArgumentUniformTexelBuffer
ArgumentWorkgroup
Array of varying structs cannot be flattened to legacy-compatible varyings
Array size for ClipDistance must be a literal
Array size for ClipDistance must not be unsized
Array size for CullDistance must be a literal
Array size for CullDistance must not be unsized
Array size of OpConstantNull must be a literal
Array sizes must be compatible
Array stride for dynamic indexing must be divisible by the size of a 4-component vector. Likely culprit here is a float or vec2 array inside a push constant block which is std430. This cannot be flattened. Try using std140 layout instead
Array-of-array output variable used. This cannot be implemented in legacy GLSL
ArrayLength
ArrayStride
Arrayed output variable used, but location is not 0. This is unimplemented in SPIRV-Cross
Arrays of arrays not supported before ESSL version 310
Arrays of arrays not supported before ESSL version 310. Try using --flatten-multidimensional-arrays or set options.flatten_multidimensional_arrays to true
Arrays of arrays of buffers are not supported
Arrays of arrays of samplers are not supported in MSL
Arrays of arrays of textures are not supported in MSL
AsmCallINTEL
AsmINTEL
AsmTargetINTEL
AssumeTrueKHR
At least ESSL 3.10 required for atomic counters
At least ESSL 3.10 required for compute shaders
At least ESSL 3.10 required for fragment shader interlock
At least ESSL 3.10 required for imageSize
At least ESSL 3.10 required for shader image load store
At least one shader must specify a layout(max_primitives = value
At least one shader must specify a layout(max_vertices = value
At least one shader must specify an input layout primitive
At least one shader must specify an output layout primitive
At least one shader must specify an output layout(vertices
Atomic memory function can only be used for shader storage block member or shared variable
AtomicAdd
AtomicAnd
AtomicCompSwap
AtomicCompareExchange
AtomicCompareExchangeWeak
AtomicCounter
AtomicCounterAdd
AtomicCounterAnd
AtomicCounterCompSwap
AtomicCounterDecrement
AtomicCounterExchange
AtomicCounterIncrement
AtomicCounterMax
AtomicCounterMemory
AtomicCounterMin
AtomicCounterOr
AtomicCounterSubtract
AtomicCounterXor
AtomicExchange
AtomicFAddEXT
AtomicFMaxEXT
AtomicFMinEXT
AtomicFlagClear
AtomicFlagTestAndSet
AtomicFloat16AddEXT
AtomicFloat16MinMaxEXT
AtomicFloat32AddEXT
AtomicFloat32MinMaxEXT
AtomicFloat64AddEXT
AtomicFloat64MinMaxEXT
AtomicIAdd
AtomicIDecrement
AtomicIIncrement
AtomicISub
AtomicLoad
AtomicMax
AtomicMin
AtomicOr
AtomicSMax
AtomicSMin
AtomicStorage
AtomicStorageOps
AtomicStore
AtomicSubtract
AtomicType
AtomicUMax
AtomicUMin
AtomicXor
Attachments
Attempting to use arrays or structs of separate samplers. This is not possible to statically remap to plain GLSL
Attempting to use image format not supported in ES profile
AttributesPos
Automatically generated. Do not edit.\n\n
Auxiliary qualifiers (centroid, patch, and sample) must appear before storage and precision qualifiers
B0HcJ H
B8L+0uCD
B;D3,s#B
BCompareOp
BEvent
BFloat16ConversionINTEL
BOOLCONSTANT
BTestEnable
BUFFER
BUFFERSH
BWriteEnable
B\b;G
B\n\b I\n\tp_\n
BackColor
BackSecondaryColor
Bad aggregation op
Bad cast
Bad shader stage provided for GLSL to SPIR-V conversion
Bad unary op
Ballot ops on iOS requires Metal 2.2 and up
BankBitsINTEL
BankwidthINTEL
Barrier
Barrier2H
BaryCoordKHR
BaryCoordNV
BaryCoordNoPersp
BaryCoordNoPerspAMD
BaryCoordNoPerspCentroid
BaryCoordNoPerspCentroidAMD
BaryCoordNoPerspKHR
BaryCoordNoPerspNV
BaryCoordNoPerspSample
BaryCoordNoPerspSampleAMD
BaryCoordPullModel
BaryCoordPullModelAMD
BaryCoordSmooth
BaryCoordSmoothAMD
BaryCoordSmoothCentroid
BaryCoordSmoothCentroidAMD
BaryCoordSmoothSample
BaryCoordSmoothSampleAMD
Barycentrics are only supported in MSL 2.2 and above on macOS
Barycentrics are only supported in MSL 2.3 and above on iOS
BaseInstance
BaseInstance not supported in ES profile
BaseInstance requires Metal 1.1 and Mac or Apple A9+ hardware
BaseSizeFromLevelSize
BaseVertex
BaseVertex not supported in ES profile
BaseVertex requires Metal 1.1 and Mac or Apple A9+ hardware
Basic types in a flattened UBO must be float, int or uint
Beehive SPIRV Toolkit
BeginEXT
BeginEXTH
BeginInvocationInterlockEXT
Bfffff
Binding
BindingTableRecordOffset is not supported in MSL
BindlessImageNV
BindlessSamplerNV
BindlessTextureNV
BitCount
BitFieldInsert
BitFieldSExtract
BitFieldUExtract
BitInstructions
BitPiece
BitReverse
Bitcast
Bitwise not
BitwiseAnd
BitwiseOr
BitwiseXor
Block
Block was not terminated
BlockMatchTextureQCOM
Block_object_assign
Block_object_dispose
BlockingPipesINTEL
Blocks cannot exist outside functions
Boolean
BorderColorFromVkBorderColor
Bound
BoundImageNV
BoundSamplerNV
BoundingBox
Bounds
Branch
Branch: Break
Branch: Continue
Branch: IgnoreIntersectionKHR
Branch: Kill
Branch: Return
Branch: TerminateInvocation
Branch: TerminateRayKHR
Branch: Unknown Branch
BranchConditional
BroadcastFirst on iOS requires Metal 2.2 and up
Buffer
Buffer block cannot be expressed as any of std430, std140, scalar, even with enhanced layouts. You can try flattening this block to support a more flexible layout
Buffer block reflection
Buffer variable reflection
BufferBlock
BufferLocationINTEL
BufferMVK
BufferMemory
BufferMemoryRequirements
BufferProperties
BufferSiH
BufferSize
Buffers2H
BuildNDRange
BuiltIn
BuiltinSymbolTable {\n
BurstCoalesceINTEL
BviceMask
Byte-aligned buffer copy region offsets and size must each fit into a 32-bit unsigned integer
B|\nA|u
C A;F
C I;D
C [A\\A^A
C(H;C0tJH
C(H;C0tZH
C(H;C0t^H
C0H+C(A
C0H;C
C0[A\\A^A
C0s&H
C0s0H
C8\\&0u3D
C8\\.0u'D
CACurrentMediaTime
CALLDATAEXT
CALLDATAINEXT
CALLDATAINNV
CALLDATANV
CAMetalDrawable could not be acquired
CD;C0s)H
CENTROID
CFArrayAppendValue
CFArrayCreateMutable
CFConstantStringClassReference
CFDataGetBytePtr
CFDictionaryAddValue
CFDictionaryCreateMutableCopy
CFRelease
CFRetain
CFString=}16@0:8
CFrontFace
CGColorSpaceCreateWithName
CGColorSpaceGetName
CGColorSpaceRelease
CGDisplayCopyDisplayMode
CGDisplayModeGetRefreshRate
CGDisplayModeRelease
CGSize=dd}16@0:8
CHAR_BIT
CHAR_MAX
CHAR_MIN
CLineWidth
COHERENT
CONTINUE
COOPMAT
CPP_for_OpenCL
CPU Emulation
CPacked
CPrimitive
CRasterizerDiscardEnable
CTopology
CX;C0s)H
CXH;CH
C\bA3E\b
C\bData
C\b[A
C\bffff
C\bs I
C\bsFL
C\buIH
C\f[A
C\fu(H
C\n`t;I
C\n`uGH
C\tt::w
C\tt::x
C\tt::y
C\tt::z
CacheSizeINTEL
Calculate cache size required to write MSL to pipeline cache
Calculate the determinant as a combination of the cofactors of the first row
CallableDataKHR
CallableDataNV
CallableKHR
CallableNV
Can not remap array of samplers
Can only remap SampledImage and Sampler type
Can only use GL_EXT_shader_framebuffer_fetch in fragment shaders
Can only use GL_EXT_shader_pixel_local_storage in fragment shaders
Can only use PrimitiveShadingRateKHR in Vulkan GLSL
Can only use ShadingRateKHR in Vulkan GLSL
Can only use in and target variables for PLS inputs
Can only use one of gl_ClipDistance or gl_ClipDistancePerViewNV
Can only use one of gl_ClipDistance or gl_ClipVertex (gl_ClipDistance is preferred
Can only use one of gl_CullDistance or gl_ClipVertex (gl_ClipDistance is preferred
Can only use one of gl_CullDistance or gl_CullDistancePerViewNV
Can only use one of gl_Layer or gl_LayerPerViewNV
Can only use one of gl_Position or gl_PositionPerViewNV
Can only use one of gl_ViewportMask or gl_ViewportMaskPerViewNV
Can only use out variables for PLS outputs
Cannot add typed ID while looping over it
Cannot apply scalar layout workaround with spec constant array size
Cannot attach multiple ES shaders of the same type to a single program
Cannot cross link ES and desktop profiles
Cannot declare both BaryCoordNV and BaryCoordNoPerspNV in same shader in MSL
Cannot declare pointer-to-pointer types
Cannot emit a packed struct currently
Cannot end a function before ending the current block.\nLikely cause: If this SPIR-V was created from glslang HLSL, make sure the entry point is valid
Cannot express an array stride smaller than size of struct type
Cannot find dummy sampler ID. Was build_dummy_sampler_for_combined_images() called
Cannot find mapping for combined sampler parameter, was build_combined_image_samplers() used before compile() was called
Cannot find mapping for combined sampler, was build_combined_image_samplers() used before compile() was called
Cannot flatten array of structs in I/O blocks
Cannot flatten constructors of multidimensional array constructors, e.g. float
Cannot implement gl_InstanceID in Vulkan GLSL. This shader was created with GL semantics
Cannot implement gl_VertexID in Vulkan GLSL. This shader was created with GL semantics
Cannot load array-of-array of composite type in tessellation IO
Cannot load tessellation IO variables with more than 2 dimensions
Cannot mix ES profile with non-ES profile shaders
Cannot override IDs when loop is soft locked
Cannot pad with negative bytes
Cannot perform any repacking for structs when it is used as a member of another struct
Cannot put a negative number in an unsigned literal
Cannot represent buffer block correctly in MSL
Cannot represent non-finite floating point constant
Cannot represent vectors with more than 4 elements in MSL
Cannot resolve expression type
Cannot reuse block name within the same interface
Cannot set ID
Cannot start a block before ending the current block
Cannot subdivide a scalar value
Cannot support this many dimensions for arrays of arrays
Cannot unroll an array copy from unsized array
Cannot use 64-bit switch selectors
Cannot use ArrayStride of 3 elements in remapping scenarios
Cannot use EXT_shader_framebuffer_fetch in Vulkan GLSL
Cannot use GL_EXT_shader_framebuffer_fetch with arrays of color outputs
Cannot use GL_EXT_shader_image_load_formatted in ESSL
Cannot use both gl_FragColor and gl_FragData
Cannot use gl_FragColor or gl_FragData when using user-defined outputs
Cannot use more than one builtin I/O block
Cannot use texel buffers with multisampling or array layers
Cannot write to file
Capabilities
Capability
CaptureEventProfilingInfo
Capturing GPU trace to Xcode
Capturing GPU trace to file %s
Capturing GPU traces to a file requires macOS 10.15 or iOS 13.0 and GPU capturing to be enabled. Falling back to Xcode GPU capture
Ceiling
Centroid
Cffff
ChH;H\b
ChannelsFromVkComponentMapping
Chp\bpX
Cl;C0s)H
ClampToEdge
Clay Shader Compiler
Cleanup: discarding lookahead
Cleanup: popping
Clear Render Area on Begin Rendering
Clear Render Area on Begin Renderpass
Clear Render Area on Next Subpass
ClearColor
ClearColorsIn
ClearColorsOut
ClearColorsOut ccOut
ClearRenderAttachments
ClipDistance
ClipDistancePerViewNV
ClipVertex
ClobberINTEL
ClosestHitKHR
ClosestHitNV
ClusteredReduce
CmdExecTime
CodeSectionINTEL
Codeplay
Coherent
ColMajor
ColorAttachmentReadEXT
ColorFromVkClearValue
ColumnMajorKHR
Combined image samplers have no default expression representation
Command
Command buffer cannot accept commands before vkBeginCommandBuffer() is called
Command buffer does not support concurrent execution
Command buffer does not support execution more that once
CommandBuffers
CommandQueueMVK
CommitReadPipe
CommitWritePipe
Commitment
Compare Equal
Compare Greater Than
Compare Greater Than or Equal
Compare Less Than
Compare Less Than or Equal
Compare Not Equal
CompareMask
Compile MSL source code into a MTLLibrary
Compile MTLFunctions into a pipeline
Compiled shader module creation
Compiler::stream() out of range
Compiling Metal shader%s
Complete MTLCommandBuffer
Component
Component decoration is not supported in ES targets
Component decoration is not supported in targets below GLSL 1.40
Component decoration is not supported in tessellation shaders
CompositeConstruct
CompositeExtract
CompositeInsert
Compress MSL source code after compiling a MTLLibrary
Compute pipeline
Compute shader function could not be compiled into pipeline. See previous logged error
Compute shader requires buffer size buffer, but there is no free slot to pass it
Compute shader requires dispatch base buffer, but there is no free slot to pass it
Compute shader requires dynamic offset buffer, but there is no free slot to pass it
Compute shader requires swizzle buffer, but there is no free slot to pass it
ComputeDerivativeGroupLinearNV
ComputeDerivativeGroupQuadsNV
Condition\n
ConduitKernelArgumentINTEL
ConstOffset
ConstOffsets
ConstType
Constant
Constant:\n
ConstantComposite
ConstantCompositeContinuedINTEL
ConstantDataPointerPushConstant
ConstantDataStorageBuffer
ConstantDataUniform
ConstantFalse
ConstantFunctionPointerINTEL
ConstantNull
ConstantPipeStorage
ConstantSampler
ConstantTrue
Constants
Construct acceleration structure
Construct bmat2
Construct bmat2x3
Construct bmat2x4
Construct bmat3
Construct bmat3x2
Construct bmat3x4
Construct bmat4
Construct bmat4x2
Construct bmat4x3
Construct bool
Construct bvec2
Construct bvec3
Construct bvec4
Construct combined texture-sampler
Construct cooperative matrix KHR
Construct cooperative matrix NV
Construct dmat2
Construct dmat2x3
Construct dmat2x4
Construct dmat3
Construct dmat3x2
Construct dmat3x4
Construct dmat4
Construct dmat4x2
Construct dmat4x3
Construct double
Construct dvec2
Construct dvec3
Construct dvec4
Construct f16mat2
Construct f16mat2x3
Construct f16mat2x4
Construct f16mat3
Construct f16mat3x2
Construct f16mat3x4
Construct f16mat4
Construct f16mat4x2
Construct f16mat4x3
Construct f16vec2
Construct f16vec3
Construct f16vec4
Construct float
Construct float16_t
Construct i16vec2
Construct i16vec3
Construct i16vec4
Construct i64vec2
Construct i64vec3
Construct i64vec4
Construct i8vec2
Construct i8vec3
Construct i8vec4
Construct imat2
Construct imat2x3
Construct imat2x4
Construct imat3
Construct imat3x2
Construct imat3x4
Construct imat4
Construct imat4x2
Construct imat4x3
Construct int
Construct int16_t
Construct int64
Construct int8_t
Construct ivec2
Construct ivec3
Construct ivec4
Construct mat2
Construct mat2x3
Construct mat2x4
Construct mat3
Construct mat3x2
Construct mat3x4
Construct mat4
Construct mat4x2
Construct mat4x3
Construct reference
Construct reference type
Construct structure
Construct u16vec2
Construct u16vec3
Construct u16vec4
Construct u64vec2
Construct u64vec3
Construct u64vec4
Construct u8vec2
Construct u8vec3
Construct u8vec4
Construct uint
Construct uint16_t
Construct uint64
Construct uint8_t
Construct umat2
Construct umat2x3
Construct umat2x4
Construct umat3
Construct umat3x2
Construct umat3x4
Construct umat4
Construct umat4x2
Construct umat4x3
Construct uvec2
Construct uvec3
Construct uvec4
Construct vec2
Construct vec3
Construct vec4
Constu
ContractionOff
Contradictory depth layouts
Contradictory input layout primitives
Contradictory input vertex spacing
Contradictory layout max_primitives values
Contradictory layout max_vertices values
Contradictory layout vertices values
Contradictory local size
Contradictory local size specialization ids
Contradictory output layout primitives
Contradictory triangle ordering
Contradictory xfb_stride
ControlBarrier
ControlBarrierArriveINTEL
ControlBarrierWaitINTEL
Convert SPIR-V to MSL source code
Convert bool to double
Convert bool to float
Convert bool to float16_t
Convert bool to in16t_t
Convert bool to int
Convert bool to int64
Convert bool to int8_t
Convert bool to uint
Convert bool to uint16_t
Convert bool to uint64
Convert bool to uint8_t
Convert double to bool
Convert double to float
Convert double to float16_t
Convert double to int
Convert double to int16_t
Convert double to int64
Convert double to int8_t
Convert double to uint
Convert double to uint16_t
Convert double to uint64
Convert double to uint8_t
Convert float to bool
Convert float to double
Convert float to float16_t
Convert float to int
Convert float to int16_t
Convert float to int64
Convert float to int8_t
Convert float to uint
Convert float to uint16_t
Convert float to uint64
Convert float to uint8_t
Convert float16_t to bool
Convert float16_t to double
Convert float16_t to float
Convert float16_t to int
Convert float16_t to int16_t
Convert float16_t to int64
Convert float16_t to int8_t
Convert float16_t to uint
Convert float16_t to uint16_t
Convert float16_t to uint64
Convert float16_t to uint8_t
Convert int to bool
Convert int to double
Convert int to float
Convert int to float16_t
Convert int to int16_t
Convert int to int64
Convert int to int8_t
Convert int to uint
Convert int to uint16_t
Convert int to uint64
Convert int to uint8_t
Convert int16_t to bool
Convert int16_t to double
Convert int16_t to float
Convert int16_t to float16_t
Convert int16_t to int
Convert int16_t to int64
Convert int16_t to int8_t
Convert int16_t to uint
Convert int16_t to uint16_t
Convert int16_t to uint64
Convert int16_t to uint8_t
Convert int64 to bool
Convert int64 to double
Convert int64 to float
Convert int64 to float16_t
Convert int64 to int
Convert int64 to int16_t
Convert int64 to int8_t
Convert int64 to uint
Convert int64 to uint16_t
Convert int64 to uint64
Convert int64 to uint8_t
Convert int8_t to bool
Convert int8_t to double
Convert int8_t to float
Convert int8_t to float16_t
Convert int8_t to int
Convert int8_t to int16_t
Convert int8_t to int64
Convert int8_t to uint
Convert int8_t to uint16_t
Convert int8_t to uint64
Convert int8_t to uint8_t
Convert pointer to uint64_t
Convert uint to bool
Convert uint to double
Convert uint to float
Convert uint to float16_t
Convert uint to int
Convert uint to int16_t
Convert uint to int64
Convert uint to int8_t
Convert uint to uint16_t
Convert uint to uint64
Convert uint to uint8_t
Convert uint16_t to bool
Convert uint16_t to double
Convert uint16_t to float
Convert uint16_t to float16_t
Convert uint16_t to int
Convert uint16_t to int16_t
Convert uint16_t to int64
Convert uint16_t to int8_t
Convert uint16_t to uint
Convert uint16_t to uint64
Convert uint16_t to uint8_t
Convert uint64 to bool
Convert uint64 to double
Convert uint64 to float
Convert uint64 to float16_t
Convert uint64 to int
Convert uint64 to int16_t
Convert uint64 to int64
Convert uint64 to int8_t
Convert uint64 to uint
Convert uint64 to uint16
Convert uint64 to uint8_t
Convert uint64_t to acceleration structure
Convert uint64_t to pointer
Convert uint8_t to bool
Convert uint8_t to double
Convert uint8_t to float
Convert uint8_t to float16_t
Convert uint8_t to int
Convert uint8_t to int16_t
Convert uint8_t to int64
Convert uint8_t to int8_t
Convert uint8_t to uint
Convert uint8_t to uint16_t
Convert uint8_t to uint64
Convert uvec2 to acceleration strucuture
ConvertBF16ToFINTEL
ConvertFToBF16INTEL
ConvertFToS
ConvertFToU
ConvertImageToUNV
ConvertPtrToU
ConvertSToF
ConvertSampledImageToUNV
ConvertSamplerToUNV
ConvertUToAccelerationStructure is not supported in MSL
ConvertUToAccelerationStructureKHR
ConvertUToF
ConvertUToImageNV
ConvertUToPtr
ConvertUToSampledImageNV
ConvertUToSamplerNV
Converted
Converting
Cooperative matrix constructor argument must be scalar or cooperative matrix
Cooperative matrix type parameters mismatch
Cooperative matrix types must not be used in shared memory
CooperativeMatrixKHR
CooperativeMatrixLengthKHR
CooperativeMatrixLengthNV
CooperativeMatrixLoadKHR
CooperativeMatrixLoadNV
CooperativeMatrixMulAddKHR
CooperativeMatrixMulAddNV
CooperativeMatrixNV
CooperativeMatrixStoreKHR
CooperativeMatrixStoreNV
CopyLogical
CopyMemory
CopyMemorySized
CopyObject
CoreBuiltinsARM
CoreCountARM
CoreIDARM
CoreMaxIDARM
Could not %scompress data (Error code %li):\n%s
Could not allocate %llu bytes of host-accessible device memory
Could not bind VkBuffer %p to a VkDeviceMemory dedicated to resource %p. A dedicated allocation may only be used with the resource it was dedicated to
Could not bind VkImage %p to a VkDeviceMemory dedicated to resource %p. A dedicated allocation may only be used with the resource it was dedicated to
Could not bind a VkBuffer to a VkDeviceMemory of size %llu bytes. The maximum memory-aligned size of a VkDeviceMemory that supports a VkBuffer is %llu bytes
Could not compile command shaders (Error code %li):\n%s
Could not compile support shader from MSL source (Error code %li):\n%s\n%s
Could not compile watermark shaders (Error code %li):\n%s
Could not create MTLCounterSampleBuffer of size %llu, for %d queries, in query pool of type %s. Reverting to emulated behavior. (Error code %li): %s
Could not create an MTLBuffer for an image that requires a buffer backing store. Images that can be used for atomic accesses must have a texel buffer backing them
Could not create watermark pipeline state (Error code %li)\n%s
Could not find memory type corresponding to VkMemoryPropertyFlags %d
Could not open file for reading
Could not open file for writing
Could not process include directive
Could not read entire contents of file
Could not write SPIR-V file
Could not write entire contents of file
Couldn't translate unknown extended instruction name
CounterBuffer
Cp[A\\A^A
Create the transpose of the cofactors, as the classical adjoint of the matrix
CreatePipeFromPipeStorage
CreateUserEvent
Created %d swapchain images with initial size (%d, %d) and contents scale %.1f for screen %s
Created VkDevice to run on GPU %s with the following %d Vulkan extensions enabled:%s
Created VkInstance for Vulkan version %s, as requested by app, with the following %d Vulkan extensions enabled:%s
CrossDevice
CrossWorkgroup
CrossWorkgroupCastToPtrINTEL
CrossWorkgroupMemory
Ctencil
CubeFace = P.x >= 0 ? 0 : 1
CubeFace = P.y >= 0 ? 2 : 3
CubeFace = P.z >= 0 ? 4 : 5
CubeFaceCoordAMD
CubeFaceIndexAMD
CullBackFacingTrianglesKHR
CullDistance
CullDistancePerViewNV
CullFrontFacingTrianglesKHR
CullMaskKHR
CullMode
CullNoOpaqueKHR
CullOpaqueKHR
CullPrimitiveEXT
CurrentRayTimeNV
Currently no block to insert opcode
Cᒱq\v\r
D$ I;G
D$ K;D> H
D$&\ft\tH
D$,IcD$0H
D$0I;D$(t
D$4A9D$ps.H
D$DA;D$0s)H
D$HA;D$4s)H
D$LA;D$8s&H
D$XA;D$0s)H
D$\bH;E
D$\bI;D
D$\v\aujD
D$lA;D$0s&H
D$tA;D$8s3H
D+N(H
D+d\btYF
D.c@t|A
D9 t\rH
D9!tCH
D9!t\fH
D91t\fH
D93t\fH
D9`\ft\nD9
D9b,u
D9r\bt\v
D;0s:J
D;D>\bs
D;I }TH
D;I }TL
D;O }\rM
D;p@u-D
D;p\ft
D=\bnputC
DBL_DIG
DBL_EPSILON
DBL_MANT_DIG
DBL_MAX
DBL_MAX_10_EXP
DBL_MAX_EXP
DBL_MIN
DBL_MIN_10_EXP
DBL_MIN_EXP
DBL_RADIX
DEC_OP
DEFAULT
DEMOTE
DEVICECOHERENT
DISCARD
DIV_ASSIGN
DMAT2X2
DMAT2X3
DMAT2X4
DMAT3X2
DMAT3X3
DMAT3X4
DMAT4X2
DMAT4X3
DMAT4X4
DOUBLE
DOUBLECONSTANT
DPdxCoarse
DPdxFine
DPdyCoarse
DPdyFine
DReference
DTestEnable
DViewport
DWriteMask
D\a\t0E\a
D\bd\btc
D_BUFFERH
DataSlotL
Debug Information
Debug printf
Debug printf is only supported in Vulkan GLSL.\n
Debug signposts
DebugBuildIdentifier
DebugCompilationUnit
DebugDeclare
DebugEntryPoint
DebugExpression
DebugFunction
DebugFunctionDeclaration
DebugFunctionDefinition
DebugGlobalVariable
DebugImportedEntity
DebugInfo
DebugInfoModuleINTEL
DebugInfoNone
DebugInlinedAt
DebugInlinedVariable
DebugLexicalBlock
DebugLexicalBlockDiscriminator
DebugLine
DebugLocalVariable
DebugMacroDef
DebugMacroUndef
DebugModuleINTEL
DebugNoLine
DebugNoScope
DebugOperation
DebugScope
DebugSource
DebugSourceContinued
DebugStoragePath
DebugTypeArray
DebugTypeBasic
DebugTypeComposite
DebugTypeEnum
DebugTypeFunction
DebugTypeInheritance
DebugTypeMatrix
DebugTypeMember
DebugTypePointer
DebugTypePtrToMember
DebugTypeQualifier
DebugTypeTemplate
DebugTypeTemplateParameter
DebugTypeTemplateParameterPack
DebugTypeTemplateTemplateParameter
DebugTypeVector
DebugTypedef
DebugUtilsLabelEXT
DebugUtilsObject
DebugValue
Declare
Declared struct in block cannot be empty
Decompress MSL source code during pipeline cache write
Decorate
DecorateId
DecorateString
DecorateStringGOOGLE
DecorationComponent on matrices and arrays is not supported
DecorationGroup
Dedicated, host-shared temporary buffers are not supported
Default case label fallthrough to other case label is not supported in ESSL 1.0
DefaultRuneLocale
Degrees
Demote
DemoteToHelperInvocation
DemoteToHelperInvocationEXT
DenormFlushToZero
DenormPreserve
Dependency
DependencyArrayINTEL
DependencyInfinite
DependencyLength
DepthAttachmentReadEXT
DepthFormat
DepthFromVkClearValue
DepthGreater
DepthLess
DepthReplacing
DepthResolveFilterFromVkResolveModeFlagBits
DepthStencil
DepthStencilImage
DepthUnchanged
DerivativeControl
DerivativeGroupLinearNV
DerivativeGroupQuadsNV
Descriptor aliasing is currently not supported with dynamic offsets
Descriptor aliasing is currently not supported with inline UBOs
DescriptorSet
DescriptorSets
Determinant
Device
Device %s does not support arrays of samplers
Device %s does not support arrays of textures
Device activity performance summary
DeviceAddress
DeviceEnqueue
DeviceEvH
DeviceEvent
DeviceGroup
DeviceIndex
DeviceMVK
DeviceMemoryBarrier
DeviceMemoryBarrierWithGroupSync
DeviceOnlyINTEL
Dffffff
Did not find suitable rule for type. Bogus decorations
Did you mean gl_InstanceIndex
Did you mean gl_VertexIndex
Discrete
DispatcK
Dispatch
DispatchH
Distance
DistanceH
Divide the classical adjoint matrix by the determinant
DontFlatten
DontInline
DontStaticallyCoalesceINTEL
DontUnroll
DotProduct
DotProductInput4x8Bit
DotProductInput4x8BitKHR
DotProductInput4x8BitPacked
DotProductInput4x8BitPackedKHR
DotProductInputAll
DotProductInputAllKHR
DotProductKHR
DoublepumpINTEL
DragonJoker
DragonJoker ShaderWriter
DrawId
DrawIndex
DrawIndex is not supported in MSL
DrawIndex not supported in ES profile
DrawParameters
E I;D
E(PASAR
E(PSAU
E+O(H
E9f\fukH
E9f\fuwH
EIG<HcV
EPA;E<s)H
EPI;EX
ERROR
ERROR: Failed to open file: %s\n
ER_QUEUEH
ES Profile
EXPLICITINTERPAMD
E\a\npF\a
E\byEXTA
E\vM̉\vH
E\vh\fff
EarlyAndLateFragmentTestsAMD
EarlyFragmentTests
EdA;E<s&H
Efffff
Effffff
EhI;D$h
EhI;Ep
Either row-major or column-major must be declared for matrices
Elect on iOS requires Metal 2.2 and up
Embark Studios
Embark Studios Rust GPU Compiler Backend
EmitMeshTasksEXT
EmitStreamVertex
EmitVertex
Emitting threads_per_simdgroup attribute with fixed subgroup size
Enable
Encoders for %p "%s
End GLSL\n\n
End of input in comment
End of input in macro
End of input reached while decoding Op
End of line in macro substitution
End of line in string
EndEXT
EndInvocationInterlockEXT
EndPrimitive
EndQueryH
EndStreamPrimitive
EnqueueKernel
EnqueueMarker
EnqueuedWorkgroupSize
Entering state %d\n
Entry point does not exist
EntryPoint
EriteTimestamp
Error compiling GLSL when converting GLSL to SPIR-V
Error creating GLSL program when converting GLSL to SPIR-V
Error reading pipeline cache data: %s
Error writing pipeline cache data: %s
Error: Result Id is 0
Error: Type Id is 0
Error: discarding
Error: popping
Estimated original
EvenfǅE
ExA;E<s&H
ExclusiveScan
ExecuteCallableKHR
ExecuteCallableNV
ExecutionMode
ExecutionModeId
ExpectAssumeKHR
ExpectKHR
Expected '=', found end of stream
Expected <opcode> or <result-id> at the beginning of an instruction, found
Expected <result-id> at the beginning of an instruction, found
Expected hex value in escape sequence
Expected id to start with
Expected literal string, found literal number
Expected opcode, found end of stream
Expected operand for
ExplicitInterpAMD
Export
ExtInst
ExtInstImport
Extended arithmetic is only available from ESSL 310
Extended arithmetic is only available from GLSL 400
Extended arithmetic is only available from GLSL 4000
Extension
Extension %s is deprecated. For access to Metal objects, use extension %s. For MoltenVK configuration, use the global vkGetMoltenVKConfigurationMVK() and vkSetMoltenVKConfigurationMVK() functions
ExtensionProperties
External
External2DY2YEXT
ExternalOES
EĉMЉUȉu
EЀ8(uG
EЀ9!ugH
EЃx\f\bt\nH
EЅW\ft\a
EЉD$0D
EЉD$\bH
F ;C t;I
F H;C
F H;C D
F I;D
F I;D$ }\e
F I;E L
F I;E |\v
F I;G
F I;G |\v
F [A\\A^A
F,A;E,r
F,L9c0
F16IMAGE1D
F16IMAGE1DARRAY
F16IMAGE2D
F16IMAGE2DARRAY
F16IMAGE2DMS
F16IMAGE2DMSARRAY
F16IMAGE2DRECT
F16IMAGE3D
F16IMAGEBUFFER
F16IMAGECUBE
F16IMAGECUBEARRAY
F16MAT2
F16MAT2X2
F16MAT2X3
F16MAT2X4
F16MAT3
F16MAT3X2
F16MAT3X3
F16MAT3X4
F16MAT4
F16MAT4X2
F16MAT4X3
F16MAT4X4
F16SAMPLER1D
F16SAMPLER1DARRAY
F16SAMPLER1DARRAYSHADOW
F16SAMPLER1DSHADOW
F16SAMPLER2D
F16SAMPLER2DARRAY
F16SAMPLER2DARRAYSHADOW
F16SAMPLER2DMS
F16SAMPLER2DMSARRAY
F16SAMPLER2DRECT
F16SAMPLER2DRECTSHADOW
F16SAMPLER2DSHADOW
F16SAMPLER3D
F16SAMPLERBUFFER
F16SAMPLERCUBE
F16SAMPLERCUBEARRAY
F16SAMPLERCUBEARRAYSHADOW
F16SAMPLERCUBESHADOW
F16SUBPASSINPUT
F16SUBPASSINPUTMS
F16TEXTURE1D
F16TEXTURE1DARRAY
F16TEXTURE2D
F16TEXTURE2DARRAY
F16TEXTURE2DMS
F16TEXTURE2DMSARRAY
F16TEXTURE2DRECT
F16TEXTURE3D
F16TEXTUREBUFFER
F16TEXTURECUBE
F16TEXTURECUBEARRAY
F16VEC2
F16VEC3
F16VEC4
F32MAT2
F32MAT2X2
F32MAT2X3
F32MAT2X4
F32MAT3
F32MAT3X2
F32MAT3X3
F32MAT3X4
F32MAT4
F32MAT4X2
F32MAT4X3
F32MAT4X4
F32VEC2
F32VEC3
F32VEC4
F64MAT2
F64MAT2X2
F64MAT2X3
F64MAT2X4
F64MAT3
F64MAT3X2
F64MAT3X3
F64MAT3X4
F64MAT4
F64MAT4X2
F64MAT4X3
F64MAT4X4
F64VEC2
F64VEC3
F64VEC4
FAMILIESH
FCOOPMATNV
FClamp
FConvert
FIXME: This won't include higher bits if Apple ever supports
FLOAT16CONSTANT
FLOAT16_T
FLOAT32_T
FLOAT64_T
FLOATCONSTANT
FLT_DIG
FLT_EPSILON
FLT_MANT_DIG
FLT_MAX
FLT_MAX_10_EXP
FLT_MAX_EXP
FLT_MIN
FLT_MIN_10_EXP
FLT_MIN_EXP
FLT_RADIX
FMax3AMD
FMid3AMD
FMin3AMD
FNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjE
FNegate
FOrdEqual
FOrdGreaterThan
FOrdGreaterThanEqual
FOrdLessThan
FOrdLessThanEqual
FOrdNotEqual
FP denorm mode
FP operation mode
FP64 not supported in ES profile
FPFastMathMode
FPFastMathModeINTEL
FPGAArgumentInterfacesINTEL
FPGABufferLocationINTEL
FPGAClusterAttributesINTEL
FPGADSPControlINTEL
FPGAInvocationPipeliningAttributesINTEL
FPGAKernelAttributesINTEL
FPGAKernelAttributesv2INTEL
FPGALatencyControlINTEL
FPGALoopControlsINTEL
FPGAMemoryAccessesINTEL
FPGAMemoryAttributesINTEL
FPGARegINTEL
FPMaxErrorDecorationINTEL
FPMaxErrorINTEL
FPRoundingMode
FP_ILOGB0
FP_ILOGBNAN
FUnordEqual
FUnordGreaterThan
FUnordGreaterThanEqual
FUnordLessThan
FUnordLessThanEqual
FUnordNotEqual
FUtilsMessengerEXT
F\b2G\bt
F\b;G\bu
F\bA3G\b
F\b[A
F\be_idA
F\bexIDA
F\bmaskA
F\boordA
F\brtexA
F\e\atMH
F\f[A
F\n t$H
F\n@t(H
F\n@tcH
F\n@uR1
F\n`t\rL
F\tcingA
F\v\at$H
FaceForward
FactorFromVkBlendFactor
Failed to automatically start GPU capture session (Error code %li): %s
Failed to get tessellation control inputs: %s
Failed to get tessellation control outputs: %s
Failed to get tessellation evaluation inputs: %s
Failed to get tessellation evaluation outputs: %s
Failed to get vertex outputs: %s
Failed to read
Failed to reflect tessellation shaders: %s
Failed to write
FenceProperties
FferredOperationKHR
Fffff
Fffffff
FhH;X\bu
FillBuffer
Finalizer
FindILsb
FindSMsb
FindUMsb
FixedCosINTEL
FixedCosPiINTEL
FixedExpINTEL
FixedLogINTEL
FixedRecipINTEL
FixedRsqrtINTEL
FixedSinCosINTEL
FixedSinCosPiINTEL
FixedSinINTEL
FixedSinPiINTEL
FixedSqrtINTEL
FlagArtificial
FlagExplicit
FlagFwdDecl
FlagIndirectVariable
FlagIsDefinition
FlagIsEnumClass
FlagIsLocal
FlagIsOptimized
FlagIsPrivate
FlagIsProtected
FlagIsPublic
FlagLValueReference
FlagObjectPointer
FlagPrototyped
FlagRValueReference
FlagStaticMember
FlagTypePassByReference
FlagTypePassByValue
Flat, Centroid, Sample, NoPerspective decorations are not supported for BaryCoord inputs
Flatten
Flattening of multidimensional arrays were enabled, but the access chain was terminated in the middle of a multidimensional array. This is not supported
Float -> Int bitcast not supported on legacy ESSL
Float -> Uint bitcast not supported on legacy ESSL
Float16
Float16Buffer
Float16ImageAMD
Float64
FloatValueFromVkComponentSwizzle
Floating point atomics requires Vulkan semantics
Floating point atomics requires desktop GLSL
FloatingPointModeALTINTEL
FloatingPointModeIEEEINTEL
FloatingPointModeINTEL
FlushToZero
FogFragCoord
ForFences
ForceOpacityMicromap2StateEXT
ForcePow2DepthINTEL
Format type %u is not supported for clearing with a compute shader
Format type %u is not supported for resolving with a compute shader
FormatFromVkFormat
FormatTypeFrom
Found a buffer packing case which we cannot represent in MSL
Found attribute with size (%u) larger than it's binding's stride (%u). Changing descriptor format from %s to %s
FputePipelines
Fraction
FragColor
FragCoord
FragData
FragDepth
FragFullyCoveredNV
FragInvocationCountEXT
FragSizeEXT
FragStencilRef
FragStencilRefEXT
Fragment
FragmentBarycentricKHR
FragmentBarycentricNV
FragmentDensityEXT
FragmentFetchAMD
FragmentFullyCoveredEXT
FragmentH3P
FragmentI3V\aH\t
FragmentMaskAMD
FragmentMaskFetchAMD
FragmentOutputs
FragmentOutputs out
FragmentShaderPixelInterlockEXT
FragmentShaderSampleInterlockEXT
FragmentShaderShadingRateInterlockEXT
FragmentShadingRateKHR
FragmentSizeNV
Frame interval
Framebuffer fetch on Mac is not supported before MSL 2.3
FrexpStruct
FromConstantToDevice
FromConstantToStack
FromConstantToThreadGroup
FromDeviceToDevice
FromDeviceToStack
FromDeviceToThreadGroup
FromStackToDevice
FromStackToStack
FromStackToThreadGroup
FromThreadGroupToDevice
FromThreadGroupToStack
FromThreadGroupToThreadGroup
FromVkComponentSwizzle
FromVkFormat
FromVkIndexType
FrontColor
FrontFacing
FrontSecondaryColor
FullyCoveredEXT
FuncParamAttr
FuncParamIOKindINTEL
Function
Function Call
Function Definition
Function Parameters
Function specialization
Function was not terminated
FunctionCall
FunctionDenormModeINTEL
FunctionEnd
FunctionFloatControlINTEL
FunctionFloatingPointModeINTEL
FunctionParameter
FunctionPointerCallINTEL
FunctionPointersINTEL
FunctionRoundingModeINTEL
FuseLoopsInFunctionINTEL
Fwidth
FwidthCoarse
FwidthFine
F{ tIH
G A;F uAI
G I;F D
G ]ÐUH
G(r$A
G,A;E,sOffffff
G0H+G(H
G0H;G8t
G@H;G8tPI
G@HcF$H
GAmainf
GD;L:Lt
GEvent
GLCompute
GLSL.std.450
GLSL450
GLSL:\n
GLSLPacked
GLSLShared
GL_3DL_array_objects
GL_AMD_gcn_shader
GL_AMD_gpu_shader_half_float
GL_AMD_gpu_shader_half_float_fetch
GL_AMD_gpu_shader_int16
GL_AMD_gpu_shader_int64
GL_AMD_shader_ballot
GL_AMD_shader_early_and_late_fragment_tests
GL_AMD_shader_explicit_vertex_parameter
GL_AMD_shader_fragment_mask
GL_AMD_shader_image_load_store_lod
GL_AMD_shader_trinary_minmax
GL_AMD_texture_gather_bias_lod
GL_ANDROID_extension_pack_es31a
GL_ARB_arrays_of_arrays
GL_ARB_bindless_texture
GL_ARB_compute_shader
GL_ARB_derivative_control
GL_ARB_derivative_control is unavailable in OpenGL ES
GL_ARB_draw_instanced
GL_ARB_enhanced_layouts
GL_ARB_enhanced_layouts is not supported in ESSL
GL_ARB_enhanced_layouts is not supported in targets below GLSL 1.40
GL_ARB_explicit_attrib_location
GL_ARB_explicit_uniform_location
GL_ARB_fragment_coord_conventions
GL_ARB_fragment_shader_interlock
GL_ARB_gH
GL_ARB_geometry_shader4
GL_ARB_gpu_shader5
GL_ARB_gpu_shader_fp64
GL_ARB_gpu_shader_int64
GL_ARB_post_depth_coverage
GL_ARB_sample_shading
GL_ARB_separate_shader_objects
GL_ARB_shader_atomic_counter_ops
GL_ARB_shader_atomic_counters
GL_ARB_shader_ballot
GL_ARB_shader_bit_encoding
GL_ARB_shader_clock
GL_ARB_shader_draw_parameters
GL_ARB_shader_group_vote
GL_ARB_shader_image_load_store
GL_ARB_shader_image_size
GL_ARB_shader_int64
GL_ARB_shader_stencil_export
GL_ARB_shader_storage_buffer_object
GL_ARB_shader_texture_image_samples
GL_ARB_shader_texture_lod
GL_ARB_shader_viewport_layer_array
GL_ARB_shading_language_420pack
GL_ARB_shading_language_packing
GL_ARB_sparse_texture2
GL_ARB_sparse_texture_clamp
GL_ARB_tessellation_shader
GL_ARB_texture_cube_map_array
GL_ARB_texture_gather
GL_ARB_texture_multisample
GL_ARB_texture_query_levels
GL_ARB_texture_query_lod
GL_ARB_texture_query_samples
GL_ARB_texture_rectangle
GL_ARB_transform_feedback3
GL_ARB_uniform_buffer_object
GL_ARB_vertex_attrib_64bit
GL_ARB_viewport_array
GL_ARM_shader_core_builtins
GL_EXT_YUV_target
GL_EXT_blend_func_extended
GL_EXT_buffer_reference
GL_EXT_buffer_reference is only supported in Vulkan GLSL
GL_EXT_buffer_reference requires ESSL 320
GL_EXT_buffer_reference requires GLSL 450
GL_EXT_buffer_reference2
GL_EXT_buffer_reference_uvec2
GL_EXT_cH
GL_EXT_clip_cull_distance
GL_EXT_control_flow_attributes
GL_EXT_debug_printf
GL_EXT_demote_to_helper_invocation
GL_EXT_demote_to_helper_invocation is only supported in Vulkan GLSL
GL_EXT_device_group
GL_EXT_draw_buffers
GL_EXT_frag_depth
GL_EXT_fragment_invocation_density
GL_EXT_fragment_shader_barycentric
GL_EXT_fragment_shading_rate
GL_EXT_geometry_point_size
GL_EXT_geometry_shader
GL_EXT_gpu_shader4
GL_EXT_gpu_shader5
GL_EXT_mesh_shader
GL_EXT_mesh_shader is already turned on, and not allowed with
GL_EXT_multiview
GL_EXT_nonuniform_qualifier
GL_EXT_nonuniform_qualifier is only supported in Vulkan GLSL
GL_EXT_null_initializer
GL_EXT_opacity_micromap
GL_EXT_post_depth_coverage
GL_EXT_primitive_bounding_box
GL_EXT_ray_cull_mask
GL_EXT_ray_flags_primitive_culling
GL_EXT_ray_query
GL_EXT_ray_tracing
GL_EXT_ray_tracing_position_fetch
GL_EXT_samplerless_texture_functions
GL_EXT_scalar_block_layout
GL_EXT_shader_16bit_storage
GL_EXT_shader_8bit_storage
GL_EXT_shader_atomic_float
GL_EXT_shader_atomic_float2
GL_EXT_shader_atomic_int64
GL_EXT_shader_explicit_arithmetic_types
GL_EXT_shader_explicit_arithmetic_types_float16
GL_EXT_shader_explicit_arithmetic_types_float32
GL_EXT_shader_explicit_arithmetic_types_float64
GL_EXT_shader_explicit_arithmetic_types_int16
GL_EXT_shader_explicit_arithmetic_types_int32
GL_EXT_shader_explicit_arithmetic_types_int64
GL_EXT_shader_explicit_arithmetic_types_int8
GL_EXT_shader_framebuffer_fetch
GL_EXT_shader_framebuffer_fetch_non_coherent
GL_EXT_shader_image_int64
GL_EXT_shader_image_load_formatted
GL_EXT_shader_implicit_conversions
GL_EXT_shader_integer_mix
GL_EXT_shader_io_blocks
GL_EXT_shader_non_constant_global_initializers
GL_EXT_shader_pixel_local_storage
GL_EXT_shader_realtime_clock
GL_EXT_shader_subgroup_extended_types_float16
GL_EXT_shader_subgroup_extended_types_int16
GL_EXT_shader_subgroup_extended_types_int64
GL_EXT_shader_subgroup_extended_types_int8
GL_EXT_shader_texture_lod
GL_EXT_shader_tile_image
GL_EXT_shadow_samplers
GL_EXT_shared_memory_block
GL_EXT_spirv_intrinsics
GL_EXT_subgroup_uniform_control_flow
GL_EXT_terminate_invocation
GL_EXT_tessellation_point_size
GL_EXT_tessellation_shader
GL_EXT_texture_array
GL_EXT_texture_buffer
GL_EXT_texture_buffer_object
GL_EXT_texture_cube_map_array
GL_EXT_texture_query_lod
GL_GOOGLE_cpp_style_line_directive
GL_GOOGLE_include_directive
GL_INTEL_shader_integer_functions2
GL_KHR_blend_equation_advanced
GL_KHR_cooperative_matrix
GL_KHR_memory_scope_semantics
GL_KHR_shader_subgroup_arithmetic
GL_KHR_shader_subgroup_ballot
GL_KHR_shader_subgroup_basic
GL_KHR_shader_subgroup_clustered
GL_KHR_shader_subgroup_quad
GL_KHR_shader_subgroup_shuffle
GL_KHR_shader_subgroup_shuffle_relative
GL_KHR_shader_subgroup_vote
GL_NVX_multiview_per_view_attributes
GL_NV_compute_shader_derivatives
GL_NV_conservative_raster_underestimation
GL_NV_cooperative_matrix
GL_NV_frI
GL_NV_fragment_shader_barycentric
GL_NV_fragment_shader_interlock
GL_NV_geometry_shader_passthrough
GL_NV_gpu_shader5
GL_NV_gpu_shader_5
GL_NV_integer_cooperative_matrix
GL_NV_mesh_shader
GL_NV_mesh_shader is already turned on, and not allowed with
GL_NV_ray_tracing
GL_NV_ray_tracing_motion_blur
GL_NV_sample_mask_override_coverage
GL_NV_shader_atomic_int64
GL_NV_shader_invocation_reorder
GL_NV_shader_noperspective_interpolation
GL_NV_shader_sm_builtins
GL_NV_shader_subgroup_partitioned
GL_NV_shader_texture_footprint
GL_NV_shader_thread_group
GL_NV_shader_thread_shuffle
GL_NV_shading_rate_image
GL_NV_shadow_samplers_cube
GL_NV_stereo_view_rendering
GL_NV_viewport_array2
GL_OES_EGL_image_external
GL_OES_EGL_image_external_essl3
GL_OES_geometry_point_size
GL_OES_geometry_shader
GL_OES_gpu_shader5
GL_OES_primitive_bounding_box
GL_OES_sample_variables
GL_OES_shader_image_atomic
GL_OES_shader_io_blocks
GL_OES_shader_multisample_interpolation
GL_OES_standard_derivatives
GL_OES_tessellation_point_size
GL_OES_tessellation_shader
GL_OES_texture_3D
GL_OES_texture_buffer
GL_OES_texture_cube_map_array
GL_OES_texture_storage_multisample_2d_array
GL_OVR_multiview
GL_OVR_multiview2
GPU deviH
GPU device
GP[A\\A^A
GS[go
GSetLayout
GXH;G`D
G\b9p0v
G\b;F\bu\v
G\bA2E\bL
G\bA2F\bt
G\bA3F\b
G\bH9X0v=H
G\bI+\aH
G\bI9F0v7H
G\tbeNVA
G_INLINEH
Gather
GdA;E
GdB;D3
Generating SPIR-V array-of-arrays, but Vulkan only supports single array level for this resource
Generator
Generic
GenericCastToPtr
GenericCastToPtrExplicit
GenericPointer
GenericPtrMemSemantics
Geometry
Geometry streams can only be used in geometry shaders
GeometryIndexEXT
GeometryPointSize
GeometryShaderPassthroughNV
GeometryStreams
GetDefaultQueue
GetKernelLocalSizeForSubgroupCount
GetKernelMaxNumSubgroups
GetKernelNDrangeMaxSubGroupSize
GetKernelNDrangeSubGroupCount
GetKernelPreferredWorkGroupSizeMultiple
GetKernelWorkGroupSize
GetMaxPipePackets
GetNumPipePackets
Gfffff
Gffffff
Ghken
GlobalInvocationID
GlobalInvocationId
GlobalLiH
GlobalLinearId
GlobalOfH
GlobalOffset
GlobalSiH
GlobalSize
GlobalVariableOffsetINTEL
Glslang Reference Front End
Google
Google ANGLE Shader Compiler
Google Clspv
Google MLIR SPIR-V Serializer
Google Shaderc over Glslang
Google Skia SkSL
Google Tint Compiler
Google rspirv
Google spiregg
GradARB
GradEXT
GroupAll
GroupAny
GroupAsyncCopy
GroupBitwiseAndKHR
GroupBitwiseOrKHR
GroupBitwiseXorKHR
GroupBroadcast
GroupCommitReadPipe
GroupCommitWritePipe
GroupDecorate
GroupFAdd
GroupFAddNonUniformAMD
GroupFMax
GroupFMaxNonUniformAMD
GroupFMin
GroupFMinNonUniformAMD
GroupFMulKHR
GroupIAdd
GroupIAddNonUniformAMD
GroupIMulKHR
GroupLogicalAndKHR
GroupLogicalOrKHR
GroupLogicalXorKHR
GroupMemberDecorate
GroupMemoryBarrier
GroupNonUniform
GroupNonUniformAll
GroupNonUniformAllEqual
GroupNonUniformAny
GroupNonUniformArithmetic
GroupNonUniformBallot
GroupNonUniformBallotBitCount
GroupNonUniformBallotBitExtract
GroupNonUniformBallotFindLSB
GroupNonUniformBallotFindMSB
GroupNonUniformBitwiseAnd
GroupNonUniformBitwiseOr
GroupNonUniformBitwiseXor
GroupNonUniformBroadcast
GroupNonUniformBroadcastFirst
GroupNonUniformClustered
GroupNonUniformElect
GroupNonUniformFAdd
GroupNonUniformFMax
GroupNonUniformFMin
GroupNonUniformFMul
GroupNonUniformIAdd
GroupNonUniformIMul
GroupNonUniformInverseBallot
GroupNonUniformLogicalAnd
GroupNonUniformLogicalOr
GroupNonUniformLogicalXor
GroupNonUniformPartitionNV
GroupNonUniformPartitionedNV
GroupNonUniformQuad
GroupNonUniformQuadBroadcast
GroupNonUniformQuadSwap
GroupNonUniformRotateKHR
GroupNonUniformSMax
GroupNonUniformSMin
GroupNonUniformShuffle
GroupNonUniformShuffleDown
GroupNonUniformShuffleRelative
GroupNonUniformShuffleUp
GroupNonUniformShuffleXor
GroupNonUniformUMax
GroupNonUniformUMin
GroupNonUniformVote
GroupReserveReadPipePackets
GroupReserveWritePipePackets
GroupSMax
GroupSMaxNonUniformAMD
GroupSMin
GroupSMinNonUniformAMD
GroupUMax
GroupUMaxNonUniformAMD
GroupUMin
GroupUMinNonUniformAMD
GroupUniformArithmeticKHR
GroupWaitEvents
Groups
Gscriptor
GxA;Fx
H hval = H(fval
H!H\bE1
H#A(H\t
H#B\bH\t
H#F H\t
H#H H\t
H#H\bH\t
H#H\bL\t
H#J(H\t
H#N H\t
H#~ H\t
H(H+H H
H)ًR\bL
H+G\bt'H
H+G\bt,H
H,A;O,r
H3q\aH\t
H97txM
H9A0v!H
H9A0v0H
H9A8vDH
H9A\bt4H
H9A\btwH
H9B\btmI
H9C0v#H
H9C0v%H
H9C0v'H
H9F0v I
H9F0v!H
H9F0v!I
H9F0v$I
H9F0v0H
H9F0v\eI
H9G0v!H
H9G0v,H
H9G0vLH
H9G`v\nH
H9H0v(H
H9N0v6H
H9O0vFH
H9O`v)H
H9P rgA
H9Q\br H
H9\bt\fH
H9_0vaI
H9s0v$H
H9w u I
H9~(t H
H;A s
H;C\bu(H
H;C\bu*H
H;X t\bD9
H;X(v*A
H;X\bt(E1
H;X\bt5I
H;X\bt=I
H;\bu(H
H;\nu(H
H;\rs?A
H;_0t
H;_Ht
H;r uLH
HALF_DIG
HALF_EPSILON
HALF_MANT_DIG
HALF_MAX
HALF_MAX_10_EXP
HALF_MAX_EXP
HALF_MIN
HALF_MIN_10_EXP
HALF_MIN_EXP
HALF_RADIX
HDR10MetadataWithDisplayInfo:contentInfo:opticalOutputScale
HERO_C
HGraphicsPipelines
HI;]PtvL
HIGH_PRECISION
HITATTREXT
HITATTRNV
HITOBJECTATTRNV
HITOBJECTNV
HUGE_VAL
HUGE_VALF
HUGE_VALH
HUpdateTemplate
H[A^A
H\a\n I\a
H\b2K\bL
H\b;K\bu
H\bA9M\bu
H\bA;O\bu
H\bH+\bH
H\bH+\bI
H\bH;\bL
H\bH;\bt%1
H\bH;\bu$I
H\b[A
H\fu)H
HalfFloat
Hash shader SPIR-V code
HcC HcK\b9
HcC8D9
HcG HcO\b9
HelperInvocation
Hero C Compiler
Hffffff
HitAttributeKHR
HitAttributeNV
HitKindKHR
HitKindNV
HitObjectAttributeNV
HitObjectExecuteShaderNV
HitObjectGetAttributesNV
HitObjectGetCurrentTimeNV
HitObjectGetGeometryIndexNV
HitObjectGetHitKindNV
HitObjectGetInstanceCustomIndexNV
HitObjectGetInstanceIdNV
HitObjectGetInstaneIdNV
HitObjectGetObjectRayDirectionNV
HitObjectGetObjectRayOriginNV
HitObjectGetObjectToWorldNV
HitObjectGetPrimitiveIndexNV
HitObjectGetRayTMaxNV
HitObjectGetRayTMinNV
HitObjectGetShaderBindingTableRecordIndexNV
HitObjectGetShaderRecordBufferHandleNV
HitObjectGetWorldRayDirectionNV
HitObjectGetWorldRayOriginNV
HitObjectGetWorldToObjectNV
HitObjectIsEmptyNV
HitObjectIsHitNV
HitObjectIsMissNV
HitObjectReadShaderRecordBufferHandleNV
HitObjectRecordEmptyNV
HitObjectRecordHitMotionNV
HitObjectRecordHitNV
HitObjectRecordHitWithIndexMotionNV
HitObjectRecordHitWithIndexNV
HitObjectRecordMissMotionNV
HitObjectRecordMissNV
HitObjectShaderRecordBufferNV
HitObjectTraceRayMotionNV
HitObjectTraceRayNV
HitTNV
HitTriangleVertexPositionsKHR
HlslCounterBufferGOOGLE
HlslSemanticGOOGLE
Hnstance
Horizontal2Pixels
Horizontal4Pixels
HostOnlyINTEL
Hramebuffer
HxA;Ox
H|A:O
I#D$\bH\r
I#V H\t
I#V\bH\t
I#w@H\t
I+4$tr
I16@0:8
I16VEC2
I16VEC3
I16VEC4
I32VEC2
I32VEC3
I32VEC4
I3v\bH\t
I64IMAGE1D
I64IMAGE1DARRAY
I64IMAGE2D
I64IMAGE2DARRAY
I64IMAGE2DMS
I64IMAGE2DMSARRAY
I64IMAGE2DRECT
I64IMAGE3D
I64IMAGEBUFFER
I64IMAGECUBE
I64IMAGECUBEARRAY
I64VEC2
I64VEC3
I64VEC4
I8VEC2
I8VEC3
I8VEC4
I9@Hv\rI
I9D$ H
I9D$(w
I9D$0v
I9D$0v%I
I9D$0v+I
I9D$0vwI
I9D$`v+I
I9E0vBI
I9E0voI
I9E\bt:1
I9E\bt;1
I9E\bt<1
I9E\btr1
I9F0v'I
I9F\bt(1
I9G0v!I
I9G0v#I
I9G0v2I
I9GHv\rI
I9L$0v?I
I9L$0v\eI
I9N\bt#1
I9V0v2H
I9\\$0w
I9]0v8I
I9^0vAI
I9^0w\v
I9_0vJI
I9t$0v&I
I9u0vzI
I;D$\bu
I;FPs3L
I;F\br
I;G`t5
I;O |8
I;O |\t
I;\\$\bt$ffffff
I;] tvL
I;]\bt8
I;_Ht
IATTACHMENTEXT
IAddCarry
IAddSatINTEL
IAverageINTEL
IAverageRoundedINTEL
ICOOPMATNV
ID bound exceeds limit of 0x3fffff.\n
IDENTIFIER
IEqual
IGNORE_INTERSECTION
IIMAGE1D
IIMAGE1DARRAY
IIMAGE2D
IIMAGE2DARRAY
IIMAGE2DMS
IIMAGE2DMSARRAY
IIMAGE2DRECT
IIMAGE3D
IIMAGEBUFFER
IIMAGECUBE
IIMAGECUBEARRAY
ILayout
IMAGE1D
IMAGE1DARRAY
IMAGE2D
IMAGE2DARRAY
IMAGE2DMS
IMAGE2DMSARRAY
IMAGE2DRECT
IMAGE3D
IMAGEBUFFER
IMAGECUBE
IMAGECUBEARRAY
IMul32x16INTEL
INC_OP
INFINITY
INT16CONSTANT
INT16_T
INT32CONSTANT
INT32_T
INT64CONSTANT
INT64_T
INT8_T
INTCONSTANT
INTERNAL ERROR
INT_MAX
INT_MIN
INVARIANT
INotEqual
IO block member Stream mismatch
IO block member XfbBuffer mismatch
IO block member XfbStride mismatch
IOIteratorNext
IOObjectRelease
IOPCIDevice
IOPipeStorageINTEL
IOPipesINTEL
IORegistryEntryGetParentEntry
IORegistryEntryIDMatching
IORegistryEntrySearchCFProperty
IOService
IOServiceGetMatchingService
IOServiceGetMatchingServices
IOServiceMatching
IOSurfaceCreate
IOSurfaceGetBytesPerElement
IOSurfaceGetBytesPerElementOfPlane
IOSurfaceGetElementHeight
IOSurfaceGetElementHeightOfPlane
IOSurfaceGetElementWidth
IOSurfaceGetElementWidthOfPlane
IOSurfaceGetHeight
IOSurfaceGetHeightOfPlane
IOSurfaceGetPlaneCount
IOSurfaceGetWidth
IOSurfaceGetWidthOfPlane
IQueryPool
ISAMPLER1D
ISAMPLER1DARRAY
ISAMPLER2D
ISAMPLER2DARRAY
ISAMPLER2DMS
ISAMPLER2DMSARRAY
ISAMPLER2DRECT
ISAMPLER3D
ISAMPLERBUFFER
ISAMPLERCUBE
ISAMPLERCUBEARRAY
ISUBPASSINPUT
ISUBPASSINPUTMS
ISubBorrow
ISubSatINTEL
ITEXTURE1D
ITEXTURE1DARRAY
ITEXTURE2D
ITEXTURE2DARRAY
ITEXTURE2DMS
ITEXTURE2DMSARRAY
ITEXTURE2DRECT
ITEXTURE3D
ITEXTUREBUFFER
ITEXTURECUBE
ITEXTURECUBEARRAY
I\b2H\bu
I\b;A\bu
I\tL$ A
IcD$ IcL$\b9
IcF IcN\b9
Ic̈D\v
IcψD\v(H
IcψD\v(I
Id is 0
IetalSurfaceEXT
If determinant is zero, matrix is not invertable, so leave it unchanged
IgnoreIntersectionKHR
IgnoreIntersectionNV
Ignoring initializer for uniform
Illegal argument to OpQuantizeToF16
Illegal to have non-comment, non-whitespace tokens before #version
Image
Image1D
ImageArgumentInfoChannelDataTypePushConstant
ImageArgumentInfoChannelDataTypeUniform
ImageArgumentInfoChannelOrderPushConstant
ImageArgumentInfoChannelOrderUniform
ImageBasic
ImageBlockMatchSADQCOM
ImageBlockMatchSSDQCOM
ImageBoxFilterQCOM
ImageBuffer
ImageCubeArray
ImageDrefGather
ImageFetch
ImageFootprintNV
ImageFormatProperties
ImageGather
ImageGatherBiasLodAMD
ImageGatherExtended
ImageKHRH
ImageMSArray
ImageMemory
ImageMipmap
ImageQuery
ImageQueryFormat
ImageQueryLevels
ImageQueryLod
ImageQueryLod is only supported on MSL 2.2 and up
ImageQueryOrder
ImageQuerySamples
ImageQuerySize
ImageQuerySizeLod
ImageRead
ImageReadWrite
ImageReadWriteLodAMD
ImageRect
ImageSampleDrefExplicitLod
ImageSampleDrefImplicitLod
ImageSampleExplicitLod
ImageSampleFootprintNV
ImageSampleImplicitLod
ImageSampleProjDrefExplicitLod
ImageSampleProjDrefImplicitLod
ImageSampleProjExplicitLod
ImageSampleProjImplicitLod
ImageSampleWeightedQCOM
ImageSparseDrefGather
ImageSparseFetch
ImageSparseGather
ImageSparseRead
ImageSparseSampleDrefExplicitLod
ImageSparseSampleDrefImplicitLod
ImageSparseSampleExplicitLod
ImageSparseSampleImplicitLod
ImageSparseSampleProjDrefExplicitLod
ImageSparseSampleProjDrefImplicitLod
ImageSparseSampleProjExplicitLod
ImageSparseSampleProjImplicitLod
ImageSparseTexelsResident
ImageTexelPointer
ImageWrite
Imagination
Implementation of the GLSL degrees() function
Implementation of the GLSL findLSB() function
Implementation of the GLSL mod() function, which is slightly different than Metal fmod
Implementation of the GLSL radians() function
Implementation of the GLSL sign() function for integer types
Implementation of the signed GLSL findMSB() function
Implementation of the unsigned GLSL findMSB() function
Implicit size of unsized array doesn't match same symbol among multiple shaders
Import
Import Id is being defined a second time
ImportedDeclaration
ImportedModule
In.y, 0.0
InBoundsAccessChain
InBoundsPtrAccessChain
InclusiveScan
IncomingCallableDataKHR
IncomingCallableDataNV
IncomingRayFlagsKHR
IncomingRayFlagsNV
IncomingRayPayloadKHR
IncomingRayPayloadNV
IndexType
Indirect
IndirectL
IndirectReferencesINTEL
Initializer
Initializers must match
InitiationIntervalINTEL
Inline
InputAttachment
InputAttachmentArrayDynamicIndexing
InputAttachmentArrayDynamicIndexingEXT
InputAttachmentArrayNonUniformIndexing
InputAttachmentArrayNonUniformIndexingEXT
InputAttachmentIndex
InputLines
InputLinesAdjacency
InputPoints
InputTrianglesAdjacency
InsertDebugUtilsLabelEXT
InsertEXT
Instance
InstanceCustomIndexKHR
InstanceCustomIndexNV
InstanceH
InstanceI
InstanceId
InstanceIndex
InstanceProcAddr
Instruction too long
Instruction too long: more than
Int -> Float bitcast not supported on legacy ESSL
Int64Atomics
Int64ImageEXT
Integer
IntegerFunctions2INTEL
Integrated
Intensity
Interface block member layout align qualifier must match
Interface block member layout component qualifier must match
Interface block member layout location qualifier must match
Interface block member layout matrix qualifier must match
Interface block member layout offset qualifier must match
Interface index is unknown. Cannot continue
Interlocks were used in a way not compatible with GLSL, this is very slow
Internal Error
Internal error: Unhandled operand type
Internal error: unhandled header parse failure
InterpolateAtCentroid
InterpolateAtOffset
InterpolateAtSample
InterpolateAtVertexAMD
Interpolation and auxiliary storage qualifiers must match
Interpolation qualifier mismatch
InterpolationFunction
IntersectionKHR
IntersectionNV
Invalid
Invalid 16-bit float literal
Invalid 32-bit float literal
Invalid 64-bit float literal
Invalid BitCount operation
Invalid ID
Invalid In/Out variable type
Invalid JSON state
Invalid OpSwitch: selector id
Invalid OpTypeFloat instruction
Invalid OpTypeInt instruction
Invalid Opcode name
Invalid Opcode prefix
Invalid SPIR-V magic number
Invalid SPIRV format
Invalid Uniform variable name
Invalid Uniform variable type
Invalid X chroma location
Invalid Y chroma location
Invalid Y'CbCr model conversion
Invalid Y'CbCr range
Invalid binding
Invalid bit width
Invalid block member name
Invalid chroma location
Invalid component swizzle
Invalid constant expression basetype
Invalid continue block detected
Invalid escape sequence
Invalid extended instruction import
Invalid extended instruction import Id
Invalid extended instruction name
Invalid extended instruction number
Invalid format resolution
Invalid group operation
Invalid immediate integer
Invalid instruction Op
Invalid instruction word count
Invalid literal string
Invalid location
Invalid mip filter
Invalid op
Invalid opcode
Invalid opcode for subgroup
Invalid quad swap direction
Invalid return type for sparse feedback
Invalid sampler addressing mode
Invalid sampler border color
Invalid sampler compare function
Invalid semantics value
Invalid shader In/Out variable
Invalid shader In/Out variable semantic
Invalid shader stage: %u
Invalid signed integer literal
Invalid storage class semantics value
Invalid type for OpImageQuerySize
Invalid type for textureProj with shadow
Invalid unsigned integer literal
Invalid word count: Op
Invalid word following !<integer
Invariant
Invariant position is only supported on MSL 2.1 and up
InverseSqrt
Invert Y-axis for Metal
Invocation
InvocationID
InvocationId
InvocationId is computed manually with multi-patch workgroups in MSL
Invocations
InvocationsPerPixelNV
IrivateDataSlot
IsFinite
IsHelperInvocation
IsHelperInvocationEXT
IsNormal
IsValidEvent
IsValidReserveId
Isolines
IterationMultiple
J0\tIJ0
JRenderPass
J\bH+\nH
J\bt8H
Jemaphore
Jffff
Jfffff
Jffffff
K0A8N0
K0A8N0u*D
KReportMessageEXT
KTagEXT
K\bH+\vH
K\bI3M\bH
K\bI;_\bH
K\b\tIK\b
Kc\\\bDH
Kernel
Kernel capability not supported
KernelAttributesINTEL
KferredOperationJoinKHR
Kffff
Kffffff
KhaderModule
Khronos
Khronos Glslang Reference Front End
Khronos LLVM/SPIR-V Translator
Khronos SPIR-V Tools Assembler
Khronos SPIR-V Tools Linker
KwapchainKHR
Kx;Hxw@x
L$ I+L
L$\b1
L$x;Hx
L9 t\fH
L9+t#I
L96u#H
L9F0vfH
L9c0v I
L9s8v H
L9x0vzH
L;(utJ
L;c\bt\rH
L;h\bL
L;x tFfff
L;x tjL
L;x uƋu
L;x(vj
LAYOUT
LCommandPool
LEFT_ANGLE
LEFT_ASSIGN
LEFT_BRACE
LEFT_BRACKET
LEFT_OP
LEFT_PAREN
LEVEL
LGORITHMH
LI9F0v
LINKEDIT
LLVM/SPIR-V Translator
LOW_PRECISION
LY_INDEXH
L_EVENTSH
L_FENCESH
LatencyControlConstraintINTEL
LatencyControlLabelINTEL
LaunchIdKHR
LaunchIdNV
LaunchSizeKHR
LaunchSizeNV
Layer
LayerPerViewNV
Layout binding qualifier must match
Layout component qualifier must match
Layout index qualifier must match
Layout location qualifier must match
Layout matrix qualifier must match
Layout offset qualifier must match
Layout packing qualifier must match
LcF LcN\bE9
Length
LessOrGreater
Level
Lfffff
License Watermark
License Watermark RenderEncoder
LifetimeStart
LifetimeStop
Linear
LinearIdH
LinkOnceODR
Linkage
LinkageAttributes
Linker Objects\n
Linking
Literal string is longer than
LiteralSampler
Load cooperative matrix KHR
Load cooperative matrix NV
Load pre-compiled MSL code into a MTLLibrary
LoadActionFromVkAttachmentLoadOp
Loading an array-of-array must be loaded directly from an IO variable
Loading array of matrix from IO variable must come directly from IO variable
Loading array of struct from IO variable must come directly from IO variable
LocalInvocationID
LocalInvocationId
LocalInvocationIndex
LocalSize
LocalSizeHint
LocalSizeHintId
LocalSizeId
Location
LodEXT
LodOffset
Logical
LogicalAnd
LogicalEqual
LogicalNot
LogicalNotEqual
LogicalOr
LongConstantCompositeINTEL
Loop Body\n
Loop Condition\n
Loop Terminal Expression\n
Loop with condition
LoopCoalesceINTEL
LoopControlINTEL
LoopCountINTEL
LoopFuseINTEL
LoopMerge
Lstroy
Luminance
LunarG
LviceWaitIdle
M H;H
M97tYH
M9<$t\nI
M9g8w
M9l$0v
M9v tAH
M9w0v5I
M; u\nK
M;/utJ
M;0u\nK
M;e\btsL
M;f(t#L
M;l$\br
M;n\bsIH
M;n\bsS
M;n\bs_H
M;n\bsu
M;o\bs@H
M;t$Hr
MAT2X2
MAT2X3
MAT2X4
MAT3X2
MAT3X3
MAT3X4
MAT4X2
MAT4X3
MAT4X4
MAXFLOAT
MAXHALF
MEDIUM_PRECISION
METAL_ALIGN
METAL_ARG_UNIFORM
METAL_ASM
METAL_COMPATIBLE_COMPARE_EXCHANGE_ORDERS
METAL_CONST
METAL_CONST_ARG
METAL_DEPRECATED
METAL_ENABLE_IF
METAL_EXPLICIT
METAL_FUNC
METAL_IMPLICIT
METAL_INTERNAL
METAL_NON_NULL_RETURN
METAL_NORETURN
METAL_NOTHROW
METAL_PURE
METAL_UNAVAILABLE
METAL_VALID_COMPARE_EXCHANGE_FAILURE_ORDER
METAL_VALID_LEVEL_ARG
METAL_VALID_LOAD_ORDER
METAL_VALID_LOD_ARG
METAL_VALID_RENDER_TARGET
METAL_VALID_STORE_ORDER
METAL_ZERO_ARG
MEvent
MH;A$u:H
MLIR SPIR-V Serializer
MMHostInterfaceAddressWidthINTEL
MMHostInterfaceDataWidthINTEL
MMHostInterfaceLatencyINTEL
MMHostInterfaceMaxBurstINTEL
MMHostInterfaceReadWriteModeINTEL
MMHostInterfaceWaitRequestINTEL
MOD_ASSIGN
MSL 1.2 or greater is required for arrays of textures
MSL 2.0 or greater is required for arrays of samplers
MSL 2.0 or greater is required for arrays of textures
MSL cannot emit arrays-of-arrays in input and output variables
MSL cannot emit arrays-of-matrices in input and output variables
MSL currently does not support 64-bit atomics
MSP Shader Compiler
MSetLayout
MTLAccelerationStructure>"24@0:8@"MTLAccelerationStructureDescriptor"16
MTLAccelerationStructure>"24@0:8Q16
MTLArgumentEncoder>"24@0:8@"<MTLBufferBinding>"16
MTLArgumentEncoder>"24@0:8@"NSArray"16
MTLBinaryArchive>"32@0:8@"MTLBinaryArchiveDescriptor"16^@24
MTLBuffer>"32@0:8Q16Q24
MTLBuffer>"40@0:8r^v16Q24Q32
MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
MTLCommandBuffer "%s" execution failed (code %li): %s
MTLCommandBuffer>"16@0:8
MTLCommandBuffer>"24@0:8@"MTLCommandBufferDescriptor"16
MTLCommandBufferEncoderInfoErrorKey
MTLCommandQueue
MTLCommandQueue>"16@0:8
MTLCommandQueue>"24@0:8Q16
MTLCommonCounterSetTimestamp
MTLCommonCounterTimestamp
MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
MTLCopyAllDevices
MTLCounterSampleBuffer>"32@0:8@"MTLCounterSampleBufferDescriptor"16^@24
MTLCreateSystemDefaultDevice
MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
MTLDevice
MTLDevice>"16@0:8
MTLDynamicLibrary>"32@0:8@"<MTLLibrary>"16^@24
MTLDynamicLibrary>"32@0:8@"NSURL"16^@24
MTLEvent>"16@0:8
MTLFence>"16@0:8
MTLHEAPH
MTLHeap>"24@0:8@"MTLHeapDescriptor"16
MTLIOCommandQueue>"32@0:8@"MTLIOCommandQueueDescriptor"16^@24
MTLIOFileHandle>"32@0:8@"NSURL"16^@24
MTLIOFileHandle>"40@0:8@"NSURL"16q24^@32
MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
MTLLibrary>"16@0:8
MTLLibrary>"32@0:8@"MTLStitchedLibraryDescriptor"16^@24
MTLLibrary>"32@0:8@"NSBundle"16^@24
MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
MTLLibrary>"32@0:8@"NSString"16^@24
MTLLibrary>"32@0:8@"NSURL"16^@24
MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
MTLPixelFormat
MTLPixelFormatA1BGR5Unorm
MTLPixelFormatA8Unorm
MTLPixelFormatABGR4Unorm
MTLPixelFormatASTC_10x10_HDR
MTLPixelFormatASTC_10x10_LDR
MTLPixelFormatASTC_10x10_sRGB
MTLPixelFormatASTC_10x5_HDR
MTLPixelFormatASTC_10x5_LDR
MTLPixelFormatASTC_10x5_sRGB
MTLPixelFormatASTC_10x6_HDR
MTLPixelFormatASTC_10x6_LDR
MTLPixelFormatASTC_10x6_sRGB
MTLPixelFormatASTC_10x8_HDR
MTLPixelFormatASTC_10x8_LDR
MTLPixelFormatASTC_10x8_sRGB
MTLPixelFormatASTC_12x10_HDR
MTLPixelFormatASTC_12x10_LDR
MTLPixelFormatASTC_12x10_sRGB
MTLPixelFormatASTC_12x12_HDR
MTLPixelFormatASTC_12x12_LDR
MTLPixelFormatASTC_12x12_sRGB
MTLPixelFormatASTC_4x4_HDR
MTLPixelFormatASTC_4x4_LDR
MTLPixelFormatASTC_4x4_sRGB
MTLPixelFormatASTC_5x4_HDR
MTLPixelFormatASTC_5x4_LDR
MTLPixelFormatASTC_5x4_sRGB
MTLPixelFormatASTC_5x5_HDR
MTLPixelFormatASTC_5x5_LDR
MTLPixelFormatASTC_5x5_sRGB
MTLPixelFormatASTC_6x5_HDR
MTLPixelFormatASTC_6x5_LDR
MTLPixelFormatASTC_6x5_sRGB
MTLPixelFormatASTC_6x6_HDR
MTLPixelFormatASTC_6x6_LDR
MTLPixelFormatASTC_6x6_sRGB
MTLPixelFormatASTC_8x5_HDR
MTLPixelFormatASTC_8x5_LDR
MTLPixelFormatASTC_8x5_sRGB
MTLPixelFormatASTC_8x6_HDR
MTLPixelFormatASTC_8x6_LDR
MTLPixelFormatASTC_8x6_sRGB
MTLPixelFormatASTC_8x8_HDR
MTLPixelFormatASTC_8x8_LDR
MTLPixelFormatASTC_8x8_sRGB
MTLPixelFormatB5G6R5Unorm
MTLPixelFormatBC1_RGBA
MTLPixelFormatBC1_RGBA_sRGB
MTLPixelFormatBC2_RGBA
MTLPixelFormatBC2_RGBA_sRGB
MTLPixelFormatBC3_RGBA
MTLPixelFormatBC3_RGBA_sRGB
MTLPixelFormatBC4_RSnorm
MTLPixelFormatBC4_RUnorm
MTLPixelFormatBC5_RGSnorm
MTLPixelFormatBC5_RGUnorm
MTLPixelFormatBC6H_RGBFloat
MTLPixelFormatBC6H_RGBUfloat
MTLPixelFormatBC7_RGBAUnorm
MTLPixelFormatBC7_RGBAUnorm_sRGB
MTLPixelFormatBGR10A2Unorm
MTLPixelFormatBGR10_XR
MTLPixelFormatBGR10_XR_sRGB
MTLPixelFormatBGR5A1Unorm
MTLPixelFormatBGRA10_XR
MTLPixelFormatBGRA10_XR_sRGB
MTLPixelFormatBGRA8Unorm
MTLPixelFormatBGRA8Unorm_sRGB
MTLPixelFormatBGRG422
MTLPixelFormatDepth16Unorm
MTLPixelFormatDepth24Unorm_Stencil8
MTLPixelFormatDepth32Float
MTLPixelFormatDepth32Float_Stencil8
MTLPixelFormatEAC_R11Snorm
MTLPixelFormatEAC_R11Unorm
MTLPixelFormatEAC_RG11Snorm
MTLPixelFormatEAC_RG11Unorm
MTLPixelFormatEAC_RGBA8
MTLPixelFormatEAC_RGBA8_sRGB
MTLPixelFormatETC2_RGB8
MTLPixelFormatETC2_RGB8A1
MTLPixelFormatETC2_RGB8A1_sRGB
MTLPixelFormatETC2_RGB8_sRGB
MTLPixelFormatGBGR422
MTLPixelFormatInvalid
MTLPixelFormatPVRTC_RGBA_2BPP
MTLPixelFormatPVRTC_RGBA_2BPP_sRGB
MTLPixelFormatPVRTC_RGBA_4BPP
MTLPixelFormatPVRTC_RGBA_4BPP_sRGB
MTLPixelFormatR16Float
MTLPixelFormatR16Sint
MTLPixelFormatR16Snorm
MTLPixelFormatR16Uint
MTLPixelFormatR16Unorm
MTLPixelFormatR32Float
MTLPixelFormatR32Sint
MTLPixelFormatR32Uint
MTLPixelFormatR8Sint
MTLPixelFormatR8Snorm
MTLPixelFormatR8Uint
MTLPixelFormatR8Unorm
MTLPixelFormatR8Unorm_sRGB
MTLPixelFormatRG11B10Float
MTLPixelFormatRG16Float
MTLPixelFormatRG16Sint
MTLPixelFormatRG16Snorm
MTLPixelFormatRG16Uint
MTLPixelFormatRG16Unorm
MTLPixelFormatRG32Float
MTLPixelFormatRG32Sint
MTLPixelFormatRG32Uint
MTLPixelFormatRG8Sint
MTLPixelFormatRG8Snorm
MTLPixelFormatRG8Uint
MTLPixelFormatRG8Unorm
MTLPixelFormatRG8Unorm_sRGB
MTLPixelFormatRGB10A2Uint
MTLPixelFormatRGB10A2Unorm
MTLPixelFormatRGB9E5Float
MTLPixelFormatRGBA16Float
MTLPixelFormatRGBA16Sint
MTLPixelFormatRGBA16Snorm
MTLPixelFormatRGBA16Uint
MTLPixelFormatRGBA16Unorm
MTLPixelFormatRGBA32Float
MTLPixelFormatRGBA32Sint
MTLPixelFormatRGBA32Uint
MTLPixelFormatRGBA8Sint
MTLPixelFormatRGBA8Snorm
MTLPixelFormatRGBA8Uint
MTLPixelFormatRGBA8Unorm
MTLPixelFormatRGBA8Unorm_sRGB
MTLPixelFormatStencil8
MTLPixelFormatX24_Stencil8
MTLPixelFormatX32_Stencil8
MTLQuadTessellationFactorsHalf
MTLRasterizationRateMap>"24@0:8@"MTLRasterizationRateMapDescriptor"16
MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
MTLRenderPipelineState>"48@0:8@"MTLMeshRenderPipelineDescriptor"16Q24^@32^@40
MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
MTLSharedEvent>"16@0:8
MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
MTLTexture>"24@0:8@"MTLSharedTextureHandle"16
MTLTexture>"24@0:8@"MTLTextureDescriptor"16
MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
MTLTriangleTessellationFactorsHalf
MTLVertexFormatChar
MTLVertexFormatChar2
MTLVertexFormatChar2Normalized
MTLVertexFormatChar3
MTLVertexFormatChar3Normalized
MTLVertexFormatChar4
MTLVertexFormatChar4Normalized
MTLVertexFormatCharNormalized
MTLVertexFormatFloat
MTLVertexFormatFloat2
MTLVertexFormatFloat3
MTLVertexFormatFloat4
MTLVertexFormatHalf
MTLVertexFormatHalf2
MTLVertexFormatHalf3
MTLVertexFormatHalf4
MTLVertexFormatInt
MTLVertexFormatInt1010102Normalized
MTLVertexFormatInt2
MTLVertexFormatInt3
MTLVertexFormatInt4
MTLVertexFormatInvalid
MTLVertexFormatShort
MTLVertexFormatShort2
MTLVertexFormatShort2Normalized
MTLVertexFormatShort3
MTLVertexFormatShort3Normalized
MTLVertexFormatShort4
MTLVertexFormatShort4Normalized
MTLVertexFormatShortNormalized
MTLVertexFormatUChar
MTLVertexFormatUChar2
MTLVertexFormatUChar2Normalized
MTLVertexFormatUChar3
MTLVertexFormatUChar3Normalized
MTLVertexFormatUChar4
MTLVertexFormatUChar4Normalized
MTLVertexFormatUChar4Normalized_BGRA
MTLVertexFormatUCharNormalized
MTLVertexFormatUInt
MTLVertexFormatUInt1010102Normalized
MTLVertexFormatUInt2
MTLVertexFormatUInt3
MTLVertexFormatUInt4
MTLVertexFormatUShort
MTLVertexFormatUShort2
MTLVertexFormatUShort2Normalized
MTLVertexFormatUShort3
MTLVertexFormatUShort3Normalized
MTLVertexFormatUShort4
MTLVertexFormatUShort4Normalized
MTLVertexFormatUShortNormalized
MUL_ASSIGN
MUtilsMessengerEXT
MVKBlockObserver
MVK_ALLOW_METAL_EVENTS
MVK_ALLOW_METAL_FENCES
MVK_CONFIG_ACTIVITY_PERFORMANCE_LOGGING_STYLE
MVK_CONFIG_ADVERTISE_EXTENSIONS
MVK_CONFIG_API_VERSION_TO_ADVERTISE
MVK_CONFIG_AUTO_GPU_CAPTURE_OUTPUT_FILE
MVK_CONFIG_AUTO_GPU_CAPTURE_SCOPE
MVK_CONFIG_DEFAULT_GPU_CAPTURE_SCOPE_QUEUE_FAMILY_INDEX
MVK_CONFIG_DEFAULT_GPU_CAPTURE_SCOPE_QUEUE_INDEX
MVK_CONFIG_DISPLAY_WATERMARK
MVK_CONFIG_FAST_MATH_ENABLED
MVK_CONFIG_FORCE_LOW_POWER_GPU
MVK_CONFIG_FULL_IMAGE_VIEW_SWIZZLE
MVK_CONFIG_LOG_LEVEL
MVK_CONFIG_MAX_ACTIVE_METAL_COMMAND_BUFFERS_PER_QUEUE
MVK_CONFIG_METAL_COMPILE_TIMEOUT
MVK_CONFIG_PERFORMANCE_LOGGING_FRAME_COUNT
MVK_CONFIG_PERFORMANCE_LOGGING_INLINE
MVK_CONFIG_PERFORMANCE_TRACKING
MVK_CONFIG_PREALLOCATE_DESCRIPTORS
MVK_CONFIG_PREFILL_METAL_COMMAND_BUFFERS
MVK_CONFIG_PRESENT_WITH_COMMAND_BUFFER
MVK_CONFIG_RESUME_LOST_DEVICE
MVK_CONFIG_SHADER_COMPRESSION_ALGORITHM
MVK_CONFIG_SHADER_CONVERSION_FLIP_VERTEX_Y
MVK_CONFIG_SHOULD_MAXIMIZE_CONCURRENT_COMPILATION
MVK_CONFIG_SPECIALIZED_QUEUE_FAMILIES
MVK_CONFIG_SUPPORT_LARGE_QUERY_POOLS
MVK_CONFIG_SWAPCHAIN_MAG_FILTER_USE_NEAREST
MVK_CONFIG_SWAPCHAIN_MIN_MAG_FILTER_USE_NEAREST
MVK_CONFIG_SWITCH_SYSTEM_GPU
MVK_CONFIG_SYNCHRONOUS_QUEUE_SUBMITS
MVK_CONFIG_TEXTURE_1D_AS_2D
MVK_CONFIG_TRACE_VULKAN_CALLS
MVK_CONFIG_USE_COMMAND_POOLING
MVK_CONFIG_USE_METAL_ARGUMENT_BUFFERS
MVK_CONFIG_USE_MTLHEAP
MVK_CONFIG_VK_SEMAPHORE_SUPPORT_STYLE
MVK_DEBUG
MVK_DEBUH
M\bH9H0
M\tEЋC$A
M\vA\bI9
M_1_PI
M_1_PI_F
M_1_PI_H
M_2_PI
M_2_PI_F
M_2_PI_H
M_2_SQRTPI
M_2_SQRTPI_F
M_2_SQRTPI_H
M_LN10
M_LN10_F
M_LN10_H
M_LN2_F
M_LN2_H
M_LOG10E
M_LOG10E_F
M_LOG10E_H
M_LOG2E
M_LOG2E_F
M_LOG2E_H
M_PI_2
M_PI_2_F
M_PI_2_H
M_PI_4
M_PI_4_F
M_PI_4_H
M_PI_F
M_PI_H
M_SQRT1_2
M_SQRT1_2_F
M_SQRT1_2_H
M_SQRT2
M_SQRT2_F
M_SQRT2_H
Macro redefined; different argument names
Macro redefined; different number of arguments
Macro redefined; different substitutions
Macro redefined; function-like versus object-like
Main Screen
MakeAvailable
MakeAvailableKHR
MakePointerAvailable
MakePointerAvailableKHR
MakePointerVisible
MakePointerVisibleKHR
MakeTexelAvailable
MakeTexelAvailableKHR
MakeTexelVisible
MakeTexelVisibleKHR
MakeVisible
MakeVisibleKHR
MarkerSetObject
Matched Uniform or Storage blocks must all be anonymous, or all be named
Matched shader interfaces are using different instance names
Matched uniform block names must also either all be lacking an instance name or all having an instance name
MathOpDSPModeINTEL
Matrix
Matrix stride for dynamic indexing must be divisible by the size of a 4-component vector. Likely culprit here is a row-major matrix being accessed dynamically. This cannot be flattened. Try using std140 layout instead
MatrixAKHR
MatrixASignedComponentsKHR
MatrixAccumulatorKHR
MatrixBKHR
MatrixBSignedComponentsKHR
MatrixCSignedComponentsKHR
MatrixInverse
MatrixResultSignedComponentsKHR
MatrixStride
MatrixTimesMatrix
MatrixTimesScalar
MatrixTimesVector
MaxByteOffset
MaxByteOffsetId
MaxConcurrencyINTEL
MaxConcurrencyKHR
MaxInterleavingINTEL
MaxIterations
MaxPrivateCopiesINTEL
MaxReinvocationDelayINTEL
MaxReplicatesINTEL
MaxWorkDimINTEL
MaxWorkgroupSizeINTEL
Maximum compilation loops detected and no forward progress was made. Must be a SPIRV-Cross bug
MbcntAMD
MediaBlockIOINTEL
Member
Member index is out of bounds
Member names and types must match
Member: n/a \n
MemberDecorate
MemberDecorateString
MemberDecorateStringGOOGLE
MemberName
Memory coherent qualifier must match
Memory devicecoherent qualifier must match
Memory is already mapped. Call vkUnmapMemory() first
Memory is not mapped. Call vkMapMemory() first
Memory nonprivate qualifier must match
Memory queuefamilycoherent qualifier must match
Memory readonly qualifier must match
Memory restrict qualifier must match
Memory shadercallcoherent qualifier must match
Memory subgroupcoherent qualifier must match
Memory volatil qualifier must match
Memory workgroupcoherent qualifier must match
Memory writeonly qualifier must match
MemoryAccessAliasingINTEL
MemoryBarrier
MemoryBarrierAtomicCounter
MemoryBarrierBuffer
MemoryBarrierImage
MemoryBarrierShared
MemoryINTEL
MemoryModel
MemoryNamedBarrier
MemoryRequirements
MergeINTEL
Mesa-IR/SPIR-V Translator
Mesh shaders require GLSL 450 or above
Mesh shaders require Vulkan semantics
MeshEXT
MeshNV
MeshShadingEXT
MeshShadingNV
MeshViewCountNV
MeshViewIndicesNV
Messiah Shader Compiler
Meta SparkSL
Metal does not support isoline tessellation
Metal doesn't support ExclusiveScan for OpGroupNonUniformBitwiseAnd
Metal doesn't support ExclusiveScan for OpGroupNonUniformBitwiseOr
Metal doesn't support ExclusiveScan for OpGroupNonUniformBitwiseXor
Metal doesn't support ExclusiveScan for OpGroupNonUniformFMax
Metal doesn't support ExclusiveScan for OpGroupNonUniformFMin
Metal doesn't support ExclusiveScan for OpGroupNonUniformLogicalAnd
Metal doesn't support ExclusiveScan for OpGroupNonUniformLogicalOr
Metal doesn't support ExclusiveScan for OpGroupNonUniformLogicalXor
Metal doesn't support ExclusiveScan for OpGroupNonUniformSMax
Metal doesn't support ExclusiveScan for OpGroupNonUniformSMin
Metal doesn't support ExclusiveScan for OpGroupNonUniformUMax
Metal doesn't support ExclusiveScan for OpGroupNonUniformUMin
Metal doesn't support InclusiveScan for OpGroupNonUniformBitwiseAnd
Metal doesn't support InclusiveScan for OpGroupNonUniformBitwiseOr
Metal doesn't support InclusiveScan for OpGroupNonUniformBitwiseXor
Metal doesn't support InclusiveScan for OpGroupNonUniformFMax
Metal doesn't support InclusiveScan for OpGroupNonUniformFMin
Metal doesn't support InclusiveScan for OpGroupNonUniformLogicalAnd
Metal doesn't support InclusiveScan for OpGroupNonUniformLogicalOr
Metal doesn't support InclusiveScan for OpGroupNonUniformLogicalXor
Metal doesn't support InclusiveScan for OpGroupNonUniformSMax
Metal doesn't support InclusiveScan for OpGroupNonUniformSMin
Metal doesn't support InclusiveScan for OpGroupNonUniformUMax
Metal doesn't support InclusiveScan for OpGroupNonUniformUMin
Metal only supports quad ClusteredReduce
Metal renderpass restart RenderEncoder
MferredOperationKHR
Mffffff
MhI9_0
Mikkosoft Productions
Mikkosoft Productions MSP Shader Compiler
MinIterations
MinLod
MissKHR
MissNV
Missing assembly text
Missing entry point: Each stage requires one entry point
Missing functionality
Missing module
ModesKHRH
ModfStruct
Module has incomplete header: only
ModuleProcessed
MoltenVK
MoltenVK driver layer
MoltenVK version %s, supporting Vulkan version %s.\n\tThe following %d Vulkan extensions are supported:%s
MoltenVKH
MoltenVKJ
MoltenVKQueue-%d-%d-%.1f
Mscriptor
MulAdd cooperative matrices KHR
MulAdd cooperative matrices NV
Multi-stream geometry shaders not supported in ES
Multi-stream geometry shaders only supported in GLSL 400
MultiTexCoord0
MultiTexCoord1
MultiTexCoord2
MultiTexCoord3
MultiTexCoord4
MultiTexCoord5
MultiTexCoord6
MultiTexCoord7
MultiView
MultiViewport
Multiple function bodies in multiple compilation units for the same signature in the same stage
Multiple geometry streams not supported in ESSL
Multisample
Multisampled array textures are supported from 2.1
Multisampled image used in OpImageRead, but unexpected operand mask was used
Multisampled image used in OpImageWrite, but unexpected operand mask was used
Must be in a function
Must end a function before starting a new one
M̉UЉu
MЉA\fffff
MЋA8I9
N(B9D
N(B9D1
N(H9O0v1I
N(\tIN
N12_GLOBAL__N_122TGlslangToSpvTraverserE
N12_GLOBAL__N_124TNoContractionPropagatorE
N12_GLOBAL__N_136TSymbolDefinitionCollectingTraverserE
N12_GLOBAL__N_139TNoContractionAssigneeCheckingTraverserE
N15MVK_spirv_cross10ObjectPoolINS_10SPIRStringEEE
N15MVK_spirv_cross10ObjectPoolINS_12SPIRConstantEEE
N15MVK_spirv_cross10ObjectPoolINS_12SPIRFunctionEEE
N15MVK_spirv_cross10ObjectPoolINS_12SPIRVariableEEE
N15MVK_spirv_cross10ObjectPoolINS_13SPIRExtensionEEE
N15MVK_spirv_cross10ObjectPoolINS_14SPIRConstantOpEEE
N15MVK_spirv_cross10ObjectPoolINS_14SPIRExpressionEEE
N15MVK_spirv_cross10ObjectPoolINS_15SPIRAccessChainEEE
N15MVK_spirv_cross10ObjectPoolINS_21SPIRFunctionPrototypeEEE
N15MVK_spirv_cross10ObjectPoolINS_24SPIRCombinedImageSamplerEEE
N15MVK_spirv_cross10ObjectPoolINS_8SPIRTypeEEE
N15MVK_spirv_cross10ObjectPoolINS_9SPIRBlockEEE
N15MVK_spirv_cross10ObjectPoolINS_9SPIRUndefEEE
N15MVK_spirv_cross10SPIRStringE
N15MVK_spirv_cross11CompilerMSL18OpCodePreprocessorE
N15MVK_spirv_cross11CompilerMSL19SampledImageScannerE
N15MVK_spirv_cross11CompilerMSLE
N15MVK_spirv_cross12CompilerGLSLE
N15MVK_spirv_cross12SPIRConstantE
N15MVK_spirv_cross12SPIRFunctionE
N15MVK_spirv_cross12SPIRVariableE
N15MVK_spirv_cross13CompilerErrorE
N15MVK_spirv_cross13SPIRExtensionE
N15MVK_spirv_cross14ObjectPoolBaseE
N15MVK_spirv_cross14SPIRConstantOpE
N15MVK_spirv_cross14SPIRExpressionE
N15MVK_spirv_cross15SPIRAccessChainE
N15MVK_spirv_cross18CompilerReflectionE
N15MVK_spirv_cross21SPIRFunctionPrototypeE
N15MVK_spirv_cross24SPIRCombinedImageSamplerE
N15MVK_spirv_cross8Compiler10CFGBuilderE
N15MVK_spirv_cross8Compiler13OpcodeHandlerE
N15MVK_spirv_cross8Compiler19BufferAccessHandlerE
N15MVK_spirv_cross8Compiler20ActiveBuiltinHandlerE
N15MVK_spirv_cross8Compiler27CombinedImageSamplerHandlerE
N15MVK_spirv_cross8Compiler29StaticExpressionAccessHandlerE
N15MVK_spirv_cross8Compiler30InterfaceVariableAccessHandlerE
N15MVK_spirv_cross8Compiler31CombinedImageSamplerDrefHandlerE
N15MVK_spirv_cross8Compiler32CombinedImageSamplerUsageHandlerE
N15MVK_spirv_cross8Compiler32InterlockedResourceAccessHandlerE
N15MVK_spirv_cross8Compiler33AnalyzeVariableScopeAccessHandlerE
N15MVK_spirv_cross8Compiler35DummySamplerForCombinedImageHandlerE
N15MVK_spirv_cross8Compiler35PhysicalStorageBufferPointerHandlerE
N15MVK_spirv_cross8Compiler39InterlockedResourceAccessPrepassHandlerE
N15MVK_spirv_cross8CompilerE
N15MVK_spirv_cross8IVariantE
N15MVK_spirv_cross8SPIRTypeE
N15MVK_spirv_cross9SPIRBlockE
N15MVK_spirv_cross9SPIRUndefE
N3mvk13charvectorbufE
N3mvk6membufE
N3mvk8countbufE
N3spv11InstructionE
N3spv5BlockE
N3spv6ModuleE
N3spv7BuilderE
N3spv8FunctionE
N6cereal12InputArchiveINS_18BinaryInputArchiveELj1EEE
N6cereal13OutputArchiveINS_19BinaryOutputArchiveELj1EEE
N6cereal18BinaryInputArchiveE
N6cereal19BinaryOutputArchiveE
N6cereal6detail16InputArchiveBaseE
N6cereal6detail17OutputArchiveBaseE
N6cereal9ExceptionE
N7glslang10TPpContext10tZeroInputE
N7glslang10TPpContext11tMacroInputE
N7glslang10TPpContext11tTokenInputE
N7glslang10TPpContext12tMarkerInputE
N7glslang10TPpContext12tStringInputE
N7glslang10TPpContext16tUngotTokenInputE
N7glslang10TPpContext22TokenizableIncludeFileE
N7glslang10TPpContext6tInputE
N7glslang10TPpContextE
N7glslang11TAnonMemberE
N7glslang11TIntermLoopE
N7glslang11TReflectionE
N7glslang12TIntermTypedE
N7glslang12TIntermUnaryE
N7glslang12TScanContextE
N7glslang13TGlslIoMapperE
N7glslang13TInputScannerE
N7glslang13TIntermBinaryE
N7glslang13TIntermBranchE
N7glslang13TIntermMethodE
N7glslang13TIntermSwitchE
N7glslang13TIntermSymbolE
N7glslang13TParseContextE
N7glslang14TIoMapResolverE
N7glslang14TLiveTraverserE
N7glslang14TParseVersionsE
N7glslang15TConstTraverserE
N7glslang15TIndexTraverserE
N7glslang15TIntermOperatorE
N7glslang16TConstUnionArrayE
N7glslang16TIntermAggregateE
N7glslang16TIntermSelectionE
N7glslang16TIntermTraverserE
N7glslang16TOutputTraverserE
N7glslang16TRemoveTraverserE
N7glslang16TUserIdTraverserE
N7glslang16TVarSetTraverserE
N7glslang17TDeferredCompilerE
N7glslang17TParseContextBaseE
N7glslang17TPrecisionManagerE
N7glslang17TRemapIdTraverserE
N7glslang17TSmallArrayVectorE
N7glslang18TBuiltInParseablesE
N7glslang18TDefaultIoResolverE
N7glslang19TBuiltInIdTraverserE
N7glslang19TInductiveTraverserE
N7glslang19TVarGatherTraverserE
N7glslang20TIntermConstantUnionE
N7glslang20TReflectionTraverserE
N7glslang22TDefaultGlslIoResolverE
N7glslang22TDefaultIoResolverBaseE
N7glslang40TextureUpgradeAndSamplerRemovalTransformE
N7glslang5TTypeE
N7glslang7TShader14ForbidIncluderE
N7glslang7TShader8IncluderE
N7glslang7TShaderE
N7glslang7TSymbolE
N7glslang8TProgramE
N7glslang9TBuiltInsE
N7glslang9TFunctionE
N7glslang9TIoMapperE
N7glslang9TVariableE
N8H)IM
NClamp
NONPRIVATE
NONUNIFORM
NOPERSPECTIVE
NSArray"16@0:8
NSConcreteGlobalBlock
NSConcreteStackBlock
NSLocalizedDescriptionKey
NSObject
NSScreenNumber
NSString
NSString"16@0:8
NSView
NSZone=}16@0:8
NS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjEEE
NSt3__11
NSt3__110__function6__baseIFNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjEEE
NSt3__110__function6__baseIFb8VkFormatEEE
NSt3__110__function6__baseIFbRKN7glslang5TTypeES5_NS2_9TOperatorEiEEE
NSt3__110__function6__baseIFbRKN7glslang5TTypeES5_S5_EEE
NSt3__110__function6__baseIFbjEEE
NSt3__110__function6__baseIFbmEEE
NSt3__110__function6__baseIFivEEE
NSt3__110__function6__baseIFv19spv_message_level_tPKcRK14spv_position_tS4_EEE
NSt3__110__function6__baseIFvP17MVKCommandEncoderR19MVKMTLBufferBinding11MVKArrayRefIjEEEE
NSt3__110__function6__baseIFvP17MVKCommandEncoderR19MVKMTLBufferBindingEEE
NSt3__110__function6__baseIFvP17MVKCommandEncoderR20MVKMTLTextureBindingEEE
NSt3__110__function6__baseIFvP17MVKCommandEncoderR25MVKMTLSamplerStateBindingEEE
NSt3__110__function6__baseIFvPK25VkRenderingAttachmentInfo21VkImageAspectFlagBitsbEEE
NSt3__110__function6__baseIFvPN3spv5BlockENS2_11ReachReasonES4_EEE
NSt3__110__function6__baseIFviPKcEEE
NSt3__110__function6__baseIFviPKcS3_EEE
NSt3__110__function6__baseIFviRKN7glslang7TVectorINS_12basic_stringIcNS_11char_traitsIcEENS2_14pool_allocatorIcEEEEEEEEE
NSt3__110__function6__baseIFviiPKcEEE
NSt3__110__function6__baseIFviibiPKcEEE
NSt3__110__function6__baseIFvjEEE
NSt3__110__function6__baseIFvvEEE
NSt3__110__function6__funcINS_6__bindIMN7glslang13TInputScannerEKFivEJPS4_EEENS_9allocatorIS8_EEFivEEE
NSt3__110__function6__funcIPFNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjENS5_IS9_EES8_EE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_2NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_3NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_4NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_5NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_6NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_7NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_8NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_9NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE4$_10NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE4$_11NS_9allocatorIS4_EEFbjEEE
NSt3__110__function6__funcIZ48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_12NS_9allocatorIS3_EEFbjEEE
NSt3__110__function6__funcIZ48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_13NS_9allocatorIS3_EEFbjEEE
NSt3__110__function6__funcIZ48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_14NS_9allocatorIS3_EEFbjEEE
NSt3__110__function6__funcIZ48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_15NS_9allocatorIS3_EEFbjEEE
NSt3__110__function6__funcIZ48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_16NS_9allocatorIS3_EEFbjEEE
NSt3__110__function6__funcIZ48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_17NS_9allocatorIS3_EEFbjEEE
NSt3__110__function6__funcIZ48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_18NS_9allocatorIS3_EEFbjEEE
NSt3__110__function6__funcIZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS4_10TPpContextERNS4_13TInputScannerEbRNS4_12TSymbolTableERNS4_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliPKcE_NS_9allocatorISJ_EEFviSI_EEE
NSt3__110__function6__funcIZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS4_10TPpContextERNS4_13TInputScannerEbRNS4_12TSymbolTableERNS4_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliPKcSI_E_NS_9allocatorISJ_EEFviSI_SI_EEE
NSt3__110__function6__funcIZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS4_10TPpContextERNS4_13TInputScannerEbRNS4_12TSymbolTableERNS4_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliRKNS4_7TVectorINS_12basic_stringIcNS_11char_traitsIcEENS4_14pool_allocatorIcEEEEEEE_NS_9allocatorISR_EEFviSQ_EEE
NSt3__110__function6__funcIZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS4_10TPpContextERNS4_13TInputScannerEbRNS4_12TSymbolTableERNS4_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliiPKcE_NS_9allocatorISJ_EEFviiSI_EEE
NSt3__110__function6__funcIZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS4_10TPpContextERNS4_13TInputScannerEbRNS4_12TSymbolTableERNS4_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliibiPKcE_NS_9allocatorISJ_EEFviibiSI_EEE
NSt3__110__function6__funcIZN13MVKRenderPassC1EP9MVKDevicePK15VkRenderingInfoE3$_3NS_9allocatorIS8_EEFvPK25VkRenderingAttachmentInfo21VkImageAspectFlagBitsbEEE
NSt3__110__function6__funcIZN13MVKRenderPassC1EP9MVKDevicePK15VkRenderingInfoE3$_4NS_9allocatorIS8_EEFvPK25VkRenderingAttachmentInfo21VkImageAspectFlagBitsbEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_28NS_9allocatorIS6_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_29NS_9allocatorIS6_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_30NS_9allocatorIS6_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_31NS_9allocatorIS6_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_32NS_9allocatorIS6_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_33NS_9allocatorIS6_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_34NS_9allocatorIS6_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_35NS_9allocatorIS6_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL20add_tess_level_inputERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESB_RNS2_12SPIRVariableEE4$_22NS7_ISE_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL20add_tess_level_inputERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEESB_RNS2_12SPIRVariableEE4$_23NS7_ISE_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL24entry_point_args_builtinERNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEE4$_46NS7_ISB_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL24entry_point_args_builtinERNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEE4$_47NS7_ISB_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL24entry_point_args_builtinERNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEE4$_48NS7_ISB_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL26emit_local_masked_variableERKNS2_12SPIRVariableEbE4$_24NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL26emit_local_masked_variableERKNS2_12SPIRVariableEbE4$_25NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL26emit_local_masked_variableERKNS2_12SPIRVariableEbE4$_26NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvE4$_51NS_9allocatorIS4_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL37add_plain_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableERNS3_18InterfaceBlockMetaEE3$_8NS9_ISK_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL37add_plain_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableERNS3_18InterfaceBlockMetaEE4$_10NS9_ISK_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL37add_plain_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableERNS3_18InterfaceBlockMetaEE4$_11NS9_ISK_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL37add_plain_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableERNS3_18InterfaceBlockMetaEE4$_12NS9_ISK_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL41add_component_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_12SPIRVariableERKNS2_8SPIRTypeERNS3_18InterfaceBlockMetaEE3$_6NS9_ISL_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL41add_component_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_12SPIRVariableERKNS2_8SPIRTypeERNS3_18InterfaceBlockMetaEE3$_7NS9_ISL_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL41add_composite_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableERNS3_18InterfaceBlockMetaEE4$_13NS9_ISK_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL41add_composite_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableERNS3_18InterfaceBlockMetaEE4$_14NS9_ISK_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL44add_plain_member_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableESF_jRNS3_18InterfaceBlockMetaESD_SD_RjSK_E4$_17NS9_ISL_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL44add_plain_member_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableESF_jRNS3_18InterfaceBlockMetaESD_SD_RjSK_E4$_18NS9_ISL_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL44add_plain_member_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableESF_jRNS3_18InterfaceBlockMetaESD_SD_RjSK_E4$_19NS9_ISL_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL44add_plain_member_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableESF_jRNS3_18InterfaceBlockMetaESD_SD_RjSK_E4$_20NS9_ISL_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL48add_composite_member_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableESF_jRNS3_18InterfaceBlockMetaESD_SD_RjSK_E4$_15NS9_ISL_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross11CompilerMSL48add_composite_member_variable_to_interface_blockEN3spv12StorageClassERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERNS2_8SPIRTypeERNS2_12SPIRVariableESF_jRNS3_18InterfaceBlockMetaESD_SD_RjSK_E4$_16NS9_ISL_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross12CompilerGLSL32emit_output_variable_initializerERKNS2_12SPIRVariableEE4$_21NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross12CompilerGLSL32emit_output_variable_initializerERKNS2_12SPIRVariableEE4$_22NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross12CompilerGLSL32emit_output_variable_initializerERKNS2_12SPIRVariableEE4$_23NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross12CompilerGLSL32emit_output_variable_initializerERKNS2_12SPIRVariableEE4$_24NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZN15MVK_spirv_cross12CompilerGLSL50emit_inout_fragment_outputs_copy_to_subpass_inputsEvE4$_46NS_9allocatorIS4_EEFvvEEE
NSt3__110__function6__funcIZN16MVKRenderSubpassC1EP13MVKRenderPassPK15VkRenderingInfoE3$_0NS_9allocatorIS8_EEFvPK25VkRenderingAttachmentInfo21VkImageAspectFlagBitsbEEE
NSt3__110__function6__funcIZN17MVKCommandEncoder14beginRenderingEP10MVKCommandPK15VkRenderingInfoE3$_0NS_9allocatorIS8_EEFvPK25VkRenderingAttachmentInfo21VkImageAspectFlagBitsbEEE
NSt3__110__function6__funcIZN17MVKDescriptorPool21allocateDescriptorSetEP22MVKDescriptorSetLayoutjPP17VkDescriptorSet_TE3$_1NS_9allocatorIS8_EEFbmEEE
NSt3__110__function6__funcIZN17MVKPhysicalDevice10initLimitsEvE3$_0NS_9allocatorIS3_EEFb8VkFormatEEE
NSt3__110__function6__funcIZN38MVKComputeResourcesCommandEncoderState10encodeImplEjE4$_21NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBindingEEE
NSt3__110__function6__funcIZN38MVKComputeResourcesCommandEncoderState10encodeImplEjE4$_22NS_9allocatorIS3_EEFvP17MVKCommandEncoderR20MVKMTLTextureBindingEEE
NSt3__110__function6__funcIZN38MVKComputeResourcesCommandEncoderState10encodeImplEjE4$_23NS_9allocatorIS3_EEFvP17MVKCommandEncoderR25MVKMTLSamplerStateBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_1NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_2NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBinding11MVKArrayRefIjEEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_3NS_9allocatorIS3_EEFvP17MVKCommandEncoderR20MVKMTLTextureBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_4NS_9allocatorIS3_EEFvP17MVKCommandEncoderR25MVKMTLSamplerStateBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_5NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_6NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBinding11MVKArrayRefIjEEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_7NS_9allocatorIS3_EEFvP17MVKCommandEncoderR20MVKMTLTextureBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_8NS_9allocatorIS3_EEFvP17MVKCommandEncoderR25MVKMTLSamplerStateBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_9NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_10NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBinding11MVKArrayRefIjEEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_11NS_9allocatorIS3_EEFvP17MVKCommandEncoderR20MVKMTLTextureBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_12NS_9allocatorIS3_EEFvP17MVKCommandEncoderR25MVKMTLSamplerStateBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_13NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_14NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBinding11MVKArrayRefIjEEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_15NS_9allocatorIS3_EEFvP17MVKCommandEncoderR20MVKMTLTextureBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_16NS_9allocatorIS3_EEFvP17MVKCommandEncoderR25MVKMTLSamplerStateBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_17NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_18NS_9allocatorIS3_EEFvP17MVKCommandEncoderR19MVKMTLBufferBinding11MVKArrayRefIjEEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_19NS_9allocatorIS3_EEFvP17MVKCommandEncoderR20MVKMTLTextureBindingEEE
NSt3__110__function6__funcIZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_20NS_9allocatorIS3_EEFvP17MVKCommandEncoderR25MVKMTLSamplerStateBindingEEE
NSt3__110__function6__funcIZN3spv7Builder14postProcessCFGEvE3$_2NS_9allocatorIS4_EEFvPNS2_5BlockENS2_11ReachReasonES8_EEE
NSt3__110__function6__funcIZN7glslang13TParseContext15findFunction400ERKNS2_10TSourceLocERKNS2_9TFunctionERbE3$_0NS_9allocatorISB_EEFbRKNS2_5TTypeESG_NS2_9TOperatorEiEEE
NSt3__110__function6__funcIZN7glslang13TParseContext15findFunction400ERKNS2_10TSourceLocERKNS2_9TFunctionERbE3$_1NS_9allocatorISB_EEFbRKNS2_5TTypeESG_SG_EEE
NSt3__110__function6__funcIZN7glslang13TParseContext25findFunctionExplicitTypesERKNS2_10TSourceLocERKNS2_9TFunctionERbE3$_2NS_9allocatorISB_EEFbRKNS2_5TTypeESG_NS2_9TOperatorEiEEE
NSt3__110__function6__funcIZN7glslang13TParseContext25findFunctionExplicitTypesERKNS2_10TSourceLocERKNS2_9TFunctionERbE3$_3NS_9allocatorISB_EEFbRKNS2_5TTypeESG_SG_EEE
NSt3__110__function6__funcIZN8spvtools15AssemblyContext26binaryEncodeNumericLiteralEPKc12spv_result_tRKNS2_6IdTypeEP17spv_instruction_tE3$_0NS_9allocatorISC_EEFvjEEE
NSt3__110__function6__funcIZN8spvtools18FriendlyNameMapper13GetNameMapperEvEUljE_NS_9allocatorIS4_EEFNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEEjEEE
NSt3__110__function6__funcIZN8spvtools30UseDiagnosticAsMessageConsumerEP13spv_context_tPP16spv_diagnostic_tE3$_0NS_9allocatorIS8_EEFv19spv_message_level_tPKcRK14spv_position_tSD_EEE
NSt3__110__function6__funcIZNK3spv8Function4dumpERNS_6vectorIjNS_9allocatorIjEEEEEUlPKNS2_5BlockENS2_11ReachReasonEPS9_E_NS5_ISE_EEFvSD_SC_SD_EEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_52clEjRNS2_12SPIRVariableEEUlvE0_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_52clEjRNS2_12SPIRVariableEEUlvE_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE0_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE10_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE11_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE12_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE13_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE14_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE15_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE16_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE17_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE18_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE19_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE1_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE20_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE21_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE22_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE23_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE24_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE25_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE26_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE27_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE28_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE29_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE2_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE30_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE3_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE4_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE5_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE6_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE7_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE8_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE9_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS2_12SPIRVariableEEUlvE_NS_9allocatorIS7_EEFvvEEE
NSt3__110__function6__funcIZZN15MVK_spirv_cross11CompilerMSL39extract_global_variables_from_functionsEvENK3$_3clEjRNS2_12SPIRVariableEEUlvE_NS_9allocatorIS7_EEFvvEEE
NSt3__113basic_filebufIcNS_11char_traitsIcEEEE
NSt3__114basic_ifstreamIcNS_11char_traitsIcEEEE
NSt3__114basic_ofstreamIcNS_11char_traitsIcEEEE
NSt3__114unary_functionIPKN7glslang13TInputScannerEiEE
NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__117bad_function_callE
NSt3__118__weak_result_typeIMN7glslang13TInputScannerEKFivEEE
NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__119basic_istringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__119basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__120__shared_ptr_emplaceIN11simple_json6StreamENS_9allocatorIS2_EEEE
NSt3__16__bindIMN7glslang13TInputScannerEKFivEJPS2_EEE
NUpdateTemplate
NVIDIA
N\bHi8\b
N\b\tȉG\b
NameEXT
NamedBarH
NamedBarrier
NamedBarrierCountINTEL
NamedBarrierInitialize
Native texture_buffer type is only supported in MSL 2.1
Nazara ShaderLang Compiler
Nearest
Need GL_ARB_enhanced_layouts for xfb_stride or xfb_buffer
Need Vulkan semantics for device group support
Need desktop GL to use GL_NV_conservative_raster_underestimation
Need to declare the corresponding fragment output variable to be able to read from it
Negate conditional
Negate value
Neither a front-end constant nor a spec constant
Neither tessellation shader specifies a partition mode (SpacingEqual, SpacingFractionalOdd, or SpacingFractionalEven
Neither tessellation shader specifies a patch input mode (Triangles, Quads, or Isolines
Neither tessellation shader specifies a winding order mode (VertexOrderCw or VertexOrderCcw
Neither tessellation shader specifies the number of output control points
Netease Games
Netease Games Messiah Shader Compiler
Next token is
NextSubpass
Nffffff
Nnstance
No backing variable for atomic operation
No block currently in scope
No errors.  No code generation or linking was requested
No function currently in scope
No function definition (body) found
No loop body\n
No loop condition\n
NoAlias
NoAliasINTEL
NoAliasINTELMask
NoCapture
NoContraction
NoFusionINTEL
NoGlobalOffsetINTEL
NoLine
NoOpaqueKHR
NoPerspective
NoReadWrite
NoSignedWrap
NoUnsignedWrap
NoWait
NoWrite
Non front-end constant expressions cannot be passed for 'spirv_literal' parameters
Non-L-value cannot be passed for 'out' or 'inout' parameters
Non-constant-index-expression
Non-square matrices are not supported in legacy GLSL, cannot transpose
NonCoherentColorAttachmentReadEXT
NonCoherentDepthAttachmentReadEXT
NonCoherentStencilAttachmentReadEXT
NonPrivatePointer
NonPrivatePointerKHR
NonPrivateTexel
NonPrivateTexelKHR
NonReadable
NonSemantic
NonSemantic.ClspvReflection
NonSemantic.DebugPrintf
NonSemantic.Shader.DebugInfo.100
NonUniform
NonUniformAMD(u16vec4);float addInvocationsExclusiveScanNonUniformAMD(float);vec2  addInvocationsExclusiveScanNonUniformAMD(vec2);vec3  addInvocationsExclusiveScanNonUniformAMD(vec3);vec4  addInvocationsExclusiveScanNonUniformAMD(vec4);int   addInvocationsExclusiveScanNonUniformAMD(int);ivec2 addInvocationsExclusiveScanNonUniformAMD(ivec2);ivec3 addInvocationsExclusiveScanNonUniformAMD(ivec3);ivec4 addInvocationsExclusiveScanNonUniformAMD(ivec4);uint  addInvocationsExclusiveScanNonUniformAMD(uint);uvec2 addInvocationsExclusiveScanNonUniformAMD(uvec2);uvec3 addInvocationsExclusiveScanNonUniformAMD(uvec3);uvec4 addInvocationsExclusiveScanNonUniformAMD(uvec4);double addInvocationsExclusiveScanNonUniformAMD(double);dvec2  addInvocationsExclusiveScanNonUniformAMD(dvec2);dvec3  addInvocationsExclusiveScanNonUniformAMD(dvec3);dvec4  addInvocationsExclusiveScanNonUniformAMD(dvec4);int64_t addInvocationsExclusiveScanNonUniformAMD(int64_t);i64vec2 addInvocationsExclusiveScanNonUniformAMD(i64vec2);i64vec3 addInvocationsExclusiveScanNonUniformAMD(i64vec3);i64vec4 addInvocationsExclusiveScanNonUniformAMD(i64vec4);uint64_t addInvocationsExclusiveScanNonUniformAMD(uint64_t);u64vec2  addInvocationsExclusiveScanNonUniformAMD(u64vec2);u64vec3  addInvocationsExclusiveScanNonUniformAMD(u64vec3);u64vec4  addInvocationsExclusiveScanNonUniformAMD(u64vec4);float16_t addInvocationsExclusiveScanNonUniformAMD(float16_t);f16vec2   addInvocationsExclusiveScanNonUniformAMD(f16vec2);f16vec3   addInvocationsExclusiveScanNonUniformAMD(f16vec3);f16vec4   addInvocationsExclusiveScanNonUniformAMD(f16vec4);int16_t addInvocationsExclusiveScanNonUniformAMD(int16_t);i16vec2 addInvocationsExclusiveScanNonUniformAMD(i16vec2);i16vec3 addInvocationsExclusiveScanNonUniformAMD(i16vec3);i16vec4 addInvocationsExclusiveScanNonUniformAMD(i16vec4);uint16_t addInvocationsExclusiveScanNonUniformAMD(uint16_t);u16vec2  addInvocationsExclusiveScanNonUniformAMD(u16vec2);u16vec3  addInvocationsExclusiveScanNonUniformAMD(u16vec3);u16vec4  addInvocationsExclusiveScanNonUniformAMD(u16vec4);float swizzleInvocationsAMD(float, uvec4);vec2  swizzleInvocationsAMD(vec2,  uvec4);vec3  swizzleInvocationsAMD(vec3,  uvec4);vec4  swizzleInvocationsAMD(vec4,  uvec4);int   swizzleInvocationsAMD(int,   uvec4);ivec2 swizzleInvocationsAMD(ivec2, uvec4);ivec3 swizzleInvocationsAMD(ivec3, uvec4);ivec4 swizzleInvocationsAMD(ivec4, uvec4);uint  swizzleInvocationsAMD(uint,  uvec4);uvec2 swizzleInvocationsAMD(uvec2, uvec4);uvec3 swizzleInvocationsAMD(uvec3, uvec4);uvec4 swizzleInvocationsAMD(uvec4, uvec4);float swizzleInvocationsMaskedAMD(float, uvec3);vec2  swizzleInvocationsMaskedAMD(vec2,  uvec3);vec3  swizzleInvocationsMaskedAMD(vec3,  uvec3);vec4  swizzleInvocationsMaskedAMD(vec4,  uvec3);int   swizzleInvocationsMaskedAMD(int,   uvec3);ivec2 swizzleInvocationsMaskedAMD(ivec2, uvec3);ivec3 swizzleInvocationsMaskedAMD(ivec3, uvec3);ivec4 swizzleInvocationsMaskedAMD(ivec4, uvec3);uint  swizzleInvocationsMaskedAMD(uint,  uvec3);uvec2 swizzleInvocationsMaskedAMD(uvec2, uvec3);uvec3 swizzleInvocationsMaskedAMD(uvec3, uvec3);uvec4 swizzleInvocationsMaskedAMD(uvec4, uvec3);float writeInvocationAMD(float, float, uint);vec2  writeInvocationAMD(vec2,  vec2,  uint);vec3  writeInvocationAMD(vec3,  vec3,  uint);vec4  writeInvocationAMD(vec4,  vec4,  uint);int   writeInvocationAMD(int,   int,   uint);ivec2 writeInvocationAMD(ivec2, ivec2, uint);ivec3 writeInvocationAMD(ivec3, ivec3, uint);ivec4 writeInvocationAMD(ivec4, ivec4, uint);uint  writeInvocationAMD(uint,  uint,  uint);uvec2 writeInvocationAMD(uvec2, uvec2, uint);uvec3 writeInvocationAMD(uvec3, uvec3, uint);uvec4 writeInvocationAMD(uvec4, uvec4, uint);uint mbcntAMD(uint64_t);\n
NonUniformEXT
NonWritable
NoneKHR
Nontemporal
Normal
Normalize
Not all array sizes match across all geometry shaders in the program
Not all shaders have valid object code
Not enough arguments to OpSpecConstantOp
NotEqual
NotInf
NotNaN
Now at end of input.\n
Nramebuffer
NumEnqueuedSubgroups
NumSIMDWorkitemsINTEL
NumSubgrH
NumSubgroups
NumSubgroups is handled specially with emulation
NumWorkGroups
NumWorkgroups
NumbanksINTEL
Number of constructor parameters does not match the number of structure fields
Nx;HxH
Nx;Hxw\n
O9t=(t,H
OBJC_CLASS_$_CAEDRMetadata
OBJC_CLASS_$_CAMetalLayer
OBJC_CLASS_$_MTLArgumentDescriptor
OBJC_CLASS_$_MTLBlitPassDescriptor
OBJC_CLASS_$_MTLCaptureDescriptor
OBJC_CLASS_$_MTLCaptureManager
OBJC_CLASS_$_MTLCommandBufferDescriptor
OBJC_CLASS_$_MTLCompileOptions
OBJC_CLASS_$_MTLComputePipelineDescriptor
OBJC_CLASS_$_MTLCounterSampleBufferDescriptor
OBJC_CLASS_$_MTLDepthStencilDescriptor
OBJC_CLASS_$_MTLFunctionConstantValues
OBJC_CLASS_$_MTLHeapDescriptor
OBJC_CLASS_$_MTLRenderPassDepthAttachmentDescriptor
OBJC_CLASS_$_MTLRenderPassDescriptor
OBJC_CLASS_$_MTLRenderPassStencilAttachmentDescriptor
OBJC_CLASS_$_MTLRenderPipelineDescriptor
OBJC_CLASS_$_MTLSamplerDescriptor
OBJC_CLASS_$_MTLSharedEventListener
OBJC_CLASS_$_MTLStageInputOutputDescriptor
OBJC_CLASS_$_MTLStencilDescriptor
OBJC_CLASS_$_MTLTextureDescriptor
OBJC_CLASS_$_NSApplication
OBJC_CLASS_$_NSData
OBJC_CLASS_$_NSDictionary
OBJC_CLASS_$_NSError
OBJC_CLASS_$_NSFileManager
OBJC_CLASS_$_NSMutableArray
OBJC_CLASS_$_NSMutableString
OBJC_CLASS_$_NSNumber
OBJC_CLASS_$_NSObject
OBJC_CLASS_$_NSProcessInfo
OBJC_CLASS_$_NSScreen
OBJC_CLASS_$_NSString
OBJC_CLASS_$_NSThread
OBJC_CLASS_$_NSURL
OBJC_CLASS_$_NSUUID
OBJC_CLASS_$_NSView
OBJC_METACLASS_$_NSObject
ODHcV
OLayout
OQueryPool
OR_ASSIGN
ORenderPass
OSurfaceMVK
OVR_multiview2 can only be used with Vertex shaders
OVR_multiview2 cannot be used with Vulkan semantics
O\bA9M\bt5L
O\b\tIO\b
ObjectRayDirectionKHR
ObjectRayDirectionNV
ObjectRayOriginKHR
ObjectRayOriginNV
ObjectRayTmaxNV
ObjectRayTminNV
ObjectToWorldKHR
ObjectToWorldNV
Oemaphore
Offff
Offffff
Offset
Offsets
Only 1D, 2D, 2DRect, 3D, Buffer, InputTarget and Cube textures supported
Only 32-bit integers and booleans are currently supported when evaluating specialization constants.\n
Only Input, Output variables and Uniform constants are part of a shader linking interface
Only Logical and PhysicalStorageBuffer64EXT addressing models are supported
Only StorageClassPhysicalStorageBufferEXT is supported by OpConvertPtrToU
Only StorageClassPhysicalStorageBufferEXT is supported by OpConvertUToPtr
Only one push_constant block is allowed per stage
Only one shaderRecordNV buffer block is allowed per stage
Only one taskNV interface block is allowed per shader
Only single variable of type taskPayloadSharedEXT is allowed per shader
Only subgroup scope is supported
OpAtomicCompareExchangeWeak is only supported in kernel profile
OpConstantComposite only supports 1, 2, 3 and 4 elements
OpExtInst set Id
OpModuleProcessed
OpSpecConstant opcode table out of sync
OpSpecConstantOp not enough arguments
OpSpecConstantOp opcode
Op]ÐUH
Opaque
OpaqueKHR
OpenCL
OpenCL.DebugInfo.100
OpenCL.DebugInfo.100 debug base type encoding
OpenCL.DebugInfo.100 debug composite type
OpenCL.DebugInfo.100 debug imported entity
OpenCL.DebugInfo.100 debug info flags
OpenCL.DebugInfo.100 debug operation
OpenCL.DebugInfo.100 debug type qualifier
OpenCL.std
OpenCL_C
OpenCL_CPP
OpenGL
OpenGL ES GLSL 3.20 glslang Khronos. 12.3.1
OpenGL ES doesn't support array input variables in vertex shader
OperationFromVkBlendOp
OptNoneINTEL
Ordered
OriginLowerLeft
OriginUpperLeft
Original GLSL extraction error
OrivateDataSlot
Out of memory
OuterProduct
Output
OutputLineStrip
OutputLinesEXT
OutputLinesNV
OutputMemory
OutputMemoryKHR
OutputPoints
OutputPrimitivesEXT
OutputPrimitivesNV
OutputTriangleStrip
OutputTrianglesEXT
OutputTrianglesNV
OutputVertices
OverrideCoverageNV
Overwriting a variant with new type
P IǆH\b
P P P
P P P PP PPP
P fAǄ$h
P fAǆh
P ffff
P ffffff
P(HǃH\b
P000@Pp
P00@@0
P0P```P
P8H)ʉU
P@00Pp
P@0`  P
P@P0  @0
PACKED
PAYLOADEXT
PAYLOADINEXT
PAYLOADINNV
PAYLOADNV
PERCENT
PERPRIMITIVEEXT
PERPRIMITIVENV
PERTASKNV
PERVERTEXEXT
PERVERTEXNV
PERVIEWNV
PFNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjE
PI;G`u
PKcEEE
PM;n\br
PM;o\br
PM;t$\br
PP00 0
PP00 0   p
PPH\tX\b
PPH\tX\bA
PPH\tX\bI
PPPPPP
PPPPPPP00
PRECISE
PRECISION
PUCacheModeFromVkMemoryPropertyFlags
PUT_FILEH
PVRTCFormat
PXH3X\bH
PackDouble2x32
PackHalf2x16
PackSnorm2x16
PackSnorm4x8
PackUnorm2x16
PackUnorm4x8
PackedVectorFormat4x8Bit
PackedVectorFormat4x8BitKHR
PartialCount
Partially converted
PartitionedExclusiveScanNV
PartitionedInclusiveScanNV
PartitionedReduceNV
Pass2KHRH
Pass2KHRL
PassthroughNV
PatchVertices
PatchVertices is derived from the auxiliary buffer in MSL
PeelCount
PerPrimitiveEXT
PerPrimitiveNV
PerTaskNV
PerVertexKHR
PerVertexKHR decoration is not supported in MSL
PerVertexNV
PerViewAttributesNV
PerViewNV
Performance statistics reporting every: %d frames, avg FPS: %.2f, elapsed time: %.3f seconds
PhaderModule
Physical32
Physical64
PhysicalStorageBuffer
PhysicalStorageBuffer64
PhysicalStorageBuffer64EXT
PhysicalStorageBufferAddresses
PhysicalStorageBufferAddressesEXT
PhysicalStorageBufferEXT
PipeStorH
PipeStorage
Pipeline does not support component swizzle (%s, %s, %s, %s) required by a VkImageView used in the %s shader. Full VkImageView component swizzling will be supported by a pipeline if the MVKConfiguration::fullImageViewSwizzle config parameter or MVK_CONFIG_FULL_IMAGE_VIEW_SWIZZLE environment variable was enabled when the pipeline is compiled
Pipeline input reflection
Pipeline output reflection
PipelineEnableINTEL
Pixel local storage only supported in ESSL 3.0 and above
Pixel local storage only supported in OpenGL ES
Pixel local storage only supported in fragment shaders
PixelCenterInteger
PixelInterlockOrderedEXT
PixelInterlockUnorderedEXT
Plane index is out of bounds. Attempted to set MTLTexture at plane index %d in VkImage that has %zu planes
PlusUconst
PointCoord
PointFromVkOffset2D
PointMode
PointSize
Pointer
Popping empty indent stack
Position
PositionPerViewNV
Possible extensions include
Post-Decrement
Post-Increment
Post-depth coverage on Mac requires MSL 2.3
Post-depth coverage requires MSL 2.0
Post-render-pass occlusion query accumulation ComputeEncoder
PostDepthCoverage
PpPPP
Pre-Decrement
Pre-Increment
Precision qualifiers must match
PrefetchINTEL
Presence of invariant qualifier must match
Presence of precise qualifier must match
Preserve
PrimitiveCountNV
PrimitiveID
PrimitiveId
PrimitiveId is computed manually with multi-patch workgroups in MSL
PrimitiveId is not supported in this execution model
PrimitiveId on iOS requires MSL 2.3
PrimitiveId on macOS requires MSL 2.2
PrimitiveIndicesNV
PrimitiveLineIndicesEXT
PrimitivePointIndicesEXT
PrimitiveShadingRateKHR
PrimitiveTriangleIndicesEXT
PrintfBufferPointerPushConstant
PrintfBufferStorageBuffer
PrintfInfo
Private
Private GPU-only memory cannot be mapped to host memory
ProgramScopeVariablePointerPushConstant
ProgramScopeVariablePointerRelocation
ProgramScopeVariablesStorageBuffer
ProjEXT
ProjGrad
ProjGradARB
ProjGradEXT
ProjLod
ProjLodEXT
ProjLodOffset
ProjectionAxis = Coords.x
ProjectionAxis = Coords.y
ProjectionAxis = Coords.z
PropertyRequiredWorkgroupSize
PtrAccessChain
PtrCastToCrossWorkgroupINTEL
PtrCastToGeneric
PtrDiff
PtrEqual
PtrNotEqual
Pull-model interpolation requires MSL 2.3
Pumerate
PurfaceKHR
Push constant block cannot be expressed as neither std430 nor std140. ES-targets do not support GL_ARB_enhanced_layouts
Push constants blocks can't be an array
PushConstant
PushConstantEnqueuedLocalSize
PushConstantGlobalOffset
PushConstantGlobalSize
PushConstantNumWorkgroups
PushConstantRegionGroupOffset
PushConstantRegionOffset
Pw\t\bpx\t
PwapchainKHR
PxportMetalObjectsEXT
Q16@0:8
Q24@0:8Q16
Q24@0:8q16
QInstance
QLayerProperties
QPH\tX\b
QPH\tX\bA
QPL\th\b
QPL\tp\bI
QPL\tx\b1
QPL\tx\bH
QPhysicalDevice
QQQ}16@0:8
QQQ}24@0:8@"MTLAccelerationStructureDescriptor"16
QQQ}24@0:8@16
QQQ}40@0:8Q16Q24Q32
QQQ}48@0:8Q16Q24Q32q40
QQ}24@0:8@"MTLAccelerationStructureDescriptor"16
QQ}24@0:8@"MTLTextureDescriptor"16
QQ}24@0:8@16
QQ}24@0:8Q16
QQ}32@0:8Q16Q24
QRTSVWXYZUP
QUESTION
QUEUEFAMILYCOHERENT
Qffffff
Qualcomm
QuantizeToF16
Query
QueryPool
QueryPoolResults
Querying alignment of opaque object
Querying size for object with opaque size
Querying size of opaque object
QueueFamily
QueueFamilyKHR
QueueFamilyProperties
QueueMVKH
QueufǅE
R11fG11fB10f
R16Snorm
R8Snorm
RARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARARBRARB
RARARARARARARARARARARARARARARARARARARBRB
RARARARARARARB[Ap
RARAXARAXARAXARAXARAXARAXARAXARAUAUA[ATAUARARARARAZARAp\bZARAp\bZARAp\bWARAWARAWARARAWARAWARAWARAWARA[ATARMYBRAZARAZARAZARAZARAZARAZARAZARAZARAYERA]ARA]ARAZARAZAp\bRAp\bZAp\bRAp\bZAp\bRAp\bZAp\bRAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bUARAUAUA[ATBp
RAVARAWARAVARAWARAVARAVARAVARAWARARAUCVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAVARAVARAWARAVARAWARAVARAWARAVARAWARAVARAVARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAVARAVARAVARAVARAVARAVARAVARAWARAVARAWARAVARAWARAVARAVARAVARAVARAVARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAVARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAWARAVARAYARARAVDVARAYARARAVDVARAYARAVARAYARAVARAXARARAVCVARAXARARAVCVARAXARAVARAXARAVARAVARAVARAVARAVARAVARAWARAVARAWARAVARAWARAVARAVARAVARAVARAVARAVARAVARAVARAWARAVARAWARAVARAVARAWATAp\bp\bp
RAYQUERYEXT
RAZARARAZARAZARAUARA[ATARBRAUA]ATA^ATA^BTBSCSCRA
RAZAp\bRA`@AWARAWARAWARAWARAWARAWARAWARAWARAWARAWARAWARA]ATA[ATARARAUARASBZAZARARA[ATARA[ATARA[ATARAZAp\bRATAVATAUAVARA\\ARAUAVARA\\A
RA[ATA[ATA[ATA[ATARARARARAp\bUARAUARAUARAUARAUARAUARAUARAUARAUARAUARAUARAUARAZAp\bRAp\b\\ARAUAp p\bRA\\ARA\\ARA\\ARA\\ARA\\ARA\\ARA\\ARA\\ARAVERA
RAp\bSBWARAWARAUCRAWARAWARAWARBSBWKp
RAp\bp\bp
RBRBRAZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bTARATARATARATARATATARATARATARAXAZAZAZAZAZARAZARAZARAZARAZARAZARAZARAZARAZARAp\bRARARARA`AARATAp\bp\bWARBp p
READONLY
RESERVED_IDENTIFIER_FIXUP
RESOURCE
RESTRICT
RETURN
RIGHT_ANGLE
RIGHT_ASSIGN
RIGHT_BRACE
RIGHT_BRACKET
RIGHT_OP
RIGHT_PAREN
RND_CONV
RND_CONV_ODD
RND_INF
RND_MIN_INF
RND_ZERO
RT_STYLEH
RVersion
Radians
Raster order groups require MSL 2.0
Ray tracing requires Vulkan semantics
Ray tracing shaders require non-es profile with version 460 or above
RayCullMaskKHR
RayGenerationKHR
RayGenerationNV
RayGeometryIndexKHR
RayPayloadKHR
RayPayloadNV
RayQuery requires Vulkan GLSL 460
RayQueryCandidateIntersectionAABBKHR
RayQueryCandidateIntersectionKHR
RayQueryCandidateIntersectionTriangleKHR
RayQueryCommittedIntersectionGeneratedKHR
RayQueryCommittedIntersectionKHR
RayQueryCommittedIntersectionNoneKHR
RayQueryCommittedIntersectionTriangleKHR
RayQueryConfirmIntersectionKHR
RayQueryGenerateIntersectionKHR
RayQueryGetIntersectionBarycentricsKHR
RayQueryGetIntersectionCandidateAABBOpaqueKHR
RayQueryGetIntersectionFrontFaceKHR
RayQueryGetIntersectionGeometryIndexKHR
RayQueryGetIntersectionInstanceCustomIndexKHR
RayQueryGetIntersectionInstanceIdKHR
RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR
RayQueryGetIntersectionObjectRayDirectionKHR
RayQueryGetIntersectionObjectRayOriginKHR
RayQueryGetIntersectionObjectToWorldKHR
RayQueryGetIntersectionPrimitiveIndexKHR
RayQueryGetIntersectionTKHR
RayQueryGetIntersectionTriangleVertexPositionsKHR
RayQueryGetIntersectionTypeKHR
RayQueryGetIntersectionWorldToObjectKHR
RayQueryGetRayFlagsKHR
RayQueryGetRayTMinKHR
RayQueryGetWorldRayDirectionKHR
RayQueryGetWorldRayOriginKHR
RayQueryInitializeKHR
RayQueryKHR
RayQueryPositionFetchKHR
RayQueryProceedKHR
RayQueryProvisionalKHR
RayQueryTerminateKHR
RayTmaxKHR
RayTmaxNV
RayTminKHR
RayTminNV
RayTracingKHR
RayTracingMotionBlurNV
RayTracingNV
RayTracingOpacityMicromapEXT
RayTracingPositionFetchKHR
RayTracingProvisionalKHR
RayTraversalPrimitiveCullingKHR
Rayan Hatout
Rayan Hatout SPIRVSmith
Read MSL from pipeline cache
ReadClockKHR
ReadOnly
ReadPipe
ReadPipeBlockingINTEL
ReadWrite
Reading a token\n
Record GPU Counter Sample BlitEncoder
RectFromVkRectLayerKHR
Rectangle textures are not supported on OpenGL ES
Recursion detected
Reduce
Reducing stack by rule %d (line %d):\n
ReferencedIndirectlyINTEL
Reflect
Refract
RegisterINTEL
RegisterMapInterfaceINTEL
RegisterMapKernelArgumentINTEL
Relaxed
RelaxedPrecision
Release
ReleaseEvent
Render
Render pipeline
ReorderThreadNV
ReorderThreadWithHintNV
ReorderThreadWithHitObjectNV
Repeat
RepeatMirrored
ReportCallbackEXT
ReportIntersectionKHR
ReportIntersectionNV
Requested
ResType
ReserveIH
ReserveId
ReserveReadPipePackets
ReserveWritePipePackets
Reserved word
ReservedReadPipe
ReservedWritePipe
Resolve Subpass Attachment ComputeEncoder
RestartEnable
RestoreMemoryINTEL
Restrict
RestrictPointer
RestrictPointerEXT
RestrictType
RetainEvent
Retrieve a CAMetalDrawable from CAMetalLayer
Retrieve a MTLFunction from a MTLLibrary
Retrieve shader library from the cache
Return
ReturnValue
Returns 2D texture coords corresponding to 1D texel buffer coords
Returns buffer coords corresponding to 2D texture coords for emulating 2D texture atomics
Returns the determinant of a 2x2 matrix
Returns the determinant of a 3x3 matrix
Returns the inverse of a matrix, by using the algorithm of calculating the classical
Rg16Snorm
Rg16ui
Rg32ui
Rg8Snorm
Rgb10A2
Rgb10a2ui
Rgba16
Rgba16Snorm
Rgba16f
Rgba16i
Rgba16ui
Rgba32f
Rgba32i
Rgba32ui
Rgba8Snorm
Rgba8i
Rgba8ui
RoundEven
RoundToInfinityINTEL
RoundingModeRTE
RoundingModeRTNINTEL
RoundingModeRTPINTEL
RoundingModeRTZ
Row-major matrices must be square on this platform
RowMajor
RowMajorKHR
Rp9\nu0
Runtime arrays with dynamic offsets are not supported yet
RuntimeAlignedAttributeINTEL
RuntimeAlignedINTEL
RuntimeDescriptorArray
RuntimeDescriptorArrayEXT
Rust GPU Compiler Backend
S3_EEE
SAMPLE
SAMPLER
SAMPLER1D
SAMPLER1DARRAY
SAMPLER1DARRAYSHADOW
SAMPLER1DSHADOW
SAMPLER2D
SAMPLER2DARRAY
SAMPLER2DARRAYSHADOW
SAMPLER2DMS
SAMPLER2DMSARRAY
SAMPLER2DRECT
SAMPLER2DRECTSHADOW
SAMPLER2DSHADOW
SAMPLER3D
SAMPLERBUFFER
SAMPLERCUBE
SAMPLERCUBEARRAY
SAMPLERCUBEARRAYSHADOW
SAMPLERCUBESHADOW
SAMPLEREXTERNAL2DY2YEXT
SAMPLEREXTERNALOES
SAMPLERSHADOW
SASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASASARN
SAT_SYM
SAT_ZERO
SAWAUAT
SAp\bp\bp
SBSB]0
SBVARARARARARAUA
SCHAR_MAX
SCHAR_MIN
SClamp
SConvert
SDescriptorSets
SDotAccSat
SDotAccSatKHR
SDotKHR
SEMICOLON
SGreaterThan
SGreaterThanEqual
SHADERCALLCOHERENT
SHARED
SHRT_MAX
SHRT_MIN
SHcw Hc_\b9
SIMTCallINTEL
SLessThan
SLessThanEqual
SMCountNV
SMIDNV
SMOOTH
SMax3AMD
SMemory
SMemoryRequirements
SMid3AMD
SMin3AMD
SMulExtended
SNegate
SPIR-V 1.0
SPIR-V 1.0 (under OpenCL 1.2 Embedded Profile semantics
SPIR-V 1.0 (under OpenCL 1.2 Full Profile semantics
SPIR-V 1.0 (under OpenCL 2.0 Embedded Profile semantics
SPIR-V 1.0 (under OpenCL 2.0 Full Profile semantics
SPIR-V 1.0 (under OpenCL 2.1 Embedded Profile semantics
SPIR-V 1.0 (under OpenCL 2.1 Full Profile semantics
SPIR-V 1.0 (under OpenGL 4.0 semantics
SPIR-V 1.0 (under OpenGL 4.1 semantics
SPIR-V 1.0 (under OpenGL 4.2 semantics
SPIR-V 1.0 (under OpenGL 4.3 semantics
SPIR-V 1.0 (under OpenGL 4.5 semantics
SPIR-V 1.0 (under Vulkan 1.0 semantics
SPIR-V 1.1
SPIR-V 1.2
SPIR-V 1.2 (under OpenCL 2.2 Embedded Profile semantics
SPIR-V 1.2 (under OpenCL 2.2 Full Profile semantics
SPIR-V 1.3
SPIR-V 1.3 (under Vulkan 1.1 semantics
SPIR-V 1.4
SPIR-V 1.4 (under Vulkan 1.1 semantics
SPIR-V 1.5
SPIR-V 1.5 (under Vulkan 1.2 semantics
SPIR-V 1.6
SPIR-V 1.6 (under Vulkan 1.3 semantics
SPIR-V Tools Assembler
SPIR-V Tools Linker
SPIR-V callers expect a uint4. We must convert
SPIR-V decorate qualifier
SPIR-V does not define ArrayStride for buffer block
SPIR-V execution mode qualifier
SPIR-V instruction goes out of bounds
SPIR-V instruction qualifier
SPIR-V instructions cannot consume 0 words. Invalid SPIR-V file
SPIR-V requires location for user input/output
SPIR-V storage class qualifier
SPIR-V to MSL conversion error
SPIR-V type specifier
SPIR-V:\n
SPIR-V\n
SPIRV file too small
SPIRVSmith
SPIRV_BY_REFERENCE
SPIRV_CROSS_BRANCH
SPIRV_CROSS_CONSTANT_ID
SPIRV_CROSS_FLATTEN
SPIRV_CROSS_LOOP
SPIRV_CROSS_SUBGROUP_ALL_EQUAL_WORKAROUND
SPIRV_CROSS_UNROLL
SPIRV_Cross_BaseInstance
SPIRV_Cross_BaseVertex
SPIRV_Cross_Combined
SPIRV_Cross_DummySampler
SPIRV_Cross_beginInvocationInterlock
SPIRV_Cross_endInvocationInterlock
SPIRV_DECORATE
SPIRV_DECORATE_ID
SPIRV_DECORATE_STRING
SPIRV_EXECUTION_MODE
SPIRV_EXECUTION_MODE_ID
SPIRV_INSTRUCTION
SPIRV_LITERAL
SPIRV_STORAGE_CLASS
SPIRV_TYPE
SPV_AMD_gcn_shader
SPV_AMD_gpu_shader_half_float
SPV_AMD_gpu_shader_half_float_fetch
SPV_AMD_gpu_shader_int16
SPV_AMD_shader_ballot
SPV_AMD_shader_early_and_late_fragment_tests
SPV_AMD_shader_explicit_vertex_parameter
SPV_AMD_shader_fragment_mask
SPV_AMD_shader_image_load_store_lod
SPV_AMD_shader_trinary_minmax
SPV_AMD_texture_gather_bias_lod
SPV_ARM_core_builtins
SPV_END_OF_STREAM
SPV_ERROR_INTERNAL
SPV_ERROR_INVALID_BINARY
SPV_ERROR_INVALID_CFG
SPV_ERROR_INVALID_DIAGNOSTIC
SPV_ERROR_INVALID_ID
SPV_ERROR_INVALID_LAYOUT
SPV_ERROR_INVALID_LOOKUP
SPV_ERROR_INVALID_POINTER
SPV_ERROR_INVALID_TABLE
SPV_ERROR_INVALID_TEXT
SPV_ERROR_INVALID_VALUE
SPV_ERROR_OUT_OF_MEMORY
SPV_EXT_demote_to_helper_invocation
SPV_EXT_descriptor_indexing
SPV_EXT_fragment_fully_covered
SPV_EXT_fragment_invocation_density
SPV_EXT_fragment_shader_interlock
SPV_EXT_mesh_shader
SPV_EXT_shader_atomic_float16_add
SPV_EXT_shader_atomic_float_add
SPV_EXT_shader_atomic_float_min_max
SPV_EXT_shader_image_int64
SPV_EXT_shader_stencil_export
SPV_EXT_shader_tile_image
SPV_EXT_shader_viewport_index_layer
SPV_FAILED_MATCH
SPV_INTEL_shader_integer_functions2
SPV_KHR_16bit_storage
SPV_KHR_8bit_storage
SPV_KHR_cooperative_matrix
SPV_KHR_device_group
SPV_KHR_fragment_shader_barycentric
SPV_KHR_fragment_shading_rate
SPV_KHR_multiview
SPV_KHR_non_semantic_info
SPV_KHR_physical_storage_buffer
SPV_KHR_post_depth_coverage
SPV_KHR_ray_cull_mask
SPV_KHR_ray_query
SPV_KHR_ray_tracing
SPV_KHR_ray_tracing_position_fetch
SPV_KHR_shader_atomic_counter_ops
SPV_KHR_shader_ballot
SPV_KHR_shader_clock
SPV_KHR_shader_draw_parameters
SPV_KHR_storage_buffer_storage_class
SPV_KHR_subgroup_uniform_control_flow
SPV_KHR_subgroup_vote
SPV_KHR_terminate_invocation
SPV_KHR_vulkan_memory_model
SPV_KHR_workgroup_memory_explicit_layout
SPV_NVX_multiview_per_view_attributes
SPV_NV_compute_shader_derivatives
SPV_NV_cooperative_matrix
SPV_NV_fragment_shader_barycentric
SPV_NV_geometry_shader_passthrough
SPV_NV_mesh_shader
SPV_NV_ray_tracing
SPV_NV_ray_tracing_motion_blur
SPV_NV_sample_mask_override_coverage
SPV_NV_shader_image_footprint
SPV_NV_shader_invocation_reorder
SPV_NV_shader_sm_builtins
SPV_NV_shader_subgroup_partitioned
SPV_NV_shading_rate
SPV_NV_stereo_view_rendering
SPV_NV_viewport_array2
SPV_REQUESTED_TERMINATION
SPV_SUCCESS
SPV_UNSUPPORTED
SPV_WARNING
SSBOs not supported in legacy targets
STATIC_DATA_TRACEPOINT
STATIC_DATA_TRACEPOINT_V
STRING_LITERAL
STRUCT
SUBGROUPCOHERENT
SUBPASSINPUT
SUBPASSINPUTMS
SUBROUTINE
SUB_ASSIGN
SUDotAccSat
SUDotAccSatKHR
SUDotKHR
SUPERP
SWITCH
Saarland University
Saarland University Shady
Sample
Sample position is retrieved by a function in MSL
Sample variables not supported in legacy GLSL
SampleId
SampleInterlockOrderedEXT
SampleInterlockUnorderedEXT
SampleMask
SampleMaskIn
SampleMaskOverrideCoverageNV
SampleMaskPostDepthCoverage
SamplePosition
SampleRateShading
Sampled1D
SampledBuffer
SampledCubeArray
SampledImage
SampledImageArrayDynamicIndexing
SampledImageArrayNonUniformIndexing
SampledImageArrayNonUniformIndexingEXT
SampledRect
SamplerImageAddressingModeNV
SatConvertSToU
SatConvertUToS
SaturatedConversion
SaturatingAccumulationKHR
SaveMemoryINTEL
Saved SPIR-V to file
SchedulerTargetFmaxMhzINTEL
Schema
Scope\n
Secondary command buffers may not be submitted directly to a queue
SecondaryColor
SecondaryFragColorEXT
SecondaryFragDataEXT
SecondaryPositionNV
SecondaryViewportMaskNV
SecondaryViewportRelativeNV
See previous logged error
Select
SelectionMerge
Semantics must include exactly one of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease
Semantics must not include multiple of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease
SemaphoreProperties
Sequence\n
SequentiallyConsistent
SetEventH
SetMeshOutputsEXT
SetUserEventStatus
Shader
Shader library
Shader log messages
Shader version
ShaderCallKHR
ShaderClockKHR
ShaderInvocationReorderNV
ShaderLayer
ShaderNonUniform
ShaderNonUniformEXT
ShaderRecordBufferKHR
ShaderRecordBufferNV
ShaderSMBuiltinsNV
ShaderStereoViewNV
ShaderViewportIndex
ShaderViewportIndexLayerEXT
ShaderViewportIndexLayerNV
ShaderViewportMaskNV
ShaderWriter
Shaderc over Glslang
ShadingRateInterlockOrderedEXT
ShadingRateInterlockUnorderedEXT
ShadingRateKHR
ShadingRateNV
Shadow
SharedLocalMemorySizeINTEL
ShiftLeftLogical
ShiftRightArithmetic
ShiftRightLogical
Shifting
Shouldn't reach lower than vector handling OpSpecConstantOp CompositeInsert
ShuffleXor
SideEffectsINTEL
SignBitSet
SignExtend
Signed
SignedChar
SignedInt16
SignedInt32
SignedInt8
SignedZeroInfNanPreserve
Simple
SimpleDualPortINTEL
SingleElementVectorINTEL
SinglepumpINTEL
SirLynix
SirLynix Nazara ShaderLang Compiler
SizeFromBaseSize
SizeFromVkExtent2D
SizeInBytes
SizeOf
Skia SkSL
SkipAABBsKHR
SkipClosestHitShaderKHR
SkipTrianglesKHR
SmoothStep
SnormInt16
SnormInt8
Source
Source entry point must be "main
SourceContinued
SourceExtension
SpacingEqual
SpacingFractionalEven
SpacingFractionalOdd
SparkSL
Sparse feedback is not supported in GLSL
Sparse feedback not yet supported in MSL
Sparse residency is not supported in ESSL
Sparse texture feedback is not supported on ESSL
SparseResidency
Spec constant evaluation must be a scalar.\n
SpecConstant
SpecConstantComposite
SpecConstantCompositeContinuedINTEL
SpecConstantFalse
SpecConstantGlobalOffset
SpecConstantOp
SpecConstantSubgroupMaxSize
SpecConstantTrue
SpecConstantWorkDim
SpecConstantWorkgroupSize
SpecId
Specialization constant operation used in OpConstantComposite
Specialize a retrieved MTLFunction
SpeculatedIterationsINTEL
SplitBarrierINTEL
SpvExecutionMode
SpvGenTwo SPIR-V IR Tools
SpvGenTwo community
SpvGenTwo community SpvGenTwo SPIR-V IR Tools
StableKernelArgumentINTEL
Stack now
Stack size increased to %ld\n
StackCallINTEL
StackValue
StallEnableINTEL
Starting parse\n
Stencil export not supported in GLES
Stencil export only supported in MSL 2.1 and up
StencilAttachmentReadEXT
StencilExportEXT
StencilFromVkClearValue
StencilRefGreaterBackAMD
StencilRefGreaterFrontAMD
StencilRefLessBackAMD
StencilRefLessFrontAMD
StencilRefReplacingEXT
StencilRefUnchangedBackAMD
StencilRefUnchangedFrontAMD
StencilResolveFilterFromVkResolveModeFlagBits
StepFunctionFromVkVertexInputRate
Storage class semantics must not be zero
Storage qualifiers must match
StorageBuffer
StorageBuffer16BitAccess
StorageBuffer8BitAccess
StorageBufferArrayDynamicIndexing
StorageBufferArrayNonUniformIndexing
StorageBufferArrayNonUniformIndexingEXT
StorageCH
StorageClass
StorageImageArrayDynamicIndexing
StorageImageArrayNonUniformIndexing
StorageImageArrayNonUniformIndexingEXT
StorageImageExtendedFormats
StorageImageMultisample
StorageImageReadWithoutFormat
StorageImageWriteWithoutFormat
StorageInputOutput16
StoragePushConstant16
StoragePushConstant8
StorageTexelBufferArrayDynamicIndexing
StorageTexelBufferArrayDynamicIndexingEXT
StorageTexelBufferArrayNonUniformIndexing
StorageTexelBufferArrayNonUniformIndexingEXT
StorageUniform16
StorageUniformBufferBlock16
Store cooperative matrix KHR
Store cooperative matrix NV
Stream
StreamingInterfaceINTEL
Stride for dynamic vector indexing must be divisible by the size of a 4-component vector. This cannot be flattened in legacy targets
String
String was not terminated before EOF
Struct member does not have ArrayStride set
Struct member does not have MatrixStride set
Struct member does not have Offset set
Structure
SubGroupEqMask
SubGroupGeMask
SubGroupGtMask
SubGroupInvocation
SubGroupLeMask
SubGroupLtMask
SubGroupSize
Subgroup
Subgroup ballot functionality requires Metal 2.1
Subgroup ballot functionality requires Metal 2.2 on iOS
Subgroup ballot masks are handled specially in MSL
Subgroup builtins are not available in this type of function
Subgroup builtins in kernel functions require Metal 2.0
Subgroup builtins require Metal 2.0
Subgroup emulation does not support operations other than Elect
Subgroup ops beyond broadcast and shuffle on macOS require Metal 2.1 and up
Subgroup ops beyond broadcast, ballot, and shuffle on iOS require Metal 2.3 and up
SubgroupAllEqualKHR
SubgroupAllKHR
SubgroupAnyKHR
SubgroupAvcBmeInitializeINTEL
SubgroupAvcFmeInitializeINTEL
SubgroupAvcImeAdjustRefOffsetINTEL
SubgroupAvcImeConvertToMcePayloadINTEL
SubgroupAvcImeConvertToMceResultINTEL
SubgroupAvcImeEvaluateWithDualReferenceINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL
SubgroupAvcImeEvaluateWithSingleReferenceINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL
SubgroupAvcImeGetBorderReachedINTEL
SubgroupAvcImeGetDualReferenceStreaminINTEL
SubgroupAvcImeGetSingleReferenceStreaminINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL
SubgroupAvcImeGetTruncatedSearchIndicationINTEL
SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL
SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL
SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL
SubgroupAvcImeInitializeINTEL
SubgroupAvcImeRefWindowSizeINTEL
SubgroupAvcImeSetDualReferenceINTEL
SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL
SubgroupAvcImeSetMaxMotionVectorCountINTEL
SubgroupAvcImeSetSingleReferenceINTEL
SubgroupAvcImeSetUnidirectionalMixDisableINTEL
SubgroupAvcImeSetWeightedSadINTEL
SubgroupAvcImeStripDualReferenceStreamoutINTEL
SubgroupAvcImeStripSingleReferenceStreamoutINTEL
SubgroupAvcMceConvertToImePayloadINTEL
SubgroupAvcMceConvertToImeResultINTEL
SubgroupAvcMceConvertToRefPayloadINTEL
SubgroupAvcMceConvertToRefResultINTEL
SubgroupAvcMceConvertToSicPayloadINTEL
SubgroupAvcMceConvertToSicResultINTEL
SubgroupAvcMceGetBestInterDistortionsINTEL
SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL
SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL
SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL
SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL
SubgroupAvcMceGetDefaultInterShapePenaltyINTEL
SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL
SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL
SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL
SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL
SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL
SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL
SubgroupAvcMceGetInterDirectionsINTEL
SubgroupAvcMceGetInterDistortionsINTEL
SubgroupAvcMceGetInterMajorShapeINTEL
SubgroupAvcMceGetInterMinorShapeINTEL
SubgroupAvcMceGetInterMotionVectorCountINTEL
SubgroupAvcMceGetInterReferenceIdsINTEL
SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL
SubgroupAvcMceGetMotionVectorsINTEL
SubgroupAvcMceSetAcOnlyHaarINTEL
SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL
SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL
SubgroupAvcMceSetInterDirectionPenaltyINTEL
SubgroupAvcMceSetInterShapePenaltyINTEL
SubgroupAvcMceSetMotionVectorCostFunctionINTEL
SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL
SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL
SubgroupAvcMotionEstimationChromaINTEL
SubgroupAvcMotionEstimationINTEL
SubgroupAvcMotionEstimationIntraINTEL
SubgroupAvcRefConvertToMcePayloadINTEL
SubgroupAvcRefConvertToMceResultINTEL
SubgroupAvcRefEvaluateWithDualReferenceINTEL
SubgroupAvcRefEvaluateWithMultiReferenceINTEL
SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL
SubgroupAvcRefEvaluateWithSingleReferenceINTEL
SubgroupAvcRefSetBidirectionalMixDisableINTEL
SubgroupAvcRefSetBilinearFilterEnableINTEL
SubgroupAvcSicConfigureIpeLumaChromaINTEL
SubgroupAvcSicConfigureIpeLumaINTEL
SubgroupAvcSicConfigureSkcINTEL
SubgroupAvcSicConvertToMcePayloadINTEL
SubgroupAvcSicConvertToMceResultINTEL
SubgroupAvcSicEvaluateIpeINTEL
SubgroupAvcSicEvaluateWithDualReferenceINTEL
SubgroupAvcSicEvaluateWithMultiReferenceINTEL
SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL
SubgroupAvcSicEvaluateWithSingleReferenceINTEL
SubgroupAvcSicGetBestIpeChromaDistortionINTEL
SubgroupAvcSicGetBestIpeLumaDistortionINTEL
SubgroupAvcSicGetInterRawSadsINTEL
SubgroupAvcSicGetIpeChromaModeINTEL
SubgroupAvcSicGetIpeLumaShapeINTEL
SubgroupAvcSicGetMotionVectorMaskINTEL
SubgroupAvcSicGetPackedIpeLumaModesINTEL
SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL
SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL
SubgroupAvcSicInitializeINTEL
SubgroupAvcSicSetBilinearFilterEnableINTEL
SubgroupAvcSicSetBlockBasedRawSkipSadINTEL
SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL
SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL
SubgroupAvcSicSetIntraLumaShapePenaltyINTEL
SubgroupAvcSicSetSkcForwardTransformEnableINTEL
SubgroupBallotKHR
SubgroupBlockReadINTEL
SubgroupBlockWriteINTEL
SubgroupBufferBlockIOINTEL
SubgroupDispatch
SubgroupEqMask
SubgroupEqMaskKHR
SubgroupFirstInvocationKHR
SubgroupGeMask
SubgroupGeMaskKHR
SubgroupGtMask
SubgroupGtMaskKHR
SubgroupH
SubgroupID
SubgroupId
SubgroupId is handled specially with emulation
SubgroupImageBlockIOINTEL
SubgroupImageBlockReadINTEL
SubgroupImageBlockWriteINTEL
SubgroupImageMediaBlockIOINTEL
SubgroupImageMediaBlockReadINTEL
SubgroupImageMediaBlockWriteINTEL
SubgroupInvocationID
SubgroupLeMask
SubgroupLeMaskKHR
SubgroupLocalInvocationId
SubgroupLocalInvocationId is handled specially with emulation
SubgroupLtMask
SubgroupLtMaskKHR
SubgroupMaxSize
SubgroupMemory
SubgroupReadInvocationKHR
SubgroupShuffleDownINTEL
SubgroupShuffleINTEL
SubgroupShuffleUpINTEL
SubgroupShuffleXorINTEL
SubgroupSize
SubgroupUniformControlFlowKHR
SubgroupVoteKHR
Subgroups are only supported in Metal 2.0 and up
SubgroupsPerWorkgroup
SubgroupsPerWorkgroupId
SubpassData
Switch
Switch statement is not structured
Swizzle
SwizzleInvocationsAMD
SwizzleInvocationsMaskedAMD
System/Library/Frameworks/AppKit.framework/Versions/C/AppKit
System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation
System/Library/Frameworks/CoreGraphics.framework/Versions/A/CoreGraphics
System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
System/Library/Frameworks/IOKit.framework/Versions/A/IOKit
System/Library/Frameworks/IOSurface.framework/Versions/A/IOSurface
System/Library/Frameworks/Metal.framework/Versions/A/Metal
System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore
T (&dst
T (&src
T NoI = n * i
T NoI2 = NoI * NoI
T elements[Num ? Num : 1
T k = T(1) - eta * eta * (T(1) - NoI2
T v = select(x, T(-1) - x, x < T(0
T@"<MTLDevice>",R
T@"NSArray",R
T@"NSScreen",R,N
T@"NSString",C
T@"NSString",R
T@"NSString",R,C
TASKPAYLOADWORKGROUPEXT
TAp\bRARATATAp\bRARATASBUBRA[ATAUDRAXAWARAp\bp\bp
TBD functionality
TBZARAp\bZARAp\bZARAp\bZARAp\bTARATBZARATATAp\bRATARATARATARATARATARATARATARATARATARATARATARATARB`fAWA
TCalibratedTimestampsEXT
TERMINATE_INVOCATION
TERMINATE_RAY
TEXTURE1D
TEXTURE1DARRAY
TEXTURE2D
TEXTURE2DARRAY
TEXTURE2DMS
TEXTURE2DMSARRAY
TEXTURE2DRECT
TEXTURE3D
TEXTUREBUFFER
TEXTURECUBE
TEXTURECUBEARRAY
TILEIMAGEEXT
TInvalidateMappedMemoryRanges
TLTextureMVK
TOpaqueCaptureAddress
TRN_ZERO
TYPE_NAME
T^{__CFString=},N
Taichi
Taichi Graphics
Taichi Graphics Taichi
TaskCountNV
TaskEXT
TaskNV
TaskPayloadWorkgroupEXT
Tc,R,GareBarycentricCoordsSupported
Tc,R,GareProgrammableSamplePositionsSupported
Tc,R,GareRasterOrderGroupsSupported
Tc,R,GisDepth24Stencil8PixelFormatSupported
Tc,R,GisHeadless
Tc,R,GisLowPower
Tc,R,GisRemovable
Tellusim
Tellusim Clay Shader Compiler
TerminateInvocation
TerminateOnFirstHitKHR
TerminateRayKHR
TerminateRayNV
TessCoord
TessLevelInner
TessLevelOuter
Tessellation
Tessellation control
Tessellation control shader requires per-patch output buffer, but there is no free slot to pass it
Tessellation control shader requires tessellation level output buffer, but there is no free slot to pass it
Tessellation evaluation
Tessellation levels are handled specially in MSL
Tessellation requires Metal 1.2
TessellationControl
TessellationEvaluation
TessellationPointSize
Test condition and select
TestEnable
TexCoord
TexCoordH3P
TexSubrez
Texel
Texel buffers are not supported on this device
TexelFetch
Texture
TextureBlockMatchQCOM
TextureBoxFilterQCOM
TextureMVK
TextureOffset does not support sampler2DArrayShadow
TextureSampleWeightedQCOM
Tffffff
The expected type is not a float type
The expected type is not a integer or float type
The expected type is not a integer type
The following extension must be enabled to use this feature
The given text is a nullptr
The required alignment of a linear texture of R32Uint format
The selector operand for OpSwitch must be the result of an instruction that generates an integer scalar
The value
The value of %s::components) (%s, %s, %s, %s), when applied to a VkImageView, requires full component swizzling to be enabled both at the time when the VkImageView is created and at the time any pipeline that uses that VkImageView is compiled. Full component swizzling can be enabled via the MVKConfiguration::fullImageViewSwizzle config parameter or MVK_CONFIG_FULL_IMAGE_VIEW_SWIZZLE environment variable
There is no entry point in the SPIR-V module
This MVKMTLBufferAllocator has been configured to dispense MVKMTLBufferRegions no larger than %lu bytes
This device does not support depth clamping
This method should only be called on dedicated allocations
This subgroup operation is only supported in Vulkan semantics
TileImageColorReadAccessEXT
TileImageDataEXT
TileImageDepthReadAccessEXT
TileImageEXT
TileImageStencilReadAccessEXT
TimeAMD
Timeout after %.3f milliseconds. Likely internal Metal compiler error
Tint Compiler
ToBuffer
ToBufferH
ToImage
ToImage2H
Too few args in Macro
Too many args in macro
TornadoVM
TornadoVM Beehive SPIRV Toolkit
TraceMotionNV
TraceNV
TraceRayKHR
TraceRayMotionNV
TransformFeedback
Transpose
Triangles
Tried passing a remapped subpassInput variable to a function. This will not work correctly because type-remapping information is lost. To workaround, please consider not passing the subpass input as a function parameter, or use in/out variables instead which do not need type remapping information
Tried to convert uint literal into int, but this made the literal negative
Trinary min/max functions require MSL 2.1
Trying to dynamically index into an array interface variable in tessellation. This is currently unsupported
Trying to dynamically index into an array interface variable using pull-model interpolation. This is currently unsupported
Trying to end a non-existing block
Trying to modify a non-existing block
Trying to remap multisampled image to variable, this is not possible
Type Id
Type for
Type parameters must match
TypeAccelerationStructureKHR
TypeAccelerationStructureNV
TypeArray
TypeAvcImeDualReferenceStreaminINTEL
TypeAvcImePayloadINTEL
TypeAvcImeResultDualReferenceStreamoutINTEL
TypeAvcImeResultINTEL
TypeAvcImeResultSingleReferenceStreamoutINTEL
TypeAvcImeSingleReferenceStreaminINTEL
TypeAvcMcePayloadINTEL
TypeAvcMceResultINTEL
TypeAvcRefPayloadINTEL
TypeAvcRefResultINTEL
TypeAvcSicPayloadINTEL
TypeAvcSicResultINTEL
TypeBool
TypeBufferSurfaceINTEL
TypeCooperativeMatrixKHR
TypeCooperativeMatrixNV
TypeDeviceEvent
TypeEvent
TypeFloat
TypeForwardPointer
TypeFromMTLTextureType
TypeFromVkImage
TypeFunction
TypeHitObjectNV
TypeImage
TypeInt
TypeMatrix
TypeNamedBarrier
TypeOpaque
TypePipe
TypePipeStorage
TypePointer
TypeQueue
TypeRayQueryKHR
TypeReserveId
TypeRuntimeArray
TypeSampledImage
TypeSampler
TypeStruct
TypeStructContinuedINTEL
TypeVector
TypeVmeImageINTEL
TypeVoid
Types in PhysicalStorageBufferEXT must be pointers
Types must match
Types, variables and constants
T{CGSize=dd},R,N
U16VEC2
U16VEC3
U16VEC4
U32VEC2
U32VEC3
U32VEC4
U64IMAGE1D
U64IMAGE1DARRAY
U64IMAGE2D
U64IMAGE2DARRAY
U64IMAGE2DMS
U64IMAGE2DMSARRAY
U64IMAGE2DRECT
U64IMAGE3D
U64IMAGEBUFFER
U64IMAGECUBE
U64IMAGECUBEARRAY
U64VEC2
U64VEC3
U64VEC4
U8VEC2
U8VEC3
U8VEC4
UATTACHMENTEXT
UAVARARA[ATA[ETA
UAddSatINTEL
UAverageINTEL
UAverageRoundedINTEL
UCHAR_MAX
UCOOPMATNV
UClamp
UConvert
UCountLeadingZerosINTEL
UCountTrailingZerosINTEL
UDotAccSat
UDotAccSatKHR
UDotKHR
UGreaterThan
UGreaterThanEqual
UIMAGE1D
UIMAGE1DARRAY
UIMAGE2D
UIMAGE2DARRAY
UIMAGE2DMS
UIMAGE2DMSARRAY
UIMAGE2DRECT
UIMAGE3D
UIMAGEBUFFER
UIMAGECUBE
UIMAGECUBEARRAY
UINT16CONSTANT
UINT16_T
UINT32CONSTANT
UINT32_T
UINT64CONSTANT
UINT64_T
UINT8_T
UINTCONSTANT
UINT_MAX
ULessThan
ULessThanEqual
UMax3AMD
UMid3AMD
UMin3AMD
UMul32x16INTEL
UMulExtended
UNIFORM
UNIMPLEMENTED
UNKNOWN ERROR
UResultKHR
USAMPLER1D
USAMPLER1DARRAY
USAMPLER2D
USAMPLER2DARRAY
USAMPLER2DMS
USAMPLER2DMSARRAY
USAMPLER2DRECT
USAMPLER3D
USAMPLERBUFFER
USAMPLERCUBE
USAMPLERCUBEARRAY
USHRT_MAX
USMStorageClassesINTEL
USUBPASSINPUT
USUBPASSINPUTMS
USubSatINTEL
UTEXTURE1D
UTEXTURE1DARRAY
UTEXTURE2D
UTEXTURE2DARRAY
UTEXTURE2DMS
UTEXTURE2DMSARRAY
UTEXTURE2DRECT
UTEXTURE3D
UTEXTUREBUFFER
UTEXTURECUBE
UTEXTURECUBEARRAY
UTF8String
UUIDString
UUUU)I
UUUU)ȉA
UUUUH
UUUUUU
UUUUUUU
UUUUUUUU
UUUUUUUUA
UUUUUUUUH
UUUUUUUUI
UUUUUUUUL
UUUUUUUUs+L
UUUUUUUUs3L
UUUUw&L
Uffff
Uffffff
Uint -> Float bitcast not supported on legacy ESSL
Unable to convert GLSL to SPIR-V:\n%s
Unable to convert SPIR-V to MSL:\n%s
Unable to parse built-ins
Unable to parse built-ins\n%s\n
Undefined behavior in SDiv, b == 0.\n
Undefined behavior in SMod, b == 0.\n
Undefined behavior in SRem, b == 0.\n
Undefined behavior in UDiv, b == 0.\n
Undefined behavior in UMod, b == 0.\n
Under Metal, vertex attribute binding strides must be aligned to %llu bytes
Unexpected argument buffer resource base type. When padding argument buffer elements, all descriptor set resources must be supplied with a base type by the app
Unexpected numeric literal type
Unexpected result code from ParseAndEncodeNumber
Unexpected scalar constant
Unexpected scalar in SpecConstantOp CompositeInsert
Unhandled number of color image planes
Uniform
Uniform block reflection
Uniform location overlaps across stages
Uniform location should be equal for same uniforms
Uniform reflection
UniformAndStorageBuffer16BitAccess
UniformAndStorageBuffer8BitAccess
UniformBufferArrayDynamicIndexing
UniformBufferArrayNonUniformIndexing
UniformBufferArrayNonUniformIndexingEXT
UniformConstant
UniformDecoration
UniformId
UniformMemory
UniformTexelBufferArrayDynamicIndexing
UniformTexelBufferArrayDynamicIndexingEXT
UniformTexelBufferArrayNonUniformIndexing
UniformTexelBufferArrayNonUniformIndexingEXT
Unimplemented block terminator
Unimplemented for this OpSpecConstantOp
Unimplemented spec constant op
UniversaH
Universal
Unknown
Unknown Error
Unknown Stage
Unknown Use BlitEncoder
Unknown Use Clear Attachments
Unknown Use CommandBuffer
Unknown Use ComputeEncoder
Unknown Use RenderEncoder
Unknown constant
Unknown glslang keyword
Unknown performance activity
Unknown storage class used for copying arrays
Unordered
UnormInt101010
UnormInt101010_2
UnormInt16
UnormInt24
UnormInt8
UnormShort555
UnormShort565
UnpackDouble2x32
UnpackHalf2x16
UnpackSnorm2x16
UnpackSnorm4x8
UnpackUnorm2x16
UnpackUnorm4x8
Unreachable
Unrecognized VkDescriptorType %d
Unrecognized bit-width of floating point type
Unrecognized type in type_to_packed_base_size
Unroll
Unsigned
Unsigned integers are not supported on legacy ESSL
Unsigned integers are not supported on legacy GLSL targets
Unsigned integers are not supported on legacy targets
UnsignedChar
UnsignedInt16
UnsignedInt32
UnsignedInt8
UnsignedIntRaw10EXT
UnsignedIntRaw12EXT
Unsized array of images is not supported in MSL
Unsized array of samplers is not supported in MSL
Unsized arrays of buffers are not supported in MSL
Unspecified
UnstructuredLoopControlsINTEL
Unsupported
Unsupported format
Unsupported legacy texture op
Unsupported result type for OpReadClockKHR opcode
Unsupported scope for OpReadClockKHR opcode
Unsupported shader stage: %d
Unsupported spec constant opcode for evaluation.\n
Unsupported type for matrix determinant
Unsupported type for matrix inverse
Unsupported workaround for arithmetic group operation
Unwind_Resume
UsageFromVkImageUsageFlags
Use of undeclared variable on a switch statement
UserSemantic
UserTypeGOOGLE
Using VkFormat
Using non-constant 0.0 bias() qualifier for sample_compare. This is not supported on macOS prior to MSL 2.3
Using non-constant 0.0 gradient() qualifier for sample_compare. This is not supported on macOS prior to MSL 2.3
UȈD\n(I
UȋH\b;J\bu
VARARARARARARARASMp
VARIABLE_TRACEPOINT
VARYING
VATAp\bp\bp
VAp\bRASJp
VERSION
VERTICAL_BAR
VEventStatus
VGroup
VKD3D Shader Compiler
VK_AMD_draw_indirect_count
VK_AMD_gpu_shader_half_float
VK_AMD_negative_viewport_height
VK_AMD_shader_image_load_store_lod
VK_AMD_shader_trinary_minmax
VK_COMPONENT_SWIZZLE_A
VK_COMPONENT_SWIZZLE_B
VK_COMPONENT_SWIZZLE_G
VK_COMPONENT_SWIZZLE_IDENTITY
VK_COMPONENT_SWIZZLE_ONE
VK_COMPONENT_SWIZZLE_R
VK_COMPONENT_SWIZZLE_ZERO
VK_ERROR_COMPRESSION_EXHAUSTED_EXT
VK_ERROR_DEVICE_LOST
VK_ERROR_EXTENSION_NOT_PRESENT
VK_ERROR_FEATURE_NOT_PRESENT
VK_ERROR_FORMAT_NOT_SUPPORTED
VK_ERROR_FRAGMENTATION
VK_ERROR_FRAGMENTED_POOL
VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR
VK_ERROR_INCOMPATIBLE_DISPLAY_KHR
VK_ERROR_INCOMPATIBLE_DRIVER
VK_ERROR_INITIALIZATION_FAILED
VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT
VK_ERROR_INVALID_EXTERNAL_HANDLE
VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS
VK_ERROR_INVALID_SHADER_NV
VK_ERROR_LAYER_NOT_PRESENT
VK_ERROR_MEMORY_MAP_FAILED
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
VK_ERROR_NOT_PERMITTED_KHR
VK_ERROR_OUT_OF_DATE_KHR
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_POOL_MEMORY
VK_ERROR_SURFACE_LOST_KHR
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_UNKNOWN
VK_ERROR_VALIDATION_FAILED_EXT
VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR
VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR
VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR
VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR
VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR
VK_EVENT_RESET
VK_EVENT_SET
VK_EXT_4444_formats
VK_EXT_buffer_device_address
VK_EXT_calibrated_timestamps
VK_EXT_debug_marker
VK_EXT_debug_report
VK_EXT_debug_utils
VK_EXT_descriptor_indexing
VK_EXT_extended_dynamic_state
VK_EXT_external_memory_host
VK_EXT_fragment_shader_interlock
VK_EXT_hdr_metadata
VK_EXT_host_query_reset
VK_EXT_image_robustness
VK_EXT_inline_uniform_block
VK_EXT_memory_budget
VK_EXT_metal_objects
VK_EXT_metal_surface
VK_EXT_pipeline_creation_cache_control
VK_EXT_pipeline_creation_feedback
VK_EXT_post_depth_coverage
VK_EXT_private_data
VK_EXT_robustness2
VK_EXT_sample_locations
VK_EXT_sampler_filter_minmax
VK_EXT_scalar_block_layout
VK_EXT_separate_stencil_usage
VK_EXT_shader_atomic_float
VK_EXT_shader_demote_to_helper_invocation
VK_EXT_shader_stencil_export
VK_EXT_shader_subgroup_ballot
VK_EXT_shader_subgroup_vote
VK_EXT_shader_viewport_index_layer
VK_EXT_subgroup_size_control
VK_EXT_surface_maintenance1
VK_EXT_swapchain_colorspace
VK_EXT_swapchain_maintenance1
VK_EXT_texel_buffer_alignment
VK_EXT_texture_compression_astc_hdr
VK_EXT_tooling_info
VK_EXT_vertex_attribute_divisor
VK_FORMAT_A1R5G5B5_UNORM_PACK16
VK_FORMAT_A2B10G10R10_SINT_PACK32
VK_FORMAT_A2B10G10R10_SNORM_PACK32
VK_FORMAT_A2B10G10R10_SSCALED_PACK32
VK_FORMAT_A2B10G10R10_UINT_PACK32
VK_FORMAT_A2B10G10R10_UNORM_PACK32
VK_FORMAT_A2B10G10R10_USCALED_PACK32
VK_FORMAT_A2R10G10B10_SINT_PACK32
VK_FORMAT_A2R10G10B10_SNORM_PACK32
VK_FORMAT_A2R10G10B10_SSCALED_PACK32
VK_FORMAT_A2R10G10B10_UINT_PACK32
VK_FORMAT_A2R10G10B10_UNORM_PACK32
VK_FORMAT_A2R10G10B10_USCALED_PACK32
VK_FORMAT_A4B4G4R4_UNORM_PACK16
VK_FORMAT_A4R4G4B4_UNORM_PACK16
VK_FORMAT_A8B8G8R8_SINT_PACK32
VK_FORMAT_A8B8G8R8_SNORM_PACK32
VK_FORMAT_A8B8G8R8_SRGB_PACK32
VK_FORMAT_A8B8G8R8_SSCALED_PACK32
VK_FORMAT_A8B8G8R8_UINT_PACK32
VK_FORMAT_A8B8G8R8_UNORM_PACK32
VK_FORMAT_A8B8G8R8_USCALED_PACK32
VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_10x10_SRGB_BLOCK
VK_FORMAT_ASTC_10x10_UNORM_BLOCK
VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_10x5_SRGB_BLOCK
VK_FORMAT_ASTC_10x5_UNORM_BLOCK
VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_10x6_SRGB_BLOCK
VK_FORMAT_ASTC_10x6_UNORM_BLOCK
VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_10x8_SRGB_BLOCK
VK_FORMAT_ASTC_10x8_UNORM_BLOCK
VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_12x10_SRGB_BLOCK
VK_FORMAT_ASTC_12x10_UNORM_BLOCK
VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_12x12_SRGB_BLOCK
VK_FORMAT_ASTC_12x12_UNORM_BLOCK
VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_4x4_SRGB_BLOCK
VK_FORMAT_ASTC_4x4_UNORM_BLOCK
VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_5x4_SRGB_BLOCK
VK_FORMAT_ASTC_5x4_UNORM_BLOCK
VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_5x5_SRGB_BLOCK
VK_FORMAT_ASTC_5x5_UNORM_BLOCK
VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_6x5_SRGB_BLOCK
VK_FORMAT_ASTC_6x5_UNORM_BLOCK
VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_6x6_SRGB_BLOCK
VK_FORMAT_ASTC_6x6_UNORM_BLOCK
VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_8x5_SRGB_BLOCK
VK_FORMAT_ASTC_8x5_UNORM_BLOCK
VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_8x6_SRGB_BLOCK
VK_FORMAT_ASTC_8x6_UNORM_BLOCK
VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT
VK_FORMAT_ASTC_8x8_SRGB_BLOCK
VK_FORMAT_ASTC_8x8_UNORM_BLOCK
VK_FORMAT_B10G11R11_UFLOAT_PACK32
VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16
VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16
VK_FORMAT_B16G16R16G16_422_UNORM
VK_FORMAT_B4G4R4A4_UNORM_PACK16
VK_FORMAT_B5G5R5A1_UNORM_PACK16
VK_FORMAT_B5G6R5_UNORM_PACK16
VK_FORMAT_B8G8R8A8_SINT
VK_FORMAT_B8G8R8A8_SNORM
VK_FORMAT_B8G8R8A8_SRGB
VK_FORMAT_B8G8R8A8_SSCALED
VK_FORMAT_B8G8R8A8_UINT
VK_FORMAT_B8G8R8A8_UNORM
VK_FORMAT_B8G8R8A8_USCALED
VK_FORMAT_B8G8R8G8_422_UNORM
VK_FORMAT_B8G8R8_SINT
VK_FORMAT_B8G8R8_SNORM
VK_FORMAT_B8G8R8_SRGB
VK_FORMAT_B8G8R8_SSCALED
VK_FORMAT_B8G8R8_UINT
VK_FORMAT_B8G8R8_UNORM
VK_FORMAT_B8G8R8_USCALED
VK_FORMAT_BC1_RGBA_SRGB_BLOCK
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
VK_FORMAT_BC1_RGB_SRGB_BLOCK
VK_FORMAT_BC1_RGB_UNORM_BLOCK
VK_FORMAT_BC2_SRGB_BLOCK
VK_FORMAT_BC2_UNORM_BLOCK
VK_FORMAT_BC3_SRGB_BLOCK
VK_FORMAT_BC3_UNORM_BLOCK
VK_FORMAT_BC4_SNORM_BLOCK
VK_FORMAT_BC4_UNORM_BLOCK
VK_FORMAT_BC5_SNORM_BLOCK
VK_FORMAT_BC5_UNORM_BLOCK
VK_FORMAT_BC6H_SFLOAT_BLOCK
VK_FORMAT_BC6H_UFLOAT_BLOCK
VK_FORMAT_BC7_SRGB_BLOCK
VK_FORMAT_BC7_UNORM_BLOCK
VK_FORMAT_D16_UNORM
VK_FORMAT_D16_UNORM_S8_UINT
VK_FORMAT_D24_UNORM_S8_UINT
VK_FORMAT_D32_SFLOAT
VK_FORMAT_D32_SFLOAT_S8_UINT
VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
VK_FORMAT_EAC_R11G11_SNORM_BLOCK
VK_FORMAT_EAC_R11G11_UNORM_BLOCK
VK_FORMAT_EAC_R11_SNORM_BLOCK
VK_FORMAT_EAC_R11_UNORM_BLOCK
VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16
VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16
VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16
VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16
VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16
VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16
VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16
VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16
VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16
VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16
VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16
VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16
VK_FORMAT_G16B16G16R16_422_UNORM
VK_FORMAT_G16_B16R16_2PLANE_420_UNORM
VK_FORMAT_G16_B16R16_2PLANE_422_UNORM
VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM
VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM
VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM
VK_FORMAT_G8B8G8R8_422_UNORM
VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
VK_FORMAT_G8_B8R8_2PLANE_422_UNORM
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM
VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM
VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG
VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG
VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG
VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG
VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG
VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG
VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG
VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG
VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16
VK_FORMAT_R10X6G10X6_UNORM_2PACK16
VK_FORMAT_R10X6_UNORM_PACK16
VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16
VK_FORMAT_R12X4G12X4_UNORM_2PACK16
VK_FORMAT_R12X4_UNORM_PACK16
VK_FORMAT_R16G16B16A16_SFLOAT
VK_FORMAT_R16G16B16A16_SINT
VK_FORMAT_R16G16B16A16_SNORM
VK_FORMAT_R16G16B16A16_SSCALED
VK_FORMAT_R16G16B16A16_UINT
VK_FORMAT_R16G16B16A16_UNORM
VK_FORMAT_R16G16B16A16_USCALED
VK_FORMAT_R16G16B16_SFLOAT
VK_FORMAT_R16G16B16_SINT
VK_FORMAT_R16G16B16_SNORM
VK_FORMAT_R16G16B16_SSCALED
VK_FORMAT_R16G16B16_UINT
VK_FORMAT_R16G16B16_UNORM
VK_FORMAT_R16G16B16_USCALED
VK_FORMAT_R16G16_SFLOAT
VK_FORMAT_R16G16_SINT
VK_FORMAT_R16G16_SNORM
VK_FORMAT_R16G16_SSCALED
VK_FORMAT_R16G16_UINT
VK_FORMAT_R16G16_UNORM
VK_FORMAT_R16G16_USCALED
VK_FORMAT_R16_SFLOAT
VK_FORMAT_R16_SINT
VK_FORMAT_R16_SNORM
VK_FORMAT_R16_SSCALED
VK_FORMAT_R16_UINT
VK_FORMAT_R16_UNORM
VK_FORMAT_R16_USCALED
VK_FORMAT_R32G32B32A32_SFLOAT
VK_FORMAT_R32G32B32A32_SINT
VK_FORMAT_R32G32B32A32_UINT
VK_FORMAT_R32G32B32_SFLOAT
VK_FORMAT_R32G32B32_SINT
VK_FORMAT_R32G32B32_UINT
VK_FORMAT_R32G32_SFLOAT
VK_FORMAT_R32G32_SINT
VK_FORMAT_R32G32_UINT
VK_FORMAT_R32_SFLOAT
VK_FORMAT_R32_SINT
VK_FORMAT_R32_UINT
VK_FORMAT_R4G4B4A4_UNORM_PACK16
VK_FORMAT_R4G4_UNORM_PACK8
VK_FORMAT_R5G5B5A1_UNORM_PACK16
VK_FORMAT_R5G6B5_UNORM_PACK16
VK_FORMAT_R64G64B64A64_SFLOAT
VK_FORMAT_R64G64B64A64_SINT
VK_FORMAT_R64G64B64A64_UINT
VK_FORMAT_R64G64B64_SFLOAT
VK_FORMAT_R64G64B64_SINT
VK_FORMAT_R64G64B64_UINT
VK_FORMAT_R64G64_SFLOAT
VK_FORMAT_R64G64_SINT
VK_FORMAT_R64G64_UINT
VK_FORMAT_R64_SFLOAT
VK_FORMAT_R64_SINT
VK_FORMAT_R64_UINT
VK_FORMAT_R8G8B8A8_SINT
VK_FORMAT_R8G8B8A8_SNORM
VK_FORMAT_R8G8B8A8_SRGB
VK_FORMAT_R8G8B8A8_SSCALED
VK_FORMAT_R8G8B8A8_UINT
VK_FORMAT_R8G8B8A8_UNORM
VK_FORMAT_R8G8B8A8_USCALED
VK_FORMAT_R8G8B8_SINT
VK_FORMAT_R8G8B8_SNORM
VK_FORMAT_R8G8B8_SRGB
VK_FORMAT_R8G8B8_SSCALED
VK_FORMAT_R8G8B8_UINT
VK_FORMAT_R8G8B8_UNORM
VK_FORMAT_R8G8B8_USCALED
VK_FORMAT_R8G8_SINT
VK_FORMAT_R8G8_SNORM
VK_FORMAT_R8G8_SRGB
VK_FORMAT_R8G8_SSCALED
VK_FORMAT_R8G8_UINT
VK_FORMAT_R8G8_UNORM
VK_FORMAT_R8G8_USCALED
VK_FORMAT_R8_SINT
VK_FORMAT_R8_SNORM
VK_FORMAT_R8_SRGB
VK_FORMAT_R8_SSCALED
VK_FORMAT_R8_UINT
VK_FORMAT_R8_UNORM
VK_FORMAT_R8_USCALED
VK_FORMAT_S8_UINT
VK_FORMAT_UNDEFINED
VK_FORMAT_X8_D24_UNORM_PACK32
VK_GOOGLE_display_timing
VK_IMG_format_pvrtc
VK_INCOMPLETE
VK_INTEL_shader_integer_functions2
VK_KHR_16bit_storage
VK_KHR_8bit_storage
VK_KHR_bind_memory2
VK_KHR_buffer_device_address
VK_KHR_copy_commands2
VK_KHR_create_renderpass2
VK_KHR_dedicated_allocation
VK_KHR_deferred_host_operations
VK_KHR_depth_stencil_resolve
VK_KHR_descriptor_update_template
VK_KHR_device_group
VK_KHR_device_group_creation
VK_KHR_draw_indirect_count
VK_KHR_driver_properties
VK_KHR_dynamic_rendering
VK_KHR_external_fence
VK_KHR_external_fence_capabilities
VK_KHR_external_memory
VK_KHR_external_memory_capabilities
VK_KHR_external_semaphore
VK_KHR_external_semaphore_capabilities
VK_KHR_fragment_shader_barycentric
VK_KHR_get_memory_requirements2
VK_KHR_get_physical_device_properties2
VK_KHR_get_surface_capabilities2
VK_KHR_image_format_list
VK_KHR_imageless_framebuffer
VK_KHR_incremental_present
VK_KHR_maintenance1
VK_KHR_maintenance2
VK_KHR_maintenance3
VK_KHR_maintenance4
VK_KHR_map_memory2
VK_KHR_multiview
VK_KHR_portability_subset
VK_KHR_push_descriptor
VK_KHR_relaxed_block_layout
VK_KHR_sH
VK_KHR_sampler_mirror_clamp_to_edge
VK_KHR_sampler_ycbcr_conversion
VK_KHR_separate_depth_stencil_layouts
VK_KHR_shader_atomic_int64
VK_KHR_shader_draw_parameters
VK_KHR_shader_float16_int8
VK_KHR_shader_float_controls
VK_KHR_shader_non_semantic_info
VK_KHR_shader_subgroup_extended_types
VK_KHR_spirv_1_4
VK_KHR_storage_buffer_storage_class
VK_KHR_surface
VK_KHR_swapchain
VK_KHR_swapchain_mutable_format
VK_KHR_synchronization2
VK_KHR_timeline_semaphore
VK_KHR_uniform_buffer_standard_layout
VK_KHR_variable_pointers
VK_KHR_vulkan_memory_model
VK_MVK_ios_surface
VK_MVK_macos_surface
VK_MVK_moltenvk
VK_NOT_READY
VK_NV_fragment_shader_barycentric
VK_NV_glsl_shader
VK_OPERATION_DEFERRED_KHR
VK_OPERATION_NOT_DEFERRED_KHR
VK_PIPELINE_COMPILE_REQUIRED
VK_QUERY_TYPE_TIMESTAMP
VK_SUBOPTIMAL_KHR
VK_SUCCESS
VK_THREAD_DONE_KHR
VK_THREAD_IDLE_KHR
VK_TIMEOUT
VK_UNKNOWN_VKComponentSwizzle
VK_UNKNOWN_VK_Result
VOLATILE
VUUUUUU
Value
Value is being defined a second time
Variable
VariableLengthArrayINTEL
VariablePointers
VariablePointers capability is not supported in GLSL
VariablePointersStorageBuffer
VaryingsPos
VaryingsPos varyings
VaryingsPosTex
VecTypeHint
Vector16
VectorAnyINTEL
VectorComputeCallableFunctionINTEL
VectorComputeFunctionINTEL
VectorComputeINTEL
VectorComputeVariableINTEL
VectorExtractDynamic
VectorInsertDynamic
VectorShuffle
VectorTimesMatrix
VectorTimesScalar
Version
Vertex
Vertex attribute type mismatch between host and shader
Vertex stage pipeline for tessellation
VertexIDH3P
VertexId
VertexIndex
VertexOrderCcw
VertexOrderCw
Vertical2Pixels
Vertical4Pixels
Vffff
ViewIndex
ViewIndex is handled specially outside fragment shaders
ViewType
ViewportIndex
ViewportIndex requires Metal 2.0
ViewportMaskNV
ViewportMaskPerViewNV
ViewportRelativeNV
Virtual
VkAttachmentLoadOp value %d is not supported
VkAttachmentStoreOp value %d is not supported
VkFormat
VkFrontFace
VkMacOSSurfaceCreateInfoMVK
VkPolygonMode value %d is not supported for render pipelines
VkPolygonMode value VK_POLYGON_MODE_POINT is not supported for render pipelines
VkPresentTimesInfoGOOGLE swapchainCount must match VkPresentInfo swapchainCount
VkPrimitiveTopology value %d is not supported for render pipelines
VkPrimitiveTopology value %d is not supported for rendering
VkResolveModeFlagBits value %d is not supported
VkShaderStage %x is not supported
VkSwapchainPresentFenceInfoEXT swapchainCount must match VkPresentInfo swapchainCount
VkSwapchainPresentModeInfoEXT swapchainCount must match VkPresentInfo swapchainCount
VmeImageINTEL
Volatile
VolatileTexel
VolatileTexelKHR
VolatileType
VscriptorSetLayoutSupport
Vulkan
Vulkan extension %s is not supported
Vulkan is not supported on this device. MoltenVK requires Metal, which is not available on this device
Vulkan layer %s is not supported
Vulkan semaphores using CPU callbacks upon GPU submission completion
Vulkan semaphores using MTLEvent
Vulkan semaphores using Metal implicit guarantees within a single queue
VulkanKHR
VulkanMemoryModel
VulkanMemoryModelDeviceScope
VulkanMemoryModelDeviceScopeKHR
VulkanMemoryModelKHR
Vv16@0:8
W3C WebGPU Group
W3C WebGPU Group WHLSL Shader Translator
WARAWARAWARAWARAWARA[ATBRBSBVATA
WARNING
WAp0VASAp
WHLSL Shader Translator
WORKGROUPCOHERENT
WRITEONLY
WSurfacePresentModesKHR
W\r\t@Z\r
WaitIdleH
WaitKernel
WaitWorkGroup
Warning, (version, profile) forced to be
WarpIDARM
WarpIDNV
WarpMaxIDARM
WarpsPerSMNV
WeightTextureQCOM
Wffffff
WindingFrom
Wine VKD3D Shader Compiler
WithCount
WithTemplate
WithTemplateKHR
WorkDim
WorkGroupID
WorkGroupSize
Workgroup
WorkgroupId
WorkgroupMemory
WorkgroupMemoryBarrier
WorkgroupMemoryBarrierWithGroupSync
WorkgroupMemoryExplicitLayout16BitAccessKHR
WorkgroupMemoryExplicitLayout8BitAccessKHR
WorkgroupMemoryExplicitLayoutKHR
WorkgroupSize
WorldRayDirectionKHR
WorldRayDirectionNV
WorldRayOriginKHR
WorldRayOriginNV
WorldToObjectKHR
WorldToObjectNV
Wrapper function that swizzles depth texture gathers
Wrapper function that swizzles texture gathers
Wrapper function that swizzles texture samples and fetches
WresentCapabilitiesKHR
Writable images are not allowed on Tier1 argument buffers on iOS
Write MSL to pipeline cache
WriteInvocationAMD
WriteOnly
WritePackedPrimitiveIndices4x8NV
WritePipe
WritePipeBlockingINTEL
X H;X
X H;X(t
X-LEGEND
X-LEGEND Mesa-IR/SPIR-V Translator
X@u#I
XCositedEvenYCositedEven
XCositedEvenYMidpoint
XImage
XL+s0H
XM+e0H
XMemory
XMidpointYCositedEven
XMidpointYMidpoint
XOR_ASSIGN
XOR_OP
XOpaqueCaptureAddress
XProcAddr
XSparseMemoryRequirements
X[A^A
Xderef
Xenia Emulator Microcode Translator
Xenia Xenia Emulator Microcode Translator
XfbBuffer
XfbStride
Y'CbCr conversion info
Y'CbCr conversion info, used to pass combined image-samplers
YDWBW0
YFenceStatus
YQueue
YcbcrConversion
Yffff
Yfffff
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_1
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_2
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_3
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_4
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_5
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_6
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_7
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_8
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE3$_9
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE4$_10
Z38spvOperandCanBeForwardDeclaredFunctionN3spv2OpEE4$_11
Z48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_12
Z48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_13
Z48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_14
Z48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_15
Z48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_16
Z48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_17
Z48spvDbgInfoExtOperandCanBeForwardDeclaredFunction19spv_ext_inst_type_tjE4$_18
ZARAp\bSAYAUASARA\\Ap\bRASAp
ZA`AARBTBTBp
ZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS1_10TPpContextERNS1_13TInputScannerEbRNS1_12TSymbolTableERNS1_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliPKcE
ZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS1_10TPpContextERNS1_13TInputScannerEbRNS1_12TSymbolTableERNS1_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliPKcSF_E
ZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS1_10TPpContextERNS1_13TInputScannerEbRNS1_12TSymbolTableERNS1_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliRKNS1_7TVectorINSt3__112basic_stringIcNSF_11char_traitsIcEENS1_14pool_allocatorIcEEEEEEE
ZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS1_10TPpContextERNS1_13TInputScannerEbRNS1_12TSymbolTableERNS1_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliiPKcE
ZN12_GLOBAL__N_115DoPreprocessingclERN7glslang17TParseContextBaseERNS1_10TPpContextERNS1_13TInputScannerEbRNS1_12TSymbolTableERNS1_13TIntermediateE20EShOptimizationLevel11EShMessagesEUliibiPKcE
ZN13MVKRenderPassC1EP9MVKDevicePK15VkRenderingInfoE3$_3
ZN13MVKRenderPassC1EP9MVKDevicePK15VkRenderingInfoE3$_4
ZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_28
ZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_29
ZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_30
ZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_31
ZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_32
ZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_33
ZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_34
ZN15MVK_spirv_cross11CompilerMSL19add_interface_blockEN3spv12StorageClassEbE4$_35
ZN15MVK_spirv_cross11CompilerMSL20add_tess_level_inputERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_RNS_12SPIRVariableEE4$_22
ZN15MVK_spirv_cross11CompilerMSL20add_tess_level_inputERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_RNS_12SPIRVariableEE4$_23
ZN15MVK_spirv_cross11CompilerMSL24entry_point_args_builtinERNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEE4$_46
ZN15MVK_spirv_cross11CompilerMSL24entry_point_args_builtinERNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEE4$_47
ZN15MVK_spirv_cross11CompilerMSL24entry_point_args_builtinERNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEE4$_48
ZN15MVK_spirv_cross11CompilerMSL26emit_local_masked_variableERKNS_12SPIRVariableEbE4$_24
ZN15MVK_spirv_cross11CompilerMSL26emit_local_masked_variableERKNS_12SPIRVariableEbE4$_25
ZN15MVK_spirv_cross11CompilerMSL26emit_local_masked_variableERKNS_12SPIRVariableEbE4$_26
ZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvE4$_51
ZN15MVK_spirv_cross11CompilerMSL37add_plain_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableERNS0_18InterfaceBlockMetaEE3$_8
ZN15MVK_spirv_cross11CompilerMSL37add_plain_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableERNS0_18InterfaceBlockMetaEE4$_10
ZN15MVK_spirv_cross11CompilerMSL37add_plain_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableERNS0_18InterfaceBlockMetaEE4$_11
ZN15MVK_spirv_cross11CompilerMSL37add_plain_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableERNS0_18InterfaceBlockMetaEE4$_12
ZN15MVK_spirv_cross11CompilerMSL41add_component_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_12SPIRVariableERKNS_8SPIRTypeERNS0_18InterfaceBlockMetaEE3$_6
ZN15MVK_spirv_cross11CompilerMSL41add_component_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_12SPIRVariableERKNS_8SPIRTypeERNS0_18InterfaceBlockMetaEE3$_7
ZN15MVK_spirv_cross11CompilerMSL41add_composite_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableERNS0_18InterfaceBlockMetaEE4$_13
ZN15MVK_spirv_cross11CompilerMSL41add_composite_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableERNS0_18InterfaceBlockMetaEE4$_14
ZN15MVK_spirv_cross11CompilerMSL44add_plain_member_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableESD_jRNS0_18InterfaceBlockMetaESB_SB_RjSI_E4$_17
ZN15MVK_spirv_cross11CompilerMSL44add_plain_member_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableESD_jRNS0_18InterfaceBlockMetaESB_SB_RjSI_E4$_18
ZN15MVK_spirv_cross11CompilerMSL44add_plain_member_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableESD_jRNS0_18InterfaceBlockMetaESB_SB_RjSI_E4$_19
ZN15MVK_spirv_cross11CompilerMSL44add_plain_member_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableESD_jRNS0_18InterfaceBlockMetaESB_SB_RjSI_E4$_20
ZN15MVK_spirv_cross11CompilerMSL48add_composite_member_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableESD_jRNS0_18InterfaceBlockMetaESB_SB_RjSI_E4$_15
ZN15MVK_spirv_cross11CompilerMSL48add_composite_member_variable_to_interface_blockEN3spv12StorageClassERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERNS_8SPIRTypeERNS_12SPIRVariableESD_jRNS0_18InterfaceBlockMetaESB_SB_RjSI_E4$_16
ZN15MVK_spirv_cross12CompilerGLSL32emit_output_variable_initializerERKNS_12SPIRVariableEE4$_21
ZN15MVK_spirv_cross12CompilerGLSL32emit_output_variable_initializerERKNS_12SPIRVariableEE4$_22
ZN15MVK_spirv_cross12CompilerGLSL32emit_output_variable_initializerERKNS_12SPIRVariableEE4$_23
ZN15MVK_spirv_cross12CompilerGLSL32emit_output_variable_initializerERKNS_12SPIRVariableEE4$_24
ZN15MVK_spirv_cross12CompilerGLSL50emit_inout_fragment_outputs_copy_to_subpass_inputsEvE4$_46
ZN16MVKRenderSubpassC1EP13MVKRenderPassPK15VkRenderingInfoE3$_0
ZN17MVKCommandEncoder14beginRenderingEP10MVKCommandPK15VkRenderingInfoE3$_0
ZN17MVKDescriptorPool21allocateDescriptorSetEP22MVKDescriptorSetLayoutjPP17VkDescriptorSet_TE3$_1
ZN17MVKPhysicalDevice10initLimitsEvE3$_0
ZN38MVKComputeResourcesCommandEncoderState10encodeImplEjE4$_21
ZN38MVKComputeResourcesCommandEncoderState10encodeImplEjE4$_22
ZN38MVKComputeResourcesCommandEncoderState10encodeImplEjE4$_23
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_1
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_2
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_3
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_4
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_5
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_6
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_7
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_8
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE3$_9
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_10
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_11
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_12
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_13
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_14
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_15
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_16
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_17
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_18
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_19
ZN39MVKGraphicsResourcesCommandEncoderState10encodeImplEjE4$_20
ZN3mvk11canReadFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
ZN3mvk12absolutePathERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
ZN3mvk12canWriteFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
ZN3mvk13pathExtensionERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
ZN3mvk17pathWithExtensionERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES6_bS6
ZN3mvk18MSLResourceBindingC1Ev
ZN3mvk18MSLResourceBindingC2Ev
ZN3mvk19SPIRVToMSLConverter7convertERNS_33SPIRVToMSLConversionConfigurationERNS_26SPIRVToMSLConversionResultEbbb
ZN3mvk19SPIRVToMSLConverter8setSPIRVEPKjm
ZN3mvk20GLSLToSPIRVConverter7convertE28MVKGLSLConversionShaderStageRNS_27GLSLToSPIRVConversionResultEbb
ZN3mvk20GLSLToSPIRVConverter7setGLSLEPKcm
ZN3mvk20GLSLToSPIRVConverter7setGLSLERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE
ZN3mvk20GLSLToSPIRVConverter8setGLSLsERKNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE
ZN3mvk26MSLShaderInterfaceVariableC1Ev
ZN3mvk26MSLShaderInterfaceVariableC2Ev
ZN3mvk27SPIRVToMSLConversionOptions15printMSLVersionEjb
ZN3mvk27SPIRVToMSLConversionOptionsC1Ev
ZN3mvk27SPIRVToMSLConversionOptionsC2Ev
ZN3mvk33SPIRVToMSLConversionConfiguration36markAllInterfaceVarsAndResourcesUsedEv
ZN3mvk33SPIRVToMSLConversionConfiguration9alignWithERKS0
ZN3mvk8fileNameERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEb
ZN3mvk8readFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERNS0_6vectorIcS5_EERS6
ZN3mvk9writeFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_6vectorIcS5_EERS6
ZN3spv7Builder14postProcessCFGEvE3$_2
ZN7glslang13TIntermediate10finalCheckER9TInfoSinkbE19TFinalLinkTraverser
ZN7glslang13TIntermediate21mergeBlockDefinitionsER9TInfoSinkPNS_13TIntermSymbolES4_PS0_E20TMergeBlockTraverser
ZN7glslang13TParseContext15findFunction400ERKNS_10TSourceLocERKNS_9TFunctionERbE3$_0
ZN7glslang13TParseContext15findFunction400ERKNS_10TSourceLocERKNS_9TFunctionERbE3$_1
ZN7glslang13TParseContext25findFunctionExplicitTypesERKNS_10TSourceLocERKNS_9TFunctionERbE3$_2
ZN7glslang13TParseContext25findFunctionExplicitTypesERKNS_10TSourceLocERKNS_9TFunctionERbE3$_3
ZN8spvtools15AssemblyContext26binaryEncodeNumericLiteralEPKc12spv_result_tRKNS_6IdTypeEP17spv_instruction_tE3$_0
ZN8spvtools18FriendlyNameMapper13GetNameMapperEvEUljE
ZN8spvtools30UseDiagnosticAsMessageConsumerEP13spv_context_tPP16spv_diagnostic_tE3$_0
ZNK3mvk17DescriptorBinding7matchesERKS0
ZNK3mvk18MSLResourceBinding7matchesERKS0
ZNK3mvk26MSLShaderInterfaceVariable7matchesERKS0
ZNK3mvk27SPIRVToMSLConversionOptions7matchesERKS0
ZNK3mvk33SPIRVToMSLConversionConfiguration14isResourceUsedEN3spv14ExecutionModelEjj
ZNK3mvk33SPIRVToMSLConversionConfiguration19countShaderInputsAtEj
ZNK3mvk33SPIRVToMSLConversionConfiguration24isShaderInputBuiltInUsedEN3spv7BuiltInE
ZNK3mvk33SPIRVToMSLConversionConfiguration25isShaderInputLocationUsedEj
ZNK3mvk33SPIRVToMSLConversionConfiguration26isShaderOutputLocationUsedEj
ZNK3mvk33SPIRVToMSLConversionConfiguration29stageSupportsVertexAttributesEv
ZNK3mvk33SPIRVToMSLConversionConfiguration7matchesERKS0
ZNK3spv8Function4dumpERNSt3__16vectorIjNS1_9allocatorIjEEEEEUlPKNS_5BlockENS_11ReachReasonEPS7_E
ZNKSt13runtime_error4whatEv
ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm
ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4findEcm
ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE5rfindEcm
ZNKSt3__119__shared_weak_count13__get_deleterERKSt9type_info
ZNKSt3__16locale9has_facetERNS0_2idE
ZNKSt3__16locale9use_facetERNS0_2idE
ZNKSt3__18ios_base6getlocEv
ZNKSt9exception4whatEv
ZNSt11logic_errorC2EPKc
ZNSt12length_errorD1Ev
ZNSt12out_of_rangeD1Ev
ZNSt13runtime_errorC2ERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
ZNSt13runtime_errorD2Ev
ZNSt20bad_array_new_lengthC1Ev
ZNSt20bad_array_new_lengthD1Ev
ZNSt3__112__next_primeEm
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE5eraseEmm
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKc
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKcm
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEmc
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcm
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEmc
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertENS_11__wrap_iterIPKcEEc
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKc
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6insertEmPKcm
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6resizeEmc
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_mmRKS4
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED1Ev
ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEaSERKS5
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEE3getEv
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEE4peekEv
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEE5seekgExNS_8ios_base7seekdirE
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEE5tellgEv
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEE5ungetEv
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEED0Ev
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEED1Ev
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEED2Ev
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERd
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERf
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERj
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERx
ZNSt3__113basic_istreamIcNS_11char_traitsIcEEErsERy
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE3putEc
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE5flushEv
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE5writeEPKcl
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE6sentryC1ERS3
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE6sentryD1Ev
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEED0Ev
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEED1Ev
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEED2Ev
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEb
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEd
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEf
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEj
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEm
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEs
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEt
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEx
ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEy
ZNSt3__114basic_iostreamIcNS_11char_traitsIcEEED0Ev
ZNSt3__114basic_iostreamIcNS_11char_traitsIcEEED1Ev
ZNSt3__114basic_iostreamIcNS_11char_traitsIcEEED2Ev
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE4syncEv
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE5imbueERKNS_6localeE
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE5uflowEv
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE6setbufEPcl
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE6xsgetnEPcl
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE6xsputnEPKcl
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE7seekoffExNS_8ios_base7seekdirEj
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE7seekposENS_4fposI11__mbstate_tEEj
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE8overflowEi
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE9pbackfailEi
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE9showmanycEv
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEE9underflowEv
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev
ZNSt3__115basic_streambufIcNS_11char_traitsIcEEED2Ev
ZNSt3__118condition_variable10notify_allEv
ZNSt3__118condition_variable15__do_timed_waitERNS_11unique_lockINS_5mutexEEENS_6chrono10time_pointINS5_12system_clockENS5_8durationIxNS_5ratioILl1ELl1000000000EEEEEEE
ZNSt3__118condition_variable4waitERNS_11unique_lockINS_5mutexEEE
ZNSt3__118condition_variableD1Ev
ZNSt3__119__shared_weak_count14__release_weakEv
ZNSt3__119__shared_weak_countD2Ev
ZNSt3__14cerrE
ZNSt3__14coutE
ZNSt3__15ctypeIcE2idE
ZNSt3__15mutex4lockEv
ZNSt3__15mutex6unlockEv
ZNSt3__15mutexD1Ev
ZNSt3__16__sortIRNS_6__lessIjjEEPjEEvT0_S5_T
ZNSt3__16chrono12steady_clock3nowEv
ZNSt3__16chrono12system_clock3nowEv
ZNSt3__16locale7classicEv
ZNSt3__16localeC1ERKS0
ZNSt3__16localeD1Ev
ZNSt3__16localeaSERKS0
ZNSt3__17codecvtIcc11__mbstate_tE2idE
ZNSt3__18ios_base33__set_badbit_and_consider_rethrowEv
ZNSt3__18ios_base4initEPv
ZNSt3__18ios_base5clearEj
ZNSt3__18ios_base5imbueERKNS_6localeE
ZNSt3__19basic_iosIcNS_11char_traitsIcEEED2Ev
ZNSt3__19to_stringEf
ZNSt3__19to_stringEi
ZNSt3__19to_stringEj
ZNSt3__19to_stringEm
ZNSt3__19to_stringEx
ZNSt3__19to_stringEy
ZNSt3__1plIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_12basic_stringIT_T0_T1_EEPKS6_RKS9
ZNSt8bad_castC1Ev
ZNSt8bad_castD1Ev
ZNSt9exceptionD2Ev
ZSt7nothrow
ZSt9terminatev
ZTIFNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjE
ZTINSt3__110__function6__baseIFNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjEEE
ZTINSt3__110__function6__baseIFbjEEE
ZTINSt3__110__function6__baseIFbmEEE
ZTINSt3__110__function6__baseIFivEEE
ZTINSt3__110__function6__baseIFviPKcEEE
ZTINSt3__110__function6__baseIFviPKcS3_EEE
ZTINSt3__110__function6__baseIFviiPKcEEE
ZTINSt3__110__function6__baseIFviibiPKcEEE
ZTINSt3__110__function6__baseIFvjEEE
ZTINSt3__110__function6__baseIFvvEEE
ZTINSt3__113basic_filebufIcNS_11char_traitsIcEEEE
ZTINSt3__113basic_istreamIcNS_11char_traitsIcEEEE
ZTINSt3__113basic_ostreamIcNS_11char_traitsIcEEEE
ZTINSt3__114basic_ifstreamIcNS_11char_traitsIcEEEE
ZTINSt3__114basic_iostreamIcNS_11char_traitsIcEEEE
ZTINSt3__114basic_ofstreamIcNS_11char_traitsIcEEEE
ZTINSt3__115basic_streambufIcNS_11char_traitsIcEEEE
ZTINSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ZTINSt3__117bad_function_callE
ZTINSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ZTINSt3__119__shared_weak_countE
ZTINSt3__119basic_istringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ZTINSt3__119basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ZTIPFNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjE
ZTISt12length_error
ZTISt12out_of_range
ZTISt13runtime_error
ZTISt20bad_array_new_length
ZTISt8bad_cast
ZTISt9exception
ZTSFNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjE
ZTSNSt3__110__function6__baseIFNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjEEE
ZTSNSt3__110__function6__baseIFbjEEE
ZTSNSt3__110__function6__baseIFbmEEE
ZTSNSt3__110__function6__baseIFivEEE
ZTSNSt3__110__function6__baseIFviPKcEEE
ZTSNSt3__110__function6__baseIFviPKcS3_EEE
ZTSNSt3__110__function6__baseIFviiPKcEEE
ZTSNSt3__110__function6__baseIFviibiPKcEEE
ZTSNSt3__110__function6__baseIFvjEEE
ZTSNSt3__110__function6__baseIFvvEEE
ZTSNSt3__113basic_filebufIcNS_11char_traitsIcEEEE
ZTSNSt3__114basic_ifstreamIcNS_11char_traitsIcEEEE
ZTSNSt3__114basic_ofstreamIcNS_11char_traitsIcEEEE
ZTSNSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ZTSNSt3__117bad_function_callE
ZTSNSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ZTSNSt3__119basic_istringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ZTSNSt3__119basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ZTSPFNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEjE
ZTVN10__cxxabiv117__class_type_infoE
ZTVN10__cxxabiv119__pointer_type_infoE
ZTVN10__cxxabiv120__function_type_infoE
ZTVN10__cxxabiv120__si_class_type_infoE
ZTVN10__cxxabiv121__vmi_class_type_infoE
ZTVNSt3__113basic_istreamIcNS_11char_traitsIcEEEE
ZTVNSt3__113basic_ostreamIcNS_11char_traitsIcEEEE
ZTVSt12length_error
ZTVSt12out_of_range
ZThn16_NSt3__114basic_iostreamIcNS_11char_traitsIcEEED0Ev
ZThn16_NSt3__114basic_iostreamIcNS_11char_traitsIcEEED1Ev
ZTv0_n24_NSt3__113basic_istreamIcNS_11char_traitsIcEEED0Ev
ZTv0_n24_NSt3__113basic_istreamIcNS_11char_traitsIcEEED1Ev
ZTv0_n24_NSt3__113basic_ostreamIcNS_11char_traitsIcEEED0Ev
ZTv0_n24_NSt3__113basic_ostreamIcNS_11char_traitsIcEEED1Ev
ZTv0_n24_NSt3__114basic_iostreamIcNS_11char_traitsIcEEED0Ev
ZTv0_n24_NSt3__114basic_iostreamIcNS_11char_traitsIcEEED1Ev
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_52clEjRNS_12SPIRVariableEEUlvE
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_52clEjRNS_12SPIRVariableEEUlvE0
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE0
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE1
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE10
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE11
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE12
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE13
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE14
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE15
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE16
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE17
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE18
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE19
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE2
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE20
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE21
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE22
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE23
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE24
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE25
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE26
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE27
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE28
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE29
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE3
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE30
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE4
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE5
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE6
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE7
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE8
ZZN15MVK_spirv_cross11CompilerMSL28fix_up_shader_inputs_outputsEvENK4$_53clEjRNS_12SPIRVariableEEUlvE9
ZZN15MVK_spirv_cross11CompilerMSL39extract_global_variables_from_functionsEvENK3$_3clEjRNS_12SPIRVariableEEUlvE
Z\ftIH
ZdaPv
ZdlPv
ZeroExtend
Zffff
ZjKᅕGᅗNᒇᒒjtᒌᒒdj
ZnstanceProcAddr
ZnwmRKSt9nothrow_t
ZubresourceLayout
a0__function6__baseIF
a6MSLShaderInterfaceVariableC
aFormats
aH9G\btAI
aI9G\bD
aI9G\bH
aI9G\btC
aL9t\a(u
aRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE
aToolProperties
a\b\t \b\b\t
a\t\a0\b\t
a`pP@P@P
abcdef
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789
abort
absdiff
absoluteDifference
absolutePathERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
acOSSurfaceMVK
accelerationStructureEXT
accelerationStructureNV
accelerationStructureNV can only be used in uniform variables or function parameters
accelerationStructureSizesWithDescriptor
acceleration_structures
accept
access
access qualifier
access::read
access::read_write
access::write
accumulateOcclusionQueryResults
acheDataH
achmentsH
ackend does not support native pointers and does not support OpPtrAccessChain
acospi
active
activeProcessorCount
add second child into first child
addCarry
addCompletedHandler
addInvocations
addInvocationsAMD
addInvocationsExclusiveScan
addInvocationsExclusiveScanAMD
addInvocationsExclusiveScanAMD(ivec2);ivec3 addInvocationsExclusiveScanAMD(ivec3);ivec4 addInvocationsExclusiveScanAMD(ivec4);uint  addInvocationsExclusiveScanAMD(uint);uvec2 addInvocationsExclusiveScanAMD(uvec2);uvec3 addInvocationsExclusiveScanAMD(uvec3);uvec4 addInvocationsExclusiveScanAMD(uvec4);double  addInvocationsExclusiveScanAMD(double);dvec2   addInvocationsExclusiveScanAMD(dvec2);dvec3   addInvocationsExclusiveScanAMD(dvec3);dvec4   addInvocationsExclusiveScanAMD(dvec4);int64_t addInvocationsExclusiveScanAMD(int64_t);i64vec2 addInvocationsExclusiveScanAMD(i64vec2);i64vec3 addInvocationsExclusiveScanAMD(i64vec3);i64vec4 addInvocationsExclusiveScanAMD(i64vec4);uint64_t addInvocationsExclusiveScanAMD(uint64_t);u64vec2  addInvocationsExclusiveScanAMD(u64vec2);u64vec3  addInvocationsExclusiveScanAMD(u64vec3);u64vec4  addInvocationsExclusiveScanAMD(u64vec4);float16_t addInvocationsExclusiveScanAMD(float16_t);f16vec2   addInvocationsExclusiveScanAMD(f16vec2);f16vec3   addInvocationsExclusiveScanAMD(f16vec3);f16vec4   addInvocationsExclusiveScanAMD(f16vec4);int16_t addInvocationsExclusiveScanAMD(int16_t);i16vec2 addInvocationsExclusiveScanAMD(i16vec2);i16vec3 addInvocationsExclusiveScanAMD(i16vec3);i16vec4 addInvocationsExclusiveScanAMD(i16vec4);uint16_t addInvocationsExclusiveScanAMD(uint16_t);u16vec2  addInvocationsExclusiveScanAMD(u16vec2);u16vec3  addInvocationsExclusiveScanAMD(u16vec3);u16vec4  addInvocationsExclusiveScanAMD(u16vec4);float minInvocationsNonUniformAMD(float);vec2  minInvocationsNonUniformAMD(vec2);vec3  minInvocationsNonUniformAMD(vec3);vec4  minInvocationsNonUniformAMD(vec4);int   minInvocationsNonUniformAMD(int);ivec2 minInvocationsNonUniformAMD(ivec2);ivec3 minInvocationsNonUniformAMD(ivec3);ivec4 minInvocationsNonUniformAMD(ivec4);uint  minInvocationsNonUniformAMD(uint);uvec2 minInvocationsNonUniformAMD(uvec2);uvec3 minInvocationsNonUniformAMD(uvec3);uvec4 minInvocationsNonUniformAMD(uvec4);double minInvocationsNonUniformAMD(double);dvec2  minInvocationsNonUniformAMD(dvec2);dvec3  minInvocationsNonUniformAMD(dvec3);dvec4  minInvocationsNonUniformAMD(dvec4);int64_t minInvocationsNonUniformAMD(int64_t);i64vec2 minInvocationsNonUniformAMD(i64vec2);i64vec3 minInvocationsNonUniformAMD(i64vec3);i64vec4 minInvocationsNonUniformAMD(i64vec4);uint64_t minInvocationsNonUniformAMD(uint64_t);u64vec2  minInvocationsNonUniformAMD(u64vec2);u64vec3  minInvocationsNonUniformAMD(u64vec3);u64vec4  minInvocationsNonUniformAMD(u64vec4);float16_t minInvocationsNonUniformAMD(float16_t);f16vec2   minInvocationsNonUniformAMD(f16vec2);f16vec3   minInvocationsNonUniformAMD(f16vec3);f16vec4   minInvocationsNonUniformAMD(f16vec4);int16_t minInvocationsNonUniformAMD(int16_t);i16vec2 minInvocationsNonUniformAMD(i16vec2);i16vec3 minInvocationsNonUniformAMD(i16vec3);i16vec4 minInvocationsNonUniformAMD(i16vec4);uint16_t minInvocationsNonUniformAMD(uint16_t);u16vec2  minInvocationsNonUniformAMD(u16vec2);u16vec3  minInvocationsNonUniformAMD(u16vec3);u16vec4  minInvocationsNonUniformAMD(u16vec4);float minInvocationsInclusiveScanNonUniformAMD(float);vec2  minInvocationsInclusiveScanNonUniformAMD(vec2);vec3  minInvocationsInclusiveScanNonUniformAMD(vec3);vec4  minInvocationsInclusiveScanNonUniformAMD(vec4);int   minInvocationsInclusiveScanNonUniformAMD(int);ivec2 minInvocationsInclusiveScanNonUniformAMD(ivec2);ivec3 minInvocationsInclusiveScanNonUniformAMD(ivec3);ivec4 minInvocationsInclusiveScanNonUniformAMD(ivec4);uint  minInvocationsInclusiveScanNonUniformAMD(uint);uvec2 minInvocationsInclusiveScanNonUniformAMD(uvec2);uvec3 minInvocationsInclusiveScanNonUniformAMD(uvec3);uvec4 minInvocationsInclusiveScanNonUniformAMD(uvec4);double minInvocationsInclusiveScanNonUniformAMD(double);dvec2  minInvocationsInclusiveScanNonUniformAMD(dvec2);dvec3  minInvocationsInclusiveScanNonUniformAMD(dvec3);dvec4  minInvocationsInclusiveScanNonUniformAMD(dvec4);int64_t minInvocationsInclusiveScanNonUniformAMD(int64_t);i64vec2 minInvocationsInclusiveScanNonUniformAMD(i64vec2);i64vec3 minInvocationsInclusiveScanNonUniformAMD(i64vec3);i64vec4 minInvoca
addInvocationsExclusiveScanNonUniform
addInvocationsExclusiveScanNonUniformAMD
addInvocationsInclusiveScan
addInvocationsInclusiveScanAMD
addInvocationsInclusiveScanNonUniform
addInvocationsInclusiveScanNonUniformAMD
addInvocationsNonUniform
addInvocationsNonUniformAMD
addObject
addObserver:forKeyPath:options:context
addPresentedHandler
addSaturate
addScheduledHandler
additive_expression
address::clamp_to_border
address::clamp_to_edge
address::clamp_to_zero
address::mirrored_repeat
address::repeat
addressing model
addsat
adj[0][0] =  m[1][1
adj[0][0] =  spvDet2x2(m[1][1], m[1][2], m[2][1], m[2][2
adj[0][1] = -spvDet2x2(m[0][1], m[0][2], m[2][1], m[2][2
adj[0][2] =  spvDet2x2(m[0][1], m[0][2], m[1][1], m[1][2
adj[1][0] = -spvDet2x2(m[1][0], m[1][2], m[2][0], m[2][2
adj[1][1] =  m[0][0
adj[1][1] =  spvDet2x2(m[0][0], m[0][2], m[2][0], m[2][2
adj[1][2] = -spvDet2x2(m[0][0], m[0][2], m[1][0], m[1][2
adj[2][0] =  spvDet2x2(m[1][0], m[1][1], m[2][0], m[2][1
adj[2][1] = -spvDet2x2(m[0][0], m[0][1], m[2][0], m[2][1
adj[2][2] =  spvDet2x2(m[0][0], m[0][1], m[1][0], m[1][1
adjoint and dividing by the determinant. The contents of the matrix are changed
ae_id
affected
affffff
ageModeFromVkMemoryPropertyFlags
age_sizeH
agment_sI
aitEvents
ajorH\t
aligA3
align
all default precisions are highp; use precision statements to quiet warning, e.g.:\n         "precision mediump int; precision highp float
all redeclarations must use the same depth layout on
all redeclarations must use the same stencil layout on
all stride settings must match for xfb buffer
allInvocations
allInvocationsARB
allInvocationsEqual
allInvocationsEqualARB
allValues
ambiguous best function under implicit type conversion
ambiguous function signature match: multiple signatures match under implicit type conversion
ampleCountFlagBitsFromSampleCount
ampleCountFromVkSampleCountFlagBits
ampler
and -= on a buffer reference
and second child into first child
and_expression
anonymous member
any-hit
anyInvocation
anyInvocationARB
apMemory
apMemoryH
appendFormat
appendLineMVK
appendString
apppppp
arameterH
arc cosine
arc hyp. cosine
arc hyp. sine
arc hyp. tangent
arc sine
arc tangent
arc4random
areBarycentricCoordsSupported
areProgrammableSamplePositionsSupported
areRasterOrderGroupsSupported
argument cannot drop memory qualifier when passed to formal parameter
argument must be a power of 2
argument must be at least 1
argument must be compile-time constant
argument must be qualified as __explicitInterpAMD in
argumentBuffersSupport
argumentDescriptor
ariablesH
array
array argument must be sized
array assignment
array comparison
array constructor argument not correct type to construct array element
array constructor must have at least one argument
array constructor needs one argument per array element
array in function return type
array index out of range '%d
array initializer
array initializer must be sized
array length
array must be declared with a size before using this method
array must be explicitly sized
array must be redeclared with a size before being indexed with a variable
array must be sized by a redeclaration or layout qualifier before being indexed with a variable
array must first be sized by a redeclaration or layout qualifier
array size
array size required
array variable name expected
array-of-array of block
arrayLength
arrayStride %d
arrayWithCapacity
array_copy
array_size_is_literal
array_specifier
array_stH
array_stride
arrayed constructor
arrayed type
arrays of arrays
arrierScopeFromVkAccessFlags
asEnableH
as_type
as_type<uint>(half2
as_type<ulong
asinpi
assert
assign
assignment_expression
assignment_operator
assuming binding count of one for compile-time checking of binding numbers for unsized array
astPresentationTimingGOOGLE
atan2
atan2pi
atanpi
atchBaseH
ateEventH
ateFenceH
ateImageH
atomic
atomic counter types
atomic counters can only be highp
atomic counters offset should align based on 4
atomic counters sharing the same offset
atomic>H
atomicAdH
atomicAdd
atomicAnd
atomicCoH3\bH
atomicCompSwap
atomicCounter
atomicCounterAdd
atomicCounterAddARB
atomicCounterAnd
atomicCounterAndARB
atomicCounterCompSwap
atomicCounterCompSwapARB
atomicCounterDecrement
atomicCounterExchange
atomicCounterExchangeARB
atomicCounterIncrement
atomicCounterMax
atomicCounterMaxARB
atomicCounterMin
atomicCounterMinARB
atomicCounterOr
atomicCounterOrARB
atomicCounterSubtract
atomicCounterSubtractARB
atomicCounterXor
atomicCounterXorARB
atomicExchange
atomicLoad
atomicLoad(coherent volatile in  int64_t, int, int, int);float16_t atomicLoad(coherent volatile in float16_t, int, int, int);   float atomicLoad(coherent volatile in float, int, int, int);  double atomicLoad(coherent volatile in double, int, int, int);void atomicStore(coherent volatile out uint64_t, uint64_t, int, int, int);void atomicStore(coherent volatile out  int64_t,  int64_t, int, int, int);void atomicStore(coherent volatile out float16_t, float16_t, int, int, int);void atomicStore(coherent volatile out float, float, int, int, int);void atomicStore(coherent volatile out double, double, int, int, int);\n
atomicMax
atomicMin
atomicOr
atomicStore
atomicXor
atomic_compare_exchange_weak_explicit
atomic_exchange_explicit
atomic_fetch_add_explicit
atomic_fetch_and_explicit
atomic_fetch_max_explicit
atomic_fetch_min_explicit
atomic_fetch_or_explicit
atomic_fetch_sub_explicit
atomic_fetch_xor_explicit
atomic_load_explicit
atomic_store_explicit
atomic_uint
atomic_uint binding is too large
atomic_uint binding is too large; see gl_MaxAtomicCounterBindings
atomic_uints can only be used in uniform variables or function parameters
attachment index is too large
attachmentEXT
attachmentEXT input
attriH
attribute
attribute does not apply to a function
attribute does not apply to a loop
attribute does not apply to a selection
attribute does not apply to a switch
attribute requires a SPIR-V 1.4 target-env
attribute vec4  gl_Color;attribute vec4  gl_SecondaryColor;attribute vec3  gl_Normal;attribute vec4  gl_Vertex;attribute vec4  gl_MultiTexCoord0;attribute vec4  gl_MultiTexCoord1;attribute vec4  gl_MultiTexCoord2;attribute vec4  gl_MultiTexCoord3;attribute vec4  gl_MultiTexCoord4;attribute vec4  gl_MultiTexCoord5;attribute vec4  gl_MultiTexCoord6;attribute vec4  gl_MultiTexCoord7;attribute float gl_FogCoord;\n
attribute with arguments not recognized, skipping
attribute_list
attributes
aurface
auto-map-bindings
auto-map-locations
autorelease
average
averageRounded
a}=ffff
b Oct\b(Lc
b$\b*\b0\b6\b<\bB\bH\bN\bT\bZ\b`\bf\bl\br\bx\b~\b
b33SPIRVToMSLConversionConfiguration
bA;E\buUL
bA;E\bu\vA
bA;G\bu
bH5ch
bH5od
bH5oordH\t
bH5tiesH\t
bH5ttenH\t
bH9H0v
bH9H\bH
bH;H\bt
bI;]\bt
bI;]\bu
bIcD$,H
bL+ I
bL3b\bH
bM;nXt
bPpXpPpPpX
bPresentModesKHR
bSAp\bSAp\bSAp\bSAp\bZAp\bRAp\bZARA`,Ap\b[BUARA`#Ap\bRARA
bSupportKHR
bZAp\bRAp\b`DAWAZAp\bRAZARARASCp\bRBRAZAp\bRAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp
b[A^A
b\a@a\b
b\b\b5
b\bp$\b
b\nu9I
b\rt+fff
b\rt|I
b\ru&I
b\vu$I
bad argument
bad character in float exponent
bad digit in hexadecimal literal
bad expression
bad profile name; use es, core, or compatibility
bad tokI
bad token
bad tokens following profile -- expected newline
ballot
ballot &= mask
ballotARB
barrier
barycentricCoordsSupported
barycentric_coord, center_no_perspective
barycentric_coord, center_perspective
base, u8vec3, int8_t, int8_t);u8vec4 bitfieldInsert(u8vec4 base, u8vec4, int8_t, int8_t);  int8_t bitCount(  int8_t);i8vec2 bitCount(i8vec2);i8vec3 bitCount(i8vec3);i8vec4 bitCount(i8vec4);  int8_t bitCount( uint8_t);i8vec2 bitCount(u8vec2);i8vec3 bitCount(u8vec3);i8vec4 bitCount(u8vec4);  int8_t findLSB(  int8_t);i8vec2 findLSB(i8vec2);i8vec3 findLSB(i8vec3);i8vec4 findLSB(i8vec4);  int8_t findLSB( uint8_t);i8vec2 findLSB(u8vec2);i8vec3 findLSB(u8vec3);i8vec4 findLSB(u8vec4);  int8_t findMSB(  int8_t);i8vec2 findMSB(i8vec2);i8vec3 findMSB(i8vec3);i8vec4 findMSB(i8vec4);  int8_t findMSB( uint8_t);i8vec2 findMSB(u8vec2);i8vec3 findMSB(u8vec3);i8vec4 findMSB(u8vec4);int16_t abs(int16_t);i16vec2 abs(i16vec2);i16vec3 abs(i16vec3);i16vec4 abs(i16vec4);int16_t sign(int16_t);i16vec2 sign(i16vec2);i16vec3 sign(i16vec3);i16vec4 sign(i16vec4);int16_t min(int16_t x, int16_t y);i16vec2 min(i16vec2 x, int16_t y);i16vec3 min(i16vec3 x, int16_t y);i16vec4 min(i16vec4 x, int16_t y);i16vec2 min(i16vec2 x, i16vec2 y);i16vec3 min(i16vec3 x, i16vec3 y);i16vec4 min(i16vec4 x, i16vec4 y);uint16_t min(uint16_t x, uint16_t y);u16vec2 min(u16vec2 x, uint16_t y);u16vec3 min(u16vec3 x, uint16_t y);u16vec4 min(u16vec4 x, uint16_t y);u16vec2 min(u16vec2 x, u16vec2 y);u16vec3 min(u16vec3 x, u16vec3 y);u16vec4 min(u16vec4 x, u16vec4 y);int16_t max(int16_t x, int16_t y);i16vec2 max(i16vec2 x, int16_t y);i16vec3 max(i16vec3 x, int16_t y);i16vec4 max(i16vec4 x, int16_t y);i16vec2 max(i16vec2 x, i16vec2 y);i16vec3 max(i16vec3 x, i16vec3 y);i16vec4 max(i16vec4 x, i16vec4 y);uint16_t max(uint16_t x, uint16_t y);u16vec2 max(u16vec2 x, uint16_t y);u16vec3 max(u16vec3 x, uint16_t y);u16vec4 max(u16vec4 x, uint16_t y);u16vec2 max(u16vec2 x, u16vec2 y);u16vec3 max(u16vec3 x, u16vec3 y);u16vec4 max(u16vec4 x, u16vec4 y);int16_t    clamp(int16_t x, int16_t minVal, int16_t maxVal);i16vec2  clamp(i16vec2  x, int16_t minVal, int16_t maxVal);i16vec3  clamp(i16vec3  x, int16_t minVal, int16_t maxVal);i16vec4  clamp(i16vec4  x, int16_t minVal, int16_t maxVal);i16vec2  clamp(i16vec2  x, i16vec2  minVal, i16vec2  maxVal);i16vec3  clamp(i16vec3  x, i16vec3  minVal, i16vec3  maxVal);i16vec4  clamp(i16vec4  x, i16vec4  minVal, i16vec4  maxVal);uint16_t   clamp(uint16_t x, uint16_t minVal, uint16_t maxVal);u16vec2  clamp(u16vec2  x, uint16_t minVal, uint16_t maxVal);u16vec3  clamp(u16vec3  x, uint16_t minVal, uint16_t maxVal);u16vec4  clamp(u16vec4  x, uint16_t minVal, uint16_t maxVal);u16vec2  clamp(u16vec2  x, u16vec2  minVal, u16vec2  maxVal);u16vec3  clamp(u16vec3  x, u16vec3  minVal, u16vec3  maxVal);u16vec4  clamp(u16vec4  x, u16vec4  minVal, u16vec4  maxVal);int16_t  mix(int16_t,  int16_t,  bool);i16vec2  mix(i16vec2,  i16vec2,  bvec2);i16vec3  mix(i16vec3,  i16vec3,  bvec3);i16vec4  mix(i16vec4,  i16vec4,  bvec4);uint16_t mix(uint16_t, uint16_t, bool);u16vec2  mix(u16vec2,  u16vec2,  bvec2);u16vec3  mix(u16vec3,  u16vec3,  bvec3);u16vec4  mix(u16vec4,  u16vec4,  bvec4);float16_t frexp(float16_t, out int16_t);f16vec2   frexp(f16vec2,   out i16vec2);f16vec3   frexp(f16vec3,   out i16vec3);f16vec4   frexp(f16vec4,   out i16vec4);float16_t ldexp(float16_t, int16_t);f16vec2   ldexp(f16vec2,   i16vec2);f16vec3   ldexp(f16vec3,   i16vec3);f16vec4   ldexp(f16vec4,   i16vec4);int16_t halfBitsToInt16(float16_t);i16vec2 halfBitsToInt16(f16vec2);i16vec3 halhBitsToInt16(f16vec3);i16vec4 halfBitsToInt16(f16vec4);uint16_t halfBitsToUint16(float16_t);u16vec2  halfBitsToUint16(f16vec2);u16vec3  halfBitsToUint16(f16vec3);u16vec4  halfBitsToUint16(f16vec4);int16_t float16BitsToInt16(float16_t);i16vec2 float16BitsToInt16(f16vec2);i16vec3 float16BitsToInt16(f16vec3);i16vec4 float16BitsToInt16(f16vec4);uint16_t float16BitsToUint16(float16_t);u16vec2  float16BitsToUint16(f16vec2);u16vec3  float16BitsToUint16(f16vec3);u16vec4  float16BitsToUint16(f16vec4);float16_t int16BitsToFloat16(int16_t);f16vec2   int16BitsToFloat16(i16vec2);f16vec3   int16BitsToFloat16(i16vec3);f16vec4   int16BitsToFloat16(i16vec4);float16_t uint16BitsToFloat16(uint16_t);f16vec2   uint16BitsToFloat16(u16vec2);f16vec3
base_insI
base_instance
base_verI
base_vertex
basic_string
because
beginInvocationInterlockARB
beginInvocationInterlockARB() cannot be placed after a return from main
beginInvocationInterlockARB() cannot be placed within flow control
beginInvocationInterlockARB() must be called before endInvocationInterlockARB
beginInvocationInterlockARB() must be in a fragment shader
beginInvocationInterlockARB() must be in main
beginInvocationInterlockARB() must only be called once
beginScope
behavior for extension not specified
behavior not supported
bffff
bffffff
bhp\bpX
biPKcEEE
bices
binding
binding is too large
bindless_image
bindless_sampler
bit float literals
bit integer literals
bit shift left
bit shift right
bit-shift left assign
bit-shift right assign
bitCount
bitFieldReverse
bitfieldExtract
bitfieldInsert
bitfieldReverse
bitselect
bitwise and
bitwise exclusive or
bitwise inclusive or
bitwise not
bitwise-and assign
bitwise-or assign
bitwise-xor assign
ble fileK
blend equation
blend_support
blend_support_all_equations
blend_support_colorburn
blend_support_colordodge
blend_support_darken
blend_support_difference
blend_support_exclusion
blend_support_hardlight
blend_support_hsl_color
blend_support_hsl_hue
blend_support_hsl_luminosity
blend_support_hsl_saturation
blend_support_lighten
blend_support_multiply
blend_support_overlay
blend_support_screen
blend_support_softlight
blitCommandEncoder
blitCommandEncoderWithDescriptor
block
block declaration
block instance name redefinition
block member has no corresponding member in
block name cannot be redefined
block name cannot redefine a non-block name
block redeclaration has extra members
block_siH
block_size
block_structure
bool   subgroupAllEqual(%s);\n
bool anyInvocation(bool);bool allInvocations(bool);bool allInvocationsEqual(bool);\n
bool anyInvocationARB(bool);bool allInvocationsARB(bool);bool allInvocationsEqualARB(bool);\n
bool gl_HelperInvocation;flat in highp int gl_PrimitiveID;flat in highp int gl_Layer
bool helperInvocationEXT();\n
bool reportIntersectionNV(float, uint);bool reportIntersectionEXT(float, uint);\n
bool sparseTexelsResidentARB(int code);\n
bool subgroupAll(bool v) { return allInvocationsARB(v
bool subgroupAll(bool value) { return allThreadsNV(value
bool subgroupAll(bool value) { return ballotAMD(value) == ballotAMD(true
bool subgroupAllEqual(bool v) { return allInvocationsEqualARB(v
bool subgroupAllEqual(bool value) { return allThreadsEqualNV(value
bool subgroupAllEqual(bool value) { uint64_t b = ballotAMD(value); return b == 0ull || b == ballotAMD(true
bool subgroupAny(bool v) { return anyInvocationARB(v
bool subgroupAny(bool value) { return anyThreadNV(value
bool subgroupAny(bool value) { return ballotAMD(value) != 0ull
bool subgroupBallotBitExtract(uvec4 value, uint index
bool subgroupElect
bool subgroupInverseBallot(uvec4 value
bool valid
bool valid = subgroupBallotBitExtract(active_threads, i
boolean expression expected
boolƅE
borderColor
borderColorMVK
border_color::opaque_black
border_color::opaque_white
border_color::transparent_black
bound_image
bound_sampler
bounds
bpp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp
br\eI
bran3K
branch
break
break statement only allowed in switch and loops
break; // unreachable workaround
brivateData
br~<(uz
bt"<\fu
budget
buffer
buffer block
buffer is too large
buffer reference indexing
buffer reference math
buffer size
bufferBytesPerRow
bufferOffset
buffer_rH
buffer_reference
buffer_reference_align
buffers can be declared only as blocks
built in unary operator function.  Type: %s
built-in
built-in block redeclaration
built-in function
builtinsH
bytes from input stream! Read
bytes to output stream! Wrote
bzero
c16@0:8
c24@0:8#16
c24@0:8:16
c24@0:8@"Protocol"16
c24@0:8@16
c24@0:8Q16
c24@0:8q16
cCounterH3P
cVersionStringsMVK
calculate_clamped_lod
calculate_unclamped_lod
call argument
callable
callable data number
callableDataEXT
callableDataInEXT
callableDataInNV
callableDataInNV block
callableDataNV
callableDataNV block
calling
calling user function from global scope
can not be used with GL_EXT_shader_tile_image enabled
can only apply depth layout to gl_FragDepth
can only apply depth layout to gl_FragStencilRefARB
can only apply highp to atomic_uint
can only apply origin_upper_left and pixel_center_origin to gl_FragCoord
can only apply to 'in
can only apply to 'out
can only apply to a standalone qualifier
can only apply to an output
can only apply to an output, or to an input in a non-vertex stage\n
can only apply to parameter
can only apply to uniform, buffer, in, or out storage qualifiers
can only be applied as standalone
can only be applied to 'const'-qualified scalar
can only be applied to a scalar
can only be applied to a standalone 'out
can only be followed by a single macro name
can only be used in tileImageEXT variables or function parameters
can only be used on an output
can only be used on variable declaration
can only be used with a block
can only be used with a buffer
can only be used with a subpass
can only be used with a uniform
can only be used with an explicit location
can only be used with buffer
can only be used with std140, std430, or scalar layout packing
can only change layout qualification of
can only have one auxiliary qualifier (centroid, patch, and sample
can only have one interpolation qualifier (flat, smooth, noperspective, __explicitInterpAMD
can only redeclare a built-in block once, and before any use
can only specify on a buffer block
can only specify on a uniform block
can only use in an in/out block
can only use on input blocks in mesh shader
can only use on input in tessellation-evaluation shader
can only use on output in tessellation-control shader
can't construct structure containing 16-bit type
can't construct structure containing 8-bit type
can't convert
can't evaluate expression
can't find function
can't handle multiple entry points per stage
can't modify EvqFragStencil if using early_fragment_tests
can't modify a const
can't modify a readonly buffer
can't modify a sampler
can't modify a shaderrecordnv qualified buffer
can't modify a uniform
can't modify accelerationStructureNV
can't modify an atomic_uint
can't modify gl_FragCoord
can't modify gl_FragDepth if using early_fragment_tests
can't modify gl_FrontFace
can't modify gl_InstanceID
can't modify gl_PointCoord
can't modify gl_VertexID
can't modify hitObjectNV
can't modify rayQueryEXT
can't modify shader input
can't modify variable with storage qualifier taskPayloadSharedEXT in mesh shaders
can't modify void
can't read from explicitly-interpolated object
can't read from gl_WorkGroupSize before a fixed workgroup size has been declared
can't read from writeonly object
can't swizzle types containing (u)int16
can't swizzle types containing (u)int8
can't swizzle types containing float16
can't use auxiliary qualifier on a fragment output
can't use function syntax on variable
can't use interpolation qualifier on a fragment output
can't use with arrays containing float16
can't use with arrays containing int16
can't use with arrays containing int8
can't use with arrays containing uint16
can't use with arrays containing uint8
can't use with reference types
can't use with samplers or structs containing samplers
can't use with structs containing float16
can't use with structs containing int16
can't use with structs containing int8
can't use with structs containing uint16
can't use with structs containing uint8
can't use with types containing arrays sized with a specialization constant
canWriteFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
cannot add memory qualifier to redeclared block member
cannot add non-XFB layout to redeclared block member
cannot add patch to redeclared block member
cannot add perprimitiveNV qualifier to redeclared block member
cannot add perviewNV qualifier to redeclared block member
cannot add storage, auxiliary, memory, interpolation, layout, or precision qualifier to an existing variable
cannot appear outside switch statement
cannot apply layout qualifier to
cannot apply layout qualifiers to hitAttributeNV variable
cannot apply precision statement to this type; use 'float', 'int' or a sampler type
cannot apply to
cannot apply to 'out
cannot apply to a block
cannot apply to a cooperative matrix type
cannot apply to a matrix, structure, or block
cannot apply to an array
cannot apply to input
cannot apply to taskNV in/out blocks
cannot apply to taskPayloadSharedEXT
cannot apply to uniform or buffer block
cannot be a matrix
cannot be a structure
cannot be an argument type except for '(void
cannot be applied to this type
cannot be bool
cannot be both specified
cannot be greater than 3 for pervertexEXT
cannot be negative
cannot be nested inside control flow
cannot be used (maybe an instance name is needed
cannot be used (ouput primitive type mismatch
cannot be used with push_constant
cannot be used with shaderRecordNV
cannot be used with tileImageEXT
cannot change array size of redeclared block
cannot change array size of redeclared block member
cannot change arrayness of redeclared block
cannot change arrayness of redeclared block member
cannot change input storage qualification of
cannot change interpolation qualification of
cannot change output storage qualification of
cannot change previously set fragment shader interlock ordering
cannot change previously set input primitive
cannot change previously set layout value
cannot change previously set output primitive
cannot change previously set size
cannot change previously set vertex order
cannot change previously set vertex spacing
cannot change qualification after use
cannot change qualification of
cannot change storage, memory, or auxiliary qualification of
cannot change the type of
cannot construct this type
cannot construct with these arguments
cannot contain a double, int64, or uint64
cannot convert a sampler
cannot convert a void
cannot convert an atomic_uint
cannot convert from '%s' to '%s
cannot convert parameter %d from '%s' to '%s
cannot convert return value to function return type
cannot declare a default, can only be used on a block
cannot declare a default, can only be used on a scalar
cannot declare a default, include a type or full declaration
cannot declare a default, use a full declaration
cannot have statements before first case/default label
cannot index buffer reference
cannot index reference to buffer containing an unsized array
cannot initialize this type of qualifier
cannot lie in previous members
cannot mix use of shared variables inside and outside blocks
cannot modify hitAttributeNV in this stage
cannot nest a block definition inside a structure or block
cannot nest a structure definition inside a structure or block
cannot re-qualify a function name
cannot redeclare a built-in block with a user name
cannot redeclare a non block as a block
cannot redeclare a user-block member array
cannot redeclare after use
cannot redeclare block
cannot redeclare block member with a different type
cannot redeclare with different qualification
cannot specify matrix layout on a variable declaration
cannot specify on a variable declaration
cannot specify on atomic counter
cannot specify packing on a variable declaration
cannot use 'inout' at global scope
cannot use auxiliary or interpolation qualifiers on a function parameter
cannot use auxiliary, memory, interpolation, or precision qualifier in a default qualifier declaration (declaration with no type
cannot use centroid qualifier on an interface block
cannot use in a block array where new locations are needed for each block element
cannot use in preprocessor expression when expanded from macros
cannot use interpolation qualifiers on an interface block
cannot use interpolation qualifiers with patch
cannot use invariant qualifier on a function parameter
cannot use invariant qualifier on an interface block
cannot use invariant qualifier on structure members
cannot use layout qualifiers on a function parameter
cannot use layout qualifiers on structure members
cannot use memory qualifiers on structure members
cannot use offset or align qualifiers in a default qualifier declaration (declaration with no type
cannot use sample qualifier on an interface block
cannot use spirv_literal qualifier
cannot use storage or interpolation qualifiers on structure members
capabiliH3\b
capabiliI3D
capabilities
capability
case component::w
case component::x
case component::y
case component::z
case spvFormatResolution::_420
case spvFormatResolution::_422
case spvFormatResolution::_444: break
case spvSwizzle::alpha
case spvSwizzle::blue
case spvSwizzle::green
case spvSwizzle::none
case spvSwizzle::one
case spvSwizzle::red
case spvSwizzle::zero
case spvXChromaLocation::cosited_even
case spvXChromaLocation::midpoint
case spvYCbCrModelConversion::rgb_identity
case spvYCbCrModelConversion::ycbcr_bt_2020
case spvYCbCrModelConversion::ycbcr_bt_601
case spvYCbCrModelConversion::ycbcr_bt_709
case spvYCbCrModelConversion::ycbcr_identity
case spvYCbCrRange::itu_full
case spvYCbCrRange::itu_narrow
case spvYChromaLocation::cosited_even
case spvYChromaLocation::midpoint
caseInsensitiveCompare
case_label
cationIDH
cations
ccOut.color%u = %@4(ccIn.colors[%u
center_no_perspective
centroid
centroid/sample/patch
centroid_no_perspective
centroid_perspective
cf. Khronos Data Format Specification, section 15.1.1
cf. Khronos Data Format Specification, section 15.1.2
cf. Khronos Data Format Specification, section 15.1.3
cfstring
chInǃI
chainKHRH
changing qualification after use
char _m
char _m0_final_padding
character literals not supported
cissor
cissorRectFromVkRect2D
clang::optnone]] F spvQuantizeToF16(F fval
clang::optnone]] T spvFAdd(T l, T r
clang::optnone]] T spvFMul(T l, T r
clang::optnone]] T spvFSub(T l, T r
clang::optnone]] T spvReflect(T i, T n
clang::optnone]] matrix<T, RCols, LRows> spvFMulMatrixMatrix(matrix<T, LCols, LRows> l, matrix<T, RCols, RRows> r
clang::optnone]] vec<T, Cols> spvFMulVectorMatrix(vec<T, Rows> v, matrix<T, Cols, Rows> m
clang::optnone]] vec<T, Rows> spvFMulMatrixVector(matrix<T, Cols, Rows> m, vec<T, Cols> v
class-code
client opengl100
client vulkan100
clip_disI
clip_distance
clock2x32ARB
clockARB
clockRealtime2x32EXT
clockRealtimeEXT
closest-hit
cluster size
cmdClearColorImage2DFloat
cmdClearColorImage2DInt
cmdClearColorImage2DUInt
cmdCopyBufferBytes
cmdCopyBufferToImage3DDecompressDXTn
cmdCopyBufferToImage3DDecompressTempBufferDXTn
cmdCopyQueryPoolResultsToBuffer
cmdDrawIndexedCopyIndex16Buffer
cmdDrawIndexedCopyIndex32Buffer
cmdDrawIndexedIndirectConvertBuffers
cmdDrawIndexedIndirectTessConvertBuffers
cmdDrawIndirectConvertBuffers
cmdDrawIndirectPopulateIndexes
cmdDrawIndirectTessConvertBuffers
cmdFillBuffer
cmdResolveColorImage2DFloat
cmdResolveColorImage2DInt
cmdResolveColorImage2DUInt
cnderAreaGranularity
coherent
coherent volatile
coherentH
color
colorAttachmentReadEXT
colorAttachments
colorspace
colorspaceNameMVK
column_mH
column_mH3
column_mI3M
column_major
columns[i] = *col
columns[i] = m.columns[i
combined token is invalid
combined tokens are too long
commandBuffer
commandBufferWithDescriptor
commandBufferWithUnretainedReferences
comment
commit
commit_bounding_box_intersection
commit_triangle_intersection
committed
common
compare
compareFunction
compareFunctionMVK
compare_H
compare_func::always
compare_func::equal
compare_func::greater
compare_func::greater_equal
compare_func::less
compare_func::less_equal
compare_func::never
compare_func::not_equal
compatibH1
compatibility
compilation errors.  No code generated.\n\n
compilation terminated
completed
componenH
component
component argument
component is too large
component vector of
component-wise multiply
component::w
component::x
component::y
component::z
components (1/4 stride) needed are
components must be in the range [0, 3
components must be in the range [0, 31
compound_statement
compound_statement_no_new_scope
compressedDataUsingAlgorithm:error
compute
compute shader derivatives
compute shaders
computeCommandEncoder
condition
condition must be a scalar integer expression
condition\n
conditional_expression
conditionopt
conformsToProtocol
const
const (read only
const array
const bool
const device
const device uint
const device ushort
const highp int gl_ShadingRateFlag2HorizontalPixelsEXT     = 4;\n
const highp int gl_ShadingRateFlag2VerticalPixelsEXT       = 1;\n
const highp int gl_ShadingRateFlag4HorizontalPixelsEXT     = 8;\n
const highp int gl_ShadingRateFlag4VerticalPixelsEXT       = 2;\n
const int
const int  gl_MaxClipPlanes = %d
const int  gl_MaxCombinedTextureImageUnits = %d
const int  gl_MaxDrawBuffers = %d
const int  gl_MaxFragmentUniformComponents = %d
const int  gl_MaxFragmentUniformVectors = %d
const int  gl_MaxLights = %d
const int  gl_MaxTextureCoords = %d
const int  gl_MaxTextureImageUnits = %d
const int  gl_MaxTextureUnits = %d
const int  gl_MaxVaryingFloats = %d
const int  gl_MaxVaryingVectors = %d
const int  gl_MaxVertexAttribs = %d
const int  gl_MaxVertexTextureImageUnits = %d
const int  gl_MaxVertexUniformComponents = %d
const int  gl_MaxVertexUniformVectors = %d
const int gl_MatrixUseA = 0;\nconst int gl_MatrixUseB = 1;\nconst int gl_MatrixUseAccumulator = 2;\nconst int gl_MatrixOperandsSaturatingAccumulation = 0x10;\nconst int gl_CooperativeMatrixLayoutRowMajor = 0;\nconst int gl_CooperativeMatrixLayoutColumnMajor = 1;\n\n
const int gl_MaxAtomicCounterBindings = %d
const int gl_MaxAtomicCounterBufferSize = %d
const int gl_MaxClipDistances = %d
const int gl_MaxCombinedAtomicCounterBuffers = %d
const int gl_MaxCombinedAtomicCounters = %d
const int gl_MaxCombinedClipAndCullDistances = %d
const int gl_MaxCombinedImageUniforms = %d
const int gl_MaxCombinedImageUnitsAndFragmentOutputs = %d
const int gl_MaxCombinedShaderOutputResources = %d
const int gl_MaxComputeAtomicCounterBuffers = %d
const int gl_MaxComputeAtomicCounters = %d
const int gl_MaxComputeImageUniforms = %d
const int gl_MaxComputeTextureImageUnits = %d
const int gl_MaxComputeUniformComponents = %d
const int gl_MaxCullDistances = %d
const int gl_MaxFragmentAtomicCounterBuffers = %d
const int gl_MaxFragmentAtomicCounters = %d
const int gl_MaxFragmentImageUniforms = %d
const int gl_MaxFragmentInputComponents = %d
const int gl_MaxGeometryAtomicCounterBuffers = %d
const int gl_MaxGeometryAtomicCounters = %d
const int gl_MaxGeometryImageUniforms = %d
const int gl_MaxGeometryInputComponents = %d
const int gl_MaxGeometryOutputComponents = %d
const int gl_MaxGeometryOutputVertices = %d
const int gl_MaxGeometryTextureImageUnits = %d
const int gl_MaxGeometryTotalOutputComponents = %d
const int gl_MaxGeometryUniformComponents = %d
const int gl_MaxGeometryVaryingComponents = %d
const int gl_MaxImageSamples = %d
const int gl_MaxImageUnits = %d
const int gl_MaxMeshOutputPrimitivesNV = %d
const int gl_MaxMeshOutputVerticesNV = %d
const int gl_MaxMeshViewCountNV = %d
const int gl_MaxPatchVertices = %d
const int gl_MaxSamples = %d
const int gl_MaxTessControlAtomicCounterBuffers = %d
const int gl_MaxTessControlAtomicCounters = %d
const int gl_MaxTessControlImageUniforms = %d
const int gl_MaxTessControlInputComponents = %d
const int gl_MaxTessControlOutputComponents = %d
const int gl_MaxTessControlTextureImageUnits = %d
const int gl_MaxTessControlTotalOutputComponents = %d
const int gl_MaxTessControlUniformComponents = %d
const int gl_MaxTessEvaluationAtomicCounterBuffers = %d
const int gl_MaxTessEvaluationAtomicCounters = %d
const int gl_MaxTessEvaluationImageUniforms = %d
const int gl_MaxTessEvaluationInputComponents = %d
const int gl_MaxTessEvaluationOutputComponents = %d
const int gl_MaxTessEvaluationTextureImageUnits = %d
const int gl_MaxTessEvaluationUniformComponents = %d
const int gl_MaxTessGenLevel = %d
const int gl_MaxTessPatchComponents = %d
const int gl_MaxTransformFeedbackBuffers = %d
const int gl_MaxTransformFeedbackInterleavedComponents = %d
const int gl_MaxVaryingComponents = %d
const int gl_MaxVertexAtomicCounterBuffers = %d
const int gl_MaxVertexAtomicCounters = %d
const int gl_MaxVertexImageUniforms = %d
const int gl_MaxVertexOutputComponents = %d
const int gl_MaxViewports = %d
const int gl_ScopeDevice      = 1;\n
const int gl_ScopeInvocation  = 4;\n
const int gl_ScopeQueueFamily = 5;\n
const int gl_ScopeShaderCallEXT = 6;\n
const int gl_ScopeSubgroup    = 3;\n
const int gl_ScopeWorkgroup   = 2;\n
const int gl_SemanticsAcquire         = 0x2;\n
const int gl_SemanticsAcquireRelease  = 0x8;\n
const int gl_SemanticsMakeAvailable   = 0x2000;\n
const int gl_SemanticsMakeVisible     = 0x4000;\n
const int gl_SemanticsRelaxed         = 0x0;\n
const int gl_SemanticsRelease         = 0x4;\n
const int gl_SemanticsVolatile        = 0x8000;\n
const int gl_StorageSemanticsBuffer   = 0x40;\n
const int gl_StorageSemanticsImage    = 0x800;\n
const int gl_StorageSemanticsNone     = 0x0;\n
const int gl_StorageSemanticsOutput   = 0x1000;\n
const int gl_StorageSemanticsShared   = 0x100;\n
const int16_t
const int64_t
const int8_t
const ivec3 gl_MaxComputeWorkGroupCount = ivec3(%d,%d,%d
const ivec3 gl_MaxComputeWorkGroupSize = ivec3(%d,%d,%d
const ivec3 gl_MaxMeshWorkGroupSizeNV = ivec3(%d,%d,%d
const ivec3 gl_MaxTaskWorkGroupSizeNV = ivec3(%d,%d,%d
const mediump int  gl_MaxCombinedTextureImageUnits = %d
const mediump int  gl_MaxDrawBuffers = %d
const mediump int  gl_MaxFragmentInputVectors = %d
const mediump int  gl_MaxFragmentUniformVectors = %d
const mediump int  gl_MaxProgramTexelOffset = %d
const mediump int  gl_MaxTextureImageUnits = %d
const mediump int  gl_MaxVaryingVectors = %d
const mediump int  gl_MaxVertexAttribs = %d
const mediump int  gl_MaxVertexOutputVectors = %d
const mediump int  gl_MaxVertexTextureImageUnits = %d
const mediump int  gl_MaxVertexUniformVectors = %d
const mediump int  gl_MinProgramTexelOffset = %d
const mediump int gl_MaxDualSourceDrawBuffersEXT = %d
const uint
const uint gl_RayFlagsNoneNV = 0U;const uint gl_RayFlagsNoneEXT = 0U;const uint gl_RayFlagsOpaqueNV = 1U;const uint gl_RayFlagsOpaqueEXT = 1U;const uint gl_RayFlagsNoOpaqueNV = 2U;const uint gl_RayFlagsNoOpaqueEXT = 2U;const uint gl_RayFlagsTerminateOnFirstHitNV = 4U;const uint gl_RayFlagsTerminateOnFirstHitEXT = 4U;const uint gl_RayFlagsSkipClosestHitShaderNV = 8U;const uint gl_RayFlagsSkipClosestHitShaderEXT = 8U;const uint gl_RayFlagsCullBackFacingTrianglesNV = 16U;const uint gl_RayFlagsCullBackFacingTrianglesEXT = 16U;const uint gl_RayFlagsCullFrontFacingTrianglesNV = 32U;const uint gl_RayFlagsCullFrontFacingTrianglesEXT = 32U;const uint gl_RayFlagsCullOpaqueNV = 64U;const uint gl_RayFlagsCullOpaqueEXT = 64U;const uint gl_RayFlagsCullNoOpaqueNV = 128U;const uint gl_RayFlagsCullNoOpaqueEXT = 128U;const uint gl_RayFlagsSkipTrianglesEXT = 256U;const uint gl_RayFlagsSkipAABBEXT = 512U;const uint gl_RayFlagsForceOpacityMicromap2StateEXT = 1024U;const uint gl_HitKindFrontFacingTriangleEXT = 254U;const uint gl_HitKindBackFacingTriangleEXT = 255U;\n
const uint gl_RayQueryCandidateIntersectionEXT = 0U;const uint gl_RayQueryCommittedIntersectionEXT = 1U;const uint gl_RayQueryCommittedIntersectionNoneEXT = 0U;const uint gl_RayQueryCommittedIntersectionTriangleEXT = 1U;const uint gl_RayQueryCommittedIntersectionGeneratedEXT = 2U;const uint gl_RayQueryCandidateIntersectionTriangleEXT = 0U;const uint gl_RayQueryCandidateIntersectionAABBEXT = 1U;\n
const uint16_t
const uint32_t
const uint64_t
const uint8_t
constant
constant TexSubrez& subRez [[buffer(0
constant expression required
constant float3x3 spvBT2020Factors = {{1, 1, 1}, {0, -0.11156702/0.6780, 1.8814}, {1.4746, -0.38737742/0.6780, 0
constant float3x3 spvBT601Factors = {{1, 1, 1}, {0, -0.202008/0.587, 1.772}, {1.402, -0.419198/0.587, 0
constant float3x3 spvBT709Factors = {{1, 1, 1}, {0, -0.13397432/0.7152, 1.8556}, {1.5748, -0.33480248/0.7152, 0
constant uint
constant uint spvLinearTextureAlignment
constant uint spvLinearTextureAlignmentOverride [[function_constant
constant uint& flags [[buffer(4)]],                                 \n                                            constant QueryStatus* availability [[buffer(5)]],                   \n                                            uint query [[thread_position_in_grid]]) {                           \n    if (query >= numQueries) { return; }                                                                        \n    device uint32_t* destCount = (device uint32_t*)(dest + stride * query);                                     \n    if (availability[query] != Initial || flags & VK_QUERY_RESULT_PARTIAL_BIT) {                                \n        destCount[0] = src[query].count;                                                                        \n        if (flags & VK_QUERY_RESULT_64_BIT) { destCount[1] = src[query].countHigh; }                            \n    }                                                                                                           \n    if (flags & VK_QUERY_RESULT_WITH_AVAILABILITY_BIT) {                                                        \n        if (flags & VK_QUERY_RESULT_64_BIT) {                                                                   \n            destCount[2] = availability[query] != Initial ? 1 : 0;                                              \n            destCount[3] = 0;                                                                                   \n        } else {                                                                                                \n            destCount[1] = availability[query] != Initial ? 1 : 0;                                              \n        }                                                                                                       \n    }                                                                                                           \n}                                                                                                               \n                                                                                                                \nkernel void accumulateOcclusionQueryResults(device VisibilityBuffer& dest [[buffer(0)]],                        \n                                            const device VisibilityBuffer& src [[buffer(1)]]) {                 \n    uint32_t oldDestCount = dest.count;                                                                         \n    dest.count += src.count;                                                                                    \n    dest.countHigh += src.countHigh;                                                                            \n    if (dest.count < max(oldDestCount, src.count)) { dest.countHigh++; }                                        \n}                                                                                                               \n                                                                                                                \n
constant uint* spvIndirectParams [[buffer
constant uint3
constantH
constant_expression
constant_id
constexpr const constant T& operator [] (size_t pos) const constant
constexpr const device T& operator [] (size_t pos) const device
constexpr const thread T& operator [] (size_t pos) const thread
constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
constexpr explicit spvComponentBits(int v) thread : value(v
constexpr sampler
constexpr sampler ce_sampler(mip_filter::nearest, filter
constexpr sampler ce_stencil_sampler(mip_filter::nearest
constexpr spvDynamicImageSampler(texture2d<T> plane0, texture2d<T> plane1
constexpr spvDynamicImageSampler(texture2d<T> plane0, texture2d<T> plane1, texture2d<T> plane2
constexpr spvDynamicImageSampler(texture2d<T> tex, sampler samp) thread
constexpr spvDynamicImageSampler(texture2d<T> tex, sampler samp, spvYCbCrSampler ycbcr_samp, uint sw) thread
constexpr spvDynamicImageSampler(texture2d<T> tex, sampler samp, uint sw) thread
constexpr spvYCbCrSampler() thread : val(build
constexpr spvYCbCrSampler(Ts... t) thread : val(build(t
constexpr spvYCbCrSampler(const thread spvYCbCrSampler& s) thread = default
constexpr static constant ushort bpc_base = 10
constexpr static constant ushort bpc_bits = 6
constexpr static constant ushort bpc_mask = ((1 << bpc_bits) - 1) << bpc_base
constexpr static constant ushort chroma_filter_base = 2
constexpr static constant ushort chroma_filter_bits = 2
constexpr static constant ushort chroma_filter_mask = ((1 << chroma_filter_bits) - 1) << chroma_filter_base
constexpr static constant ushort resolution_base = 0
constexpr static constant ushort resolution_bits = 2
constexpr static constant ushort resolution_mask = ((1 << resolution_bits) - 1) << resolution_base
constexpr static constant ushort x_chroma_off_base = 4
constexpr static constant ushort x_chroma_off_bit = 1
constexpr static constant ushort x_chroma_off_mask = ((1 << x_chroma_off_bit) - 1) << x_chroma_off_base
constexpr static constant ushort y_chroma_off_base = 5
constexpr static constant ushort y_chroma_off_bit = 1
constexpr static constant ushort y_chroma_off_mask = ((1 << y_chroma_off_bit) - 1) << y_chroma_off_base
constexpr static constant ushort ycbcr_model_base = 6
constexpr static constant ushort ycbcr_model_bits = 3
constexpr static constant ushort ycbcr_model_mask = ((1 << ycbcr_model_bits) - 1) << ycbcr_model_base
constexpr static constant ushort ycbcr_range_base = 9
constexpr static constant ushort ycbcr_range_bit = 1
constexpr static constant ushort ycbcr_range_mask = ((1 << ycbcr_range_bit) - 1) << ycbcr_range_base
constructing matrix from matrix
constructing non-array constituent from array argument
constructor
constructor argument does not have a type
contentView
contents
contentsScale
context-insensitive value
continue
continue statement only allowed in loops
control
controlBarrier
convertE28MVKGLSLConversionShaderStageRNS_27GLSLToSPIRVConversionResultEbb
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions
coopMatLoad
coopMatLoadNV
coopMatMulAdd
coopMatMulAddNV
coopMatStore
coopMatStoreNV
cooperative matrix layout
cooperative matrix operands
cooperative matrix use
coopmat
coopmat incorrect number of type parameters
coopmat invalid basic type
coopmat invalid matrix Use
coopmat missing type parameters
coord, spvForward<LodOptions>(options
coord::pH
coord::pixel
copy object
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount
copysign
cosine
cosited_even = 0
count
countByEnumeratingWithState:objects:count
countLeadingZeros
countTrailingZeros
counter %d
counterSets
counters
cpuCacheMode
cquireNextImage
criptor
cross-product
cstring
cubeFaceCoord
cubeFaceCoordAMD
cubeFaceIndex
cubeFaceIndexAMD
currentAllocatedSize
currentDirectoryPath
cwapchainImagesKHR
cxa_allocate_exception
cxa_atexit
cxa_bad_typeid
cxa_begin_catch
cxa_demangle
cxa_end_catch
cxa_free_exception
cxa_guard_abort
cxa_guard_acquire
cxa_guard_release
cxa_pure_virtual
cxa_rethrow
cxa_throw
d (%s
d const H
d must be the same basic type
d$\bffff
d-errorsH
dBuffersH
dCommandBuffer
dEndDebugUtilsLabelEXT
dFdxCoarse
dFdxFine
dFdyCoarse
dFdyFine
dPdxCoarse
dPdxFine
dPdyCoarse
dPdyFine
dQueue
d_types
daryPosiH
dataWithBytes:length
dataWithBytesNoCopy:length:freeWhenDone
de, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent int8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent int16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent int[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent int64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent ivec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent ivec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent int8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent int16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent int[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent int64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent ivec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent ivec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nicoopmatNV coopMatMulAddNV(icoopmatNV A, icoopmatNV B, icoopmatNV C);\nucoopmatNV coopMatMulAddNV(ucoopmatNV A, ucoopmatNV B, ucoopmatNV C);\n
dealloc
debug base type encoding
debug composite type
debug info flags
debug operation
debug pragma syntax is incorrect
debug type qualifier
debugDescription
debugPriH
debugPrintfEXT
debugSignposts
declaration
declaration_statement
decompressedDataUsingAlgorithm:error
decoration
decoration=%u
default
default qualifier requires 'uniform', 'buffer', 'in', 'out' or 'shared' storage qualification
default std430 layout for uniform
defaultManager
default_H
default_value
define
define GL_ANY_HIT_SHADER_EXT 1 \n
define GL_ARB_texture_rectangle 1\n#define GL_ARB_shading_language_420pack 1\n#define GL_ARB_texture_gather 1\n#define GL_ARB_gpu_shader5 1\n#define GL_ARB_separate_shader_objects 1\n#define GL_ARB_compute_shader 1\n#define GL_ARB_tessellation_shader 1\n#define GL_ARB_enhanced_layouts 1\n#define GL_ARB_texture_cube_map_array 1\n#define GL_ARB_texture_multisample 1\n#define GL_ARB_shader_texture_lod 1\n#define GL_ARB_explicit_attrib_location 1\n#define GL_ARB_explicit_uniform_location 1\n#define GL_ARB_shader_image_load_store 1\n#define GL_ARB_shader_atomic_counters 1\n#define GL_ARB_shader_draw_parameters 1\n#define GL_ARB_shader_group_vote 1\n#define GL_ARB_derivative_control 1\n#define GL_ARB_shader_texture_image_samples 1\n#define GL_ARB_viewport_array 1\n#define GL_ARB_gpu_shader_int64 1\n#define GL_ARB_gpu_shader_fp64 1\n#define GL_ARB_shader_ballot 1\n#define GL_ARB_sparse_texture2 1\n#define GL_ARB_sparse_texture_clamp 1\n#define GL_ARB_shader_stencil_export 1\n#define GL_ARB_sample_shading 1\n#define GL_ARB_shader_image_size 1\n#define GL_ARB_shading_language_packing 1\n#define GL_ARB_post_depth_coverage 1\n#define GL_ARB_fragment_shader_interlock 1\n#define GL_ARB_uniform_buffer_object 1\n#define GL_ARB_shader_bit_encoding 1\n#define GL_ARB_shader_storage_buffer_object 1\n#define GL_ARB_texture_query_lod 1\n#define GL_ARB_vertex_attrib_64bit 1\n#define GL_ARB_draw_instanced 1\n#define GL_ARB_fragment_coord_conventions 1\n#define GL_ARB_bindless_texture 1\n#define GL_EXT_shader_non_constant_global_initializers 1\n#define GL_EXT_shader_image_load_formatted 1\n#define GL_EXT_post_depth_coverage 1\n#define GL_EXT_control_flow_attributes 1\n#define GL_EXT_nonuniform_qualifier 1\n#define GL_EXT_shader_16bit_storage 1\n#define GL_EXT_shader_8bit_storage 1\n#define GL_EXT_samplerless_texture_functions 1\n#define GL_EXT_scalar_block_layout 1\n#define GL_EXT_fragment_invocation_density 1\n#define GL_EXT_buffer_reference 1\n#define GL_EXT_buffer_reference2 1\n#define GL_EXT_buffer_reference_uvec2 1\n#define GL_EXT_demote_to_helper_invocation 1\n#define GL_EXT_debug_printf 1\n#define GL_EXT_fragment_shading_rate 1\n#define GL_EXT_shared_memory_block 1\n#define GL_EXT_shader_integer_mix 1\n#define GL_KHR_shader_subgroup_basic 1\n#define GL_KHR_shader_subgroup_vote 1\n#define GL_KHR_shader_subgroup_arithmetic 1\n#define GL_KHR_shader_subgroup_ballot 1\n#define GL_KHR_shader_subgroup_shuffle 1\n#define GL_KHR_shader_subgroup_shuffle_relative 1\n#define GL_KHR_shader_subgroup_clustered 1\n#define GL_KHR_shader_subgroup_quad 1\n#define GL_KHR_cooperative_matrix 1\n#define GL_EXT_shader_image_int64 1\n#define GL_EXT_shader_atomic_int64 1\n#define GL_EXT_shader_realtime_clock 1\n#define GL_EXT_ray_tracing 1\n#define GL_EXT_ray_query 1\n#define GL_EXT_ray_flags_primitive_culling 1\n#define GL_EXT_ray_cull_mask 1\n#define GL_EXT_ray_tracing_position_fetch 1\n#define GL_EXT_spirv_intrinsics 1\n#define GL_EXT_mesh_shader 1\n#define GL_AMD_shader_ballot 1\n#define GL_AMD_shader_trinary_minmax 1\n#define GL_AMD_shader_explicit_vertex_parameter 1\n#define GL_AMD_gcn_shader 1\n#define GL_AMD_gpu_shader_half_float 1\n#define GL_AMD_texture_gather_bias_lod 1\n#define GL_AMD_gpu_shader_int16 1\n#define GL_AMD_shader_image_load_store_lod 1\n#define GL_AMD_shader_fragment_mask 1\n#define GL_AMD_gpu_shader_half_float_fetch 1\n#define GL_INTEL_shader_integer_functions2 1\n#define GL_NV_sample_mask_override_coverage 1\n#define GL_NV_geometry_shader_passthrough 1\n#define GL_NV_viewport_array2 1\n#define GL_NV_shader_atomic_int64 1\n#define GL_NV_conservative_raster_underestimation 1\n#define GL_NV_shader_subgroup_partitioned 1\n#define GL_NV_shading_rate_image 1\n#define GL_NV_ray_tracing 1\n#define GL_NV_ray_tracing_motion_blur 1\n#define GL_NV_fragment_shader_barycentric 1\n#define GL_NV_compute_shader_derivatives 1\n#define GL_NV_shader_texture_footprint 1\n#define GL_NV_mesh_shader 1\n#define GL_NV_cooperative_matrix 1\n#define GL_NV_integer_cooperative_matrix 1\n#define GL_NV_shader_invocation_reorder 1\n#define GL_EXT_shader_explicit_arith
define GL_CALLABLE_SHADER_EXT 1 \n
define GL_CLOSEST_HIT_SHADER_EXT 1 \n
define GL_COMPUTE_SHADER 1 \n
define GL_ES 1\n#define GL_FRAGMENT_PRECISION_HIGH 1\n#define GL_OES_texture_3D 1\n#define GL_OES_standard_derivatives 1\n#define GL_EXT_frag_depth 1\n#define GL_OES_EGL_image_external 1\n#define GL_OES_EGL_image_external_essl3 1\n#define GL_EXT_YUV_target 1\n#define GL_EXT_shader_texture_lod 1\n#define GL_EXT_shadow_samplers 1\n#define GL_EXT_fragment_shading_rate 1\n#define GL_ANDROID_extension_pack_es31a 1\n#define GL_OES_sample_variables 1\n#define GL_OES_shader_image_atomic 1\n#define GL_OES_shader_multisample_interpolation 1\n#define GL_OES_texture_storage_multisample_2d_array 1\n#define GL_EXT_geometry_shader 1\n#define GL_EXT_geometry_point_size 1\n#define GL_EXT_gpu_shader5 1\n#define GL_EXT_primitive_bounding_box 1\n#define GL_EXT_shader_io_blocks 1\n#define GL_EXT_tessellation_shader 1\n#define GL_EXT_tessellation_point_size 1\n#define GL_EXT_texture_buffer 1\n#define GL_EXT_texture_cube_map_array 1\n#define GL_EXT_shader_implicit_conversions 1\n#define GL_EXT_shader_integer_mix 1\n#define GL_EXT_blend_func_extended 1\n#define GL_OES_geometry_shader 1\n#define GL_OES_geometry_point_size 1\n#define GL_OES_gpu_shader5 1\n#define GL_OES_primitive_bounding_box 1\n#define GL_OES_shader_io_blocks 1\n#define GL_OES_tessellation_shader 1\n#define GL_OES_tessellation_point_size 1\n#define GL_OES_texture_buffer 1\n#define GL_OES_texture_cube_map_array 1\n#define GL_EXT_shader_non_constant_global_initializers 1\n
define GL_EXT_device_group 1\n#define GL_EXT_multiview 1\n#define GL_NV_shader_sm_builtins 1\n
define GL_EXT_null_initializer 1\n
define GL_EXT_subgroup_uniform_control_flow 1\n
define GL_EXT_terminate_invocation 1\n
define GL_FRAGMENT_PRECISION_HIGH 1\n
define GL_FRAGMENT_SHADER 1 \n
define GL_GEOMETRY_SHADER 1 \n
define GL_GOOGLE_cpp_style_line_directive 1\n#define GL_GOOGLE_include_directive 1\n#define GL_KHR_blend_equation_advanced 1\n
define GL_INTERSECTION_SHADER_EXT 1 \n
define GL_MESH_SHADER_NV 1 \n
define GL_MISS_SHADER_EXT 1 \n
define GL_NV_shader_noperspective_interpolation 1\n
define GL_OVR_multiview 1\n#define GL_OVR_multiview2 1\n
define GL_RAY_GENERATION_SHADER_EXT 1 \n
define GL_SPIRV
define GL_TASK_SHADER_NV 1 \n
define GL_TESSELLATION_CONTROL_SHADER 1 \n
define GL_TESSELLATION_EVALUATION_SHADER 1 \n
define GL_VERTEX_SHADER 1 \n
define GL_compatibility_profile 1\n
define GL_core_profile 1\n
define SPIRV_CROSS_BRANCH
define SPIRV_CROSS_BRANCH [[dont_flatten
define SPIRV_CROSS_FLATTEN
define SPIRV_CROSS_FLATTEN [[flatten
define SPIRV_CROSS_LOOP
define SPIRV_CROSS_LOOP [[dont_unroll
define SPIRV_CROSS_UNROLL
define SPIRV_CROSS_UNROLL [[unroll
define SPIRV_Cross_BaseInstance gl_BaseInstanceARB
define SPIRV_Cross_BaseVertex gl_BaseVertexARB
define SPIRV_Cross_beginInvocationInterlock() beginFragmentShaderOrderingINTEL
define SPIRV_Cross_beginInvocationInterlock() beginInvocationInterlockARB
define SPIRV_Cross_beginInvocationInterlock() beginInvocationInterlockNV
define SPIRV_Cross_endInvocationInterlock
define SPIRV_Cross_endInvocationInterlock() endInvocationInterlockARB
define SPIRV_Cross_endInvocationInterlock() endInvocationInterlockNV
define VULKAN
define _SPIRV_CROSS_SUBGROUP_ALL_EQUAL_WORKAROUND(type) bool subgroupAllEqual(type value) { return subgroupAllEqual(subgroupBroadcastFirst(value) == value
define gl_NumSubgroups gl_WarpsPerSMNV
define gl_SubgroupEqMask uvec4(gl_ThreadEqMaskNV, 0u, 0u, 0u
define gl_SubgroupEqMask uvec4(unpackUint2x32(gl_SubGroupEqMaskARB), 0u, 0u
define gl_SubgroupGeMask uvec4(gl_ThreadGeMaskNV, 0u, 0u, 0u
define gl_SubgroupGeMask uvec4(unpackUint2x32(gl_SubGroupGeMaskARB), 0u, 0u
define gl_SubgroupGtMask uvec4(gl_ThreadGtMaskNV, 0u, 0u, 0u
define gl_SubgroupGtMask uvec4(unpackUint2x32(gl_SubGroupGtMaskARB), 0u, 0u
define gl_SubgroupID gl_WarpIDNV
define gl_SubgroupInvocationID gl_SubGroupInvocationARB
define gl_SubgroupInvocationID gl_ThreadInWarpNV
define gl_SubgroupLeMask uvec4(gl_ThreadLeMaskNV, 0u, 0u, 0u
define gl_SubgroupLeMask uvec4(unpackUint2x32(gl_SubGroupLeMaskARB), 0u, 0u
define gl_SubgroupLtMask uvec4(gl_ThreadLtMaskNV, 0u, 0u, 0u
define gl_SubgroupLtMask uvec4(unpackUint2x32(gl_SubGroupLtMaskARB), 0u, 0u
define gl_SubgroupSize gl_SubGroupSizeARB
define gl_SubgroupSize gl_WarpSizeNV
define gl_SubgroupSize uint(gl_SIMDGroupSizeAMD
define spvImage2DAtomicCoord(tc, tex) (((((tex).get_width
define spvTexelBufferCoord(tc, tex) uint2((tc) % (tex).get_width(), (tc) / (tex).get_width
defined
defined" can't be (un)defined
defined" is (un)defined
defined(GL_AMD_gpu_shader_int64) || defined(GL_NV_gpu_shader5
defined(GL_ARB_shader_int64
degrees
delegate
demote
demote_statement
dependency_infinite
dependency_length
deprecated in version
deprecated, may be removed in future release
depth [[depth(any
depth layout qualifier
depth(any
depth(greater
depth(less
depth1d_unsupported_by_metal
depth24Stencil8PixelFormatSupported
depth2d
depth2d_array
depth2d_ms
depth2d_ms_array
depth3d_unsupported_by_metal
depthAttachment
depthAttachmentReadEXT
depthPlane
depthResolveFilter
depthResolveFilterMVK
depth_any
depth_greater
depth_less
depth_unchanged
depthcube
depthcube_array
derPass2H
der_fp64H
dergePipelineCaches
derivative_group
derivative_group_linearNV
derivative_group_linearnv
derivative_group_quadsNV
derivative_group_quadsNV and derivative_group_linearNV
derivative_group_quadsnv
description
descriptor set
determinant
device
device T& operator [] (size_t pos) device
device atomic
device auto& destTC = *(device MTLDispatchThreadgroupsIndirectArguments*)(dest + sizeof(MTLDispatchThreadgroupsIndirectArguments));\n    device auto& destTE = *(device MTLDrawPatchIndirectArguments*)(dest + sizeof(MTLDispatchThreadgroupsIndirectArguments) * 2);\n    uint32_t patchCount = (src.vertexCount * src.instanceCount + inControlPointCount - 1) / inControlPointCount;\n    params[0] = inControlPointCount;                                                                            \n    params[1] = patchCount;                                                                                     \n    destVtx.threadgroupsPerGrid[0] = (src.vertexCount + vtxThreadExecWidth - 1) / vtxThreadExecWidth;           \n    destVtx.threadgroupsPerGrid[1] = src.instanceCount;                                                         \n    destVtx.threadgroupsPerGrid[2] = 1;                                                                         \n    destTC.threadgroupsPerGrid[0] = (patchCount * outControlPointCount + tcWorkgroupSize - 1) / tcWorkgroupSize;\n    destTC.threadgroupsPerGrid[1] = destTC.threadgroupsPerGrid[2] = 1;                                          \n    destTE.patchCount = patchCount;                                                                             \n    destTE.instanceCount = 1;                                                                                   \n    destTE.patchStart = destTE.baseInstance = 0;                                                                \n#if __METAL_VERSION__ >= 210                                                                                    \n    destSI.stageInOrigin[0] = src.vertexStart;                                                                  \n    destSI.stageInOrigin[1] = src.baseInstance;                                                                 \n    destSI.stageInOrigin[2] = 0;                                                                                \n    destSI.stageInSize[0] = src.vertexCount;                                                                    \n    destSI.stageInSize[1] = src.instanceCount;                                                                  \n    destSI.stageInSize[2] = 1;                                                                                  \n#endif                                                                                                          \n}                                                                                                               \n                                                                                                                \nkernel void cmdDrawIndexedIndirectTessConvertBuffers(const device char* srcBuff [[buffer(0)]],                  \n                                                     device char* destBuff [[buffer(1)]],                       \n                                                     device char* paramsBuff [[buffer(2)]],                     \n                                                     constant uint32_t& srcStride [[buffer(3)]],                \n                                                     constant uint32_t& inControlPointCount [[buffer(4)]],      \n                                                     constant uint32_t& outControlPointCount [[buffer(5)]],     \n                                                     constant uint32_t& drawCount [[buffer(6)]],                \n                                                     constant uint32_t& vtxThreadExecWidth [[buffer(7)]],       \n                                                     constant uint32_t& tcWorkgroupSize [[buffer(8)]],          \n                                                     uint idx [[thread_position_in_grid]]) {                    \n    if (idx >= drawCount) { return; }                                                                           \n    const device auto& src = *reinterpret_cast<const device MTLDrawIndexedPrimitivesIndirectArguments*>(srcBuff + idx * srcStride);\n    device char* dest
device const
device uint* spvIndirectParams [[buffer
device-id
deviceDescription
devicecoherent
dfffff
dictionaryWithObjects:forKeys:count
didModifyRange
dimensionality
dindSparse
ding3N
direct index
direct index for structure
directive must end with a newline
disable
discard
discard_fragment
discard_fragment() does not formally have demote semantics until MSL 2.3
discƃ\b
dispatchThreadgroups:threadsPerThreadgroup
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup
dispatchThreads:threadsPerThreadgroup
dispatch_async
dispatch_data_create
dispatch_get_global_queue
dispatch_main_q
dispatch_queue_attr_make_with_qos_class
dispatch_queue_create
dispatch_release
dispatch_sync
displaySyncEnabled
displaySyncEnabledMVK
distance
distanceI
divide
divide second child into first child
division by 0
djacencyH
dmat2x2
dmat2x3
dmat2x4
dmat3x2
dmat3x3
dmat3x4
dmat4x2
dmat4x3
dmat4x4
do-while loops not available
does not apply to floating point images
does not apply to signed integer images
does not apply to this type
does not apply to unsigned integer images
does not fit in a
does not operate on this type
does not operate on types containing (u)int16
does not operate on types containing (u)int8
does not operate on types containing float16
does not produce a result ID
does not reference an OpExtInstImport result Id
dont_flaH3\b
dont_flaH3s
dont_flatten
dont_unrH3\bH
dont_unroll
dot-product
double
double floating-point suffix
double fma(double, double, double);dvec2  fma(dvec2,  dvec2,  dvec2 );dvec3  fma(dvec3,  dvec3,  dvec3 );dvec4  fma(dvec4,  dvec4,  dvec4 );\n
double frexp(double, out int);dvec2  frexp( dvec2, out ivec2);dvec3  frexp( dvec3, out ivec3);dvec4  frexp( dvec4, out ivec4);double ldexp(double, int);dvec2  ldexp( dvec2, ivec2);dvec3  ldexp( dvec3, ivec3);dvec4  ldexp( dvec4, ivec4);double packDouble2x32(uvec2);uvec2 unpackDouble2x32(double);\n
double literal
double matrix
double sqrt(double);dvec2  sqrt(dvec2);dvec3  sqrt(dvec3);dvec4  sqrt(dvec4);double inversesqrt(double);dvec2  inversesqrt(dvec2);dvec3  inversesqrt(dvec3);dvec4  inversesqrt(dvec4);double abs(double);dvec2  abs(dvec2);dvec3  abs(dvec3);dvec4  abs(dvec4);double sign(double);dvec2  sign(dvec2);dvec3  sign(dvec3);dvec4  sign(dvec4);double floor(double);dvec2  floor(dvec2);dvec3  floor(dvec3);dvec4  floor(dvec4);double trunc(double);dvec2  trunc(dvec2);dvec3  trunc(dvec3);dvec4  trunc(dvec4);double round(double);dvec2  round(dvec2);dvec3  round(dvec3);dvec4  round(dvec4);double roundEven(double);dvec2  roundEven(dvec2);dvec3  roundEven(dvec3);dvec4  roundEven(dvec4);double ceil(double);dvec2  ceil(dvec2);dvec3  ceil(dvec3);dvec4  ceil(dvec4);double fract(double);dvec2  fract(dvec2);dvec3  fract(dvec3);dvec4  fract(dvec4);double mod(double, double);dvec2  mod(dvec2 , double);dvec3  mod(dvec3 , double);dvec4  mod(dvec4 , double);dvec2  mod(dvec2 , dvec2);dvec3  mod(dvec3 , dvec3);dvec4  mod(dvec4 , dvec4);double modf(double, out double);dvec2  modf(dvec2,  out dvec2);dvec3  modf(dvec3,  out dvec3);dvec4  modf(dvec4,  out dvec4);double min(double, double);dvec2  min(dvec2,  double);dvec3  min(dvec3,  double);dvec4  min(dvec4,  double);dvec2  min(dvec2,  dvec2);dvec3  min(dvec3,  dvec3);dvec4  min(dvec4,  dvec4);double max(double, double);dvec2  max(dvec2 , double);dvec3  max(dvec3 , double);dvec4  max(dvec4 , double);dvec2  max(dvec2 , dvec2);dvec3  max(dvec3 , dvec3);dvec4  max(dvec4 , dvec4);double clamp(double, double, double);dvec2  clamp(dvec2 , double, double);dvec3  clamp(dvec3 , double, double);dvec4  clamp(dvec4 , double, double);dvec2  clamp(dvec2 , dvec2 , dvec2);dvec3  clamp(dvec3 , dvec3 , dvec3);dvec4  clamp(dvec4 , dvec4 , dvec4);double mix(double, double, double);dvec2  mix(dvec2,  dvec2,  double);dvec3  mix(dvec3,  dvec3,  double);dvec4  mix(dvec4,  dvec4,  double);dvec2  mix(dvec2,  dvec2,  dvec2);dvec3  mix(dvec3,  dvec3,  dvec3);dvec4  mix(dvec4,  dvec4,  dvec4);double mix(double, double, bool);dvec2  mix(dvec2,  dvec2,  bvec2);dvec3  mix(dvec3,  dvec3,  bvec3);dvec4  mix(dvec4,  dvec4,  bvec4);double step(double, double);dvec2  step(dvec2 , dvec2);dvec3  step(dvec3 , dvec3);dvec4  step(dvec4 , dvec4);dvec2  step(double, dvec2);dvec3  step(double, dvec3);dvec4  step(double, dvec4);double smoothstep(double, double, double);dvec2  smoothstep(dvec2 , dvec2 , dvec2);dvec3  smoothstep(dvec3 , dvec3 , dvec3);dvec4  smoothstep(dvec4 , dvec4 , dvec4);dvec2  smoothstep(double, double, dvec2);dvec3  smoothstep(double, double, dvec3);dvec4  smoothstep(double, double, dvec4);bool  isnan(double);bvec2 isnan(dvec2);bvec3 isnan(dvec3);bvec4 isnan(dvec4);bool  isinf(double);bvec2 isinf(dvec2);bvec3 isinf(dvec3);bvec4 isinf(dvec4);double length(double);double length(dvec2);double length(dvec3);double length(dvec4);double distance(double, double);double distance(dvec2 , dvec2);double distance(dvec3 , dvec3);double distance(dvec4 , dvec4);double dot(double, double);double dot(dvec2 , dvec2);double dot(dvec3 , dvec3);double dot(dvec4 , dvec4);dvec3 cross(dvec3, dvec3);double normalize(double);dvec2  normalize(dvec2);dvec3  normalize(dvec3);dvec4  normalize(dvec4);double faceforward(double, double, double);dvec2  faceforward(dvec2,  dvec2,  dvec2);dvec3  faceforward(dvec3,  dvec3,  dvec3);dvec4  faceforward(dvec4,  dvec4,  dvec4);double reflect(double, double);dvec2  reflect(dvec2 , dvec2 );dvec3  reflect(dvec3 , dvec3 );dvec4  reflect(dvec4 , dvec4 );double refract(double, double, double);dvec2  refract(dvec2 , dvec2 , double);dvec3  refract(dvec3 , dvec3 , double);dvec4  refract(dvec4 , dvec4 , double);dmat2 matrixCompMult(dmat2, dmat2);dmat3 matrixCompMult(dmat3, dmat3);dmat4 matrixCompMult(dmat4, dmat4);dmat2x3 matrixCompMult(dmat2x3, dmat2x3);dmat2x4 matrixCompMult(dmat2x4, dmat2x4);dmat3x2 matrixCompMult(dmat3x2, dmat3x2);dmat3x4 matrixCompMult(dmat3x4, dmat3x4);dmat4x2 matrixCompMult(dmat4x2, dmat4x2);dmat4x3 matrixCompMult(dmat4x3, dmat4x3);dmat2   outerProduct(dvec2, dvec2);dmat3   outerProduct(dvec3, dvec3);dmat4   ou
double types are not supported in buffers in MSL
double vector
doubleBitsToInt64
doubleBitsToUint64
doubles cannot start on an odd-numbered component
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawPrimitives:indirectBuffer:indirectBufferOffset
drawPrimitives:vertexStart:vertexCount
drawPrimitives:vertexStart:vertexCount:instanceCount
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance
drawableSize
dressKHRH
dst[i] = src[i
dst[i], src[i
duplicate label
duplicate macro parameter
duplicate member name
duplicated value
dvec2(0.0LF
dvec2(0.H
dvec2(1.0LF
dvec2(1.H
dvec3(0.0LF
dvec3(0.H
dvec3(1.0LF
dvec3(1.H
dvec4(0.0LF
dvec4(0.H
dvec4(1.0LF
dvec4(1.H
dx-position-w
dyld_stub_binder
dynamic offset
dynamically to functions
e@_OBJC_CLASS_$_NSObject
e@_objc_alloc
e@_objc_autorelease
e@_objc_autoreleasePoolPop
e@_objc_autoreleasePoolPush
e@_objc_enumerationMutation
e@_objc_msgSendSuper2
e@_objc_msgSend_stret
e@_objc_sync_enter
e@_objc_sync_exit
eActionFromVkAttachmentStoreOp
eAddressH
eAddƅE
eInsertDebugUtilsLabelEXT
eMaskKHRH
eMulƅ5
ePresentKHR
eProjLodH3H
eProjLodH3q
eProjLodI3F\aH\t
eSamplerH
eSubmit
eSubmit2H
eWaitIdle
e_bufferH
e_bufferL
e_gatherH
e_matrixH
e_shaderH
eadgroupH3P
early_and_late_fragment_tests_amd
early_frH
early_fragment_tests
early_fragment_tests ]] fragment
eatures
ebugMarker
ec3   minInvocationsExclusiveScanAMD(f16vec3);f16vec4   minInvocationsExclusiveScanAMD(f16vec4);int16_t minInvocationsExclusiveScanAMD(int16_t);i16vec2 minInvocationsExclusiveScanAMD(i16vec2);i16vec3 minInvocationsExclusiveScanAMD(i16vec3);i16vec4 minInvocationsExclusiveScanAMD(i16vec4);uint16_t minInvocationsExclusiveScanAMD(uint16_t);u16vec2  minInvocationsExclusiveScanAMD(u16vec2);u16vec3  minInvocationsExclusiveScanAMD(u16vec3);u16vec4  minInvocationsExclusiveScanAMD(u16vec4);float maxInvocationsAMD(float);vec2  maxInvocationsAMD(vec2);vec3  maxInvocationsAMD(vec3);vec4  maxInvocationsAMD(vec4);int   maxInvocationsAMD(int);ivec2 maxInvocationsAMD(ivec2);ivec3 maxInvocationsAMD(ivec3);ivec4 maxInvocationsAMD(ivec4);uint  maxInvocationsAMD(uint);uvec2 maxInvocationsAMD(uvec2);uvec3 maxInvocationsAMD(uvec3);uvec4 maxInvocationsAMD(uvec4);double maxInvocationsAMD(double);dvec2  maxInvocationsAMD(dvec2);dvec3  maxInvocationsAMD(dvec3);dvec4  maxInvocationsAMD(dvec4);int64_t maxInvocationsAMD(int64_t);i64vec2 maxInvocationsAMD(i64vec2);i64vec3 maxInvocationsAMD(i64vec3);i64vec4 maxInvocationsAMD(i64vec4);uint64_t maxInvocationsAMD(uint64_t);u64vec2  maxInvocationsAMD(u64vec2);u64vec3  maxInvocationsAMD(u64vec3);u64vec4  maxInvocationsAMD(u64vec4);float16_t maxInvocationsAMD(float16_t);f16vec2   maxInvocationsAMD(f16vec2);f16vec3   maxInvocationsAMD(f16vec3);f16vec4   maxInvocationsAMD(f16vec4);int16_t maxInvocationsAMD(int16_t);i16vec2 maxInvocationsAMD(i16vec2);i16vec3 maxInvocationsAMD(i16vec3);i16vec4 maxInvocationsAMD(i16vec4);uint16_t maxInvocationsAMD(uint16_t);u16vec2  maxInvocationsAMD(u16vec2);u16vec3  maxInvocationsAMD(u16vec3);u16vec4  maxInvocationsAMD(u16vec4);float maxInvocationsInclusiveScanAMD(float);vec2  maxInvocationsInclusiveScanAMD(vec2);vec3  maxInvocationsInclusiveScanAMD(vec3);vec4  maxInvocationsInclusiveScanAMD(vec4);int   maxInvocationsInclusiveScanAMD(int);ivec2 maxInvocationsInclusiveScanAMD(ivec2);ivec3 maxInvocationsInclusiveScanAMD(ivec3);ivec4 maxInvocationsInclusiveScanAMD(ivec4);uint  maxInvocationsInclusiveScanAMD(uint);uvec2 maxInvocationsInclusiveScanAMD(uvec2);uvec3 maxInvocationsInclusiveScanAMD(uvec3);uvec4 maxInvocationsInclusiveScanAMD(uvec4);double maxInvocationsInclusiveScanAMD(double);dvec2  maxInvocationsInclusiveScanAMD(dvec2);dvec3  maxInvocationsInclusiveScanAMD(dvec3);dvec4  maxInvocationsInclusiveScanAMD(dvec4);int64_t maxInvocationsInclusiveScanAMD(int64_t);i64vec2 maxInvocationsInclusiveScanAMD(i64vec2);i64vec3 maxInvocationsInclusiveScanAMD(i64vec3);i64vec4 maxInvocationsInclusiveScanAMD(i64vec4);uint64_t maxInvocationsInclusiveScanAMD(uint64_t);u64vec2  maxInvocationsInclusiveScanAMD(u64vec2);u64vec3  maxInvocationsInclusiveScanAMD(u64vec3);u64vec4  maxInvocationsInclusiveScanAMD(u64vec4);float16_t maxInvocationsInclusiveScanAMD(float16_t);f16vec2   maxInvocationsInclusiveScanAMD(f16vec2);f16vec3   maxInvocationsInclusiveScanAMD(f16vec3);f16vec4   maxInvocationsInclusiveScanAMD(f16vec4);int16_t maxInvocationsInclusiveScanAMD(int16_t);i16vec2 maxInvocationsInclusiveScanAMD(i16vec2);i16vec3 maxInvocationsInclusiveScanAMD(i16vec3);i16vec4 maxInvocationsInclusiveScanAMD(i16vec4);uint16_t maxInvocationsInclusiveScanAMD(uint16_t);u16vec2  maxInvocationsInclusiveScanAMD(u16vec2);u16vec3  maxInvocationsInclusiveScanAMD(u16vec3);u16vec4  maxInvocationsInclusiveScanAMD(u16vec4);float maxInvocationsExclusiveScanAMD(float);vec2  maxInvocationsExclusiveScanAMD(vec2);vec3  maxInvocationsExclusiveScanAMD(vec3);vec4  maxInvocationsExclusiveScanAMD(vec4);int   maxInvocationsExclusiveScanAMD(int);ivec2 maxInvocationsExclusiveScanAMD(ivec2);ivec3 maxInvocationsExclusiveScanAMD(ivec3);ivec4 maxInvocationsExclusiveScanAMD(ivec4);uint  maxInvocationsExclusiveScanAMD(uint);uvec2 maxInvocationsExclusiveScanAMD(uvec2);uvec3 maxInvocationsExclusiveScanAMD(uvec3);uvec4 maxInvocationsExclusiveScanAMD(uvec4);double maxInvocationsExclusiveScanAMD(double);dvec2  maxInvocationsExclusiveScanAMD(dvec2);dvec3  maxInvocationsExclusiveScanAMD(dvec3);dvec4  maxInvocationsExclusiveScanAMD(dvec4);int64_t ma
ectCountH
ectangleH
edgeTessellationFactor
eerMemoryFeatures
eferenceH
effff
efffff
effffff
eginCommandBuffer
eginDebugUtilsLabelEXT
either the block needs a location, or all members need a location, or no members have a location
element array of
elements
elif !defined(GL_INTEL_fragment_shader_ordering
elif after #else
elif defined(GL_AMD_gpu_shader_int16
elif defined(GL_EXT_shader_explicit_arithmetic_types_float16
elif defined(GL_INTEL_fragment_shader_ordering
elif defined(GL_NV_gpu_shader5
else after #else
else if (Coords.y >= Coords.x && Coords.y >= Coords.z
emaphoreCounterValue
emoryHostPointerPropertiesEXT
empty { } initializer
enable
encodeSignalEvent:value
encodeWaitForEvent:value
encodedLength
end of file
endEncoding
endInvocationInterlockARB
endInvocationInterlockARB() cannot be placed after a return from main
endInvocationInterlockARB() cannot be placed within flow control
endInvocationInterlockARB() must be in a fragment shader
endInvocationInterlockARB() must be in main
endInvocationInterlockARB() must only be called once
endScope
endif
enqueue
entry point cannot return a value
entry-point
entryPoiH
entryPoints
ents2KHRH
enum class spvChromaFilter
enum class spvFormatResolution
enum class spvSwizzle : uint
enum class spvXChromaLocation
enum class spvYCbCrModelConversion
enum class spvYCbCrRange
enum class spvYChromaLocation
environment
epthH\t
equal_spH
equal_spacing
equality_expression
erEndEXTH
erModuleH
erViewNVH;E
er_int16H
er_int64H
er_int64fH
erformanceStatisticsMVK
eringKHRH
error
error Fragment Shader Interlock/Ordering extension missing
error GL_ARB_shader_draw_parameters is not supported
error No extension available for 64-bit integers
error No extension available for FP16
error No extension available for Int16
error No extension available for Int8
error No extensions available to emulate requested subgroup feature
error adding atomic counter to atomic counter block
error adding uniform to default uniform block
errorOptions
errorState
erties2
es_adjacH
esentRectanglesKHR
etEvent2H
etFencesH
evice MTLDrawIndexedPrimitivesIndirectArguments& params [[buffer(2)]],\n                                            uint i [[thread_position_in_grid]]) {                               \n    destBuff[i] = srcBuff[params.indexStart + i];                                                               \n}                                                                                                               \n                                                                                                                \nkernel void cmdDrawIndexedCopyIndex32Buffer(const device uint32_t* srcBuff [[buffer(0)]],                       \n                                            device uint32_t* destBuff [[buffer(1)]],                            \n                                            const device MTLDrawIndexedPrimitivesIndirectArguments& params [[buffer(2)]],\n                                            uint i [[thread_position_in_grid]]) {                               \n    destBuff[i] = srcBuff[params.indexStart + i];                                                               \n}                                                                                                               \n                                                                                                                \n#endif                                                                                                          \n                                                                                                                \ntypedef struct {                                                                                                \n    uint32_t count;                                                                                             \n    uint32_t countHigh;                                                                                         \n} VisibilityBuffer;                                                                                             \n                                                                                                                \ntypedef enum {                                                                                                  \n    Initial,                                                                                                    \n    DeviceAvailable,                                                                                            \n    Available                                                                                                   \n} QueryStatus;                                                                                                  \n                                                                                                                \ntypedef enum {                                                                                                  \n    VK_QUERY_RESULT_64_BIT                = 0x00000001,                                                         \n    VK_QUERY_RESULT_WAIT_BIT              = 0x00000002,                                                         \n    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,                                                         \n    VK_QUERY_RESULT_PARTIAL_BIT           = 0x00000008,                                                         \n} VkQueryResultFlagBits;                                                                                        \n                                                                                                                \nkernel void cmdCopyQueryPoolResultsToBuffer(const device VisibilityBuffer* src [[buffer(0)]],                   \n                                            device uint8_t* dest [[buffer(1)]],                                 \n                                            constant uint& stride [[buffer(2)]],                                \n                                            constant uint& numQueries [[buffer(3)]],                            \n
excl_scan
exclusive or second child into first child
exclusive-or
exclusive_or_expression
executeCallableEXT
executeCallableKHR
executeCallableNV
execution mode
execution model
expect an array name
expected
expected 16, 32, or 64 bits for first type parameter
expected 8, 16, 32, or 64 bit signed or unsigned integer or 16, 32, or 64 bit float type
expected 8, 16, or 32 bits for first type parameter
expected a single integer argument
expected after 'debug' keyword
expected after 'optimize' keyword
expected after result id but found
expected four type parameters
expected more operands after
expected newline after header name
expected no arguments
expected no more operands after
expected to end 'debug' pragma
expected to end 'optimize' pragma
expected type name
explicit interpolation
explicitInterpAMD
expression
expression_statement
extensioH3
extensioI3D
extension
extension 'all' cannot have 'require' or 'enable' behavior
extension GL_AMD_gpu_shader_half_float : require
extension GL_AMD_gpu_shader_int16 : require
extension GL_ARB_fragment_shader_interlock : enable
extension GL_ARB_gpu_shader_int64 : require
extension GL_ARB_post_depth_coverage : require
extension GL_ARB_shading_language_420pack : require
extension GL_EXT_control_flow_attributes : require
extension GL_EXT_mesh_shader
extension GL_EXT_post_depth_coverage : require
extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
extension GL_INTEL_fragment_shader_ordering : enable
extension GL_NV_fragment_shader_interlock : require
extension GL_NV_gpu_shader5 : require
extension GL_NV_mesh_shader
extension instruction number
extension is only partially supported
extension name expected
extension name not specified
extension not supported
extensions
extern
external
external_declaration
extra content after header name
extra tokens
extra tokens -- expected newline
extract_bits
extraneous semicolon
f t9H
f#\f(\f-\f3\f8\f=\fB\fH\fM\fR\fW\f]\fb\fg\fl\fr\fw\f|\f
f$H9H0vAH
f$I9L$\bt@1
f(I9NHs
f16image1D
f16image1DArray
f16image2D
f16image2DArray
f16image2DMS
f16image2DMSArray
f16image2DRect
f16image3D
f16imageBuffer
f16imageCube
f16imageCubeArray
f16mat
f16mat2
f16mat2x2
f16mat2x3
f16mat2x4
f16mat3
f16mat3x2
f16mat3x3
f16mat3x4
f16mat4
f16mat4x2
f16mat4x3
f16mat4x4
f16sampler1D
f16sampler1DArray
f16sampler1DArrayShadow
f16sampler1DShadow
f16sampler2D
f16sampler2DArray
f16sampler2DArrayShadow
f16sampler2DMS
f16sampler2DMSArray
f16sampler2DRect
f16sampler2DRectShadow
f16sampler2DShadow
f16sampler3D
f16samplerBuffer
f16samplerCube
f16samplerCubeArray
f16samplerCubeArrayShadow
f16samplerCubeShadow
f16subpassInput
f16subpassInputMS
f16texture1D
f16texture1DArray
f16texture2D
f16texture2DArray
f16texture2DMS
f16texture2DMSArray
f16texture2DRect
f16texture3D
f16textureBuffer
f16textureCube
f16textureCubeArray
f16vec
f16vec2
f16vec3
f16vec4
f32mat2
f32mat2x2
f32mat2x3
f32mat2x4
f32mat3
f32mat3x2
f32mat3x3
f32mat3x4
f32mat4
f32mat4x2
f32mat4x3
f32mat4x4
f32vec2
f32vec3
f32vec4
f64mat2
f64mat2x2
f64mat2x3
f64mat2x4
f64mat3
f64mat3x2
f64mat3x3
f64mat3x4
f64mat4
f64mat4x2
f64mat4x3
f64mat4x4
f64vec2
f64vec3
f64vec3 );f64vec4  reflect(f64vec4 , f64vec4 );float64_t refract(float64_t, float64_t, float64_t);f64vec2  refract(f64vec2 , f64vec2 , float64_t);f64vec3  refract(f64vec3 , f64vec3 , float64_t);f64vec4  refract(f64vec4 , f64vec4 , float64_t);f64mat2 matrixCompMult(f64mat2, f64mat2);f64mat3 matrixCompMult(f64mat3, f64mat3);f64mat4 matrixCompMult(f64mat4, f64mat4);f64mat2x3 matrixCompMult(f64mat2x3, f64mat2x3);f64mat2x4 matrixCompMult(f64mat2x4, f64mat2x4);f64mat3x2 matrixCompMult(f64mat3x2, f64mat3x2);f64mat3x4 matrixCompMult(f64mat3x4, f64mat3x4);f64mat4x2 matrixCompMult(f64mat4x2, f64mat4x2);f64mat4x3 matrixCompMult(f64mat4x3, f64mat4x3);f64mat2   outerProduct(f64vec2, f64vec2);f64mat3   outerProduct(f64vec3, f64vec3);f64mat4   outerProduct(f64vec4, f64vec4);f64mat2x3 outerProduct(f64vec3, f64vec2);f64mat3x2 outerProduct(f64vec2, f64vec3);f64mat2x4 outerProduct(f64vec4, f64vec2);f64mat4x2 outerProduct(f64vec2, f64vec4);f64mat3x4 outerProduct(f64vec4, f64vec3);f64mat4x3 outerProduct(f64vec3, f64vec4);f64mat2   transpose(f64mat2);f64mat3   transpose(f64mat3);f64mat4   transpose(f64mat4);f64mat2x3 transpose(f64mat3x2);f64mat3x2 transpose(f64mat2x3);f64mat2x4 transpose(f64mat4x2);f64mat4x2 transpose(f64mat2x4);f64mat3x4 transpose(f64mat4x3);f64mat4x3 transpose(f64mat3x4);float64_t determinant(f64mat2);float64_t determinant(f64mat3);float64_t determinant(f64mat4);f64mat2 inverse(f64mat2);f64mat3 inverse(f64mat3);f64mat4 inverse(f64mat4);\n
f64vec4
f8MSLResourceBinding7matchesERKS0
f@I9E0H
f@u:I
f@uBH
fA\tF8I
fBuffer
fDescriptorPool
fH9H0v
fI9D$0
fI9G0v"I
fRH9S0v
fRH9W0v
fRI9U0v
f[I9]0vM
f\bt HcC
f\bt!H
f\bt#I
f\bt~A
f\bu@ǃL\a
f\buI
f\n\r\t\v
f_arraysH
face-forward
faceforward
failed to insert the global constant buffer
false case\n
falsfǅE
fast::clamp
fast::cosh
fast::max
fast::min
fast::normalize
fast::sinh
fastMathEnabled
fast_distance
fast_length
fast_normalize
faulted
fclamp
fclose
fcoopmatNV
fd418aa7fe5c69ddba00b8cfd6611cef03f13011
feature not yet implemented
ference2H
ferredOperation
fffff
ffffff
fffffff
fflush
fileExistsAtPath:isDirectory
fileNameERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEb
fileURLWithPath
filename-based #line
filename-based __FILE
fillBuffer:range:value
filter
filter::H
filter::linear
findLSB
findMSB
first argument must be an interpolant, or interpolant-array element
flat  in lowp     int gl_SampleID;      in mediump vec2 gl_SamplePosition;flat  in highp    int gl_SampleMaskIn[];     out highp    int gl_SampleMask
flat in  int  gl_SampleID;     in  vec2 gl_SamplePosition;     out int  gl_SampleMask
flat in  int  gl_SampleMaskIn
flat in highp int gl_DeviceIndex;flat in highp int gl_ViewIndex;\n
flat in highp int gl_ShadingRateEXT
flat in highp uint gl_ViewID_OVR;\n
flat in int gl_Layer;flat in int gl_ViewportIndex
flat in int gl_PrimitiveID
flat in int gl_ShadingRateEXT
flat in ivec2 gl_FragSizeEXT;flat in int   gl_FragInvocationCountEXT
flat in ivec2 gl_FragmentSizeNV;flat in int   gl_InvocationsPerPixelNV
flat in ivec2 gl_FragmentSizeNV;flat in int   gl_InvocationsPerPixelNV;in vec3 gl_BaryCoordNV;in vec3 gl_BaryCoordNoPerspNV;in vec3 gl_BaryCoordEXT;in vec3 gl_BaryCoordNoPerspEXT
flat in mediump uint  gl_SubgroupSize;flat in mediump uint  gl_SubgroupInvocationID;flat in highp   uvec4 gl_SubgroupEqMask;flat in highp   uvec4 gl_SubgroupGeMask;flat in highp   uvec4 gl_SubgroupGtMask;flat in highp   uvec4 gl_SubgroupLeMask;flat in highp   uvec4 gl_SubgroupLtMask;flat in highp   uint  gl_WarpsPerSMNV;flat in highp   uint  gl_SMCountNV;flat in highp   uint  gl_WarpIDNV;flat in highp   uint  gl_SMIDNV;flat in highp   uint  gl_CoreIDARM;flat in highp   uint  gl_CoreCountARM;flat in highp   uint  gl_CoreMaxIDARM;flat in highp   uint  gl_WarpIDARM;flat in highp   uint  gl_WarpMaxIDARM;\n
flat/smooth/noperspective
flat3K
flat3\b
flatten
float
float  fma(float,  float,  float );vec2   fma(vec2,   vec2,   vec2  );vec3   fma(vec3,   vec3,   vec3  );vec4   fma(vec4,   vec4,   vec4  );\n
float CubeFace = 0
float ProjectionAxis = 0
float cubeFaceIndexAMD(vec3);vec2  cubeFaceCoordAMD(vec3);uint64_t timeAMD();in int gl_SIMDGroupSizeAMD;\n
float dFdxFine(float p);vec2  dFdxFine(vec2  p);vec3  dFdxFine(vec3  p);vec4  dFdxFine(vec4  p);float dFdyFine(float p);vec2  dFdyFine(vec2  p);vec3  dFdyFine(vec3  p);vec4  dFdyFine(vec4  p);float fwidthFine(float p);vec2  fwidthFine(vec2  p);vec3  fwidthFine(vec3  p);vec4  fwidthFine(vec4  p);float dFdxCoarse(float p);vec2  dFdxCoarse(vec2  p);vec3  dFdxCoarse(vec3  p);vec4  dFdxCoarse(vec4  p);float dFdyCoarse(float p);vec2  dFdyCoarse(vec2  p);vec3  dFdyCoarse(vec3  p);vec4  dFdyCoarse(vec4  p);float fwidthCoarse(float p);vec2  fwidthCoarse(vec2  p);vec3  fwidthCoarse(vec3  p);vec4  fwidthCoarse(vec4  p
float det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0
float det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]) + (adj[0][2] * m[2][0
float det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]) + (adj[0][2] * m[2][0]) + (adj[0][3] * m[3][0
float determinant(mat2 m);float determinant(mat3 m);float determinant(mat4 m);mat2 inverse(mat2 m);mat3 inverse(mat3 m);mat4 inverse(mat4 m);\n
float frexp(highp float, out highp int);vec2  frexp(highp vec2,  out highp ivec2);vec3  frexp(highp vec3,  out highp ivec3);vec4  frexp(highp vec4,  out highp ivec4);float ldexp(highp float, highp int);vec2  ldexp(highp vec2,  highp ivec2);vec3  ldexp(highp vec3,  highp ivec3);vec4  ldexp(highp vec4,  highp ivec4);\n
float gl_ClipDistance
float gl_CullDistance
float gl_CullDistance[];vec4 gl_SecondaryPositionNV;vec4 gl_PositionPerViewNV
float gl_PointSize
float imageAtomicAdd(volatile coherent
float imageAtomicExchange(volatile coherent
float imageAtomicLoad(readonly volatile coherent
float imageAtomicMax(volatile coherent
float imageAtomicMin(volatile coherent
float interpolateAtCentroid(float);vec2  interpolateAtCentroid(vec2);vec3  interpolateAtCentroid(vec3);vec4  interpolateAtCentroid(vec4);float interpolateAtSample(float, int);vec2  interpolateAtSample(vec2,  int);vec3  interpolateAtSample(vec3,  int);vec4  interpolateAtSample(vec4,  int);float interpolateAtOffset(float, vec2);vec2  interpolateAtOffset(vec2,  vec2);vec3  interpolateAtOffset(vec3,  vec2);vec4  interpolateAtOffset(vec4,  vec2);\n
float interpolateAtVertexAMD(float, uint);vec2  interpolateAtVertexAMD(vec2,  uint);vec3  interpolateAtVertexAMD(vec3,  uint);vec4  interpolateAtVertexAMD(vec4,  uint);int   interpolateAtVertexAMD(int,   uint);ivec2 interpolateAtVertexAMD(ivec2, uint);ivec3 interpolateAtVertexAMD(ivec3, uint);ivec4 interpolateAtVertexAMD(ivec4, uint);uint  interpolateAtVertexAMD(uint,  uint);uvec2 interpolateAtVertexAMD(uvec2, uint);uvec3 interpolateAtVertexAMD(uvec3, uint);uvec4 interpolateAtVertexAMD(uvec4, uint);float16_t interpolateAtVertexAMD(float16_t, uint);f16vec2   interpolateAtVertexAMD(f16vec2,   uint);f16vec3   interpolateAtVertexAMD(f16vec3,   uint);f16vec4   interpolateAtVertexAMD(f16vec4,   uint);\n
float literal needs a decimal point or exponent
float literal too long
float lod
float min3(float, float, float);vec2  min3(vec2,  vec2,  vec2);vec3  min3(vec3,  vec3,  vec3);vec4  min3(vec4,  vec4,  vec4);int   min3(int,   int,   int);ivec2 min3(ivec2, ivec2, ivec2);ivec3 min3(ivec3, ivec3, ivec3);ivec4 min3(ivec4, ivec4, ivec4);uint  min3(uint,  uint,  uint);uvec2 min3(uvec2, uvec2, uvec2);uvec3 min3(uvec3, uvec3, uvec3);uvec4 min3(uvec4, uvec4, uvec4);float max3(float, float, float);vec2  max3(vec2,  vec2,  vec2);vec3  max3(vec3,  vec3,  vec3);vec4  max3(vec4,  vec4,  vec4);int   max3(int,   int,   int);ivec2 max3(ivec2, ivec2, ivec2);ivec3 max3(ivec3, ivec3, ivec3);ivec4 max3(ivec4, ivec4, ivec4);uint  max3(uint,  uint,  uint);uvec2 max3(uvec2, uvec2, uvec2);uvec3 max3(uvec3, uvec3, uvec3);uvec4 max3(uvec4, uvec4, uvec4);float mid3(float, float, float);vec2  mid3(vec2,  vec2,  vec2);vec3  mid3(vec3,  vec3,  vec3);vec4  mid3(vec4,  vec4,  vec4);int   mid3(int,   int,   int);ivec2 mid3(ivec2, ivec2, ivec2);ivec3 mid3(ivec3, ivec3, ivec3);ivec4 mid3(ivec4, ivec4, ivec4);uint  mid3(uint,  uint,  uint);uvec2 mid3(uvec2, uvec2, uvec2);uvec3 mid3(uvec3, uvec3, uvec3);uvec4 mid3(uvec4, uvec4, uvec4);float16_t min3(float16_t, float16_t, float16_t);f16vec2   min3(f16vec2,   f16vec2,   f16vec2);f16vec3   min3(f16vec3,   f16vec3,   f16vec3);f16vec4   min3(f16vec4,   f16vec4,   f16vec4);float16_t max3(float16_t, float16_t, float16_t);f16vec2   max3(f16vec2,   f16vec2,   f16vec2);f16vec3   max3(f16vec3,   f16vec3,   f16vec3);f16vec4   max3(f16vec4,   f16vec4,   f16vec4);float16_t mid3(float16_t, float16_t, float16_t);f16vec2   mid3(f16vec2,   f16vec2,   f16vec2);f16vec3   mid3(f16vec3,   f16vec3,   f16vec3);f16vec4   mid3(f16vec4,   f16vec4,   f16vec4);int16_t   min3(int16_t,   int16_t,   int16_t);i16vec2   min3(i16vec2,   i16vec2,   i16vec2);i16vec3   min3(i16vec3,   i16vec3,   i16vec3);i16vec4   min3(i16vec4,   i16vec4,   i16vec4);int16_t   max3(int16_t,   int16_t,   int16_t);i16vec2   max3(i16vec2,   i16vec2,   i16vec2);i16vec3   max3(i16vec3,   i16vec3,   i16vec3);i16vec4   max3(i16vec4,   i16vec4,   i16vec4);int16_t   mid3(int16_t,   int16_t,   int16_t);i16vec2   mid3(i16vec2,   i16vec2,   i16vec2);i16vec3   mid3(i16vec3,   i16vec3,   i16vec3);i16vec4   mid3(i16vec4,   i16vec4,   i16vec4);uint16_t  min3(uint16_t,  uint16_t,  uint16_t);u16vec2   min3(u16vec2,   u16vec2,   u16vec2);u16vec3   min3(u16vec3,   u16vec3,   u16vec3);u16vec4   min3(u16vec4,   u16vec4,   u16vec4);uint16_t  max3(uint16_t,  uint16_t,  uint16_t);u16vec2   max3(u16vec2,   u16vec2,   u16vec2);u16vec3   max3(u16vec3,   u16vec3,   u16vec3);u16vec4   max3(u16vec4,   u16vec4,   u16vec4);uint16_t  mid3(uint16_t,  uint16_t,  uint16_t);u16vec2   mid3(u16vec2,   u16vec2,   u16vec2);u16vec3   mid3(u16vec3,   u16vec3,   u16vec3);u16vec4   mid3(u16vec4,   u16vec4,   u16vec4);\n
float minInvocationsAMD(float);vec2  minInvocationsAMD(vec2);vec3  minInvocationsAMD(vec3);vec4  minInvocationsAMD(vec4);int   minInvocationsAMD(int);ivec2 minInvocationsAMD(ivec2);ivec3 minInvocationsAMD(ivec3);ivec4 minInvocationsAMD(ivec4);uint  minInvocationsAMD(uint);uvec2 minInvocationsAMD(uvec2);uvec3 minInvocationsAMD(uvec3);uvec4 minInvocationsAMD(uvec4);double minInvocationsAMD(double);dvec2  minInvocationsAMD(dvec2);dvec3  minInvocationsAMD(dvec3);dvec4  minInvocationsAMD(dvec4);int64_t minInvocationsAMD(int64_t);i64vec2 minInvocationsAMD(i64vec2);i64vec3 minInvocationsAMD(i64vec3);i64vec4 minInvocationsAMD(i64vec4);uint64_t minInvocationsAMD(uint64_t);u64vec2  minInvocationsAMD(u64vec2);u64vec3  minInvocationsAMD(u64vec3);u64vec4  minInvocationsAMD(u64vec4);float16_t minInvocationsAMD(float16_t);f16vec2   minInvocationsAMD(f16vec2);f16vec3   minInvocationsAMD(f16vec3);f16vec4   minInvocationsAMD(f16vec4);int16_t minInvocationsAMD(int16_t);i16vec2 minInvocationsAMD(i16vec2);i16vec3 minInvocationsAMD(i16vec3);i16vec4 minInvocationsAMD(i16vec4);uint16_t minInvocationsAMD(uint16_t);u16vec2  minInvocationsAMD(u16vec2);u16vec3  minInvocationsAMD(u16vec3);u16vec4  minInvocationsAMD(u16vec4);float minInvocationsInclusiveScanAMD(float);vec2  minInvocationsInclusiveScanAMD(vec2);vec3  minInvocationsInclusiveScanAMD(vec3);vec4  minInvocationsInclusiveScanAMD(vec4);int   minInvocationsInclusiveScanAMD(int);ivec2 minInvocationsInclusiveScanAMD(ivec2);ivec3 minInvocationsInclusiveScanAMD(ivec3);ivec4 minInvocationsInclusiveScanAMD(ivec4);uint  minInvocationsInclusiveScanAMD(uint);uvec2 minInvocationsInclusiveScanAMD(uvec2);uvec3 minInvocationsInclusiveScanAMD(uvec3);uvec4 minInvocationsInclusiveScanAMD(uvec4);double minInvocationsInclusiveScanAMD(double);dvec2  minInvocationsInclusiveScanAMD(dvec2);dvec3  minInvocationsInclusiveScanAMD(dvec3);dvec4  minInvocationsInclusiveScanAMD(dvec4);int64_t minInvocationsInclusiveScanAMD(int64_t);i64vec2 minInvocationsInclusiveScanAMD(i64vec2);i64vec3 minInvocationsInclusiveScanAMD(i64vec3);i64vec4 minInvocationsInclusiveScanAMD(i64vec4);uint64_t minInvocationsInclusiveScanAMD(uint64_t);u64vec2  minInvocationsInclusiveScanAMD(u64vec2);u64vec3  minInvocationsInclusiveScanAMD(u64vec3);u64vec4  minInvocationsInclusiveScanAMD(u64vec4);float16_t minInvocationsInclusiveScanAMD(float16_t);f16vec2   minInvocationsInclusiveScanAMD(f16vec2);f16vec3   minInvocationsInclusiveScanAMD(f16vec3);f16vec4   minInvocationsInclusiveScanAMD(f16vec4);int16_t minInvocationsInclusiveScanAMD(int16_t);i16vec2 minInvocationsInclusiveScanAMD(i16vec2);i16vec3 minInvocationsInclusiveScanAMD(i16vec3);i16vec4 minInvocationsInclusiveScanAMD(i16vec4);uint16_t minInvocationsInclusiveScanAMD(uint16_t);u16vec2  minInvocationsInclusiveScanAMD(u16vec2);u16vec3  minInvocationsInclusiveScanAMD(u16vec3);u16vec4  minInvocationsInclusiveScanAMD(u16vec4);float minInvocationsExclusiveScanAMD(float);vec2  minInvocationsExclusiveScanAMD(vec2);vec3  minInvocationsExclusiveScanAMD(vec3);vec4  minInvocationsExclusiveScanAMD(vec4);int   minInvocationsExclusiveScanAMD(int);ivec2 minInvocationsExclusiveScanAMD(ivec2);ivec3 minInvocationsExclusiveScanAMD(ivec3);ivec4 minInvocationsExclusiveScanAMD(ivec4);uint  minInvocationsExclusiveScanAMD(uint);uvec2 minInvocationsExclusiveScanAMD(uvec2);uvec3 minInvocationsExclusiveScanAMD(uvec3);uvec4 minInvocationsExclusiveScanAMD(uvec4);double minInvocationsExclusiveScanAMD(double);dvec2  minInvocationsExclusiveScanAMD(dvec2);dvec3  minInvocationsExclusiveScanAMD(dvec3);dvec4  minInvocationsExclusiveScanAMD(dvec4);int64_t minInvocationsExclusiveScanAMD(int64_t);i64vec2 minInvocationsExclusiveScanAMD(i64vec2);i64vec3 minInvocationsExclusiveScanAMD(i64vec3);i64vec4 minInvocationsExclusiveScanAMD(i64vec4);uint64_t minInvocationsExclusiveScanAMD(uint64_t);u64vec2  minInvocationsExclusiveScanAMD(u64vec2);u64vec3  minInvocationsExclusiveScanAMD(u64vec3);u64vec4  minInvocationsExclusiveScanAMD(u64vec4);float16_t minInvocationsExclusiveScanAMD(float16_t);f16vec2   minInvocationsExclusiveScanAMD(f16vec2);f16v
float near;float far;float diff
float noise1(float x);float noise1(vec2  x);float noise1(vec3  x);float noise1(vec4  x);vec2 noise2(float x);vec2 noise2(vec2  x);vec2 noise2(vec3  x);vec2 noise2(vec4  x);vec3 noise3(float x);vec3 noise3(vec2  x);vec3 noise3(vec3  x);vec3 noise3(vec4  x);vec4 noise4(float x);vec4 noise4(vec2  x);vec4 noise4(vec3  x);vec4 noise4(vec4  x);\n
float spvDet2x2(float a1, float a2, float b1, float b2
float spvDet3x3(float a1, float a2, float a3, float b1, float b2, float b3, float c1, float c2, float c3
float spvDeterminant
float u = 0
float v = 0
float);\n
float,float
float16 types can only be in uniform block or buffer storage
float16BitsToInt16
float16BitsToUint16
float16_t
float16_t dFdx(float16_t);f16vec2   dFdx(f16vec2);f16vec3   dFdx(f16vec3);f16vec4   dFdx(f16vec4);float16_t dFdy(float16_t);f16vec2   dFdy(f16vec2);f16vec3   dFdy(f16vec3);f16vec4   dFdy(f16vec4);float16_t dFdxFine(float16_t);f16vec2   dFdxFine(f16vec2);f16vec3   dFdxFine(f16vec3);f16vec4   dFdxFine(f16vec4);float16_t dFdyFine(float16_t);f16vec2   dFdyFine(f16vec2);f16vec3   dFdyFine(f16vec3);f16vec4   dFdyFine(f16vec4);float16_t dFdxCoarse(float16_t);f16vec2   dFdxCoarse(f16vec2);f16vec3   dFdxCoarse(f16vec3);f16vec4   dFdxCoarse(f16vec4);float16_t dFdyCoarse(float16_t);f16vec2   dFdyCoarse(f16vec2);f16vec3   dFdyCoarse(f16vec3);f16vec4   dFdyCoarse(f16vec4);float16_t fwidth(float16_t);f16vec2   fwidth(f16vec2);f16vec3   fwidth(f16vec3);f16vec4   fwidth(f16vec4);float16_t fwidthFine(float16_t);f16vec2   fwidthFine(f16vec2);f16vec3   fwidthFine(f16vec3);f16vec4   fwidthFine(f16vec4);float16_t fwidthCoarse(float16_t);f16vec2   fwidthCoarse(f16vec2);f16vec3   fwidthCoarse(f16vec3);f16vec4   fwidthCoarse(f16vec4
float16_t interpolateAtCentroid(float16_t);f16vec2   interpolateAtCentroid(f16vec2);f16vec3   interpolateAtCentroid(f16vec3);f16vec4   interpolateAtCentroid(f16vec4);float16_t interpolateAtSample(float16_t, int);f16vec2   interpolateAtSample(f16vec2,   int);f16vec3   interpolateAtSample(f16vec3,   int);f16vec4   interpolateAtSample(f16vec4,   int);float16_t interpolateAtOffset(float16_t, f16vec2);f16vec2   interpolateAtOffset(f16vec2,   f16vec2);f16vec3   interpolateAtOffset(f16vec3,   f16vec2);f16vec4   interpolateAtOffset(f16vec4,   f16vec2);\n
float16_t radians(float16_t);f16vec2   radians(f16vec2);f16vec3   radians(f16vec3);f16vec4   radians(f16vec4);float16_t degrees(float16_t);f16vec2   degrees(f16vec2);f16vec3   degrees(f16vec3);f16vec4   degrees(f16vec4);float16_t sin(float16_t);f16vec2   sin(f16vec2);f16vec3   sin(f16vec3);f16vec4   sin(f16vec4);float16_t cos(float16_t);f16vec2   cos(f16vec2);f16vec3   cos(f16vec3);f16vec4   cos(f16vec4);float16_t tan(float16_t);f16vec2   tan(f16vec2);f16vec3   tan(f16vec3);f16vec4   tan(f16vec4);float16_t asin(float16_t);f16vec2   asin(f16vec2);f16vec3   asin(f16vec3);f16vec4   asin(f16vec4);float16_t acos(float16_t);f16vec2   acos(f16vec2);f16vec3   acos(f16vec3);f16vec4   acos(f16vec4);float16_t atan(float16_t, float16_t);f16vec2   atan(f16vec2,   f16vec2);f16vec3   atan(f16vec3,   f16vec3);f16vec4   atan(f16vec4,   f16vec4);float16_t atan(float16_t);f16vec2   atan(f16vec2);f16vec3   atan(f16vec3);f16vec4   atan(f16vec4);float16_t sinh(float16_t);f16vec2   sinh(f16vec2);f16vec3   sinh(f16vec3);f16vec4   sinh(f16vec4);float16_t cosh(float16_t);f16vec2   cosh(f16vec2);f16vec3   cosh(f16vec3);f16vec4   cosh(f16vec4);float16_t tanh(float16_t);f16vec2   tanh(f16vec2);f16vec3   tanh(f16vec3);f16vec4   tanh(f16vec4);float16_t asinh(float16_t);f16vec2   asinh(f16vec2);f16vec3   asinh(f16vec3);f16vec4   asinh(f16vec4);float16_t acosh(float16_t);f16vec2   acosh(f16vec2);f16vec3   acosh(f16vec3);f16vec4   acosh(f16vec4);float16_t atanh(float16_t);f16vec2   atanh(f16vec2);f16vec3   atanh(f16vec3);f16vec4   atanh(f16vec4);float16_t pow(float16_t, float16_t);f16vec2   pow(f16vec2,   f16vec2);f16vec3   pow(f16vec3,   f16vec3);f16vec4   pow(f16vec4,   f16vec4);float16_t exp(float16_t);f16vec2   exp(f16vec2);f16vec3   exp(f16vec3);f16vec4   exp(f16vec4);float16_t log(float16_t);f16vec2   log(f16vec2);f16vec3   log(f16vec3);f16vec4   log(f16vec4);float16_t exp2(float16_t);f16vec2   exp2(f16vec2);f16vec3   exp2(f16vec3);f16vec4   exp2(f16vec4);float16_t log2(float16_t);f16vec2   log2(f16vec2);f16vec3   log2(f16vec3);f16vec4   log2(f16vec4);float16_t sqrt(float16_t);f16vec2   sqrt(f16vec2);f16vec3   sqrt(f16vec3);f16vec4   sqrt(f16vec4);float16_t inversesqrt(float16_t);f16vec2   inversesqrt(f16vec2);f16vec3   inversesqrt(f16vec3);f16vec4   inversesqrt(f16vec4);float16_t abs(float16_t);f16vec2   abs(f16vec2);f16vec3   abs(f16vec3);f16vec4   abs(f16vec4);float16_t sign(float16_t);f16vec2   sign(f16vec2);f16vec3   sign(f16vec3);f16vec4   sign(f16vec4);float16_t floor(float16_t);f16vec2   floor(f16vec2);f16vec3   floor(f16vec3);f16vec4   floor(f16vec4);float16_t trunc(float16_t);f16vec2   trunc(f16vec2);f16vec3   trunc(f16vec3);f16vec4   trunc(f16vec4);float16_t round(float16_t);f16vec2   round(f16vec2);f16vec3   round(f16vec3);f16vec4   round(f16vec4);float16_t roundEven(float16_t);f16vec2   roundEven(f16vec2);f16vec3   roundEven(f16vec3);f16vec4   roundEven(f16vec4);float16_t ceil(float16_t);f16vec2   ceil(f16vec2);f16vec3   ceil(f16vec3);f16vec4   ceil(f16vec4);float16_t fract(float16_t);f16vec2   fract(f16vec2);f16vec3   fract(f16vec3);f16vec4   fract(f16vec4);float16_t mod(float16_t, float16_t);f16vec2   mod(f16vec2,   float16_t);f16vec3   mod(f16vec3,   float16_t);f16vec4   mod(f16vec4,   float16_t);f16vec2   mod(f16vec2,   f16vec2);f16vec3   mod(f16vec3,   f16vec3);f16vec4   mod(f16vec4,   f16vec4);float16_t modf(float16_t, out float16_t);f16vec2   modf(f16vec2,   out f16vec2);f16vec3   modf(f16vec3,   out f16vec3);f16vec4   modf(f16vec4,   out f16vec4);float16_t min(float16_t, float16_t);f16vec2   min(f16vec2,   float16_t);f16vec3   min(f16vec3,   float16_t);f16vec4   min(f16vec4,   float16_t);f16vec2   min(f16vec2,   f16vec2);f16vec3   min(f16vec3,   f16vec3);f16vec4   min(f16vec4,   f16vec4);float16_t max(float16_t, float16_t);f16vec2   max(f16vec2,   float16_t);f16vec3   max(f16vec3,   float16_t);f16vec4   max(f16vec4,   float16_t);f16vec2   max(f16vec2,   f16vec2);f16vec3   max(f16vec3,   f16vec3);f16vec4   max(f16vec4,   f16vec4);float16_t clamp(float16_t, float16_t, float16_t);f16vec2   clamp(f16vec2,   float16_t, float16_t);f1
float16_t,float16_t
float2
float2 ab = fract((round(coord * float2(plane0.get_width(), plane0.get_height())) - float2(0, 0.5)) * 0.5
float2 ab = fract((round(coord * float2(plane0.get_width(), plane0.get_height())) - float2(0.5, 0)) * 0.5
float2 ab = fract((round(coord * float2(plane0.get_width(), plane0.get_height())) - float2(0.5, 0.5)) * 0.5
float2 ab = fract(round(coord * float2(plane0.get_width(), plane0.get_height())) * 0.5
float2(as_type<half2
float2x2 adj;\t// The adjoint matrix (inverse after dividing by determinant
float2x2 spvInverse2x2(float2x2 m
float3
float3 Coords = abs(P.xyz
float3 spvCubemapTo2DArrayFace(float3 P
float3 v_texCoord
float3(1.0
float32_t
float32_t matrix
float32_t vector
float3x3 adj;\t// The adjoint matrix (inverse after dividing by determinant
float3x3 spvInverse3x3(float3x3 m
float4
float4 a_position [[attribute(0
float4 colors[9
float4 v_position [[position
float4x4 adj;\t// The adjoint matrix (inverse after dividing by determinant
float4x4 spvInverse4x4(float4x4 m
float64_t
float64_t dFdx(float64_t);f64vec2   dFdx(f64vec2);f64vec3   dFdx(f64vec3);f64vec4   dFdx(f64vec4);float64_t dFdy(float64_t);f64vec2   dFdy(f64vec2);f64vec3   dFdy(f64vec3);f64vec4   dFdy(f64vec4);float64_t dFdxFine(float64_t);f64vec2   dFdxFine(f64vec2);f64vec3   dFdxFine(f64vec3);f64vec4   dFdxFine(f64vec4);float64_t dFdyFine(float64_t);f64vec2   dFdyFine(f64vec2);f64vec3   dFdyFine(f64vec3);f64vec4   dFdyFine(f64vec4);float64_t dFdxCoarse(float64_t);f64vec2   dFdxCoarse(f64vec2);f64vec3   dFdxCoarse(f64vec3);f64vec4   dFdxCoarse(f64vec4);float64_t dFdyCoarse(float64_t);f64vec2   dFdyCoarse(f64vec2);f64vec3   dFdyCoarse(f64vec3);f64vec4   dFdyCoarse(f64vec4);float64_t fwidth(float64_t);f64vec2   fwidth(f64vec2);f64vec3   fwidth(f64vec3);f64vec4   fwidth(f64vec4);float64_t fwidthFine(float64_t);f64vec2   fwidthFine(f64vec2);f64vec3   fwidthFine(f64vec3);f64vec4   fwidthFine(f64vec4);float64_t fwidthCoarse(float64_t);f64vec2   fwidthCoarse(f64vec2);f64vec3   fwidthCoarse(f64vec3);f64vec4   fwidthCoarse(f64vec4
float64_t fma(float64_t, float64_t, float64_t);f64vec2  fma(f64vec2,  f64vec2,  f64vec2 );f64vec3  fma(f64vec3,  f64vec3,  f64vec3 );f64vec4  fma(f64vec4,  f64vec4,  f64vec4 );\n
float64_t frexp(float64_t, out int);f64vec2  frexp( f64vec2, out ivec2);f64vec3  frexp( f64vec3, out ivec3);f64vec4  frexp( f64vec4, out ivec4);float64_t ldexp(float64_t, int);f64vec2  ldexp( f64vec2, ivec2);f64vec3  ldexp( f64vec3, ivec3);f64vec4  ldexp( f64vec4, ivec4);\n
float64_t interpolateAtCentroid(float64_t);f64vec2   interpolateAtCentroid(f64vec2);f64vec3   interpolateAtCentroid(f64vec3);f64vec4   interpolateAtCentroid(f64vec4);float64_t interpolateAtSample(float64_t, int);f64vec2   interpolateAtSample(f64vec2,   int);f64vec3   interpolateAtSample(f64vec3,   int);f64vec4   interpolateAtSample(f64vec4,   int);float64_t interpolateAtOffset(float64_t, f64vec2);f64vec2   interpolateAtOffset(f64vec2,   f64vec2);f64vec3   interpolateAtOffset(f64vec3,   f64vec2);f64vec4   interpolateAtOffset(f64vec4,   f64vec2);\n
float64_t matrix
float64_t sqrt(float64_t);f64vec2  sqrt(f64vec2);f64vec3  sqrt(f64vec3);f64vec4  sqrt(f64vec4);float64_t inversesqrt(float64_t);f64vec2  inversesqrt(f64vec2);f64vec3  inversesqrt(f64vec3);f64vec4  inversesqrt(f64vec4);float64_t abs(float64_t);f64vec2  abs(f64vec2);f64vec3  abs(f64vec3);f64vec4  abs(f64vec4);float64_t sign(float64_t);f64vec2  sign(f64vec2);f64vec3  sign(f64vec3);f64vec4  sign(f64vec4);float64_t floor(float64_t);f64vec2  floor(f64vec2);f64vec3  floor(f64vec3);f64vec4  floor(f64vec4);float64_t trunc(float64_t);f64vec2  trunc(f64vec2);f64vec3  trunc(f64vec3);f64vec4  trunc(f64vec4);float64_t round(float64_t);f64vec2  round(f64vec2);f64vec3  round(f64vec3);f64vec4  round(f64vec4);float64_t roundEven(float64_t);f64vec2  roundEven(f64vec2);f64vec3  roundEven(f64vec3);f64vec4  roundEven(f64vec4);float64_t ceil(float64_t);f64vec2  ceil(f64vec2);f64vec3  ceil(f64vec3);f64vec4  ceil(f64vec4);float64_t fract(float64_t);f64vec2  fract(f64vec2);f64vec3  fract(f64vec3);f64vec4  fract(f64vec4);float64_t mod(float64_t, float64_t);f64vec2  mod(f64vec2 , float64_t);f64vec3  mod(f64vec3 , float64_t);f64vec4  mod(f64vec4 , float64_t);f64vec2  mod(f64vec2 , f64vec2);f64vec3  mod(f64vec3 , f64vec3);f64vec4  mod(f64vec4 , f64vec4);float64_t modf(float64_t, out float64_t);f64vec2  modf(f64vec2,  out f64vec2);f64vec3  modf(f64vec3,  out f64vec3);f64vec4  modf(f64vec4,  out f64vec4);float64_t min(float64_t, float64_t);f64vec2  min(f64vec2,  float64_t);f64vec3  min(f64vec3,  float64_t);f64vec4  min(f64vec4,  float64_t);f64vec2  min(f64vec2,  f64vec2);f64vec3  min(f64vec3,  f64vec3);f64vec4  min(f64vec4,  f64vec4);float64_t max(float64_t, float64_t);f64vec2  max(f64vec2 , float64_t);f64vec3  max(f64vec3 , float64_t);f64vec4  max(f64vec4 , float64_t);f64vec2  max(f64vec2 , f64vec2);f64vec3  max(f64vec3 , f64vec3);f64vec4  max(f64vec4 , f64vec4);float64_t clamp(float64_t, float64_t, float64_t);f64vec2  clamp(f64vec2 , float64_t, float64_t);f64vec3  clamp(f64vec3 , float64_t, float64_t);f64vec4  clamp(f64vec4 , float64_t, float64_t);f64vec2  clamp(f64vec2 , f64vec2 , f64vec2);f64vec3  clamp(f64vec3 , f64vec3 , f64vec3);f64vec4  clamp(f64vec4 , f64vec4 , f64vec4);float64_t mix(float64_t, float64_t, float64_t);f64vec2  mix(f64vec2,  f64vec2,  float64_t);f64vec3  mix(f64vec3,  f64vec3,  float64_t);f64vec4  mix(f64vec4,  f64vec4,  float64_t);f64vec2  mix(f64vec2,  f64vec2,  f64vec2);f64vec3  mix(f64vec3,  f64vec3,  f64vec3);f64vec4  mix(f64vec4,  f64vec4,  f64vec4);float64_t mix(float64_t, float64_t, bool);f64vec2  mix(f64vec2,  f64vec2,  bvec2);f64vec3  mix(f64vec3,  f64vec3,  bvec3);f64vec4  mix(f64vec4,  f64vec4,  bvec4);float64_t step(float64_t, float64_t);f64vec2  step(f64vec2 , f64vec2);f64vec3  step(f64vec3 , f64vec3);f64vec4  step(f64vec4 , f64vec4);f64vec2  step(float64_t, f64vec2);f64vec3  step(float64_t, f64vec3);f64vec4  step(float64_t, f64vec4);float64_t smoothstep(float64_t, float64_t, float64_t);f64vec2  smoothstep(f64vec2 , f64vec2 , f64vec2);f64vec3  smoothstep(f64vec3 , f64vec3 , f64vec3);f64vec4  smoothstep(f64vec4 , f64vec4 , f64vec4);f64vec2  smoothstep(float64_t, float64_t, f64vec2);f64vec3  smoothstep(float64_t, float64_t, f64vec3);f64vec4  smoothstep(float64_t, float64_t, f64vec4);float64_t length(float64_t);float64_t length(f64vec2);float64_t length(f64vec3);float64_t length(f64vec4);float64_t distance(float64_t, float64_t);float64_t distance(f64vec2 , f64vec2);float64_t distance(f64vec3 , f64vec3);float64_t distance(f64vec4 , f64vec4);float64_t dot(float64_t, float64_t);float64_t dot(f64vec2 , f64vec2);float64_t dot(f64vec3 , f64vec3);float64_t dot(f64vec4 , f64vec4);f64vec3 cross(f64vec3, f64vec3);float64_t normalize(float64_t);f64vec2  normalize(f64vec2);f64vec3  normalize(f64vec3);f64vec4  normalize(f64vec4);float64_t faceforward(float64_t, float64_t, float64_t);f64vec2  faceforward(f64vec2,  f64vec2,  f64vec2);f64vec3  faceforward(f64vec3,  f64vec3,  f64vec3);f64vec4  faceforward(f64vec4,  f64vec4,  f64vec4);float64_t reflect(float64_t, float64_t);f64vec2  reflect(f64vec2 , f64vec2 );f64vec3  reflect(f64vec3
float64_t vector
floatBitsToInt
floatBitsToUint
floating-point fast math mode
floating-point rounding mode
floating-point suffix
floor
flow_atI
fmax_common
fmin_common
fopen
for (i = 0, col = cols.begin(); i < Cols; ++i, ++col
for (int i = 0; i < Cols; ++i
for (int i = 0; i < int
for (int spvDummy
for (size_t i = 0; i < Cols; ++i
for (uint i = 0; i < A; i
for (uint i = 0; i < RCols; i
for (uint i = 0u; i < gl_SubgroupSize; ++i
for (uint i = 1u; i <= total; i <<= 1u
for (uint i = Cols; i > 0; --i
for (uint i = Rows; i > 0; --i
for (uint j = 0; j < Cols; ++j
for (uint j = 0; j < LCols; j
for header name: %s
for non-parameter, can only apply to 'in' or no storage qualifier
for_init_statement
for_rest_statement
forcing 32-bit vector type to non 64-bit scalar
forcing non 32-bit vector type
format
format requires readonly or writeonly memory qualifier
fpp\bp`ppp\bp`ppp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`ppp\bp`p\bp
fprintf
fputc
fputs
fractionH
fractional_even_spacing
fractional_odd_spacing
fragClear
fragCmdBlitImage
fragColor
fragment
fragment ClearColorsOut %@(VaryingsPos varyings [[stage_in]], constant ClearColorsIn& ccIn [[buffer(0
fragment FragmentOutputs %@(VaryingsPosTex varyings [[stage_in
fragment input block
fragment outputs or tileImageEXTs sharing the same location
fragment shader barycentric
fragment shader interlock layout qualifier
fragment shader output
fragment-shader array-of-array input
fragment-shader array-of-array output
fragment-shader array-of-struct input
fragment-shader struct input
fragment-shader struct input containing an array
fragment-shader struct input containing structure
fragmentFetchAMD
fragmentMaskFetchAMD
fread
freshCycleDurationGOOGLE
frexp
front_faI
front_facing
fseek
fseeko
ftello
ftransform
fully_specified_type
func::aH
func::eH
func::gH
func::lH
func::nH
function already has a body
function call, method, or subroutine call expected
function cannot take any parameter(s
function control
function does not return a value
function name is redeclaration of existing name
function not supported in this version; use texture() instead
function parameter attribute
functionConstantsDictionary
function_call
function_call_generic
function_call_header
function_call_header_no_parameters
function_call_header_with_parameters
function_call_or_method
function_constant
function_declarator
function_definition
function_header
function_header_with_parameters
function_identifier
function_prototype
future reserved word in ES 300 and keyword in GLSL
fwidth
fwidthCoarse
fwidthFine
fwrite
fʋD\b
gEvent
gFences
gQueryPool
gTagEXT
g\bL;'t\bM
gather
gcc_except_tab__TEXT
ge, see H
geometry
geometry shader passthrough
geometry shaders
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice
getBytes:length
getDefaultSamplePositions:count
get_array_size
get_candidate_geometry_id
get_candidate_instance_id
get_candidate_intersection_type()) - 1
get_candidate_object_to_world_transform
get_candidate_primitive_id
get_candidate_ray_direction
get_candidate_ray_origin
get_candidate_triangle_barycentric_coord
get_candidate_triangle_distance
get_candidate_user_instance_id
get_candidate_world_to_object_transform
get_committed_distance
get_committed_geometry_id
get_committed_instance_id
get_committed_intersection_type
get_committed_object_to_world_transform
get_committed_primitive_id
get_committed_ray_direction
get_committed_ray_origin
get_committed_triangle_barycentric_coord
get_committed_user_instance_id
get_committed_world_to_object_transform
get_depth
get_height
get_num_mip_levels
get_num_samples
get_ray_min_distance
get_sample_position
get_width
get_width(), 1.0
get_world_space_ray_direction
get_world_space_ray_origin
gffffff
gfffffffH
gfx-rs community
gfx-rs community Naga
gignalSemaphore
ginQueryH
gl_AtomicCounterBlock
gl_BackColor
gl_BackSecondaryColor
gl_BaryCoordEXT
gl_BaryCoordEXT requires ESSL 320
gl_BaryCoordEXT requires GLSL 450
gl_BaryCoordNV
gl_BaryCoordNoPerspAMD
gl_BaryCoordNoPerspCentroidAMD
gl_BaryCoordNoPerspEXT
gl_BaryCoordNoPerspEXT requires ESSL 320
gl_BaryCoordNoPerspEXT requires GLSL 450
gl_BaryCoordNoPerspNV
gl_BaryCoordNoPerspSampleAMD
gl_BaryCoordPullModelAMD
gl_BaryCoordSmoothAMD
gl_BaryCoordSmoothCentroidAMD
gl_BaryCoordSmoothSampleAMD
gl_BaseIH
gl_BaseII
gl_BaseInstance
gl_BaseInstanceARB
gl_BaseVI
gl_BaseVertex
gl_BaseVertexARB
gl_BoundingBox
gl_BoundingBoxEXT
gl_BoundingBoxOES
gl_BuiltIn
gl_ClipDH
gl_ClipDistance
gl_ClipDistance array size
gl_ClipDistancePerViewNV
gl_ClipDistancePerViewNV array size
gl_ClipVI
gl_ClipVertex
gl_Color
gl_CoreCountARM
gl_CoreIDARM
gl_CoreMaxIDARM
gl_CullDH
gl_CullDistance
gl_CullDistance array size
gl_CullDistancePerViewNV
gl_CullDistancePerViewNV array size
gl_CullMaskEXT
gl_CullPrimitiveEXT
gl_CurrentRayTimeNV
gl_DefaultUniformBlock
gl_DeviceIndex
gl_DrawID
gl_DrawIDARB
gl_FogCoord
gl_FogFragCoord
gl_FragC
gl_FragCH
gl_FragCH3
gl_FragCH3\b
gl_FragColor
gl_FragCoord
gl_FragCoord origin is upper left\n
gl_FragCoord pixel center is integer\n
gl_FragCoord redeclarations must match across shaders
gl_FragDH
gl_FragDH3
gl_FragData
gl_FragDepth
gl_FragDepthEXT
gl_FragFullyCoveredNV
gl_FragInvocationCountEXT
gl_FragSizeEXT
gl_FragStencilRe
gl_FragStencilRefARB
gl_FragmentSizeNV
gl_FrontColor
gl_FrontFacing
gl_FrontH
gl_FrontSecondaryColor
gl_GeometryIndexEXT
gl_GlobalInvocationID
gl_HelperInvocation
gl_HitKindEXT
gl_HitKindNV
gl_HitTEXT
gl_HitTNV
gl_HitTriangleVertexPositionsEXT
gl_IncomingRayFlagsEXT
gl_IncomingRayFlagsNV
gl_InstaH
gl_InstaH3\bH
gl_InstaI
gl_InstanceCustomIndexEXT
gl_InstanceCustomIndexNV
gl_InstanceID
gl_InstanceID + SPIRV_Cross_BaseInstance
gl_InstanceID - gl_BaseInstance
gl_InstanceId
gl_InstanceIndex
gl_InstanceIndex - gl_BaseInstance
gl_InvocH
gl_InvocationID
gl_InvocationsPerPixelNV
gl_LastFragData
gl_LaunchIDEXT
gl_LaunchIDNV
gl_LaunchSizeEXT
gl_LaunchSizeNV
gl_Layer
gl_LayerH
gl_LayerPerViewNV
gl_LocalInvocationID
gl_LocalInvocationIndex
gl_MaxClipDistances
gl_MaxComputeAtomicCounterBuffers
gl_MaxComputeAtomicCounters
gl_MaxComputeImageUniforms
gl_MaxComputeTextureImageUnits
gl_MaxComputeUniformComponents
gl_MaxComputeWorkGroupCount
gl_MaxComputeWorkGroupSize
gl_MaxCullDistances
gl_MaxDualSourceDrawBuffersEXT
gl_MaxMeshOutputPrimitivesEXT
gl_MaxMeshOutputPrimitivesNV
gl_MaxMeshOutputVerticesEXT
gl_MaxMeshOutputVerticesNV
gl_MaxMeshViewCountNV
gl_MaxMeshWorkGroupSizeEXT
gl_MaxMeshWorkGroupSizeNV
gl_MaxProgramTexelOffset
gl_MaxTaskWorkGroupSizeEXT
gl_MaxTaskWorkGroupSizeNV
gl_MaxTextureCoords
gl_MaxTransformFeedbackBuffers
gl_MaxTransformFeedbackBuffers is %d
gl_MaxTransformFeedbackInterleavedComponents
gl_MaxTransformFeedbackInterleavedComponents is
gl_MaxTransformFeedbackInterleavedComponents is %d
gl_MaxViewports
gl_MeshPerPrimitiveEXT
gl_MeshPerPrimitiveNV
gl_MeshPerVertexEXT
gl_MeshPerVertexNV
gl_MeshPrimitivesEXT
gl_MeshPrimitivesNV
gl_MeshVerticesEXT
gl_MeshVerticesNV
gl_MeshViewCountNV
gl_MeshViewIndicesNV
gl_MinProgramTexelOffset
gl_MinProgramTexelOffset, gl_MaxProgramTexelOffset
gl_MultiTexCoord0
gl_MultiTexCoord1
gl_MultiTexCoord2
gl_MultiTexCoord3
gl_MultiTexCoord4
gl_MultiTexCoord5
gl_MultiTexCoord6
gl_MultiTexCoord7
gl_Normal
gl_NumSamples
gl_NumSubgroups
gl_NumWorkGroups
gl_ObjectRayDirectionEXT
gl_ObjectRayDirectionNV
gl_ObjectRayOriginEXT
gl_ObjectRayOriginNV
gl_ObjectToWorld3x4EXT
gl_ObjectToWorldEXT
gl_ObjectToWorldNV
gl_PatchVertices
gl_PatchVerticesIn
gl_PerFrH3\bH
gl_PerFrI3N
gl_PerFragment
gl_PerVeH
gl_PerVeH3
gl_PerVeI3
gl_PerVeI3F
gl_PerVertex
gl_PointCoord
gl_PointH
gl_PointSize
gl_PositH
gl_Position
gl_Position.y = -gl_Position.y
gl_Position.z - gl_Position.w
gl_Position.z = 2.0
gl_PositionPerVierViewNV
gl_PositionPerViewNV
gl_PrimiH
gl_PrimitiveCountNV
gl_PrimitiveID
gl_PrimitiveIDIn
gl_PrimitiveIndicesNV
gl_PrimitiveLineIndicesEXT
gl_PrimitivePointIndicesEXT
gl_PrimitiveShadingRateEXT
gl_PrimitiveTriangleIndicesEXT
gl_RayFlagsForceOpacityMicromap2StateEXT
gl_RayFlagsSkipAABBEXT
gl_RayFlagsSkipTrianglesEXT
gl_RayTmaxEXT
gl_RayTmaxNV
gl_RayTminEXT
gl_RayTminNV
gl_SIMDGroupSizeAMD
gl_SMCountNV
gl_SMIDNV
gl_SamplH
gl_SampleID
gl_SampleMask
gl_SampleMaskIn
gl_SamplePosition
gl_ScopeDevice
gl_ScopeInvocation
gl_ScopeSubgroup
gl_ScopeWorkgroup
gl_SeconH
gl_SecondaryColor
gl_SecondaryFragColorEXT
gl_SecondaryFragDataEXT
gl_SecondaryPositionNV
gl_SecondaryViewportMaskNV
gl_SemanticsAcquire
gl_SemanticsAcquire must not be used with (image) atomic store
gl_SemanticsAcquireRelease
gl_SemanticsAcquireRelease must not be used with (image) atomic load/store
gl_SemanticsMakeAvailable
gl_SemanticsMakeAvailable requires gl_SemanticsRelease or gl_SemanticsAcquireRelease
gl_SemanticsMakeVisible
gl_SemanticsMakeVisible requires gl_SemanticsAcquire or gl_SemanticsAcquireRelease
gl_SemanticsRelaxed
gl_SemanticsRelease
gl_SemanticsRelease must not be used with (image) atomic load
gl_SemanticsVolatile
gl_SemanticsVolatile must not be used with memoryBarrier or controlBarrier
gl_ShadingRateEXT
gl_ShadingRateFlag2HorizontalPixelsEXT
gl_ShadingRateFlag2VerticalPixelsEXT
gl_ShadingRateFlag4HorizontalPixelsEXT
gl_ShadingRateFlag4VerticalPixelsEXT
gl_StorageSemanticsBuffer
gl_StorageSemanticsImage
gl_StorageSemanticsNone
gl_StorageSemanticsOutput
gl_StorageSemanticsShared
gl_SubGroupEqMaskARB
gl_SubGroupGeMaskARB
gl_SubGroupGtMaskARB
gl_SubGroupInvocationARB
gl_SubGroupLeMaskARB
gl_SubGroupLtMaskARB
gl_SubGroupSizeARB
gl_SubgroupEqMask
gl_SubgroupGeMask
gl_SubgroupGtMask
gl_SubgroupID
gl_SubgroupInvocationID
gl_SubgroupLeMask
gl_SubgroupLtMask
gl_SubgroupSize
gl_TaskCountNV
gl_TessCH
gl_TessCoord
gl_TessLevel
gl_TessLevelInner
gl_TessLevelOuter
gl_TexCoH3\bH
gl_TexCoord
gl_TexCoord array size
gl_VerteH
gl_VerteH3\bH
gl_VerteI
gl_Vertex
gl_VertexID
gl_VertexID - gl_BaseVertex
gl_VertexId
gl_VertexIndex
gl_VertexIndex - gl_BaseVertex
gl_ViewID_OVR
gl_ViewIndex
gl_ViewpH
gl_ViewpH3\bH
gl_ViewportIndex
gl_ViewportMask
gl_ViewportMaskP
gl_ViewportMaskPerViewNV
gl_WarpIDARM
gl_WarpIDNV
gl_WarpMaxIDARM
gl_WarpsPerSMNV
gl_WorkGH
gl_WorkGroupID
gl_WorkGroupSize
gl_WorldRayDirectionEXT
gl_WorldRayDirectionNV
gl_WorldRayOriginEXT
gl_WorldRayOriginNV
gl_WorldToObject3x4EXT
gl_WorldToObjectEXT
gl_WorldToObjectNV
gl_i3\n
gl_if
gl_in
gl_in.size
gl_in[];in int gl_PrimitiveIDIn;out gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];\n
gl_in[gl_MaxPatchVertices];\n
gl_out
gl_out[];patch out float gl_TessLevelOuter[4];patch out float gl_TessLevelInner[2];\n
gl_out[];patch out highp float gl_TessLevelOuter[4];patch out highp float gl_TessLevelInner[2];patch out highp vec4 gl_BoundingBoxOES[2];patch out highp vec4 gl_BoundingBoxEXT[2];\n
gl_out_mH
gl_out_masked
global
global const initializers must be constant
global storage input qualifier cannot be used in a compute shader
global storage output qualifier cannot be used in a compute shader
glslang_binary_double_output
gpuAddress
gpu_shadH
gradient
gradient2d
gradient3d
gradientcube
greaterThan
greaterThanEqual
green
grid_origin
grid_size
group operation
groupMemoryBarrier
gxx_personality_v0
hH;~ht
hHdrMetadataEXT
hL;h\b
hOutƃD
hPrivateData
hWorkgroupSizeMVK
h[A^A
h\bL+(I
haderStageFromVkShaderStageFlagBits
half float image
half float literal
half float matrix
half float sampler
half float subpass input
half float texture
half float vector
half floating-point suffix
halfBitsToInt16
halfBitsToUint16
half_cos
half_divide
half_exp
half_exp10
half_exp2
half_log
half_log10
half_log2
half_powr
half_recip
half_rsqrt
half_sin
half_sqrt
half_tan
has already been used to generate a type
has invalid mask component
has no type
hasUnifiedMemory
have layout format conflict cross stage
have layoutAlign conflict cross stage
have layoutMatrix conflict cross stage
have layoutOffset conflict cross stage
have layoutPacking conflict cross stage
have precision conflict cross stage
header name too long
headless
heapAccelerationStructureSizeAndAlignWithDescriptor
heapAccelerationStructureSizeAndAlignWithSize
heapBufferSizeAndAlignWithLength:options
heapTextureSizeAndAlignWithDescriptor
height
helperInvocationEXT
heroseh
heroseh Hero C Compiler
hexadecimal literal too big
hexadecimal literal too long
highp
highp   vec4  gl_FragCoord;        bool  gl_FrontFacing;mediump vec2  gl_PointCoord;highp   float gl_FragDepth
highp   vec4  gl_Position;mediump float gl_PointSize
highp float gl_FragDepthEXT
highp float near;highp float far;highp float diff
highp int
highp int64_t
highp ivec2 textureSize(__samplerExternal2DY2YEXT, int lod);vec4 texture(__samplerExternal2DY2YEXT, vec2);vec4 texture(__samplerExternal2DY2YEXT, vec2, float bias);vec4 textureProj(__samplerExternal2DY2YEXT, vec3);vec4 textureProj(__samplerExternal2DY2YEXT, vec3, float bias);vec4 textureProj(__samplerExternal2DY2YEXT, vec4);vec4 textureProj(__samplerExternal2DY2YEXT, vec4, float bias);vec4 texelFetch(__samplerExternal2DY2YEXT sampler, ivec2, int lod);\n
highp ivec2 textureSize(samplerExternalOES, int lod);vec4 texture(samplerExternalOES, vec2);vec4 texture(samplerExternalOES, vec2, float bias);vec4 textureProj(samplerExternalOES, vec3);vec4 textureProj(samplerExternalOES, vec3, float bias);vec4 textureProj(samplerExternalOES, vec4);vec4 textureProj(samplerExternalOES, vec4, float bias);vec4 texelFetch(samplerExternalOES, ivec2, int lod);\n
highp precision qualifier
highp uint
highp uint packSnorm2x16(vec2);      vec2 unpackSnorm2x16(highp uint);highp uint packHalf2x16(vec2);\n
highp uint packSnorm4x8(vec4);highp uint packUnorm4x8(vec4);\n
highp uint packUnorm2x16(vec2);vec2 unpackUnorm2x16(highp uint);\n
highp uint64_t
highp vec4  gl_Position;highp float gl_PointSize
hit objects cannot be initialized using initializers
hitAttributeEXT
hitAttributeNV
hitAttributeNV block
hitObjectAttributeNV
hitObjectAttributeNV block
hitObjectExecuteShaderNV
hitObjectGetAttributesNV
hitObjectGetCurrentTimeNV
hitObjectGetGeometryIndexNV
hitObjectGetHitKindNV
hitObjectGetInstanceCustomIndexNV
hitObjectGetInstanceIdNV
hitObjectGetObjectRayDirectionNV
hitObjectGetObjectRayOriginNV
hitObjectGetObjectToWorldNV
hitObjectGetPrimitiveIndexNV
hitObjectGetRayTMaxNV
hitObjectGetRayTMinNV
hitObjectGetShaderBindingTableRecordIndexNV
hitObjectGetShaderRecordBufferHandleNV
hitObjectGetWorldRayDirectionNV
hitObjectGetWorldRayOriginNV
hitObjectGetWorldToObjectNV
hitObjectGetbjectToWorldNV
hitObjectIsEmptyNV
hitObjectIsHitNV
hitObjectIsMissNV
hitObjectNV
hitObjectRecordEmptyNV
hitObjectRecordHitMotionNV
hitObjectRecordHitNV
hitObjectRecordHitWithIndexMotionNV
hitObjectRecordHitWithIndexNV
hitObjectRecordMissMotionNV
hitObjectRecordMissNV
hitObjectTraceRayMotionNV
hitObjectTraceRayNV
hitobject shader record NV
hitobjectattribute number
hitobjectshaderrecordnv
holtenVKConfigurationMVK
host_info
host_page_size
host_statistics
hp\bpXp\bpX
hp\bpXp\bpXp\bpXp\bpXp\bpXp
hp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpX
hp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bp\bpHp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpX
hp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp
hp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp
hp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpX
hp\bpXp\bpXphp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpH
hp\bpXphp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpX
hp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpXp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bpXp\bpXp\bpXp\bpXp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpX
hp_copy
hppZAp\bRAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZARAp\bZAp\bRARA
hval = select(copysign(H(0), hval), hval, isnormal(hval) || isinf(hval) || isnan(hval
hyp. cosine
hyp. sine
hyp. tangent
hysicalDevice
i, gl_SubgroupSize, valid
i16vec
i16vec2
i16vec3
i16vec4
i32vec2
i32vec3
i32vec4
i64image1D
i64image1DArray
i64image2D
i64image2DArray
i64image2DMS
i64image2DMSArray
i64image2DRect
i64image3D
i64imageBuffer
i64imageCube
i64imageCubeArray
i64vec
i64vec2
i64vec3
i64vec4
i8vec2
i8vec3
i8vec4
iMulExtended
iTrimCommandPool
i] = gl_in[i
iangleIndicesEXTgl_PrimitiveTriaveLineIndicesEXTgl_PrimitiveLineePointIndicesEXTgl_PrimitivePoinCounterIncrementatomicCounterIncCounterDecrementatomicCounterDecgl_MeshPerVertexNV
iattachmentEXT
ic_typesH
icoopmatNV
identifier not previously declared
identifier_list
identifiers containing consecutive underscores ("__") are reserved
identifiers containing consecutive underscores ("__") are reserved, and an error if version < 300
identifiers starting with "gl_" are reserved
iewportFromVkViewport
if (!is_null_texture(plane1
if (!is_null_texture(plane2
if (!s
if ((flags
if (Coords.x >= Coords.y && Coords.x >= Coords.z
if (any
if (fract(coord.x * plane1.get_width()) != 0.0
if (gl_InvocationID == 0
if (k < T(0
if (subgroupBallotBitCount(active_threads) == gl_SubgroupSize
if (subgroupElect
if (sw
if (ycbcr_samp.get_resolution() == spvFormatResolution::_444
if (ycbcr_samp.get_ycbcr_model() == spvYCbCrModelConversion::rgb_identity
if __HAVE_MIN_LOD_CLAMP
if __METAL_VERSION__ >= 230
if defined(GL_AMD_gpu_shader_half_float
if defined(GL_ARB_fragment_shader_interlock
if defined(GL_ARB_gpu_shader_int64
if defined(GL_ARB_post_depth_coverge
if defined(GL_EXT_control_flow_attributes
if defined(GL_EXT_shader_explicit_arithmetic_types_int16
if defined(GL_EXT_shader_explicit_arithmetic_types_int8
if the verison is 150 , the EmitStreamVertex and EndStreamPrimitive only support at extension GL_ARB_gpu_shader5
if you are creating a new source language please use value 0 (Unknown) and when ready, add your source language to SPRIV-Headers
if/#ifdef/#ifndef
ifdef
ifdef GL_ARB_fragment_shader_interlock
ifdef GL_ARB_shader_draw_parameters
ifdef GL_ARB_shading_language_420pack
ifdef GL_NV_shader_thread_group
ifdef __HAVE_IMAGEBLOCKS
ifdef __HAVE_MESH
ifdef __HAVE_RAYTRACING
ifffff
ifndef
ifndef GL_ARB_shader_draw_parameters
ifndef GL_KHR_shader_subgroup_ballot
ifndef GL_KHR_shader_subgroup_basic
ifndef GL_KHR_shader_subgroup_vote
ifstreamIcNS_11char_traitsIcEEEE
ignoreIntersectionEXT
ignoreIntersectionKHR
ignoreIntersectionNV
ignoring layout qualifier for uniform
iimage1D
iimage1DArray
iimage2D
iimage2DArray
iimage2DMS
iimage2DMSArray
iimage2DRect
iimage3D
iimageBuffer
iimageCube
iimageCubeArray
ilities
illegal use of escape character
illegal use of type 'void
image channel data type
image channel order
image format
image formats must match
image load store
image load-store format
image variables not declared 'writeonly' and without a format layout qualifier
image1D
image1DArray
image2D
image2DArray
image2DMS
image2DMSArray
image2DRect
image3D
imageAtomic
imageAtomicAdd
imageAtomicAdd(volatile coherent
imageAtomicAnd
imageAtomicAnd(volatile coherent
imageAtomicCompSwap
imageAtomicCompSwap(volatile coherent
imageAtomicExchange
imageAtomicExchange(volatile coherent
imageAtomicLoad
imageAtomicLoad(volatile coherent
imageAtomicMax
imageAtomicMax(volatile coherent
imageAtomicMin
imageAtomicMin(volatile coherent
imageAtomicOr
imageAtomicOr(volatile coherent
imageAtomicStore
imageAtomicXor
imageAtomicXor(volatile coherent
imageBuffer
imageCube
imageCubeArray
imageLoad
imageLoadLod
imageLoadLodAMD
imageQuerySamples
imageQuerySize
imageSampleFootprintClampNV
imageSampleFootprintGradNV
imageSampleFootprintLodNV
imageSampleFootprintNV
imageSamples
imageSamples(readonly writeonly volatile coherent
imageSize
imageSize(readonly writeonly volatile coherent
imageStore
imageStoreLod
imageStoreLodAMD
images
imitivesH
imulExtended
in    highp uvec3 gl_NumWorkGroups;const highp uvec3 gl_WorkGroupSize = uvec3(1,1,1);in highp uvec3 gl_WorkGroupID;in highp uvec3 gl_LocalInvocationID;in highp uvec3 gl_GlobalInvocationID;in highp uint gl_LocalInvocationIndex;\n
in    uvec3  gl_LaunchIDNV;in    uvec3  gl_LaunchIDEXT;in    uvec3  gl_LaunchSizeNV;in    uvec3  gl_LaunchSizeEXT;\n
in    uvec3  gl_LaunchIDNV;in    uvec3  gl_LaunchIDEXT;in    uvec3  gl_LaunchSizeNV;in    uvec3  gl_LaunchSizeEXT;in     int   gl_PrimitiveID;in     int   gl_InstanceID;in     int   gl_InstanceCustomIndexNV;in     int   gl_InstanceCustomIndexEXT;in     int   gl_GeometryIndexEXT;in    vec3   gl_WorldRayOriginNV;in    vec3   gl_WorldRayOriginEXT;in    vec3   gl_WorldRayDirectionNV;in    vec3   gl_WorldRayDirectionEXT;in    vec3   gl_ObjectRayOriginNV;in    vec3   gl_ObjectRayOriginEXT;in    vec3   gl_ObjectRayDirectionNV;in    vec3   gl_ObjectRayDirectionEXT;in    float  gl_RayTminNV;in    float  gl_RayTminEXT;in    float  gl_RayTmaxNV;in    float  gl_RayTmaxEXT;in    float  gl_HitTNV;in    float  gl_HitTEXT;in    uint   gl_HitKindNV;in    uint   gl_HitKindEXT;in    mat4x3 gl_ObjectToWorldNV;in    mat4x3 gl_ObjectToWorldEXT;in    mat3x4 gl_ObjectToWorld3x4EXT;in    mat4x3 gl_WorldToObjectNV;in    mat4x3 gl_WorldToObjectEXT;in    mat3x4 gl_WorldToObject3x4EXT;in    uint   gl_IncomingRayFlagsNV;in    uint   gl_IncomingRayFlagsEXT;in    float  gl_CurrentRayTimeNV;in    uint   gl_CullMaskEXT;in    vec3   gl_HitTriangleVertexPositionsEXT[3];\n
in    uvec3  gl_LaunchIDNV;in    uvec3  gl_LaunchIDEXT;in    uvec3  gl_LaunchSizeNV;in    uvec3  gl_LaunchSizeEXT;in     int   gl_PrimitiveID;in     int   gl_InstanceID;in     int   gl_InstanceCustomIndexNV;in     int   gl_InstanceCustomIndexEXT;in     int   gl_GeometryIndexEXT;in    vec3   gl_WorldRayOriginNV;in    vec3   gl_WorldRayOriginEXT;in    vec3   gl_WorldRayDirectionNV;in    vec3   gl_WorldRayDirectionEXT;in    vec3   gl_ObjectRayOriginNV;in    vec3   gl_ObjectRayOriginEXT;in    vec3   gl_ObjectRayDirectionNV;in    vec3   gl_ObjectRayDirectionEXT;in    float  gl_RayTminNV;in    float  gl_RayTminEXT;in    float  gl_RayTmaxNV;in volatile float gl_RayTmaxEXT;in    mat4x3 gl_ObjectToWorldNV;in    mat4x3 gl_ObjectToWorldEXT;in    mat3x4 gl_ObjectToWorld3x4EXT;in    mat4x3 gl_WorldToObjectNV;in    mat4x3 gl_WorldToObjectEXT;in    mat3x4 gl_WorldToObject3x4EXT;in    uint   gl_IncomingRayFlagsNV;in    uint   gl_IncomingRayFlagsEXT;in    float  gl_CurrentRayTimeNV;in    uint   gl_CullMaskEXT;\n
in    uvec3  gl_LaunchIDNV;in    uvec3  gl_LaunchIDEXT;in    uvec3  gl_LaunchSizeNV;in    uvec3  gl_LaunchSizeEXT;in    vec3   gl_WorldRayOriginNV;in    vec3   gl_WorldRayOriginEXT;in    vec3   gl_WorldRayDirectionNV;in    vec3   gl_WorldRayDirectionEXT;in    vec3   gl_ObjectRayOriginNV;in    vec3   gl_ObjectRayDirectionNV;in    float  gl_RayTminNV;in    float  gl_RayTminEXT;in    float  gl_RayTmaxNV;in    float  gl_RayTmaxEXT;in    uint   gl_IncomingRayFlagsNV;in    uint   gl_IncomingRayFlagsEXT;in    float  gl_CurrentRayTimeNV;in    uint   gl_CullMaskEXT;\n
in bool gl_FragFullyCoveredNV
in buffer %d
in float gl_ClipDistance
in float gl_CullDistance[];bool gl_HelperInvocation
in float gl_FogFragCoord;in vec4  gl_TexCoord[];in vec4  gl_Color;in vec4  gl_SecondaryColor
in for stage inputs
in gl_PerFragment {in float gl_FogFragCoord;in vec4  gl_TexCoord[];in vec4  gl_Color;in vec4  gl_SecondaryColor
in gl_PerVertex
in gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize;highp vec4 gl_SecondaryPositionNV;highp vec4 gl_PositionPerViewNV[];} gl_in[gl_MaxPatchVertices];\n
in gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize;} gl_in[];\nin highp int gl_PrimitiveIDIn;in highp int gl_InvocationID;\nout gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize;};\nout highp int gl_PrimitiveID;out highp int gl_Layer;\n
in gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance
in highp   uint  gl_NumSubgroups;in highp   uint  gl_SubgroupID;\n
in highp int gl_DeviceIndex;\n
in highp int gl_DeviceIndex;in highp int gl_ViewIndex;\n
in highp int gl_DeviceIndex;in int gl_DrawIDARB;\n
in highp int gl_DeviceIndex;in int gl_DrawIDARB;in int gl_ViewIndex;\n
in highp int gl_PatchVerticesIn;in highp int gl_PrimitiveID;in highp int gl_InvocationID;out gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize
in highp int gl_PatchVerticesIn;in highp int gl_PrimitiveID;in highp vec3 gl_TessCoord;patch in highp float gl_TessLevelOuter[4];patch in highp float gl_TessLevelInner[2];out gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize
in highp int gl_VertexID;in highp int gl_InstanceID
in highp int gl_VertexIndex;in highp int gl_InstanceIndex
in highp uint gl_ViewID_OVR;\n
in int gl_BaseVertex;in int gl_BaseInstance;in int gl_DrawID
in int gl_BaseVertexARB;in int gl_BaseInstanceARB;in int gl_DrawIDARB
in int gl_DrawID;\n
in int gl_InvocationID
in int gl_PatchVerticesIn;in int gl_PrimitiveID;in int gl_InvocationID;out gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance
in int gl_PatchVerticesIn;in int gl_PrimitiveID;in vec3 gl_TessCoord;patch in float gl_TessLevelOuter[4];patch in float gl_TessLevelInner[2];out gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance
in int gl_VertexID;in int gl_InstanceID
in int gl_VertexIndex;in int gl_InstanceIndex
in mediump uint  gl_SubgroupSize;in mediump uint  gl_SubgroupInvocationID;in highp   uvec4 gl_SubgroupEqMask;in highp   uvec4 gl_SubgroupGeMask;in highp   uvec4 gl_SubgroupGtMask;in highp   uvec4 gl_SubgroupLeMask;in highp   uvec4 gl_SubgroupLtMask;in highp   uint  gl_WarpsPerSMNV;in highp   uint  gl_SMCountNV;in highp   uint  gl_WarpIDNV;in highp   uint  gl_SMIDNV;in highp   uint  gl_CoreIDARM;in highp   uint  gl_CoreCountARM;in highp   uint  gl_CoreMaxIDARM;in highp   uint  gl_WarpIDARM;in highp   uint  gl_WarpMaxIDARM;\n
in mediump volatile uint  gl_SubgroupSize;in mediump volatile uint  gl_SubgroupInvocationID;in highp   volatile uvec4 gl_SubgroupEqMask;in highp   volatile uvec4 gl_SubgroupGeMask;in highp   volatile uvec4 gl_SubgroupGtMask;in highp   volatile uvec4 gl_SubgroupLeMask;in highp   volatile uvec4 gl_SubgroupLtMask;in highp    uint  gl_WarpsPerSMNV;in highp    uint  gl_SMCountNV;in highp volatile uint  gl_WarpIDNV;in highp volatile uint  gl_SMIDNV;in highp   uint  gl_CoreIDARM;in highp   uint  gl_CoreCountARM;in highp   uint  gl_CoreMaxIDARM;in highp   uint  gl_WarpIDARM;in highp   uint  gl_WarpMaxIDARM;\n
in vec2 gl_BaryCoordNoPerspAMD;in vec2 gl_BaryCoordNoPerspCentroidAMD;in vec2 gl_BaryCoordNoPerspSampleAMD;in vec2 gl_BaryCoordSmoothAMD;in vec2 gl_BaryCoordSmoothCentroidAMD;in vec2 gl_BaryCoordSmoothSampleAMD;in vec3 gl_BaryCoordPullModelAMD
in vec3 gl_BaryCoordNV;in vec3 gl_BaryCoordNoPerspNV;in vec3 gl_BaryCoordEXT;in vec3 gl_BaryCoordNoPerspEXT
in vec4  gl_Color;in vec4  gl_SecondaryColor;in vec3  gl_Normal;in vec4  gl_Vertex;in vec4  gl_MultiTexCoord0;in vec4  gl_MultiTexCoord1;in vec4  gl_MultiTexCoord2;in vec4  gl_MultiTexCoord3;in vec4  gl_MultiTexCoord4;in vec4  gl_MultiTexCoord5;in vec4  gl_MultiTexCoord6;in vec4  gl_MultiTexCoord7;in float gl_FogCoord;\n
in xfb mode\n
in/out must appear before const
in_gridH
incl_scan
include
include <metal_atomic
include <metal_raytracing
include <metal_stdlib
include <simd/simd.h
include <stdint.h>\n\n
inclusive-or
inclusive_or_expression
incomplete method syntax
inconsistent input primitive for array size of
inconsistent output array size of
inconsistent output number of vertices for array size of
incorrect directive, expected identifier
index
index layout qualifier on fragment output
index out of range '%d
indexable
indirect index
indirect parameters
inductive loop index modified
inductive loop requires a scalar 'int' or 'float' loop index
inductive-loop condition requires the form "loop-index <comparison-op> constant-expression
inductive-loop init-declaration requires the form "type-specifier loop-index = constant-expression
inductive-loop termination requires the form "loop-index++, loop-index--, loop-index += constant-expression, or loop-index -= constant-expression
ineCacheL
initWithBlock
initWithBlock:forObject:atKeyPath
initWithDomain:code:userInfo
initWithFormat
initWithUTF8String
initWithUUIDBytes
init_declarator_list
initialization with shared qualifier
initializer
initializer can only be a null initializer
initializer list
initializer requires a variable, not a member
initializer_list
inline
inline T degrees(T r
inline T radians(T d
inline T sign(T x
inline T spvFaceForward(T n, T i, T nref
inline T spvFindLSB(T x
inline T spvFindSMSB(T x
inline T spvFindUMSB(T x
inline T spvGetSwizzle(vec<T, 4> x, T c, spvSwizzle s
inline T spvQuadBroadcast(T value, uint lane
inline T spvQuadSwap(T value, uint dir
inline T spvRefract(T i, T n, T eta
inline T spvSubgroupBroadcast(T value, ushort lane
inline T spvSubgroupBroadcastFirst(T value
inline T spvSubgroupShuffle(T value, ushort lane
inline T spvSubgroupShuffleDown(T value, ushort delta
inline T spvSubgroupShuffleUp(T value, ushort delta
inline T spvSubgroupShuffleXor(T value, ushort mask
inline T spvTextureSwizzle(T x, uint s
inline Tx mod(Tx x, Ty y
inline bool spvQuadBroadcast(bool value, uint lane
inline bool spvQuadSwap(bool value, uint dir
inline bool spvSubgroupAllEqual(T value
inline bool spvSubgroupAllEqual(bool value
inline bool spvSubgroupAllEqual(vec<bool, N> value
inline bool spvSubgroupBallotBitExtract(uint4 ballot, uint bit
inline bool spvSubgroupBroadcast(bool value, ushort lane
inline bool spvSubgroupBroadcastFirst(bool value
inline bool spvSubgroupShuffle(bool value, ushort lane
inline bool spvSubgroupShuffleDown(bool value, ushort delta
inline bool spvSubgroupShuffleUp(bool value, ushort delta
inline bool spvSubgroupShuffleXor(bool value, ushort mask
inline uint spvPopCount4(uint4 ballot
inline uint spvSubgroupBallotBitCount(uint4 ballot, uint gl_SubgroupSize
inline uint spvSubgroupBallotExclusiveBitCount(uint4 ballot, uint gl_SubgroupInvocationID
inline uint spvSubgroupBallotFindLSB(uint4 ballot, uint gl_SubgroupSize
inline uint spvSubgroupBallotFindMSB(uint4 ballot, uint gl_SubgroupSize
inline uint spvSubgroupBallotInclusiveBitCount(uint4 ballot, uint gl_SubgroupInvocationID
inline uint4 spvSubgroupBallot(bool value
inline vec<T, 4> spvChromaReconstructLinear420XCositedEvenYCositedEven(texture2d<T> plane0, texture2d<T> plane1, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear420XCositedEvenYCositedEven(texture2d<T> plane0, texture2d<T> plane1, texture2d<T> plane2, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear420XCositedEvenYMidpoint(texture2d<T> plane0, texture2d<T> plane1, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear420XCositedEvenYMidpoint(texture2d<T> plane0, texture2d<T> plane1, texture2d<T> plane2, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear420XMidpointYCositedEven(texture2d<T> plane0, texture2d<T> plane1, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear420XMidpointYCositedEven(texture2d<T> plane0, texture2d<T> plane1, texture2d<T> plane2, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear420XMidpointYMidpoint(texture2d<T> plane0, texture2d<T> plane1, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear420XMidpointYMidpoint(texture2d<T> plane0, texture2d<T> plane1, texture2d<T> plane2, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear422CositedEven(texture2d<T> plane0, texture2d<T> plane1, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear422CositedEven(texture2d<T> plane0, texture2d<T> plane1, texture2d<T> plane2, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear422Midpoint(texture2d<T> plane0, texture2d<T> plane1, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructLinear422Midpoint(texture2d<T> plane0, texture2d<T> plane1, texture2d<T> plane2, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructNearest(texture2d<T> plane0, texture2d<T> plane1, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvChromaReconstructNearest(texture2d<T> plane0, texture2d<T> plane1, texture2d<T> plane2, sampler samp, float2 coord, LodOptions... options
inline vec<T, 4> spvConvertYCbCrBT2020(vec<T, 4> ycbcr
inline vec<T, 4> spvConvertYCbCrBT601(vec<T, 4> ycbcr
inline vec<T, 4> spvConvertYCbCrBT709(vec<T, 4> ycbcr
inline vec<T, 4> spvExpandITUFullRange(vec<T, 4> ycbcr, int n
inline vec<T, 4> spvExpandITUNarrowRange(vec<T, 4> ycbcr, int n
inline vec<T, 4> spvGatherCompareSwizzle(const thread Tex<T>& t, sampler s, uint sw, Ts... params
inline vec<T, 4> spvGatherSwizzle(const thread Tex<T>& t, sampler s, uint sw, component c, Ts... params) METAL_CONST_ARG(c
inline vec<T, 4> spvTextureSwizzle(vec<T, 4> x, uint s
inline vec<bool, N> spvQuadBroadcast(vec<bool, N> value, uint lane
inline vec<bool, N> spvQuadSwap(vec<bool, N> value, uint dir
inline vec<bool, N> spvSubgroupBroadcast(vec<bool, N> value, ushort lane
inline vec<bool, N> spvSubgroupBroadcastFirst(vec<bool, N> value
inline vec<bool, N> spvSubgroupShuffle(vec<bool, N> value, ushort lane
inline vec<bool, N> spvSubgroupShuffleDown(vec<bool, N> value, ushort delta
inline vec<bool, N> spvSubgroupShuffleUp(vec<bool, N> value, ushort delta
inline vec<bool, N> spvSubgroupShuffleXor(vec<bool, N> value, ushort mask
inline void spvArrayCopy
inout
input block
input blocks cannot be used in a mesh shader
input primitive
inputPrimitiveTopology
inputPrimitiveTopologyMVK
input_attachment_index
inputs
insertDebugCaptureBoundary
insertDebugSignpost
insert_bits
insideTessellationFactor
instance
instanceI
instance_id
instancesRespondToSelector
instead
instruction, but found the end of the stream
instruction, but found the next instruction instead
int   floatBitsToInt(highp float value);ivec2 floatBitsToInt(highp vec2  value);ivec3 floatBitsToInt(highp vec3  value);ivec4 floatBitsToInt(highp vec4  value);uint  floatBitsToUint(highp float value);uvec2 floatBitsToUint(highp vec2  value);uvec3 floatBitsToUint(highp vec3  value);uvec4 floatBitsToUint(highp vec4  value);float intBitsToFloat(highp int   value);vec2  intBitsToFloat(highp ivec2 value);vec3  intBitsToFloat(highp ivec3 value);vec4  intBitsToFloat(highp ivec4 value);float uintBitsToFloat(highp uint  value);vec2  uintBitsToFloat(highp uvec2 value);vec3  uintBitsToFloat(highp uvec3 value);vec4  uintBitsToFloat(highp uvec4 value);\n
int  gl_ViewportMask
int bitCount(  int);ivec2 bitCount(ivec2);ivec3 bitCount(ivec3);ivec4 bitCount(ivec4);  int bitCount( uint);ivec2 bitCount(uvec2);ivec3 bitCount(uvec3);ivec4 bitCount(uvec4);  int findMSB(highp   int);ivec2 findMSB(highp ivec2);ivec3 findMSB(highp ivec3);ivec4 findMSB(highp ivec4);  int findMSB(highp  uint);ivec2 findMSB(highp uvec2);ivec3 findMSB(highp uvec3);ivec4 findMSB(highp uvec4);\n
int bitfieldExtract(  int, int, int);ivec2 bitfieldExtract(ivec2, int, int);ivec3 bitfieldExtract(ivec3, int, int);ivec4 bitfieldExtract(ivec4, int, int); uint bitfieldExtract( uint, int, int);uvec2 bitfieldExtract(uvec2, int, int);uvec3 bitfieldExtract(uvec3, int, int);uvec4 bitfieldExtract(uvec4, int, int);  int bitfieldInsert(  int base,   int, int, int);ivec2 bitfieldInsert(ivec2 base, ivec2, int, int);ivec3 bitfieldInsert(ivec3 base, ivec3, int, int);ivec4 bitfieldInsert(ivec4 base, ivec4, int, int); uint bitfieldInsert( uint base,  uint, int, int);uvec2 bitfieldInsert(uvec2 base, uvec2, int, int);uvec3 bitfieldInsert(uvec3 base, uvec3, int, int);uvec4 bitfieldInsert(uvec4 base, uvec4, int, int);\n
int empty_struct_member
int findLSB(  int);ivec2 findLSB(ivec2);ivec3 findLSB(ivec3);ivec4 findLSB(ivec4);  int findLSB( uint);ivec2 findLSB(uvec2);ivec3 findLSB(uvec3);ivec4 findLSB(uvec4);\n
int firstLive = findLSB(value.x
int firstLive = findMSB(value.y
int get_bpc() const thread { return (val & bpc_mask) >> bpc_base
int gl_InstanceID
int gl_VertexID
int mix(int, int, bool);ivec2 mix(ivec2, ivec2, bvec2);ivec3 mix(ivec3, ivec3, bvec3);ivec4 mix(ivec4, ivec4, bvec4);uint  mix(uint,  uint,  bool );uvec2 mix(uvec2, uvec2, bvec2);uvec3 mix(uvec3, uvec3, bvec3);uvec4 mix(uvec4, uvec4, bvec4);bool  mix(bool,  bool,  bool );bvec2 mix(bvec2, bvec2, bvec2);bvec3 mix(bvec3, bvec3, bvec3);bvec4 mix(bvec4, bvec4, bvec4);\n
int sparseImageLoadARB(readonly volatile coherent
int sparseImageLoadLodAMD(readonly volatile coherent
int textureQueryLevels
int(0x80000000
int(0x80H
int(1u
int(short
int);\n
int)max
int, int, int
int, int, int);\n
int, int, int, int, int
int16BitsToFloat16
int16BitsToHalf
int16_t
int2 offs = int2(fract(coord.x * plane1.get_width()) != 0.0 ? 1 : -1, 0
int2(0
int32_t
int64BitsToDouble
int64_t
int64_t abs(int64_t);i64vec2 abs(i64vec2);i64vec3 abs(i64vec3);i64vec4 abs(i64vec4);int64_t sign(int64_t);i64vec2 sign(i64vec2);i64vec3 sign(i64vec3);i64vec4 sign(i64vec4);int64_t  min(int64_t,  int64_t);i64vec2  min(i64vec2,  int64_t);i64vec3  min(i64vec3,  int64_t);i64vec4  min(i64vec4,  int64_t);i64vec2  min(i64vec2,  i64vec2);i64vec3  min(i64vec3,  i64vec3);i64vec4  min(i64vec4,  i64vec4);uint64_t min(uint64_t, uint64_t);u64vec2  min(u64vec2,  uint64_t);u64vec3  min(u64vec3,  uint64_t);u64vec4  min(u64vec4,  uint64_t);u64vec2  min(u64vec2,  u64vec2);u64vec3  min(u64vec3,  u64vec3);u64vec4  min(u64vec4,  u64vec4);int64_t  max(int64_t,  int64_t);i64vec2  max(i64vec2,  int64_t);i64vec3  max(i64vec3,  int64_t);i64vec4  max(i64vec4,  int64_t);i64vec2  max(i64vec2,  i64vec2);i64vec3  max(i64vec3,  i64vec3);i64vec4  max(i64vec4,  i64vec4);uint64_t max(uint64_t, uint64_t);u64vec2  max(u64vec2,  uint64_t);u64vec3  max(u64vec3,  uint64_t);u64vec4  max(u64vec4,  uint64_t);u64vec2  max(u64vec2,  u64vec2);u64vec3  max(u64vec3,  u64vec3);u64vec4  max(u64vec4,  u64vec4);int64_t  clamp(int64_t,  int64_t,  int64_t);i64vec2  clamp(i64vec2,  int64_t,  int64_t);i64vec3  clamp(i64vec3,  int64_t,  int64_t);i64vec4  clamp(i64vec4,  int64_t,  int64_t);i64vec2  clamp(i64vec2,  i64vec2,  i64vec2);i64vec3  clamp(i64vec3,  i64vec3,  i64vec3);i64vec4  clamp(i64vec4,  i64vec4,  i64vec4);uint64_t clamp(uint64_t, uint64_t, uint64_t);u64vec2  clamp(u64vec2,  uint64_t, uint64_t);u64vec3  clamp(u64vec3,  uint64_t, uint64_t);u64vec4  clamp(u64vec4,  uint64_t, uint64_t);u64vec2  clamp(u64vec2,  u64vec2,  u64vec2);u64vec3  clamp(u64vec3,  u64vec3,  u64vec3);u64vec4  clamp(u64vec4,  u64vec4,  u64vec4);int64_t  mix(int64_t,  int64_t,  bool);i64vec2  mix(i64vec2,  i64vec2,  bvec2);i64vec3  mix(i64vec3,  i64vec3,  bvec3);i64vec4  mix(i64vec4,  i64vec4,  bvec4);uint64_t mix(uint64_t, uint64_t, bool);u64vec2  mix(u64vec2,  u64vec2,  bvec2);u64vec3  mix(u64vec3,  u64vec3,  bvec3);u64vec4  mix(u64vec4,  u64vec4,  bvec4);int64_t doubleBitsToInt64(float64_t);i64vec2 doubleBitsToInt64(f64vec2);i64vec3 doubleBitsToInt64(f64vec3);i64vec4 doubleBitsToInt64(f64vec4);uint64_t doubleBitsToUint64(float64_t);u64vec2  doubleBitsToUint64(f64vec2);u64vec3  doubleBitsToUint64(f64vec3);u64vec4  doubleBitsToUint64(f64vec4);float64_t int64BitsToDouble(int64_t);f64vec2  int64BitsToDouble(i64vec2);f64vec3  int64BitsToDouble(i64vec3);f64vec4  int64BitsToDouble(i64vec4);float64_t uint64BitsToDouble(uint64_t);f64vec2  uint64BitsToDouble(u64vec2);f64vec3  uint64BitsToDouble(u64vec3);f64vec4  uint64BitsToDouble(u64vec4);int64_t  packInt2x32(ivec2);uint64_t packUint2x32(uvec2);ivec2    unpackInt2x32(int64_t);uvec2    unpackUint2x32(uint64_t);bvec2 lessThan(i64vec2, i64vec2);bvec3 lessThan(i64vec3, i64vec3);bvec4 lessThan(i64vec4, i64vec4);bvec2 lessThan(u64vec2, u64vec2);bvec3 lessThan(u64vec3, u64vec3);bvec4 lessThan(u64vec4, u64vec4);bvec2 lessThanEqual(i64vec2, i64vec2);bvec3 lessThanEqual(i64vec3, i64vec3);bvec4 lessThanEqual(i64vec4, i64vec4);bvec2 lessThanEqual(u64vec2, u64vec2);bvec3 lessThanEqual(u64vec3, u64vec3);bvec4 lessThanEqual(u64vec4, u64vec4);bvec2 greaterThan(i64vec2, i64vec2);bvec3 greaterThan(i64vec3, i64vec3);bvec4 greaterThan(i64vec4, i64vec4);bvec2 greaterThan(u64vec2, u64vec2);bvec3 greaterThan(u64vec3, u64vec3);bvec4 greaterThan(u64vec4, u64vec4);bvec2 greaterThanEqual(i64vec2, i64vec2);bvec3 greaterThanEqual(i64vec3, i64vec3);bvec4 greaterThanEqual(i64vec4, i64vec4);bvec2 greaterThanEqual(u64vec2, u64vec2);bvec3 greaterThanEqual(u64vec3, u64vec3);bvec4 greaterThanEqual(u64vec4, u64vec4);bvec2 equal(i64vec2, i64vec2);bvec3 equal(i64vec3, i64vec3);bvec4 equal(i64vec4, i64vec4);bvec2 equal(u64vec2, u64vec2);bvec3 equal(u64vec3, u64vec3);bvec4 equal(u64vec4, u64vec4);bvec2 notEqual(i64vec2, i64vec2);bvec3 notEqual(i64vec3, i64vec3);bvec4 notEqual(i64vec4, i64vec4);bvec2 notEqual(u64vec2, u64vec2);bvec3 notEqual(u64vec3, u64vec3);bvec4 notEqual(u64vec4, u64vec4);int64_t bitCount(int64_t);i64vec2 bitCount(i64vec2);i64vec3 bitCount(i64vec3);i64vec4 bitCount(i64vec4);in
int8_t
int8_t abs(int8_t);i8vec2 abs(i8vec2);i8vec3 abs(i8vec3);i8vec4 abs(i8vec4);int8_t sign(int8_t);i8vec2 sign(i8vec2);i8vec3 sign(i8vec3);i8vec4 sign(i8vec4);int8_t min(int8_t x, int8_t y);i8vec2 min(i8vec2 x, int8_t y);i8vec3 min(i8vec3 x, int8_t y);i8vec4 min(i8vec4 x, int8_t y);i8vec2 min(i8vec2 x, i8vec2 y);i8vec3 min(i8vec3 x, i8vec3 y);i8vec4 min(i8vec4 x, i8vec4 y);uint8_t min(uint8_t x, uint8_t y);u8vec2 min(u8vec2 x, uint8_t y);u8vec3 min(u8vec3 x, uint8_t y);u8vec4 min(u8vec4 x, uint8_t y);u8vec2 min(u8vec2 x, u8vec2 y);u8vec3 min(u8vec3 x, u8vec3 y);u8vec4 min(u8vec4 x, u8vec4 y);int8_t max(int8_t x, int8_t y);i8vec2 max(i8vec2 x, int8_t y);i8vec3 max(i8vec3 x, int8_t y);i8vec4 max(i8vec4 x, int8_t y);i8vec2 max(i8vec2 x, i8vec2 y);i8vec3 max(i8vec3 x, i8vec3 y);i8vec4 max(i8vec4 x, i8vec4 y);uint8_t max(uint8_t x, uint8_t y);u8vec2 max(u8vec2 x, uint8_t y);u8vec3 max(u8vec3 x, uint8_t y);u8vec4 max(u8vec4 x, uint8_t y);u8vec2 max(u8vec2 x, u8vec2 y);u8vec3 max(u8vec3 x, u8vec3 y);u8vec4 max(u8vec4 x, u8vec4 y);int8_t    clamp(int8_t x, int8_t minVal, int8_t maxVal);i8vec2  clamp(i8vec2  x, int8_t minVal, int8_t maxVal);i8vec3  clamp(i8vec3  x, int8_t minVal, int8_t maxVal);i8vec4  clamp(i8vec4  x, int8_t minVal, int8_t maxVal);i8vec2  clamp(i8vec2  x, i8vec2  minVal, i8vec2  maxVal);i8vec3  clamp(i8vec3  x, i8vec3  minVal, i8vec3  maxVal);i8vec4  clamp(i8vec4  x, i8vec4  minVal, i8vec4  maxVal);uint8_t   clamp(uint8_t x, uint8_t minVal, uint8_t maxVal);u8vec2  clamp(u8vec2  x, uint8_t minVal, uint8_t maxVal);u8vec3  clamp(u8vec3  x, uint8_t minVal, uint8_t maxVal);u8vec4  clamp(u8vec4  x, uint8_t minVal, uint8_t maxVal);u8vec2  clamp(u8vec2  x, u8vec2  minVal, u8vec2  maxVal);u8vec3  clamp(u8vec3  x, u8vec3  minVal, u8vec3  maxVal);u8vec4  clamp(u8vec4  x, u8vec4  minVal, u8vec4  maxVal);int8_t  mix(int8_t,  int8_t,  bool);i8vec2  mix(i8vec2,  i8vec2,  bvec2);i8vec3  mix(i8vec3,  i8vec3,  bvec3);i8vec4  mix(i8vec4,  i8vec4,  bvec4);uint8_t mix(uint8_t, uint8_t, bool);u8vec2  mix(u8vec2,  u8vec2,  bvec2);u8vec3  mix(u8vec3,  u8vec3,  bvec3);u8vec4  mix(u8vec4,  u8vec4,  bvec4);bvec2 lessThan(i8vec2, i8vec2);bvec3 lessThan(i8vec3, i8vec3);bvec4 lessThan(i8vec4, i8vec4);bvec2 lessThan(u8vec2, u8vec2);bvec3 lessThan(u8vec3, u8vec3);bvec4 lessThan(u8vec4, u8vec4);bvec2 lessThanEqual(i8vec2, i8vec2);bvec3 lessThanEqual(i8vec3, i8vec3);bvec4 lessThanEqual(i8vec4, i8vec4);bvec2 lessThanEqual(u8vec2, u8vec2);bvec3 lessThanEqual(u8vec3, u8vec3);bvec4 lessThanEqual(u8vec4, u8vec4);bvec2 greaterThan(i8vec2, i8vec2);bvec3 greaterThan(i8vec3, i8vec3);bvec4 greaterThan(i8vec4, i8vec4);bvec2 greaterThan(u8vec2, u8vec2);bvec3 greaterThan(u8vec3, u8vec3);bvec4 greaterThan(u8vec4, u8vec4);bvec2 greaterThanEqual(i8vec2, i8vec2);bvec3 greaterThanEqual(i8vec3, i8vec3);bvec4 greaterThanEqual(i8vec4, i8vec4);bvec2 greaterThanEqual(u8vec2, u8vec2);bvec3 greaterThanEqual(u8vec3, u8vec3);bvec4 greaterThanEqual(u8vec4, u8vec4);bvec2 equal(i8vec2, i8vec2);bvec3 equal(i8vec3, i8vec3);bvec4 equal(i8vec4, i8vec4);bvec2 equal(u8vec2, u8vec2);bvec3 equal(u8vec3, u8vec3);bvec4 equal(u8vec4, u8vec4);bvec2 notEqual(i8vec2, i8vec2);bvec3 notEqual(i8vec3, i8vec3);bvec4 notEqual(i8vec4, i8vec4);bvec2 notEqual(u8vec2, u8vec2);bvec3 notEqual(u8vec3, u8vec3);bvec4 notEqual(u8vec4, u8vec4);  int8_t bitfieldExtract(  int8_t, int8_t, int8_t);i8vec2 bitfieldExtract(i8vec2, int8_t, int8_t);i8vec3 bitfieldExtract(i8vec3, int8_t, int8_t);i8vec4 bitfieldExtract(i8vec4, int8_t, int8_t); uint8_t bitfieldExtract( uint8_t, int8_t, int8_t);u8vec2 bitfieldExtract(u8vec2, int8_t, int8_t);u8vec3 bitfieldExtract(u8vec3, int8_t, int8_t);u8vec4 bitfieldExtract(u8vec4, int8_t, int8_t);  int8_t bitfieldInsert(  int8_t base,   int8_t, int8_t, int8_t);i8vec2 bitfieldInsert(i8vec2 base, i8vec2, int8_t, int8_t);i8vec3 bitfieldInsert(i8vec3 base, i8vec3, int8_t, int8_t);i8vec4 bitfieldInsert(i8vec4 base, i8vec4, int8_t, int8_t); uint8_t bitfieldInsert( uint8_t base,  uint8_t, int8_t, int8_t);u8vec2 bitfieldInsert(u8vec2 base, u8vec2, int8_t, int8_t);u8vec3 bitfieldInsert(u8vec3
intBitsToFloat
intCoordH
integer
integer_expression
interface
interlock ordering
internal max is %d
interpolant
interpolateAtCentroid
interpolateAtOffset
interpolateAtSample
interpolateAtVertex
interpolateAtVertexAMD
interpolate_at_center
interpolate_at_centroid
interpolate_at_offset
interpolate_at_sample
interpolation
interpolation qualifiers must appear before storage and precision qualifiers
interpolation_qualifier
intersection
intersection_params ip
intersection_params spvMakeIntersectionParams(uint flags
intfEXT(H
invalid directive
invalid token
invariant
invariant gl_Position
invariant qualifier must appear before interpolation, storage, and precision qualifiers
invariant_qualifier
inverse
inverse sqrt
inversesqrt
invert-y
invocation operation
invocations
ionIndexH
ionPerViH
iosurface
ip.accept_any_intersection(true
ip.force_opacity(forced_opacity::non_opaque
ip.force_opacity(forced_opacity::opaque
ip.set_geometry_cull_mode(geometry_cull_mode::bounding_box
ip.set_geometry_cull_mode(geometry_cull_mode::triangle
ip.set_opacity_cull_mode(opacity_cull_mode::non_opaque
ip.set_opacity_cull_mode(opacity_cull_mode::opaque
ip.set_triangle_cull_mode(triangle_cull_mode::back
ip.set_triangle_cull_mode(triangle_cull_mode::front
ipVertexH
ipdateDescriptorSet
ipeline
ipelineBarrier
ipelineCacheData
ipelinesH
ipmap
irect
irementsH
is a type, not a value
is an array of UBOs
is an empty struct
is being used for
is defined more than once
is not a block
is not a readable file
is not a scalar integer
is not a scalar numeric type
is not a struct
is not a type
is not a valid Component index, which must be one of 0, 1, 2, or 3
is not supported for vertex buffers on this device
is not supported on this device
isAbsolutePath
isDepth24Stencil8PixelFormatSupported
isEqual
isEqualToString
isHeadless
isKindOfClass
isLowPower
isMainThread
isMemberOfClass
isProxy
isReadableFileAtPath
isRemovable
isWritableFileAtPath
is_candidate_non_opaque_bounding_box
is_candidate_triangle_front_facing
is_committed_triangle_front_facing
is_function_constant_defined
is_function_constant_defined(spvLinearTextureAlignmentOverride
isampler1D
isampler1DArray
isampler2D
isampler2DArray
isampler2DMS
isampler2DMSArray
isampler2DRect
isampler3D
isamplerBuffer
isamplerCube
isamplerCubeArray
isfinite
ismatch.K
isolines
isolinesH
ispatch
istringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
isubpassInput
isubpassInputMS
isunordered
itEventsH
itImage2H
iteration_multiple
iteration_statement
iteration_statement_nonattributed
itexture1D
itexture1DArray
itexture2D
itexture2DArray
itexture2DMS
itexture2DMSArray
itexture2DRect
itexture3D
itextureBuffer
itextureCube
itextureCubeArray
ithCountH
itiesKHRH
itiveEXTH
itu_full = 0
itu_narrow
iubmitDebugUtilsMessageEXT
ivec2
ivec2 c = bitCount(v
ivec2 c = bitCount(value.xy
ivec2(0)H
ivec2(1)H
ivec2(gl_FragCoord.xy
ivec2(gl_FragCoord.xy), 0
ivec2/uvec2 convert to texture handle
ivec3
ivec3(0)H
ivec3(1)H
ivec4(0)H
ivec4(1)H
ixelFormat
jSemaphores
jectsEXTH
jffff
jseIOSurfaceMVK
jsonu\vH
jump_statement
kCAFilterLinear
kCAFilterNearest
kCAGravityBottom
kCAGravityBottomLeft
kCAGravityBottomRight
kCAGravityCenter
kCAGravityLeft
kCAGravityResize
kCAGravityResizeAspect
kCAGravityRight
kCAGravityTop
kCAGravityTopLeft
kCAGravityTopRight
kCFAllocatorDefault
kCGColorSpaceAdobeRGB1998
kCGColorSpaceDCIP3
kCGColorSpaceDisplayP3
kCGColorSpaceExtendedLinearDisplayP3
kCGColorSpaceExtendedLinearITUR_2020
kCGColorSpaceExtendedLinearSRGB
kCGColorSpaceExtendedSRGB
kCGColorSpaceITUR_2100_HLG
kCGColorSpaceITUR_2100_PQ
kCGColorSpaceITUR_709
kCGColorSpaceSRGB
kGroupIDH
kIOSurfaceBytesPerElement
kIOSurfaceElementHeight
kIOSurfaceElementWidth
kIOSurfaceHeight
kIOSurfaceIsGlobal
kIOSurfacePlaneBytesPerElement
kIOSurfacePlaneElementHeight
kIOSurfacePlaneElementWidth
kIOSurfacePlaneHeight
kIOSurfacePlaneInfo
kIOSurfacePlaneWidth
kIOSurfaceWidth
kNegotiateLoaderICDInterfaceVersion
kPhysicalDeviceProcAddr
kUTᓭg
keep-uncH
keep-uncalled
kernel
kernel enqeue flags
kernel profiling info
keyPath
kffff
l-value of swizzle cannot have duplicate components
l-value required
lResultsH
l_fence
la_symbol_ptr
ladder_break
ladder_break = false
ladder_break = true
last case/default label not followed by statements
lastPathComponent
layout
layout offset = %d | member alignment = %d
layout qualifier
layout qualifier can not have storage qualifiers
layout(binding=X) is required
layout(buffer_reference) buffer
layout(buffer_reference, buffer_reference_align
layout(constant_id
layout(depth_greater) out float gl_FragDepth
layout(depth_less) out float gl_FragDepth
layout(passthrough) in gl_PerVertex
layout(pixel_interlock_ordered) in
layout(pixel_interlock_unordered) in
layout(primitive_culling
layout(r11f_g11f_b10f
layout(r32f
layout(r32ui
layout(rg16
layout(rg16f
layout(rg16i
layout(rg16ui
layout(rgb10_a2
layout(rgb10_a2ui
layout(rgba8
layout(rgba8i
layout(rgba8ui
layout(sample_interlock_ordered) in
layout(sample_interlock_unordered) in
layout(xfb_offset
layout-id value
layoutBindlessImage
layoutBindlessSampler
layoutSecondaryViewportRelativeOffset
layoutViewportRelative
layout_qualifier
layout_qualifier_id
layout_qualifier_id_list
layouts
layoutsH
ldexp
le_imageH
le_stripH
leaseSwapchainImagesEXT
left of '[' is not of type array, matrix, or vector
left shift second child into first child
left-shift
leng3\b
length
length() on vectors and matrices
lessThan
lessThanEqual
level
level(0
lfffff
lgamma
lgamma_r
limitation
limitations
line 1\n
line continuation
line_strH
line_strip
linear
linearH
linearI
lines_adH
lines_adjacency
linkage type
litImageH
literal number
literal string
literalH
llBufferH
lld (%s
llu (%s
local function declaration
local_size
local_size id
local_size ids
local_size_x
local_size_x_id
local_size_y
local_size_y_id
local_size_z
local_size_z_id
localizedDescription
localizedName
location
location is too large
location on block member
location qualifier on in/out block
location qualifier on input
location qualifier on output
location qualifier on uniform or buffer
location/component/index
locationH
locationH9
locationI9
locationNumber
lockTexelSize
lod_clamp
logical-and
logical-or
logical-xor
logical_and_expression
logical_or_expression
logical_xor_expression
long types in buffers are only supported in MSL 2.3 and above
loop control
lorWriteMaskFromVkChannelFlags
lowPower
lowp   int bitCount(  int);lowp ivec2 bitCount(ivec2);lowp ivec3 bitCount(ivec3);lowp ivec4 bitCount(ivec4);lowp   int bitCount( uint);lowp ivec2 bitCount(uvec2);lowp ivec3 bitCount(uvec3);lowp ivec4 bitCount(uvec4);lowp   int findMSB(highp   int);lowp ivec2 findMSB(highp ivec2);lowp ivec3 findMSB(highp ivec3);lowp ivec4 findMSB(highp ivec4);lowp   int findMSB(highp  uint);lowp ivec2 findMSB(highp uvec2);lowp ivec3 findMSB(highp uvec3);lowp ivec4 findMSB(highp uvec4);\n
lowp   int findLSB(  int);lowp ivec2 findLSB(ivec2);lowp ivec3 findLSB(ivec3);lowp ivec4 findLSB(ivec4);lowp   int findLSB( uint);lowp ivec2 findLSB(uvec2);lowp ivec3 findLSB(uvec3);lowp ivec4 findLSB(uvec4);\n
lowp precision qualifier
lowp uint stencilAttachmentReadEXT();lowp uint stencilAttachmentReadEXT(int);highp float depthAttachmentReadEXT();highp float depthAttachmentReadEXT(int);\n
lt_valueH
lushMappedMemoryRanges
m.columns[i] = columns[i
m_location
mach_absolute_time
mach_continuous_time
mach_host_self
mach_task_self
mach_timebase_info
macro expansion
mag_filtH
mag_filter::linear
mage2KHRH
mageSampleFootprintGradClampNV
magesKHRH
mainScreen
mainf
mainfA
mainfǅE
mainfǅU
mainfǅe
maint7L
mainu
mainƅN
makeAliasable
malloc
mandPool
map::at:  key not found
mapped binding out of range
mapped set out of range
maskrune
maskƅu
mat2   outerProduct(vec2 c, vec2 r);mat3   outerProduct(vec3 c, vec3 r);mat4   outerProduct(vec4 c, vec4 r);mat2x3 outerProduct(vec3 c, vec2 r);mat3x2 outerProduct(vec2 c, vec3 r);mat2x4 outerProduct(vec4 c, vec2 r);mat4x2 outerProduct(vec2 c, vec4 r);mat3x4 outerProduct(vec4 c, vec3 r);mat4x3 outerProduct(vec3 c, vec4 r);mat2   transpose(mat2   m);mat3   transpose(mat3   m);mat4   transpose(mat4   m);mat2x3 transpose(mat3x2 m);mat3x2 transpose(mat2x3 m);mat2x4 transpose(mat4x2 m);mat4x2 transpose(mat2x4 m);mat3x4 transpose(mat4x3 m);mat4x3 transpose(mat3x4 m);mat2x3 matrixCompMult(mat2x3, mat2x3);mat2x4 matrixCompMult(mat2x4, mat2x4);mat3x2 matrixCompMult(mat3x2, mat3x2);mat3x4 matrixCompMult(mat3x4, mat3x4);mat4x2 matrixCompMult(mat4x2, mat4x2);mat4x3 matrixCompMult(mat4x3, mat4x3);\n
mat2 m
mat2 matrixCompMult(mat2 x, mat2 y);mat3 matrixCompMult(mat3 x, mat3 y);mat4 matrixCompMult(mat4 x, mat4 y);\n
mat2 spvInverse
mat2 spvTranspose
mat2x2
mat2x3
mat2x4
mat3 m
mat3 spvInverse
mat3 spvTranspose
mat3x2
mat3x3
mat3x4
mat4 m
mat4 spvInverse
mat4 spvTranspose
mat4x2
mat4x3
mat4x4
matrix constructed from matrix can only have one argument
matrix index out of range '%d
matrix mult second child into first child
matrix of
matrix or packing qualifiers can only be used on a uniform or buffer
matrix sH
matrix scale second child into first child
matrix swizzle
matrix-multiply
matrix-scale
matrix-times-vector
matrix<T, Cols, Rows> m
matrix<T, Cols, Rows>& m
matrix<T, RCols, LRows> res
matrix<T, Rows, Cols> transpose(spvStorageMatrix<T, Cols, Rows> m
matrixCompMult
matrix_sH
matrix_stride
mats2KHRH
maxArgumentBufferSamplerCount
maxBufferLength
maxInvocations
maxInvocationsAMD
maxInvocationsExclusiveScan
maxInvocationsExclusiveScanAMD
maxInvocationsExclusiveScanNonUniform
maxInvocationsExclusiveScanNonUniformAMD
maxInvocationsInclusiveScan
maxInvocationsInclusiveScanAMD
maxInvocationsInclusiveScanNonUniform
maxInvocationsInclusiveScanNonUniformAMD
maxInvocationsNonUniform
maxInvocationsNonUniformAMD
maxThreadgroupMemoryLength
maxThreadsPerThreadgroup
maxTotalThreadsPerThreadgroup
maxTransferRate
max_anisotropy
max_iterations
max_primH
max_primitives
max_vertH
max_vertices
maximum nesting depth exceeded
maximumConcurrentCompilationTaskCount
maximumConcurrentCompilationTaskCount %lu
maximumDrawableCount
maximumDrawableCountMVK
maximumFramesPerSecond
maxmag
may be removed in future release
maybe_unused
mbcntAMD
median3
mediump
mediump I
mediump precision qualifier
mediump vec2 unpackHalf2x16(highp uint);\n
mediump vec4 gl_FragCoord;        bool gl_FrontFacing;mediump vec4 gl_FragColor;mediump vec2 gl_PointCoord
mediump vec4 gl_SecondaryFragColorEXT;mediump vec4 gl_SecondaryFragDataEXT[gl_MaxDualSourceDrawBuffersEXT];\n
mediump vec4 unpackSnorm4x8(highp uint);mediump vec4 unpackUnorm4x8(highp uint);\n
mem_flags::mem_device
mem_flags::mem_device_and_threadgroup
mem_flags::mem_none
mem_flags::mem_texture
mem_flags::mem_threadgroup
member cannot contradict block
member cannot contradict block (or what block inherited from global
member cannot have a spirv_decorate_id qualifier
member cannot have a spirv_storage_class qualifier
member name mismatch
member of block cannot be or contain a cooperative matrix type
member of block cannot be or contain a sampler, image, or atomic_uint type
member of block cannot have a packing layout qualifier
member of nameless block was not redeclared
member of uniform or buffer block cannot have an auxiliary or interpolation qualifier
member storage qualifier cannot contradict block storage qualifier
members
memchr
memcmp
memcpy
memmove
memory
memory access
memory exhausted
memory model
memory qualifiers cannot be used on this type
memory semantics ID
memoryBarrier
memoryBarrierAtomicCounter
memoryBarrierBuffer
memoryBarrierImage
memoryBarrierShared
memoryBarrierWithResources:count:afterStages:beforeStages
memoryBarrierWithScope:afterStages:beforeStages
memory_order_relaxed
memset
memset_pattern16
mentsKHRL
mesh shaders
mesh view output array size must be gl_MaxMeshViewCountNV or implicitly sized
method does not accept any arguments
metic_types 1\n#define GL_EXT_shader_explicit_arithmetic_types_int8 1\n#define GL_EXT_shader_explicit_arithmetic_types_int16 1\n#define GL_EXT_shader_explicit_arithmetic_types_int32 1\n#define GL_EXT_shader_explicit_arithmetic_types_int64 1\n#define GL_EXT_shader_explicit_arithmetic_types_float16 1\n#define GL_EXT_shader_explicit_arithmetic_types_float32 1\n#define GL_EXT_shader_explicit_arithmetic_types_float64 1\n#define GL_EXT_shader_subgroup_extended_types_int8 1\n#define GL_EXT_shader_subgroup_extended_types_int16 1\n#define GL_EXT_shader_subgroup_extended_types_int64 1\n#define GL_EXT_shader_subgroup_extended_types_float16 1\n#define GL_EXT_shader_atomic_float 1\n#define GL_EXT_shader_atomic_float2 1\n#define GL_EXT_fragment_shader_barycentric 1\n
mffffff
micromapH
midpoint
minInvocations
minInvocationsAMD
minInvocationsExclusiveScan
minInvocationsExclusiveScanAMD
minInvocationsExclusiveScanNonUniform
minInvocationsExclusiveScanNonUniformAMD
minInvocationsInclusiveScan
minInvocationsInclusiveScanAMD
minInvocationsInclusiveScanNonUniform
minInvocationsInclusiveScanNonUniformAMD
minInvocationsNonUniform
minInvocationsNonUniformAMD
min_filtH
min_filter::linear
min_iterations
min_lod_clamp
min_lod_clamp() is only supported in MSL 2.2+ and up
minimum stride needed
minimumLinearTextureAlignmentForPixelFormat
minimumTextureBufferAlignmentForPixelFormat
minmag
mip_filtH
mip_filter::linear
mip_filter::nearest
mipmapLevelCount
mismatched statements
missing
missing #endif
missing after extension name
missing parenthesis
missing perprimitiveNV qualifier to redeclared block member
missing perviewNV qualifier to redeclared block member
missing space after macro name
missing user function; linker needs to catch that
mitiveIDH
mitives*H
mmands2
mod second child into first child
mod_init_func
modff
mory2KHRH
moryProperties
move second child to first child
mp_copy
mpareFunctionFromVkCompareOp
mpleMaskH
mulhi
multiple prototypes for same function
multiplicative_expression
multiply second child into first child
multiply32x16
must be 0, 1, 2, or 3
must be a compile-time constant
must be a constant integer expression
must be a multiple of size of first component
must be a multiple of the member's alignment
must be a non-negative integer
must be a positive integer
must be a power of 2
must be a scalar floating point or integer type
must be at least 1
must be followed by a header name
must be followed by macro name
must be followed by version number
must be greater than 0
must be greater than or equal to 1
must be in the range [0, 2
must be less than or equal to
must be positive
must be qualified as flat
must by followed by an integral literal
must occur first in shader
must specify 'location' to use 'component
mvk-debug
mvk-error
mvk-error] %s\n
mvk-info
mvk-trace] %s()%s [%llu/%llu/%s]\n
mvk-trace] %s()%s\n
mvk-trace] } %s [%.4f ms]\n
mvk-trace] } %s\n
mvk-warn
mvkCGPointFromVkOffset2D
mvkCGRectFromVkRectLayerKHR
mvkCGSizeFromVkExtent2D
mvkFormatTypeFromMTLPixelFormat
mvkFormatTypeFromVkFormat
mvkMTLBarrierScopeFromVkAccessFlags
mvkMTLBlendFactorFromVkBlendFactor
mvkMTLBlendOperationFromVkBlendOp
mvkMTLCPUCacheModeFromVkMemoryPropertyFlags
mvkMTLClearColorFromVkClearValue
mvkMTLClearDepthFromVkClearValue
mvkMTLClearStencilFromVkClearValue
mvkMTLColorWriteMaskFromVkChannelFlags
mvkMTLCompareFunctionFromVkCompareOp
mvkMTLCullModeFromVkCullModeFlags
mvkMTLIndexTypeFromVkIndexType
mvkMTLIndexTypeSizeInBytes
mvkMTLLoadActionFromVkAttachmentLoadOp
mvkMTLMultisampleDepthResolveFilterFromVkResolveModeFlagBits
mvkMTLMultisampleStencilResolveFilterFromVkResolveModeFlagBits
mvkMTLPixelFormatBlockTexelSize
mvkMTLPixelFormatBytesPerBlock
mvkMTLPixelFormatBytesPerLayer
mvkMTLPixelFormatBytesPerRow
mvkMTLPixelFormatBytesPerTexel
mvkMTLPixelFormatFromVkFormat
mvkMTLPixelFormatIsDepthFormat
mvkMTLPixelFormatIsPVRTCFormat
mvkMTLPixelFormatIsStencilFormat
mvkMTLPixelFormatIsSupported
mvkMTLPixelFormatName
mvkMTLPrimitiveTopologyClassFromVkPrimitiveTopology
mvkMTLPrimitiveTypeFromVkPrimitiveTopology
mvkMTLRenderStagesFromVkPipelineStageFlags
mvkMTLResourceOptions
mvkMTLSamplerAddressModeFromVkSamplerAddressMode
mvkMTLSamplerBorderColorFromVkBorderColor
mvkMTLSamplerMinMagFilterFromVkFilter
mvkMTLSamplerMipFilterFromVkSamplerMipmapMode
mvkMTLScissorRectFromVkRect2D
mvkMTLStencilOperationFromVkStencilOp
mvkMTLStepFunctionFromVkVertexInputRate
mvkMTLStorageModeFromVkMemoryPropertyFlags
mvkMTLStoreActionFromVkAttachmentStoreOp
mvkMTLTessellationPartitionModeFromSpvExecutionMode
mvkMTLTextureSwizzleChannelsFromVkComponentMapping
mvkMTLTextureSwizzleFromVkComponentSwizzle
mvkMTLTextureTypeFromVkImageType
mvkMTLTextureTypeFromVkImageViewType
mvkMTLTextureUsageFromVkImageUsageFlags
mvkMTLTriangleFillModeFromVkPolygonMode
mvkMTLVertexFormatFromVkFormat
mvkMTLVertexStepFunctionFromVkVertexInputRate
mvkMTLViewportFromVkViewport
mvkMTLWindingFromSpvExecutionMode
mvkMTLWindingFromVkFrontFace
mvkMipmapBaseSizeFromLevelSize2D
mvkMipmapBaseSizeFromLevelSize3D
mvkMipmapLevelSizeFromBaseSize2D
mvkMipmapLevelSizeFromBaseSize3D
mvkMipmapLevels
mvkMipmapLevels2D
mvkMipmapLevels3D
mvkSampleCountFromVkSampleCountFlagBits
mvkShaderStageFromVkShaderStageFlagBits
mvkVkClearColorFloatValueFromVkComponentSwizzle
mvkVkClearColorIntValueFromVkComponentSwizzle
mvkVkClearColorUIntValueFromVkComponentSwizzle
mvkVkExtent2DFromCGSize
mvkVkFormatBlockTexelSize
mvkVkFormatBytesPerBlock
mvkVkFormatBytesPerLayer
mvkVkFormatBytesPerRow
mvkVkFormatBytesPerTexel
mvkVkFormatFromMTLPixelFormat
mvkVkFormatIsSupported
mvkVkFormatName
mvkVkFormatProperties
mvkVkImageTypeFromMTLTextureType
mvkVkImageUsageFlagsFromMTLTextureUsage
mvkVkSampleCountFlagBitsFromSampleCount
mvkVkShaderStageFlagBitsFromMVKShaderStage
m۶m۶mH
m۶m۶mI9
m۶m۶mL
n                                                                                                                \ntypedef struct {                                                                                                \n    uint32_t width;                                                                                             \n    uint32_t height;                                                                                            \n    uint32_t depth;                                                                                             \n} __attribute__((packed)) VkExtent3D;                                                                           \n                                                                                                                \ntypedef struct {                                                                                                \n    int32_t x;                                                                                                  \n    int32_t y;                                                                                                  \n    int32_t z;                                                                                                  \n} __attribute__((packed)) VkOffset3D;                                                                           \n                                                                                                                \nstatic bool isBC1Format(VkFormat format) { return format == VK_FORMAT_BC1_RGB_UNORM_BLOCK || format == VK_FORMAT_BC1_RGB_SRGB_BLOCK || format == VK_FORMAT_BC1_RGBA_UNORM_BLOCK || format == VK_FORMAT_BC1_RGBA_SRGB_BLOCK; } static bool isBC2Format(VkFormat format) { return format == VK_FORMAT_BC2_UNORM_BLOCK || format == VK_FORMAT_BC2_SRGB_BLOCK; } static bool isBC3Format(VkFormat format) { return format == VK_FORMAT_BC3_UNORM_BLOCK || format == VK_FORMAT_BC3_SRGB_BLOCK; } static bool isSRGBFormat(VkFormat format) { return format == VK_FORMAT_BC1_RGB_SRGB_BLOCK || format == VK_FORMAT_BC1_RGBA_SRGB_BLOCK || format == VK_FORMAT_BC2_SRGB_BLOCK || format == VK_FORMAT_BC3_SRGB_BLOCK; } static void buildDXTnColourTable(uint16_t colour0, uint16_t colour1, thread float3* pColourTable, VkFormat format) { pColourTable[0] = unpack_unorm565_to_float(colour0); pColourTable[1] = unpack_unorm565_to_float(colour1); if (isBC1Format(format) && colour0 <= colour1) { pColourTable[2] = (pColourTable[0] + pColourTable[1]) / 2; pColourTable[3] = float3(0); } else { for (uint32_t i = 0; i < 2; ++i) { pColourTable[i + 2] = (2 * pColourTable[i] + pColourTable[1 - i]) / 3; } } } static void buildDXT5AlphaTable(uint8_t alpha0, uint8_t alpha1, thread float* pAlphaTable) { pAlphaTable[0] = alpha0 / 255.0f; pAlphaTable[1] = alpha1 / 255.0f; if (alpha0 > alpha1) { for (uint32_t i = 0; i < 6; ++i) { pAlphaTable[2 + i] = ((6 - i) * pAlphaTable[0] + (i + 1) * pAlphaTable[1]) / 7; } } else { for (uint32_t i = 0; i < 4; ++i) { pAlphaTable[2 + i] = ((4 - i) * pAlphaTable[0] + (i + 1) * pAlphaTable[1]) / 5; } pAlphaTable[6] = 0; pAlphaTable[7] = 1; } } static float3 sRGBCorrect(float3 colour) { return select(pow((colour + 0.055)/1.055, float3(2.4)), colour/12.92, colour <= 0.04045); } static void decompressDXTnBlock(const device void* pSrc, thread void* pDest, VkExtent2D extent, VkDeviceSize destRowPitch, VkFormat format) { const device uint32_t* pSrcBlock = (const device uint32_t *)pSrc; bool isBC1Alpha = false; float3 colourTable[4]; float alphaTable[8]; size_t alphaBits; uint32_t colourBits; if (isBC1Format(format)) { alphaBits = 0; uint16_t colour0 = pSrcBlock[0] & 0xffff; uint16_t colour1 = pSrcBlock[0] >> 16; colourBits = pSrcBlock[1]; buildDXTnColourTable(colour0, colour1, colourTable, format); if (colour0 <= colour1) { isBC1Alpha = true; } } else { alphaBits = pSrcBlock[0] | ((size_t)pSrcBlock[1] << 32); if (isBC3Format(format)) { buildDXT5AlphaTable(alphaBits & 0xff, (alphaBits >> 8) & 0xff, alphaTable); alphaBits >>= 16; } c
n                                           &((constant uint16_t*)triFanIdxs)[src.indexStart],                   \n                                           src.indexCount);                                                     \n                break;                                                                                          \n            case MTLIndexTypeUInt32:                                                                            \n                populateTriIndxsFromTriFan(&((device uint32_t*)triIdxs)[dst.indexStart],                        \n                                           &((constant uint32_t*)triFanIdxs)[src.indexStart],                   \n                                           src.indexCount);                                                     \n                break;                                                                                          \n        }                                                                                                       \n    }                                                                                                           \n}                                                                                                               \n                                                                                                                \n#if __METAL_VERSION__ >= 120                                                                                    \nkernel void cmdDrawIndirectTessConvertBuffers(const device char* srcBuff [[buffer(0)]],                         \n                                              device char* destBuff [[buffer(1)]],                              \n                                              device char* paramsBuff [[buffer(2)]],                            \n                                              constant uint32_t& srcStride [[buffer(3)]],                       \n                                              constant uint32_t& inControlPointCount [[buffer(4)]],             \n                                              constant uint32_t& outControlPointCount [[buffer(5)]],            \n                                              constant uint32_t& drawCount [[buffer(6)]],                       \n                                              constant uint32_t& vtxThreadExecWidth [[buffer(7)]],              \n                                              constant uint32_t& tcWorkgroupSize [[buffer(8)]],                 \n                                              uint idx [[thread_position_in_grid]]) {                           \n    if (idx >= drawCount) { return; }                                                                           \n    const device auto& src = *reinterpret_cast<const device MTLDrawPrimitivesIndirectArguments*>(srcBuff + idx * srcStride);\n    device char* dest;                                                                                          \n    device auto* params = reinterpret_cast<device uint32_t*>(paramsBuff + idx * 256);                           \n#if __METAL_VERSION__ >= 210                                                                                    \n    dest = destBuff + idx * (sizeof(MTLStageInRegionIndirectArguments) + sizeof(MTLDispatchThreadgroupsIndirectArguments) * 2 + sizeof(MTLDrawPatchIndirectArguments));\n    device auto& destSI = *(device MTLStageInRegionIndirectArguments*)dest;                                     \n    dest += sizeof(MTLStageInRegionIndirectArguments);                                                          \n#else                                                                                                           \n    dest = destBuff + idx * (sizeof(MTLDispatchThreadgroupsIndirectArguments) * 2 + sizeof(MTLDrawPatchIndirectArguments));\n#endif                                                                                                          \n    device auto& destVtx = *(device MTLDispatchThreadgroupsIndirectArguments*)dest;                             \n
n        if (triIdx1 == primRestartSentinel)                                                                     \n            triFanBaseIdx = triFanIdxIdx;                                                                       \n                                                                                                                \n        T triIdx2 = triFanIdxs[triFanIdxIdx];                                                                   \n        if (triIdx2 == primRestartSentinel)                                                                     \n            triFanBaseIdx = triFanIdxIdx + 1;                                                                   \n                                                                                                                \n        if (triFanBaseIdx != triFanBaseIdxCurr) {    // Restart the triangle fan                                \n            triFanIdxIdx = triFanBaseIdx + 2;                                                                   \n        } else {                                                                                                \n            // Provoking vertex is 1 in triangle fan but 0 in triangle list                                     \n            triIdxs[triIdxIdx++] = triIdx1;                                                                     \n            triIdxs[triIdxIdx++] = triIdx2;                                                                     \n            triIdxs[triIdxIdx++] = triIdx0;                                                                     \n            triFanIdxIdx++;                                                                                     \n        }                                                                                                       \n    }                                                                                                           \n}                                                                                                               \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nkernel void cmdDrawIndirectPopulateIndexes(const device char* srcBuff [[buffer(0)]],                            \n                                           device MTLDrawIndexedPrimitivesIndirectArguments* destBuff [[buffer(1)]],\n                                           constant uint32_t& srcStride [[buffer(2)]],                          \n                                           constant uint32_t& drawCount [[buffer(3)]],                          \n\t\t\t\t\t\t\t\t\t\t   device uint32_t* idxBuff [[buffer(4)]],                              \n                                           uint idx [[thread_position_in_grid]]) {                              \n    if (idx >= drawCount) { return; }                                                                           \n    const device auto& src = *reinterpret_cast<const device MTLDrawPrimitivesIndirectArguments*>(srcBuff + idx * srcStride);\n\tdevice auto& dst = destBuff[idx];                                                                           \n    dst.indexCount = src.vertexCount;                                                                           \n\tdst.indexStart = src.vertexStart;                                                                           \n\tdst.baseVertex = 0;                                                                                         \n\tdst.instanceCount = src.instanceCount;                                                                      \n\tdst.baseInstance = src.baseInstance;                                                                        \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    for (uint32_t idxIdx = 0; idxIdx < dst.indexCount; idxIdx++) {                                              \n\t\tuint32_t idxBuffIdx = dst.indexStart + idxIdx;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tidxBuff[idxBuffIdx] = idxBuffIdx;                                                                       \n
n    decompressDXTnBlock(src, pixels, blockExtent, 4 * sizeof(uint), info.format);                               \n    for (uint j = 0; j < blockExtent.height; ++j) {                                                             \n        for (uint i = 0; i < blockExtent.width; ++i) {                                                          \n            // The pixel components are in BGRA order, but texture::write wants them                            \n            // in RGBA order. We can fix that (ironically) with a BGRA swizzle.                                 \n            dest.write(unpack_unorm4x8_to_float(pixels[j * 4 + i]).bgra,                                        \n                       uint3(info.offset.x + x + i, info.offset.y + y + j, info.offset.z + z));                 \n        }                                                                                                       \n    }                                                                                                           \n}                                                                                                               \n                                                                                                                \nkernel void cmdCopyBufferToImage3DDecompressTempBufferDXTn(const device uint8_t* src [[buffer(0)]],             \n                                                           device uint8_t* dest [[buffer(1)]],                  \n                                                           constant CmdCopyBufferToImageInfo& info [[buffer(2)]],\n                                                           uint3 pos [[thread_position_in_grid]]) {             \n    uint x = pos.x * 4, y = pos.y * 4, z = pos.z;                                                               \n    VkDeviceSize blockByteCount = isBC1Format(info.format) ? 8 : 16;                                            \n                                                                                                                \n    if (x >= info.extent.width || y >= info.extent.height || z >= info.extent.depth) { return; }                \n                                                                                                                \n    src += z * info.srcDepthStride + y * info.srcRowStride / 4 + x * blockByteCount / 4;                        \n    dest += z * info.destDepthStride + y * info.destRowStride + x * sizeof(uint);                               \n    VkExtent2D blockExtent;                                                                                     \n    blockExtent.width = min(info.extent.width - x, 4u);                                                         \n    blockExtent.height = min(info.extent.height - y, 4u);                                                       \n    uint pixels[16] = {0};                                                                                      \n    decompressDXTnBlock(src, pixels, blockExtent, 4 * sizeof(uint), info.format);                               \n    device uint* destPixel = (device uint*)dest;                                                                \n    for (uint j = 0; j < blockExtent.height; ++j) {                                                             \n        for (uint i = 0; i < blockExtent.width; ++i) {                                                          \n            destPixel[j * info.destRowStride / sizeof(uint) + i] = pixels[j * 4 + i];                           \n        }                                                                                                       \n    }                                                                                                           \n}                                                                                                               \n                                                                                                                \n#if __METAL_VERSION__ >= 210
n    device auto* params = reinterpret_cast<device uint32_t*>(paramsBuff + idx * 256);                           \n#if __METAL_VERSION__ >= 210                                                                                    \n    dest = destBuff + idx * (sizeof(MTLStageInRegionIndirectArguments) + sizeof(MTLDispatchThreadgroupsIndirectArguments) * 2 + sizeof(MTLDrawPatchIndirectArguments));\n    device auto& destSI = *(device MTLStageInRegionIndirectArguments*)dest;                                     \n    dest += sizeof(MTLStageInRegionIndirectArguments);                                                          \n#else                                                                                                           \n    dest = destBuff + idx * (sizeof(MTLDispatchThreadgroupsIndirectArguments) * 2 + sizeof(MTLDrawPatchIndirectArguments));\n#endif                                                                                                          \n    device auto& destVtx = *(device MTLDispatchThreadgroupsIndirectArguments*)dest;                             \n    device auto& destTC = *(device MTLDispatchThreadgroupsIndirectArguments*)(dest + sizeof(MTLDispatchThreadgroupsIndirectArguments));\n    device auto& destTE = *(device MTLDrawPatchIndirectArguments*)(dest + sizeof(MTLDispatchThreadgroupsIndirectArguments) * 2);\n    uint32_t patchCount = (src.indexCount * src.instanceCount + inControlPointCount - 1) / inControlPointCount;\n    params[0] = inControlPointCount;                                                                            \n    params[1] = patchCount;                                                                                     \n    destVtx.threadgroupsPerGrid[0] = (src.indexCount + vtxThreadExecWidth - 1) / vtxThreadExecWidth;            \n    destVtx.threadgroupsPerGrid[1] = src.instanceCount;                                                         \n    destVtx.threadgroupsPerGrid[2] = 1;                                                                         \n    destTC.threadgroupsPerGrid[0] = (patchCount * outControlPointCount + tcWorkgroupSize - 1) / tcWorkgroupSize;\n    destTC.threadgroupsPerGrid[1] = destTC.threadgroupsPerGrid[2] = 1;                                          \n    destTE.patchCount = patchCount;                                                                             \n    destTE.instanceCount = 1;                                                                                   \n    destTE.patchStart = destTE.baseInstance = 0;                                                                \n#if __METAL_VERSION__ >= 210                                                                                    \n    destSI.stageInOrigin[0] = src.baseVertex;                                                                   \n    destSI.stageInOrigin[1] = src.baseInstance;                                                                 \n    destSI.stageInOrigin[2] = 0;                                                                                \n    destSI.stageInSize[0] = src.indexCount;                                                                     \n    destSI.stageInSize[1] = src.instanceCount;                                                                  \n    destSI.stageInSize[2] = 1;                                                                                  \n#endif                                                                                                          \n}                                                                                                               \n                                                                                                                \nkernel void cmdDrawIndexedCopyIndex16Buffer(const device uint16_t* srcBuff [[buffer(0)]],                       \n                                            device uint16_t* destBuff [[buffer(1)]],                            \n                                            const d
n int
n#include <metal_stdlib>                                                                                         \nusing namespace metal;                                                                                          \n                                                                                                                \ntypedef struct {                                                                                                \n    float2 a_position [[attribute(0)]];                                                                         \n    float3 a_texCoord [[attribute(1)]];                                                                         \n} AttributesPosTex;                                                                                             \n                                                                                                                \ntypedef struct {                                                                                                \n    float4 v_position [[position]];                                                                             \n    float3 v_texCoord;                                                                                          \n} VaryingsPosTex;                                                                                               \n                                                                                                                \ntypedef struct {                                                                                                \n    float4 v_position [[position]];                                                                             \n    float3 v_texCoord;                                                                                          \n    uint v_layer [[render_target_array_index]];                                                                 \n} VaryingsPosTexLayer;                                                                                          \n                                                                                                                \ntypedef size_t VkDeviceSize;                                                                                    \n                                                                                                                \ntypedef enum : uint32_t {                                                                                       \n    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,                                                                        \n    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,                                                                         \n    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,                                                                       \n    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,                                                                        \n    VK_FORMAT_BC2_UNORM_BLOCK = 135,                                                                            \n    VK_FORMAT_BC2_SRGB_BLOCK = 136,                                                                             \n    VK_FORMAT_BC3_UNORM_BLOCK = 137,                                                                            \n    VK_FORMAT_BC3_SRGB_BLOCK = 138,                                                                             \n} VkFormat;                                                                                                     \n                                                                                                                \ntypedef struct {                                                                                                \n    uint32_t width;                                                                                             \n    uint32_t height;                                                                                            \n} VkExtent2D
n// This structure is missing from the MSL headers. :/                                                           \nstruct MTLStageInRegionIndirectArguments {                                                                      \n    uint32_t stageInOrigin[3];                                                                                  \n    uint32_t stageInSize[3];                                                                                    \n};                                                                                                              \n#endif                                                                                                          \n                                                                                                                \ntypedef enum : uint8_t {                                                                                        \n    MTLIndexTypeUInt16 = 0,                                                                                     \n    MTLIndexTypeUInt32 = 1,                                                                                     \n} MTLIndexType;                                                                                                 \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ntypedef struct MVKVtxAdj {                                                                                      \n    MTLIndexType idxType;                                                                                       \n    bool isMultiView;                                                                                           \n    bool isTriFan;                                                                                              \n} MVKVtxAdj;                                                                                                    \n                                                                                                                \n// Populates triangle vertex indexes for a triangle fan.                                                        \ntemplate<typename T>                                                                                            \nstatic inline void populateTriIndxsFromTriFan(device T* triIdxs,                                                \n                                              constant T* triFanIdxs,                                           \n                                              uint32_t triFanIdxCnt) {                                          \n    T primRestartSentinel = (T)0xFFFFFFFF;                                                                      \n    uint32_t triIdxIdx = 0;                                                                                     \n    uint32_t triFanBaseIdx = 0;                                                                                 \n    uint32_t triFanIdxIdx = triFanBaseIdx + 2;                                                                  \n    while (triFanIdxIdx < triFanIdxCnt) {                                                                       \n        uint32_t triFanBaseIdxCurr = triFanBaseIdx;                                                             \n                                                                                                                \n        // Detect primitive restart on any index, to catch possible consecutive restarts                        \n        T triIdx0 = triFanIdxs[triFanBaseIdx];                                                                  \n        if (triIdx0 == primRestartSentinel)                                                                     \n            triFanBaseIdx++;                                                                                    \n                                                                                                                \n        T triIdx1 = triFanIdxs[triFanIdxIdx - 1
n00P@0
n9alignWithERKS0
n9writeFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_6vectorIcS5_EERS6
nBlendConstants
nBuffer
nD;D1Lt
nEnd SPIR-V\n\n
nLinked
nMagFilterFromVkFilter
nPp\bp@p\bp@p\bp@pPpPpX
nSPIR-V error
n\b\ftƾ\b
n\n\n
n\t\tGPU Family Apple 1
n\t\tGPU Family Apple 2
n\t\tGPU Family Apple 3
n\t\tGPU Family Apple 4
n\t\tGPU Family Apple 5
n\t\tGPU Family Apple 6
n\t\tGPU Family Apple 7
n\t\tGPU Family Apple 8
n\t\tGPU Family Common 1
n\t\tGPU Family Common 2
n\t\tGPU Family Common 3
n\t\tGPU Family Mac 1
n\t\tGPU Family Mac 2
n\t\tGPU Family Mac Catalyst 1
n\t\tGPU Family Mac Catalyst 2
n\t\tMetal Shading Language %s
n\t\tdeviceID: %#06x
n\t\tmacOS GPU Family 1 v1
n\t\tmacOS GPU Family 1 v2
n\t\tmacOS GPU Family 1 v3
n\t\tmacOS GPU Family 1 v4
n\t\tmacOS GPU Family 2 v1
n\t\tmacOS Read-Write Texture Tier 2
n\t\tmodel: %s
n\t\tpipelineCacheUUID: %s
n\t\ttype: %s
n\t\tvendorID: %#06x
n\tsupports the following Metal Versions, GPU's and Feature Sets
n`t/I
n`tAI
n`tgH
n`uIA
n`u[I
nal_odd_H
name too long
nameless block contains a member that already has a name at global scope
names beginning with "GL_" can't be (un)defined
names containing consecutive underscores are reserved
names containing consecutive underscores are reserved, and an error if version < 300
namespace
native_cos
native_divide
native_exp
native_exp10
native_exp2
native_log
native_log10
native_log2
native_powr
native_recip
native_rsqrt
native_sin
native_sqrt
native_tan
naturalDrawableSizeMVK
ncilOperationFromVkStencilOp
nderStagesFromVkPipelineStageFlags
neCachesH
neLayoutL
nearest
nearest = 0
needs a literal integer
newAccelerationStructureWithDescriptor
newAccelerationStructureWithSize
newArgumentEncoderWithArguments
newArgumentEncoderWithBufferBinding
newArgumentEncoderWithBufferIndex
newBinaryArchiveWithDescriptor:error
newBufferWithBytes:length:options
newBufferWithBytesNoCopy:length:options:deallocator
newBufferWithLength:options
newBufferWithLength:options:offset
newCaptureScopeWithCommandQueue
newCommandQueue
newCommandQueueWithMaxCommandBufferCount
newComputePipelineStateWithDescriptor:options:completionHandler
newComputePipelineStateWithDescriptor:options:reflection:error
newComputePipelineStateWithFunction:completionHandler
newComputePipelineStateWithFunction:error
newComputePipelineStateWithFunction:options:completionHandler
newComputePipelineStateWithFunction:options:reflection:error
newCounterSampleBufferWithDescriptor:error
newDefaultLibrary
newDefaultLibraryWithBundle:error
newDepthStencilStateWithDescriptor
newDynamicLibrary:error
newDynamicLibraryWithURL:error
newEvent
newFence
newFunctionWithName
newFunctionWithName:constantValues:completionHandler
newHeapWithDescriptor
newIOCommandQueueWithDescriptor:error
newIOHandleWithURL:compressionMethod:error
newIOHandleWithURL:error
newIndirectCommandBufferWithDescriptor:maxCommandCount:options
newLibraryWithData:error
newLibraryWithFile:error
newLibraryWithSource:options:completionHandler
newLibraryWithSource:options:error
newLibraryWithStitchedDescriptor:completionHandler
newLibraryWithStitchedDescriptor:error
newLibraryWithURL:error
newRasterizationRateMapWithDescriptor
newRenderPipelineStateWithDescriptor:completionHandler
newRenderPipelineStateWithDescriptor:error
newRenderPipelineStateWithDescriptor:options:completionHandler
newRenderPipelineStateWithDescriptor:options:reflection:error
newRenderPipelineStateWithMeshDescriptor:options:completionHandler
newRenderPipelineStateWithMeshDescriptor:options:reflection:error
newRenderPipelineStateWithTileDescriptor:options:completionHandler
newRenderPipelineStateWithTileDescriptor:options:reflection:error
newSamplerStateWithDescriptor
newSharedEvent
newSharedEventWithHandle
newSharedTextureWithDescriptor
newSharedTextureWithHandle
newTextureViewWithPixelFormat
newTextureViewWithPixelFormat:textureType:levels:slices
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle
newTextureWithDescriptor
newTextureWithDescriptor:iosurface:plane
newTextureWithDescriptor:offset
newTextureWithDescriptor:offset:bytesPerRow
nextDrawable
nextafter
nffffff
nglesKHRH
nl_langinfo
nl_symbol_ptr
nmapMemory
no callableDataEXT/callableDataInEXT declared
no declaration found for redeclaration
no hitObjectAttributeNV declared
no longer supported in
no matching overloaded function found
no operation '%s' exists that takes a left-hand operand of type '%s' and a right operand of type '%s' (or there is no acceptable conversion
no operation '%s' exists that takes an operand of type %s (or there is no acceptable conversion
no qualifiers allowed for function return
no rayPayloadEXT/rayPayloadInEXT declared
no shortcircuit
no such field in structure
no-storage-format
noContraction
no_perspective
node is still EOpNull
noinline
noise1
noise2
noise3
noise4
non-constant global initializer (needs GL_EXT_shader_non_constant_global_initializers
non-constant initializer
non-constant offset argument
non-float shader input/output
non-literal layout-id value
non-matching or non-convertible constant type for const initializer
non-opaque uniform variables need a layout(location=L
non-opaque uniforms outside a block
non-uniform struct contains a sampler or image
non-uniform struct contains an accelerationStructureNV
non-uniform struct contains an atomic_uint
non-void function must return a value
non_coherent_color_attachment_readEXT
non_coherent_color_attachment_readext
non_coherent_depth_attachment_readEXT
non_coherent_depth_attachment_readext
non_coherent_stencil_attachment_readEXT
non_coherent_stencil_attachment_readext
non_uniform_qualifier
noncoherH
noncoherent
none = 0
nonportable when expanded from macros for preprocessor expression
nonprivate
nonuniform
nonuniformEXT
noperspective
noperspective requires ESSL 300
normalize
not allowed before
not allowed in legacy ES
not allowed in nested scope
not allowed in this version
not allowed on block or structure members
not allowed on depth samplers in legacy ES
not allowed when generating SPIR-V
not allowed when using GLSL for Vulkan
not allowed when using generating SPIR-V codes
not been declare as a output variable in pre shader stage
not enough data provided for construction
not implemented
not supported
not supported for current targeted SPIR-V version
not supported for these tokens
not supported for this version or the enabled extensions
not supported in this stage
not supported on this image type
not supported with this profile
notEqual
notifyListener:atValue:block
nownƅ0
nreadFileERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERNS0_6vectorIcS5_EERS6
nspose(f16mat2x3);f16mat2x4 transpose(f16mat4x2);f16mat4x2 transpose(f16mat2x4);f16mat3x4 transpose(f16mat4x3);f16mat4x3 transpose(f16mat3x4);float16_t determinant(f16mat2);float16_t determinant(f16mat3);float16_t determinant(f16mat4);f16mat2 inverse(f16mat2);f16mat3 inverse(f16mat3);f16mat4 inverse(f16mat4);bvec2 lessThan(f16vec2, f16vec2);bvec3 lessThan(f16vec3, f16vec3);bvec4 lessThan(f16vec4, f16vec4);bvec2 lessThanEqual(f16vec2, f16vec2);bvec3 lessThanEqual(f16vec3, f16vec3);bvec4 lessThanEqual(f16vec4, f16vec4);bvec2 greaterThan(f16vec2, f16vec2);bvec3 greaterThan(f16vec3, f16vec3);bvec4 greaterThan(f16vec4, f16vec4);bvec2 greaterThanEqual(f16vec2, f16vec2);bvec3 greaterThanEqual(f16vec3, f16vec3);bvec4 greaterThanEqual(f16vec4, f16vec4);bvec2 equal(f16vec2, f16vec2);bvec3 equal(f16vec3, f16vec3);bvec4 equal(f16vec4, f16vec4);bvec2 notEqual(f16vec2, f16vec2);bvec3 notEqual(f16vec3, f16vec3);bvec4 notEqual(f16vec4, f16vec4);\n
nstancedH
ntFacingH
nt_indexH
nterlockI
ntxzv~u
null initializers can't be used on opaque values
null initializers can't size unsized arrays
null-init
nullptr
numMembers %d
num_views
number of invocations must match between compilation units
numberWithBool
numberWithUnsignedInt
numeric literal too big
numeric literal too long
n}                                                                                                               \n                                                                                                                \nkernel void cmdFillBuffer(device uint32_t* dst [[ buffer(0) ]],                                                 \n                          constant uint32_t& fillValue [[ buffer(1) ]],                                         \n                          uint pos [[thread_position_in_grid]]) {                                               \n    dst[pos] = fillValue;                                                                                       \n}                                                                                                               \n                                                                                                                \nkernel void cmdClearColorImage2DFloat(texture2d<float, access::write> dst [[ texture(0) ]],                     \n                                      constant float4& clearValue [[ buffer(0) ]],                              \n                                      uint2 pos [[thread_position_in_grid]]) {                                  \n    dst.write(clearValue, pos);                                                                                 \n}                                                                                                               \n                                                                                                                \nkernel void cmdClearColorImage2DUInt(texture2d<uint, access::write> dst [[ texture(0) ]],                       \n                                     constant uint4& clearValue [[ buffer(0) ]],                                \n                                     uint2 pos [[thread_position_in_grid]]) {                                   \n    dst.write(clearValue, pos);                                                                                 \n}                                                                                                               \n                                                                                                                \nkernel void cmdClearColorImage2DInt(texture2d<int, access::write> dst [[ texture(0) ]],                         \n                                    constant int4& clearValue [[ buffer(0) ]],                                  \n                                    uint2 pos [[thread_position_in_grid]]) {                                    \n    dst.write(clearValue, pos);                                                                                 \n}                                                                                                               \n                                                                                                                \nkernel void cmdResolveColorImage2DFloat(texture2d<float, access::write> dst [[ texture(0) ]],                   \n                                       texture2d_ms<float, access::read> src [[ texture(1) ]],                  \n                                       uint2 pos [[thread_position_in_grid]]) {                                 \n    dst.write(src.read(pos, 0), pos);                                                                           \n}                                                                                                               \n                                                                                                                \nkernel void cmdResolveColorImage2DUInt(texture2d<uint, access::write> dst [[ texture(0) ]],                     \n                                       texture2d_ms<uint, access::read> src [[ texture(1) ]],                   \n                                       uint2 pos [[thread_position_in_grid]]) {                                 \n    dst.write(src.read(pos, 0), pos
n}                                                                                                               \n                                                                                                                \nkernel void cmdResolveColorImage2DInt(texture2d<int, access::write> dst [[ texture(0) ]],                       \n                                      texture2d_ms<int, access::read> src [[ texture(1) ]],                     \n                                      uint2 pos [[thread_position_in_grid]]) {                                  \n    dst.write(src.read(pos, 0), pos);                                                                           \n}                                                                                                               \n                                                                                                                \ntypedef struct {                                                                                                \n    uint32_t srcRowStride;                                                                                      \n    uint32_t srcRowStrideHigh;                                                                                  \n    uint32_t srcDepthStride;                                                                                    \n    uint32_t srcDepthStrideHigh;                                                                                \n    uint32_t destRowStride;                                                                                     \n    uint32_t destRowStrideHigh;                                                                                 \n    uint32_t destDepthStride;                                                                                   \n    uint32_t destDepthStrideHigh;                                                                               \n    VkFormat format;                                                                                            \n    VkOffset3D offset;                                                                                          \n    VkExtent3D extent;                                                                                          \n} CmdCopyBufferToImageInfo;                                                                                     \n                                                                                                                \nkernel void cmdCopyBufferToImage3DDecompressDXTn(const device uint8_t* src [[buffer(0)]],                       \n                                                 texture3d<float, access::write> dest [[texture(0)]],           \n                                                 constant CmdCopyBufferToImageInfo& info [[buffer(2)]],         \n                                                 uint3 pos [[thread_position_in_grid]]) {                       \n    uint x = pos.x * 4, y = pos.y * 4, z = pos.z;                                                               \n    VkDeviceSize blockByteCount = isBC1Format(info.format) ? 8 : 16;                                            \n                                                                                                                \n    if (x >= info.extent.width || y >= info.extent.height || z >= info.extent.depth) { return; }                \n                                                                                                                \n    src += z * info.srcDepthStride + y * info.srcRowStride / 4 + x * blockByteCount / 4;                        \n    VkExtent2D blockExtent;                                                                                     \n    blockExtent.width = min(info.extent.width - x, 4u);                                                         \n    blockExtent.height = min(info.extent.height - y, 4u);                                                       \n    uint pixels[16] = {0
n}                                                                                                               \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nkernel void cmdDrawIndirectConvertBuffers(const device char* srcBuff [[buffer(0)]],                             \n                                          device MTLDrawPrimitivesIndirectArguments* destBuff [[buffer(1)]],    \n                                          constant uint32_t& srcStride [[buffer(2)]],                           \n                                          constant uint32_t& drawCount [[buffer(3)]],                           \n                                          constant uint32_t& viewCount [[buffer(4)]],                           \n                                          uint idx [[thread_position_in_grid]]) {                               \n    if (idx >= drawCount) { return; }                                                                           \n    const device auto& src = *reinterpret_cast<const device MTLDrawPrimitivesIndirectArguments*>(srcBuff + idx * srcStride);\n    destBuff[idx] = src;                                                                                        \n    destBuff[idx].instanceCount *= viewCount;                                                                   \n}                                                                                                               \n                                                                                                                \nkernel void cmdDrawIndexedIndirectConvertBuffers(const device char* srcBuff [[buffer(0)]],                      \n                                                 device MTLDrawIndexedPrimitivesIndirectArguments* destBuff [[buffer(1)]],\n                                                 constant uint32_t& srcStride [[buffer(2)]],                    \n                                                 constant uint32_t& drawCount [[buffer(3)]],                    \n                                                 constant uint32_t& viewCount [[buffer(4)]],                    \n                                                 constant MVKVtxAdj& vtxAdj [[buffer(5)]],                      \n                                                 device void* triIdxs [[buffer(6)]],                            \n                                                 constant void* triFanIdxs [[buffer(7)]],                       \n                                                 uint idx [[thread_position_in_grid]]) {                        \n    if (idx >= drawCount) { return; }                                                                           \n    const device auto& src = *reinterpret_cast<const device MTLDrawIndexedPrimitivesIndirectArguments*>(srcBuff + idx * srcStride);\n    destBuff[idx] = src;                                                                                        \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    device auto& dst = destBuff[idx];                                                                           \n\tif (vtxAdj.isMultiView) {                                                                                   \n\t\tdst.instanceCount *= viewCount;                                                                         \n\t}                                                                                                           \n    if (vtxAdj.isTriFan) {                                                                                      \n\t    dst.indexCount = (src.indexCount - 2) * 3;                                                              \n        switch (vtxAdj.idxType) {                                                                               \n            case MTLIndexTypeUInt16:                                                                            \n                populateTriIndxsFromTriFan(&((device uint16_t*)triIdxs)[dst.indexStart
o L;o(t
oBuffer2H
oIptASE23C
o_blocksH
objc_alloc
objc_autorelease
objc_autoreleasePoolPop
objc_autoreleasePoolPush
objc_catlist
objc_classlist__DATA
objc_classname__TEXT
objc_classrefs__DATA
objc_const
objc_data
objc_empty_cache
objc_enumerationMutation
objc_imageinfo__DATA
objc_ivar
objc_methname
objc_methtype
objc_msgSend
objc_msgSendSuper2
objc_msgSend_stret
objc_protolist__DATA
objc_protorefs__DATA
objc_release
objc_retain
objc_selrefs
objc_superrefs__DATA
objc_sync_enter
objc_sync_exit
objectAtIndexedSubscript
objectForKey
objectForKeyedSubscript
object_data
objects
observeValueForKeyPath:ofObject:change:context
observerWithBlock
observerWithBlock:forObject:atKeyPath
octal literal digit too large
octal literal too big
oe>8%<3
of OpConstant ID
offs32
offsA34$A
offset
offset %d in buffer %d
offset is too large
offset" on block member
offset/align
offset/align can only be used on a uniform or buffer
offsets
offsets argument
ofstreamIcNS_11char_traitsIcEEEE
olorƅu
olourBits = pSrcBlock[3]; buildDXTnColourTable(pSrcBlock[2] & 0xffff, pSrcBlock[2] >> 16, colourTable, format); } for (uint32_t y = 0; y < extent.height; ++y) { thread uint32_t* pDestRow = (thread uint32_t *)((thread uint8_t *)pDest + y * destRowPitch); for (uint32_t x = 0; x < extent.width; ++x) { uint8_t colourIndex = (colourBits >> (y * 8 + x * 2)) & 0x3; float alpha; if (isBC1Format(format)) { alpha = (!isBC1Alpha || colourIndex != 3) ? 1.0f : 0.0f; } else if (isBC2Format(format)) { alpha = ((alphaBits >> (y * 16 + x * 4)) & 0xf) / 15.0f; } else { alpha = alphaTable[(alphaBits >> (y * 12 + x * 3)) & 0x7]; } float4 colour; colour.rgb = colourTable[colourIndex]; if (isSRGBFormat(format)) { colour.rgb = sRGBCorrect(colour.rgb); } colour.a = alpha; pDestRow[x] = pack_float_to_unorm4x8(colour); } } }\n                                                                                                                \nvertex VaryingsPosTex vtxCmdBlitImage(AttributesPosTex attributes [[stage_in]]) {                               \n    VaryingsPosTex varyings;                                                                                    \n    varyings.v_position = float4(attributes.a_position, 0.0, 1.0);                                              \n    varyings.v_texCoord = attributes.a_texCoord;                                                                \n    return varyings;                                                                                            \n}                                                                                                               \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                \t\t\t        \nvertex VaryingsPosTexLayer vtxCmdBlitImageLayered(AttributesPosTex attributes [[stage_in]],                     \n                                                  uint instanceID [[instance_id]],                              \n                                                  constant float &zIncr [[buffer(0)]]) {                        \n    VaryingsPosTexLayer varyings;                                                                               \n    varyings.v_position = float4(attributes.a_position, 0.0, 1.0);                                              \n    varyings.v_texCoord = float3(attributes.a_texCoord.xy, attributes.a_texCoord.z + (instanceID + 0.5) * zIncr);\n    varyings.v_layer = instanceID;                                                                              \n    return varyings;                                                                                            \n}                                                                                                               \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                \t\t\t        \ntypedef struct {                                                                                                \n    uint32_t srcOffset;                                                                                         \n    uint32_t dstOffset;                                                                                         \n    uint32_t size;                                                                                              \n} CopyInfo;                                                                                                     \n                                                                                                                \nkernel void cmdCopyBufferBytes(device uint8_t* src [[ buffer(0) ]],                                             \n                               device uint8_t* dst [[ buffer(1) ]],                                             \n                               constant CopyInfo& info [[ buffer(2) ]]) {                                       \n    for (size_t i = 0; i < info.size; i++) {                                                                    \n        dst[i + info.dstOffset] = src[i + info.srcOffset];                                                      \n
oltenVKConfigurationMVK
olveImage
ompareOpH
on Queue %d-%d
on iOS.H
on" or "off" expected after '(' for 'debug' pragma
on" or "off" expected after '(' for 'optimize' pragma
ondaryPoE1
only allow constants or variables which are not elements of a composite
only allowed when generating SPIR-V
only allowed when using GLSL for Vulkan
only applies to
only applies to block members, not blocks
only apply to images
only one coherent/devicecoherent/queuefamilycoherent/workgroupcoherent/subgroupcoherent/shadercallcoherent qualifier allowed
only one precision qualifier allowed
only outermost dimension of an array of arrays can be a specialization constant
only outermost dimension of an array of arrays can be implicitly sized
only supported on image with format r32f
only supported on image with format r32i or r32ui
only supported on image with format r64i
only supported on image with format r64ui
only supported on integer images
only uniform, buffer, in, or out blocks are supported
onstantsH
ontrol_fH
oordH\t
opcode
opencl1.2
opencl1.2embedded
opencl2.0
opencl2.0embedded
opencl2.1
opencl2.1embedded
opencl2.2
opencl2.2embedded
opengl4.0
opengl4.1
opengl4.2
opengl4.3
opengl4.5
operand
operand at word offset
operatingSystemVersion
operation at
operator matrix<T, Cols, Rows>() const
operties
opertiesL
opologyClassFromVkPrimitiveTopology
optimize
optimize pragma syntax is incorrect
opyImageH
or second child into first child
orFencesH
origin_upper_left
ormatProperties
ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
ot_equalI
oup_sizeH
oup_voteH
out float gl_ClipDistance
out for stage outputs
out gl_MeshPerVertexEXT
out gl_MeshPerVertexEXT {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];float gl_CullDistance[];} gl_MeshVerticesEXT
out gl_MeshPerVertexNV {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];float gl_CullDistance[];perviewNV vec4 gl_PositionPerViewNV[];perviewNV float gl_ClipDistancePerViewNV[][];perviewNV float gl_CullDistancePerViewNV[][];} gl_MeshVerticesNV
out gl_PerVertex
out gl_PerVertex {highp vec4  gl_Position;highp float gl_PointSize
out gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance
out highp int gl_PrimitiveShadingRateEXT;\n
out int  gl_ViewportMask
out int gl_FragStencilRefARB
out int gl_PrimitiveID;out int gl_Layer
out int gl_SecondaryViewportMaskNV[];out vec4 gl_SecondaryPositionNV;out vec4 gl_PositionPerViewNV[];out int  gl_ViewportMaskPerViewNV
out int gl_ViewportIndex
out int gl_ViewportIndex;out int gl_Layer
out int gl_ViewportIndex;out int gl_Layer;\n
out int gl_ViewportMask
out uint gl_PrimitiveCountNV;out uint gl_PrimitiveIndicesNV[];in uint gl_MeshViewCountNV;in uint gl_MeshViewIndicesNV[4];const highp uvec3 gl_WorkGroupSize = uvec3(1,1,1);in highp uvec3 gl_WorkGroupID;in highp uvec3 gl_LocalInvocationID;in highp uvec3 gl_GlobalInvocationID;in highp uint gl_LocalInvocationIndex;\n
out uint gl_PrimitivePointIndicesEXT[];out uvec2 gl_PrimitiveLineIndicesEXT[];out uvec3 gl_PrimitiveTriangleIndicesEXT[];in    highp uvec3 gl_NumWorkGroups;\n
out uint gl_TaskCountNV;const highp uvec3 gl_WorkGroupSize = uvec3(1,1,1);in highp uvec3 gl_WorkGroupID;in highp uvec3 gl_LocalInvocationID;in highp uvec3 gl_GlobalInvocationID;in highp uint gl_LocalInvocationIndex;in uint gl_MeshViewCountNV;in uint gl_MeshViewIndicesNV[4];in    highp uvec3 gl_NumWorkGroups;\n
out vec4 gl_ClipVertex
out vec4 gl_SecondaryPositionNV;out int  gl_SecondaryViewportMaskNV[];out vec4 gl_PositionPerViewNV[];out int  gl_ViewportMaskPerViewNV
out.color = tex.sample(ce_sampler, varyings.v_texCoord%@%@, level(subRez.lod)).%.4s
out.depth = tex.sample(ce_sampler, varyings.v_texCoord%@%@, level(subRez.lod)).%c
out.stencil = stencilTex.sample(ce_stencil_sampler, varyings.v_texCoord%@%@, level(subRez.lod)).%c
outer product
outerProduct
output
output block
output blocks cannot be used in a task shader
output primitive
outputs
overflow mode
overlapping offsets at
overlapping use of location
overloaded functions must have the same parameter precision qualifiers for argument
overloaded functions must have the same parameter storage qualifiers for argument
overloaded functions must have the same qualifiers
overloaded functions must have the same return type
override_coverage
ovr_multiview_view_count must be non-zero when using GL_OVR_multiview2
oyBufferH
oyDeviceH
p L;p(t
p(SBRC`FA`1ASAUA`-A
p0L;p8s
p0p p pH
p@00 @0000000 @0
p@P@P
pAddƅl
pElect()H
pFilterFromVkSamplerMipmapMode
pFunctionFromVkVertexInputRate
pHp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp
pHp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpXphp\bpXp\bpXphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpX
pHp\bpXp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpX
pHp\bp\bpHp
pHp\bp\bpHp\bp\bpHp
pHp\bp\bpHp\bp\bpHp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bp\bpHp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp
pHp\bp\bpHp\bp\bpHp\bp\bpHp
pHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp
pHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp
pHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp
pHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp
pHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp
pHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpH
pL;`x
pMaxSizeH
pPP00
pPppp
p\bH+0H
p\bL+0I
p\bSAp\bSAp\bZAp\bRAp\bZAp\bRAp\bZARAp\bZARA`NA
p\b\\BVCRE
p\t\app\t
p``0Pp00
pack16
pack32
pack3\b
pack64
packA3M
packDouble2x32
packFloat2x16
packHalf2x16
packInt2x16
packInt2x32
packInt4x16
packSnorm2x16
packSnorm4x8
packUint2x16
packUint2x32
packUint4x16
packUnorm2x16
packUnorm4x8
pack_float_to_snorm2x16
pack_float_to_snorm4x8
pack_float_to_unorm2x16
pack_float_to_unorm4x8
packed
packed vector format
packed_rm
packfA
parameter_declaration
parameter_declarator
parameter_type_specifier
parentTexture
parseImageFormatProperties
parseMemoryRequirements
partial_count
partition
passthroH
passthrough
patch
patch out highp vec4 gl_BoundingBox[2];\n
patchIn
patchOutH
patch_control_point
patch_id
patcƃP
pathExtension
payload number
peel_count
peerCount
peerGroupID
peerIndex
pending
per-vertex output
per_gridI
performSelector
performSelector:withObject
performSelector:withObject:withObject
performance
perprimitiveEXT
perprimitiveEXT out gl_MeshPerPrimitiveEXT {int gl_PrimitiveID;int gl_Layer;int gl_ViewportIndex;bool gl_CullPrimitiveEXT;int  gl_PrimitiveShadingRateEXT;} gl_MeshPrimitivesEXT
perprimitiveNV
perprimitiveNV out gl_MeshPerPrimitiveNV {int gl_PrimitiveID;int gl_Layer;int gl_ViewportIndex;int gl_ViewportMask[];perviewNV int gl_LayerPerViewNV[];perviewNV int gl_ViewportMaskPerViewNV[][];} gl_MeshPrimitivesNV
perspective
pervertexEXT
pervertexEXT requires ESSL 320
pervertexEXT requires GLSL 450
pervertexNV
perviewNV
pfffff
physical_pointer
pixelFormat
pixel_center_integer
pixel_interlock_ordered
pixel_interlock_unordered
pixel_local_inEXT _PLSIn
pixel_local_outEXT _PLSOut
plane0
plane0(plane0), plane1(plane1), plane2(plane2), samp(samp), ycbcr_samp(ycbcr_samp), swizzle(sw
plane0(plane0), plane1(plane1), samp(samp), ycbcr_samp(ycbcr_samp), swizzle(sw
plane0(tex), samp(samp
plane0(tex), samp(samp), swizzle(sw
plane0(tex), samp(samp), ycbcr_samp(ycbcr_samp), swizzle(sw
plane0, plane1, plane2, samp
plane0, plane1, samp, coord
plateKHRH
point_coI
point_coord
point_moH
point_mode
point_siI
point_size
points
polationH
polationL
popDebugGroup
popcount
portMaskH
portMaskH3P\aH\t
position
position, invariant
positionI
position_in_patch
posix_memalign
possibly multi-word literal integer
possibly multi-word literal number
post depth coverage
post-OpEmitMeshTasksEXT
post-discard
post-ignoreIntersectionKHR
post-terminate-invocation
post-terminateRayKHR
post_coverage_coverage
post_depH
post_depth_coverage
post_depth_coverage requires early_fragment_tests
postfix_expression
pp  00
pp\bp`p\bp`p\bp`p\bp`p\bp
pp\bp`p\bp`p\bp`p\bp`p\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bp`p\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bp`p\bpPp\bp\bp`p\bpPp\bp\bp`p\bpPp\bp\bp`p\bpPp\bp\bp`p\bpPp\bp\bp`p\bpPp\bp\bp`p\bp`p\bp`p\bp`p\bp`p\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bp`p\bp`p\bp`p\bp`p\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bpPp\bp\bp`p\bp`p\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bp`p\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bp`p\bp`p\bpPp\bp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bpPp\bp\bpPp\bp\bp`p\bp`p\bp`p\bp`p\bp`p\bpPp\bp\bpPp\bp`p\bp`p\bp`p\bp`p\bp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bpPp\bp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bphZAp\bRA
pp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp
pp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`ppp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`ppppp`p\bp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp
pp\bp`p\bp`p\bp`p\bp`ppp\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp`p\bp
pp\bp`ppp\bp`ppppp\bp`p\bp`p\bp`p\bp`p\bp`p\bp
pp\bp`ppppp\bp`p\bp`p\bp`p\bp
ppppppp
pragma
pragma clang diagnostic ignored "-Wmissing-braces
pragma clang diagnostic ignored "-Wmissing-prototypes
pragma clang diagnostic ignored "-Wunused-variable
pragma once
pragma use_variable_pointers
precise
precise qualifier must appear first
precise::atan2
precise::clamp
precise::max
precise::min
precise::tanh
precise_qualifier
precision
precision highp float
precision highp int
precision lowp float
precision lowp int
precision mediump float
precision mediump int
precision qualifier must appear as last qualifier
precision statement
precision_qualifier
predefined names can't be (un)defined
prefetch
preprocessor directive cannot be preceded by another token
preprocessor evaluation
present
presentAtTime
presentedTime
primary_expression
primitive culling
primitive_culling
primitive_id
printf
private
processInfo
programmableSamplePositionsSupported
pth_coveH
pthread_getname_np
pthread_mach_thread_np
pthread_self
pthread_threadid_np
ptorPoolL
ptorSetsL
pu_shadeH
public
pushDebugGroup
push_conH
push_constant
push_constants
putchar
pyBufferH
pyImage2H
q24@?0@"<MTLDevice>"8@"<MTLDevice>"16
quad_all
quad_and
quad_any
quad_broadcast
quad_is_first
quad_max
quad_min
quad_or
quad_product
quad_sum
quad_xor
quadgroup_index_in_threadgroup
quadgroups_per_threadgroup
qualifier
qualifier has no effect on non-output parameters
quantization mode
queuefamilycoherent
r layer
r#\r(\r-\r2\r7\r<\rA\rF\rK\rP\rU\rZ\r_\rd\ri\rn\rs\rx\r}\r
r.ffff
r0fff
r11f_g11f_b10f
r16_snorm
r33SPIRVToMSLConversionConfiguration
r3fff
r7SPIRVToMSLConversionOptions7matchesERKS0
r8_snorm
r<fff
rToImageH
r\bH+2H
r\btqA
r\bu{I
r\r\r
r\vHǃP\b
radians
radr://5614542
rageƅL
ragment_H
rasterOrderGroupsSupported
raster_order_group(0
ray flags
ray queries can only be initialized by using the rayQueryInitializeEXT intrinsic
ray query candidate intersection type
ray query committed intersection type
ray query intersection
ray-generation
rayPayloadEXT
rayPayloadInEXT
rayPayloadInNV
rayPayloadInNV block
rayPayloadNV
rayPayloadNV block
rayQueryConfirmIntersectionEXT
rayQueryEXT
rayQueryGenerateIntersectionEXT
rayQueryGetIntersectionBarycentricsEXT
rayQueryGetIntersectionCandidateAABBOpaqueEXT
rayQueryGetIntersectionFrontFaceEXT
rayQueryGetIntersectionGeometryIndexEXT
rayQueryGetIntersectionInstanceCustomIndexEXT
rayQueryGetIntersectionInstanceIdEXT
rayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetEXT
rayQueryGetIntersectionObjectRayDirectionEXT
rayQueryGetIntersectionObjectRayOriginEXT
rayQueryGetIntersectionObjectToWorldEXT
rayQueryGetIntersectionPrimitiveIndexEXT
rayQueryGetIntersectionTEXT
rayQueryGetIntersectionTriangleVertexPositionsEXT
rayQueryGetIntersectionTypeEXT
rayQueryGetIntersectionWorldToObjectEXT
rayQueryGetRayFlagsEXT
rayQueryGetRayTMinEXT
rayQueryGetWorldRayDirectionEXT
rayQueryGetWorldRayOriginEXT
rayQueryI
rayQueryInitializeEXT
rayQueryProceedEXT
rayQueryTerminateEXT
ray_data
raytracing::acceleration_structure<raytracing::instancing
raytracing::instance_acceleration_structure
raytracing::intersection_query<raytracing::instancing, raytracing::triangle_data
reAǇx\n
readFirstInvocation
readFirstInvocationARB
readInvocation
readInvocationARB
readWriteTextureSupport
readonly
readonlyH
reater
recommendedMaxWorkingSetSize
redeclaration
redeclaration of array with a different array dimensions or sizes
redeclaration of array with a different element type
redeclaration of array with size
redeclaration only allowed for override_coverage layout
redeclaration only allowed for viewport_relative or secondary_view_offset layout
redeclaring non-array as array
redefinition
redefinition of built-in function
reduction
referencH
reference
reference conversion to uvec2
reflect
refract
registryID
reinterpret_cast
reinterpret_cast<ulong
relational_expression
relativeH
relaxed-H
relaxed-errors
release
remainder
removable
removeObserver:forKeyPath:context
remquo
rencyKHRH
renderCommandEncoderWithDescriptor
renderPassDescriptor
renderTargetArrayLength
renderTargetArrayLengthMVK
renderTargetHeight
renderTargetHeightMVK
renderTargetWidth
renderTargetWidthMVK
render_target_array_index
reorderThreadNV
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage
replicated qualifiers
reportIntersectionEXT
reportIntersectionNV
require
required extension not requested
requires SPIR-V 1.3
requires a view array dimension
requires an input_attachment_index layout qualifier
requires block, or sampler/image, or atomic-counter type
requires local_size_x and local_size_y to be multiple of two
requires total group size to be multiple of four
requires uniform or buffer storage qualifier
res = fma(m[i - 1], vec<T, Rows>(v[i - 1]), res
res = fma(tmp, vec<T, Cols>(v[i - 1]), res
res[i] = tmp
reset
resolveCounterRange
resolveCounters:inRange:destinationBuffer:destinationOffset
resolveDepthPlane
resolveSlice
resolveTexture
resource
resource-set-binding
respondsToSelector
restrict
restrictH
restrictI
result ID
retain
retainCount
return
return !!extract_bits(ballot[bit / 32], bit % 32, 1
return !!quad_broadcast((ushort)value, lane
return !!quad_broadcast_first((ushort)value
return !!quad_shuffle((ushort)value, lane
return !!quad_shuffle_down((ushort)value, delta
return !!quad_shuffle_up((ushort)value, delta
return !!quad_shuffle_xor((ushort)value, dir + 1
return !!quad_shuffle_xor((ushort)value, mask
return !!simd_broadcast((ushort)value, lane
return !!simd_broadcast_first((ushort)value
return !!simd_shuffle((ushort)value, lane
return !!simd_shuffle_down((ushort)value, delta
return !!simd_shuffle_up((ushort)value, delta
return !!simd_shuffle_xor((ushort)value, mask
return (det != 0.0f) ? (adj * (1.0f / det)) : m
return (shifted & 1u) != 0u
return (ushort(bpc.value) << bpc_base) | (build(t...) & ~bpc_mask
return (ushort(filt) << chroma_filter_base) | (build(t...) & ~chroma_filter_mask
return (ushort(loc) << x_chroma_off_base) | (build(t...) & ~x_chroma_off_mask
return (ushort(loc) << y_chroma_off_base) | (build(t...) & ~y_chroma_off_mask
return (ushort(model) << ycbcr_model_base) | (build(t...) & ~ycbcr_model_mask
return (ushort(range) << ycbcr_range_base) | (build(t...) & ~ycbcr_range_mask
return (ushort(res) << resolution_base) | (build(t...) & ~resolution_mask
return (vec<bool, N>)quad_broadcast((vec<ushort, N>)value, lane
return (vec<bool, N>)quad_broadcast_first((vec<ushort, N>)value
return (vec<bool, N>)quad_shuffle((vec<ushort, N>)value, lane
return (vec<bool, N>)quad_shuffle_down((vec<ushort, N>)value, delta
return (vec<bool, N>)quad_shuffle_up((vec<ushort, N>)value, delta
return (vec<bool, N>)quad_shuffle_xor((vec<ushort, N>)value, dir + 1
return (vec<bool, N>)quad_shuffle_xor((vec<ushort, N>)value, mask
return (vec<bool, N>)simd_broadcast((vec<ushort, N>)value, lane
return (vec<bool, N>)simd_broadcast_first((vec<ushort, N>)value
return (vec<bool, N>)simd_shuffle((vec<ushort, N>)value, lane
return (vec<bool, N>)simd_shuffle_down((vec<ushort, N>)value, delta
return (vec<bool, N>)simd_shuffle_up((vec<ushort, N>)value, delta
return (vec<bool, N>)simd_shuffle_xor((vec<ushort, N>)value, mask
return *this
return 0
return 1
return F(hval
return T(0
return a1 * b2 - b1 * a2
return a1 * spvDet2x2(b2, b3, c2, c3) - b1 * spvDet2x2(a2, a3, c2, c3) + c1 * spvDet2x2(a2, a3, b2, b3
return any(notEqual(value.xy & gl_SubgroupEqMask.xy, uvec2(0u
return c
return ccOut
return columns[idx
return d * T(0.01745329251
return elements[pos
return eta * i - (eta * NoI + sqrt(k)) * n
return float3(u, v, CubeFace
return fma(T(-1), r, l
return fma(T(1), l, r
return fma(l, r, T(0
return gl_SubgroupInvocationID == firstLive
return i * nref < T(0) ? n : -n
return i - T(2) * i * n * n
return ip
return m
return m[0][0] * m[1][1] - m[0][1] * m[1][0
return mat2(m[0][0], m[1][0], m[0][1], m[1][1
return out
return plane0.gather(samp, coord, offset, c
return plane0.read(coord, lod
return plane0.sample(samp, coord, b, min_lod, offset
return plane0.sample(samp, coord, grad, min_lod, offset
return plane0.sample(samp, coord, offset
return plane0.sample(samp, coord, options, offset
return plane0.sample(samp, coord, spvForward<LodOptions>(options
return popcount(ballot.x) + popcount(ballot.y) + popcount(ballot.z) + popcount(ballot.w
return quad_all(all(value == (vec<bool, N>)quad_broadcast_first((vec<ushort, N>)value
return quad_all(all(value == quad_broadcast_first(value
return quad_all(value) || !quad_any(value
return quad_broadcast(value, lane
return quad_broadcast_first(value
return quad_shuffle(value, lane
return quad_shuffle_down(value, delta
return quad_shuffle_up(value, delta
return quad_shuffle_xor(value, dir + 1
return quad_shuffle_xor(value, mask
return r * T(57.2957795131
return res
return rgba
return s
return select(128 - (clz(ballot.w) + 1), select(96 - (clz(ballot.z) + 1), select(64 - (clz(ballot.y) + 1), select(32 - (clz(ballot.x) + 1), uint(-1), ballot.x == 0), ballot.y == 0), ballot.z == 0), ballot.w == 0
return select(clz(T(0)) - (clz(v) + T(1)), T(-1), v == T(0
return select(clz(T(0)) - (clz(x) + T(1)), T(-1), x == T(0
return select(ctz(ballot.x), select(32 + ctz(ballot.y), select(64 + ctz(ballot.z), select(96 + ctz(ballot.w), uint(-1), ballot.w == 0), ballot.z == 0), ballot.y == 0), ballot.x == 0
return select(ctz(x), T(-1), x == T(0
return select(select(select(x, T(0), x == T(0)), T(1), x > T(0)), T(-1), x < T(0
return simd_all(all(value == (vec<bool, N>)simd_broadcast_first((vec<ushort, N>)value
return simd_all(all(value == simd_broadcast_first(value
return simd_all(value) || !simd_any(value
return simd_broadcast(value, lane
return simd_broadcast_first(value
return simd_shuffle(value, lane
return simd_shuffle_down(value, delta
return simd_shuffle_up(value, delta
return simd_shuffle_xor(value, mask
return spvChromaFilter((val & chroma_filter_mask) >> chroma_filter_base
return spvChromaReconstructLinear420XCositedEvenYCositedEven
return spvChromaReconstructLinear420XCositedEvenYMidpoint
return spvChromaReconstructLinear420XMidpointYCositedEven
return spvChromaReconstructLinear420XMidpointYMidpoint
return spvChromaReconstructLinear422CositedEven
return spvChromaReconstructLinear422Midpoint
return spvChromaReconstructNearest(plane0, plane1, plane2, samp, coord
return spvChromaReconstructNearest(plane0, plane1, samp, coord, spvForward<LodOptions>(options
return spvConvertYCbCrBT2020(s
return spvConvertYCbCrBT601(s
return spvConvertYCbCrBT709(s
return spvFormatResolution((val & resolution_mask) >> resolution_base
return spvGatherSwizzle(plane0, samp, swizzle, c, coord, offset
return spvPopCount4(ballot & mask
return spvTextureSwizzle(plane0.sample(samp, coord, offset), swizzle
return spvTextureSwizzle(plane0.sample(samp, coord, options, offset), swizzle
return spvTextureSwizzle(vec<T, 4>(x, 0, 0, 1), s).x
return spvXChromaLocation((val & x_chroma_off_mask) >> x_chroma_off_base
return spvYCbCrModelConversion((val & ycbcr_model_mask) >> ycbcr_model_base
return spvYCbCrRange((val & ycbcr_range_mask) >> ycbcr_range_base
return spvYChromaLocation((val & y_chroma_off_mask) >> y_chroma_off_base
return static_cast<thread T&&>(x
return t.gather(s, spvForward<Ts>(params)..., component::w
return t.gather(s, spvForward<Ts>(params)..., component::x
return t.gather(s, spvForward<Ts>(params)..., component::y
return t.gather(s, spvForward<Ts>(params)..., component::z
return t.gather_compare(s, spvForward<Ts>(params
return transpose(matrix<T, Cols, Rows>(m
return uint(c.x
return uint(c.x + c.y
return uint(firstLive != -1 ? (firstLive + 32) : findMSB(value.x
return uint(firstLive != -1 ? firstLive : (findLSB(value.y) + 32
return uint2(tc
return uint4((quad_vote::vote_t)quad_ballot(value), 0, 0, 0
return uint4((simd_vote::vote_t)simd_ballot(value), 0, 0, 0
return uint4(as_type<uint2>((simd_vote::vote_t)vote), 0, 0
return varyings
return vec<T, 4>(0, 0, 0, 0
return vec<T, 4>(1, 1, 1, 1
return vec<T, 4>(spvGetSwizzle(x, x.r, spvSwizzle((s >> 0) & 0xFF)), spvGetSwizzle(x, x.g, spvSwizzle((s >> 8) & 0xFF)), spvGetSwizzle(x, x.b, spvSwizzle((s >> 16) & 0xFF)), spvGetSwizzle(x, x.a, spvSwizzle((s >> 24) & 0xFF
return x
return x - y * floor(x / y
return x.a
return x.b
return x.g
return x.r
return ycbcr
reverse_bits
rfaceEXTH
rfaceMVKH
rffff
rg16_snorm
rg16ui
rg32ui
rg8_snorm
rgb10_a2
rgb10_a2ui
rgb_identity = 0
rgba.a = ycbcr.a
rgba.rgb = vec<T, 3>(spvBT2020Factors * ycbcr.gbr
rgba.rgb = vec<T, 3>(spvBT601Factors * ycbcr.gbr
rgba.rgb = vec<T, 3>(spvBT709Factors * ycbcr.gbr
rgba16
rgba16_snorm
rgba16f
rgba16i
rgba16ui
rgba32f
rgba32i
rgba32ui
rgba8_snorm
rgba8i
rgba8ui
riangleFillModeFromVkPolygonMode
rier2KHRH
rierƅM
right shift second child into first child
right-shift
rimitiveT
ringsMVKH
rintfEXTH3P
riteMaskH
rotate
roundEven
roundEven supported only in ESSL 300
roupSizeH
row_majoH
row_majoH3\b
row_majoI3M
row_major
royEventH
royFenceH
royImageH
rpath/libMoltenVK.dylib
rspirv
rt_arrayH
rtexH\t
runtime-sized array of
runtimeH
runtimearr
ryViewportMaskNVgl_SecondaryViewondaryPositionNVgl_SecondaryPosiveShadingRateEXTgl_PrimitiveShadewNV
s     subgroupAdd(%s);\n
s     subgroupAnd(%s);\n
s     subgroupBroadcast(%s, uint);\n
s     subgroupBroadcastFirst(%s);\n
s     subgroupClusteredAdd(%s, uint);\n
s     subgroupClusteredAnd(%s, uint);\n
s     subgroupClusteredMax(%s, uint);\n
s     subgroupClusteredMin(%s, uint);\n
s     subgroupClusteredMul(%s, uint);\n
s     subgroupClusteredOr(%s, uint);\n
s     subgroupClusteredXor(%s, uint);\n
s     subgroupExclusiveAdd(%s);\n
s     subgroupExclusiveAnd(%s);\n
s     subgroupExclusiveMax(%s);\n
s     subgroupExclusiveMin(%s);\n
s     subgroupExclusiveMul(%s);\n
s     subgroupExclusiveOr(%s);\n
s     subgroupExclusiveXor(%s);\n
s     subgroupInclusiveAdd(%s);\n
s     subgroupInclusiveAnd(%s);\n
s     subgroupInclusiveMax(%s);\n
s     subgroupInclusiveMin(%s);\n
s     subgroupInclusiveMul(%s);\n
s     subgroupInclusiveOr(%s);\n
s     subgroupInclusiveXor(%s);\n
s     subgroupMax(%s);\n
s     subgroupMin(%s);\n
s     subgroupMul(%s);\n
s     subgroupOr(%s);\n
s     subgroupPartitionedAddNV(%s, uvec4 ballot);\n
s     subgroupPartitionedAndNV(%s, uvec4 ballot);\n
s     subgroupPartitionedExclusiveAddNV(%s, uvec4 ballot);\n
s     subgroupPartitionedExclusiveAndNV(%s, uvec4 ballot);\n
s     subgroupPartitionedExclusiveMaxNV(%s, uvec4 ballot);\n
s     subgroupPartitionedExclusiveMinNV(%s, uvec4 ballot);\n
s     subgroupPartitionedExclusiveMulNV(%s, uvec4 ballot);\n
s     subgroupPartitionedExclusiveOrNV(%s, uvec4 ballot);\n
s     subgroupPartitionedExclusiveXorNV(%s, uvec4 ballot);\n
s     subgroupPartitionedInclusiveAddNV(%s, uvec4 ballot);\n
s     subgroupPartitionedInclusiveAndNV(%s, uvec4 ballot);\n
s     subgroupPartitionedInclusiveMaxNV(%s, uvec4 ballot);\n
s     subgroupPartitionedInclusiveMinNV(%s, uvec4 ballot);\n
s     subgroupPartitionedInclusiveMulNV(%s, uvec4 ballot);\n
s     subgroupPartitionedInclusiveOrNV(%s, uvec4 ballot);\n
s     subgroupPartitionedInclusiveXorNV(%s, uvec4 ballot);\n
s     subgroupPartitionedMaxNV(%s, uvec4 ballot);\n
s     subgroupPartitionedMinNV(%s, uvec4 ballot);\n
s     subgroupPartitionedMulNV(%s, uvec4 ballot);\n
s     subgroupPartitionedOrNV(%s, uvec4 ballot);\n
s     subgroupPartitionedXorNV(%s, uvec4 ballot);\n
s     subgroupQuadBroadcast(%s, uint);\n
s     subgroupQuadSwapDiagonal(%s);\n
s     subgroupQuadSwapHorizontal(%s);\n
s     subgroupQuadSwapVertical(%s);\n
s     subgroupShuffle(%s, uint);\n
s     subgroupShuffleDown(%s, uint delta);\n
s     subgroupShuffleUp(%s, uint delta);\n
s     subgroupShuffleXor(%s, uint);\n
s     subgroupXor(%s);\n
s (%d
s = shuffleNV(v, i, gl_SubgroupSize
s = shuffleUpNV
s = shuffleXorNV
s = spvExpandITUFullRange(s, ycbcr_samp.get_bpc
s = spvExpandITUNarrowRange(s, ycbcr_samp.get_bpc
s compilation succeeded with warnings (Error code %li):\n%s
s compile failed (Error code %li):\n%s
s compile occurred already in this instance. Instances of %s should only be used for a single compile activity
s failed (Error code %li):\n%s
s profile; removed in version %d
s shader function could not be compiled into pipeline. See previous logged error
s shader requires %s buffer, but there is no free slot to pass it
s stage.J
s stage.K
s succeeded with warnings (Error code %li):\n%s
s with storage tileImageEXT
s%s%s avg: %.3f ms, latest: %.3f ms, min: %.3f ms, max: %.3f ms, count: %d
s(): On-screen rendering requires a layer of type CAMetalLayer
s(): The image is using Metal format %s as a substitute for Vulkan format %s. Since the pixel size is different, content for the image cannot be copied to or from a buffer
s(): You are not calling this function from the main thread. %s should only be accessed from the main thread. When using this function outside the main thread, consider passing the CAMetalLayer itself in %s::pView, instead of the %s
s(fff
s0L;s8s
s8[A\\A^A
s: %s
s: offset %d, type %x, size %d, index %d, binding %d, stages %d
s] %s\n
s_abs_diff
s_add_sat
s_clamp
s_hadd
s_mad24
s_mad_hi
s_mad_sat
s_mul24
s_mul_hi
s_rhadd
s_sub_sat
s_upsample
sample
sample mask override coverage
sample requires ESSL 300
sampleBufferAttachments
sampleCount
sampleCountersInBuffer:atSampleIndex:withBarrier
sampleTimestamps:gpuTimestamp
sample_iI
sample_id
sample_interlock_ordered
sample_interlock_unordered
sample_mI
sample_mask
sample_no_perspective
sample_perspective
sampler
sampler addressing mode
sampler assignment for bindless texture
sampler binding not less than gl_MaxCombinedTextureImageUnits
sampler constructor must appear at point of use
sampler conversion to uvec2
sampler filter mode
sampler or image can be used as return type only when the extension GL_ARB_bindless_texture enabled
sampler samp
sampler samp, spvYCbCrSampler ycbcr_samp, uint sw) thread
sampler-constructor cannot make an array of samplers
sampler-constructor first argument must be a *texture* type matching the dimensionality and sampled type of the constructor
sampler-constructor first argument must be a scalar *texture* type
sampler-constructor requires the extension GL_ARB_bindless_texture enabled
sampler-constructor requires the input to be ivec2 or uvec2
sampler-constructor requires two arguments
sampler-constructor second argument must be a scalar sampler or samplerShadow
sampler/image
sampler/image types can only be used in uniform variables or function parameters
sampler/texture/image requires layout(binding=X
sampler1D
sampler1DArray
sampler1DArrayShadow
sampler1DShadow
sampler2D
sampler2DArray
sampler2DArrayShadow
sampler2DMS
sampler2DMSArray
sampler2DRect
sampler2DRectShadow
sampler2DShadow
sampler3D
sampler3DRect
samplerBuffer
samplerCube
samplerCubeArray
samplerCubeArrayShadow
samplerCubeShadow
samplerExternal2DY2YEXT
samplerExternalOES
samplerShadow
samplers and atomic_uints cannot be output parameters
samplersH
saturate
says it has
scalar
scalar block layout
scalar integer expression required
scalar swizzle
scalfA
scope ID
screen
screenMVK
seVertex
secondary_view_offset
select
selecting output stream
selection control
selection_rest_statement
selection_statement
selection_statement_nonattributed
semEqual and semUnequal must either both include gl_SemanticsVolatile or neither
semUnequal must not be gl_SemanticsRelease or gl_SemanticsAcquireRelease
semUnequal must not include multiple of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease
separate_images
separate_samplers
set is too large
setAccess
setAlphaBlendOperation
setAlphaToCoverageEnabled
setAlphaToOneEnabled
setArgumentBuffer:offset
setArrayLength
setBackFaceStencil
setBlendColorRed:green:blue:alpha
setBlendingEnabled
setBorderColor
setBorderColorMVK
setBuffer:offset:atIndex
setBufferIndex
setBufferOffset:atIndex
setBytes:length:atIndex
setCaptureObject
setClearColor
setClearDepth
setClearStencil
setColorStoreAction:atIndex
setColorspace
setColorspaceNameMVK
setCompareFunction
setCompareFunctionMVK
setComputeFunction
setComputePipelineState
setConstantValue:type:atIndex
setContentsGravity
setCounterSet
setCpuCacheMode
setCullMode
setDataType
setDefaultCaptureScope
setDefaultRasterSampleCount
setDepth
setDepthAttachmentPixelFormat
setDepthBias:slopeScale:clamp
setDepthClipMode
setDepthCompareFunction
setDepthFailureOperation
setDepthPlane
setDepthResolveFilter
setDepthResolveFilterMVK
setDepthStencilPassOperation
setDepthStencilState
setDepthStoreAction
setDepthWriteEnabled
setDestination
setDestinationAlphaBlendFactor
setDestinationRGBBlendFactor
setDevice
setDisplaySyncEnabled
setDisplaySyncEnabledMVK
setDrawableSize
setEDRMetadata
setEndOfEncoderSampleIndex
setErrorOptions
setEventH
setFastMathEnabled
setFormat
setFragmentBuffer:offset:atIndex
setFragmentBufferOffset:atIndex
setFragmentBytes:length:atIndex
setFragmentFunction
setFragmentSamplerState:atIndex
setFragmentTexture:atIndex
setFramebufferOnly
setFrontFaceStencil
setFrontFacingWinding
setGLSLE
setHazardTrackingMode
setHeight
setIndex
setIndexBufferIndex
setIndexType
setInputPrimitiveTopology
setInputPrimitiveTopologyMVK
setLabel
setLanguageVersion
setLevel
setLoadAction
setLodMaxClamp
setLodMinClamp
setMagFilter
setMagnificationFilter
setMaxAnisotropy
setMaxTessellationFactor
setMaxTotalThreadsPerThreadgroup
setMaximumDrawableCount
setMaximumDrawableCountMVK
setMinFilter
setMinificationFilter
setMipFilter
setMipmapLevelCount
setNeedsDisplay
setNeedsDisplayInRect
setNormalizedCoordinates
setOffset
setOpaque
setOutputURL
setPixelFormat
setPreserveInvariance
setPurgeableState
setRAddressMode
setRasterizationEnabled
setReadMask
setRenderPipelineState
setRenderTargetArrayLength
setRenderTargetArrayLengthMVK
setRenderTargetHeight
setRenderTargetHeightMVK
setRenderTargetWidth
setRenderTargetWidthMVK
setResolveDepthPlane
setResolveLevel
setResolveSlice
setResolveTexture
setRetainedReferences
setRgbBlendOperation
setSAddressMode
setSampleBuffer
setSampleCount
setSamplePositions:count
setSamplerState:atIndex
setScissorRect
setScissorRects:count
setShouldMaximizeConcurrentCompilation
setSignaledValue
setSize
setSlice
setSourceAlphaBlendFactor
setSourceRGBBlendFactor
setStageInRegion
setStageInRegionWithIndirectBuffer:indirectBufferOffset
setStageInputDescriptor
setStartOfEncoderSampleIndex
setStencilAttachmentPixelFormat
setStencilCompareFunction
setStencilFailureOperation
setStencilFrontReferenceValue:backReferenceValue
setStencilReferenceValue
setStencilResolveFilter
setStencilResolveFilterMVK
setStencilStoreAction
setStepFunction
setStepRate
setStorageMode
setStorageModeMVK
setStoreAction
setStride
setSupportArgumentBuffers
setTAddressMode
setTessellationFactorBuffer:offset:instanceStride
setTessellationFactorFormat
setTessellationFactorStepFunction
setTessellationOutputWindingOrder
setTessellationPartitionMode
setTexture
setTexture:atIndex
setTextureType
setThreadGroupSizeIsMultipleOfThreadExecutionWidth
setTriangleFillMode
setType
setUsage
setUsageMVK
setVertexBuffer:offset:atIndex
setVertexBufferOffset:atIndex
setVertexBytes:length:atIndex
setVertexFunction
setVertexSamplerState:atIndex
setVertexTexture:atIndex
setViewport
setViewports:count
setVisibilityResultBuffer
setVisibilityResultMode:offset
setWantsExtendedDynamicRangeContent
setWantsExtendedDynamicRangeContentMVK
setWidth
setWriteMask
sffff
shPerPrimitiveNVgl_MeshPerPrimitMeshPerVertexEXThPerPrimitiveEXTfARB
shader record EXT
shader record NV
shaderRecordEXT
shaderRecordNV
shader_iH
shadercallcoherent
shaderrecordext
shaderrecordnv
shading rate
shadingH
shading_rate_interlock_ordered
shading_rate_interlock_unordered
shadow
shadow1D
shadow1DGradARB
shadow1DLod
shadow1DProj
shadow1DProjGradARB
shadow1DProjLod
shadow2D
shadow2DEXT
shadow2DGradARB
shadow2DLod
shadow2DProj
shadow2DProjEXT
shadow2DProjGradARB
shadow2DProjLod
shadow2DRect
shadow2DRectGradARB
shadow2DRectProj
shadow2DRectProjGradARB
shadowCuI
shadowCubeNV
shar3\b
sharA3M
shared
shared block
shared block requires at least SPIR-V 1.4
sharedApplication
sharedCaptureManager
shift-UBO-binding
shift-image-binding
shift-sampler-binding
shift-ssbo-binding
shift-texture-binding
shift-uav-binding
shift_expression
shouldMaximizeConcurrentCompilation
shuffle
shuffle2
shuffleUpNV
signaledValue
signed
simd_all
simd_and
simd_any
simd_ballot() returns a 64-bit integer-like object, but
simd_is_first
simd_is_helper_thread
simd_is_helper_thread() requires MSL 2.1 on macOS
simd_is_helper_thread() requires MSL 2.3 on iOS
simd_is_helper_thread() requires version 2.1 on macOS
simd_is_helper_thread() requires version 2.3 on iOS
simd_max
simd_min
simd_or
simd_pow_f4
simd_prefix_exclusive_product
simd_prefix_exclusive_sum
simd_prefix_inclusive_product
simd_prefix_inclusive_sum
simd_product
simd_sum
simd_vote vote = simd_ballot(value
simd_xor
simdgroup_barrier
simdgroup_index_in_threadgroup
simdgroups_per_threadgroup
simple_statement
sincos
single_attribute
single_declaration
single_type_qualifier
sitionNVH
size %s: %u\n
size1x16
size1x32
size1x8
size2x32
size4x32
size_t i
sizeof
smooth
smoothstep
snprintf
sortUsingComparator
source language
source-entrypoint
sourceOptions
spacing
spacingH
sparse
sparseImageLoad
sparseImageLoadARB
sparseImageLoadLod
sparseImageLoadLodAMD
sparseTexel
sparseTexelFetch
sparseTexelFetchARB
sparseTexelFetchOffset
sparseTexelFetchOffsetARB
sparseTexelsResident
sparseTexelsResidentARB
sparseTexture
sparseTextureARB
sparseTextureClamp
sparseTextureClampARB
sparseTextureGather
sparseTextureGatherARB
sparseTextureGatherLod
sparseTextureGatherLodAMD
sparseTextureGatherLodOffset
sparseTextureGatherLodOffsetAMD
sparseTextureGatherLodOffsets
sparseTextureGatherLodOffsetsAMD
sparseTextureGatherOffset
sparseTextureGatherOffsetARB
sparseTextureGatherOffsets
sparseTextureGatherOffsetsARB
sparseTextureGrad
sparseTextureGradARB
sparseTextureGradClamp
sparseTextureGradClampARB
sparseTextureGradOffset
sparseTextureGradOffsetARB
sparseTextureGradOffsetClam
sparseTextureGradOffsetClampARB
sparseTextureLod
sparseTextureLodARB
sparseTextureLodOffset
sparseTextureLodOffsetARB
sparseTextureOffset
sparseTextureOffsetARB
sparseTextureOffsetClamp
sparseTextureOffsetClampARB
sparseTileSizeInBytes
sparseTileSizeInBytesForSparsePageSize
sparseTileSizeWithTextureType:pixelFormat:sampleCount
sparseTileSizeWithTextureType:pixelFormat:sampleCount:sparsePageSize
specialization-constant
specialization-constant id already used
specialization-constant id is too large
specialization_constants
specific signature of builtin mix
spectiveH
spiregg
spirv_by_literal
spirv_by_reference
spirv_capability_list
spirv_decorate
spirv_decorate_id
spirv_decorate_id_parameter
spirv_decorate_id_parameter_list
spirv_decorate_parameter
spirv_decorate_parameter_list
spirv_decorate_qualifier
spirv_decorate_string
spirv_decorate_string_parameter_list
spirv_execution_mode
spirv_execution_mode_id
spirv_execution_mode_id_parameter_list
spirv_execution_mode_parameter
spirv_execution_mode_parameter_list
spirv_execution_mode_qualifier
spirv_extension_list
spirv_instruction
spirv_instruction_qualifier
spirv_instruction_qualifier_id
spirv_instruction_qualifier_list
spirv_literal
spirv_literal' can only be used on functions defined with 'spirv_instruction' for argument
spirv_requirements_list
spirv_requirements_parameter
spirv_storage_class
spirv_storage_class_qualifier
spirv_type
spirv_type_parameter
spirv_type_parameter_list
spirv_type_specifier
sprintf
spv1.0
spv1.1
spv1.2
spv1.3
spv1.4
spv1.5
spv1.6
spv::ExecutionMode %u is not a tessellation partition mode.\n
spv::ExecutionMode %u is not a winding order mode.\n
spvArrayCopy
spvBufferAliasSet
spvBufferSizeConstants
spvChromaFilter get_chroma_filter() const thread
spvChromaFilter::linear
spvChromaReconstructLinear
spvChromaReconstructNearest
spvComponentBits
spvConvertYCbCrBT2020
spvConvertYCbCrBT601
spvConvertYCbCrBT709
spvCubemapTo2DArrayFace
spvDescriptorSet
spvDescriptorSetBuffer
spvDeterminant
spvDeterminantMP
spvDispaH
spvDispatchBase
spvDynamicImageSampler
spvDynamicImageSampler requires default-constructible texture objects, which require MSL 2.0
spvDynamicOffsets
spvExpandITUFullRange
spvExpandITUNarrowRange
spvFAdd
spvFMul
spvFMulMatrixMatrix
spvFMulMatrixVector
spvFMulVectorMatrix
spvFSub
spvFaceForward
spvFindLSB
spvFindSMSB
spvFindUMSB
spvFormatResolution get_resolution() const thread
spvFormatResolution::_420
spvFormatResolution::_422
spvForward<LodOptions>(options
spvGatherCompareSwizzle
spvGatherSwizzle
spvImage2DAtomicCoord
spvIndicH
spvIndices
spvIndirectParams[0
spvIndirectParams[1] - 1
spvIndirectParams[1] - 1) * spvIndirectParams[0
spvInverse
spvInverse2x2
spvInverse3x3
spvInverse4x4
spvInverseMP
spvLinearTextureAlignment / 4 - 1
spvLinearTextureAlignment / 4 - 1)) * (tc).y) + (tc).x
spvLinearTextureAlignmentOverride
spvMainInterlockedBody
spvMakeIntersectionParams
spvOut
spvPatchH
spvPatchIn
spvPatchOut
spvQuadBroadcast
spvQuadSwap
spvQuantizeToF16
spvReflect
spvRefract
spvReturnValue
spvStageInputSize
spvStorage
spvStorageMatrix
spvStorageMatrix& m
spvStorageMatrix& operator=(const
spvStorageMatrix& operator=(initializer_list<vec<T, Rows>> cols
spvStorageMatrix(const
spvSubgroupAllEqual
spvSubgroupBallot
spvSubgroupBallotBitCount
spvSubgroupBallotBitExtract
spvSubgroupBallotExclusiveBitCount
spvSubgroupBallotFindLSB
spvSubgroupBallotFindMSB
spvSubgroupBallotInclusiveBitCount
spvSubgroupBroadcast
spvSubgroupBroadcastFirst
spvSubgroupShuffle
spvSubgroupShuffleDown
spvSubgroupShuffleUp
spvSubgroupShuffleXor
spvSwizzH
spvSwizzle::alpha
spvSwizzle::blue
spvSwizzle::green
spvSwizzle::none
spvSwizzle::one
spvSwizzle::red
spvSwizzle::zero
spvSwizzleConstants
spvTessLH
spvTessLevel
spvTexelBufferCoord
spvTextureSwizzle
spvTranspose
spvUnsafeArray
spvViewMH
spvViewMask
spvWorkaroundRowMajor
spvWorkaroundRowMajor(highp
spvWorkaroundRowMajorMP(mediump
spvXChromaLocation get_x_chroma_offset() const thread
spvXChromaLocation::midpoint
spvYCbCrModelConversion get_ycbcr_model() const thread
spvYCbCrModelConversion::ycbcr_bt_2020
spvYCbCrModelConversion::ycbcr_bt_601
spvYCbCrModelConversion::ycbcr_bt_709
spvYCbCrModelConversion::ycbcr_identity
spvYCbCrRange get_ycbcr_range() const thread
spvYCbCrRange::itu_narrow
spvYCbCrSampler
spvYCbCrSampler ycbcr_samp
spvYChromaLocation get_y_chroma_offset() const thread
spvYChromaLocation::midpoint
ss_equalI
ssageEXTH
ssellationPartitionModeFromSpvExecutionMode
stEnableH
stack_chk_fail
stack_chk_guard
stage
stage: Block
stage:\n\n
stageInputDescriptor
stageInputOutputDescriptor
stage_in
stages
stages must match when linking into a single stage
stanceIDH
stanceIDH3P
stanceIDI
startCaptureWithCommandQueue
startCaptureWithDescriptor:error
startCaptureWithDevice
startObservingObject:atKeyPath
starting at word
statement
statement_list
statement_no_new_scope
statement_scoped
static
static constexpr ushort build
static constexpr ushort build(spvChromaFilter filt, Ts... t
static constexpr ushort build(spvComponentBits bpc, Ts... t
static constexpr ushort build(spvFormatResolution res, Ts... t
static constexpr ushort build(spvXChromaLocation loc, Ts... t
static constexpr ushort build(spvYCbCrModelConversion model, Ts... t
static constexpr ushort build(spvYCbCrRange range, Ts... t
static constexpr ushort build(spvYChromaLocation loc, Ts... t
static inline __attribute__((always_inline
status
std13\b
std140
std1A3M
std1fA
std430
std430 requires the buffer storage qualifier
std4fA
stderrp
stdoutp
stencil
stencil layout qualifier
stencilAttachment
stencilAttachmentReadEXT
stencilResolveFilter
stencilResolveFilterMVK
stencil_ref_greater_back_amd
stencil_ref_greater_front_amd
stencil_ref_less_back_amd
stencil_ref_less_front_amd
stencil_ref_unchanged_back_amd
stencil_ref_unchanged_front_amd
stepFunction
stepRate
stereo view rendering
stopCapture
stopObserving
storage
storage class
storage qualifier not allowed on function parameter
storageMode
storageModeMVK
storage_qualifier
strchr
strcmp
strcpy
stream
stride
stride is too large
string
string literal
stringByAppendingPathComponent
stringByAppendingPathExtension
stringByAppendingString
stringByDeletingPathExtension
stringByExpandingTildeInPath
stringWithCapacity
stringWithFormat
stringWithUTF8String
strlcpy
strlen
strncmp
strncpy
strstr
strtod
strtoll
strtoul
strtoull
struct
struct gl_DepthRangeParameters
struct gl_TextureFootprint2DNV {uvec2 anchor;uvec2 offset;uvec2 mask;uint lod;uint granularity;};struct gl_TextureFootprint3DNV {uvec3 anchor;uvec3 offset;uvec2 mask;uint lod;uint granularity;};bool textureFootprintNV(sampler2D, vec2, int, bool, out gl_TextureFootprint2DNV);bool textureFootprintNV(sampler3D, vec3, int, bool, out gl_TextureFootprint3DNV);bool textureFootprintNV(sampler2D, vec2, int, bool, out gl_TextureFootprint2DNV, float);bool textureFootprintNV(sampler3D, vec3, int, bool, out gl_TextureFootprint3DNV, float);bool textureFootprintClampNV(sampler2D, vec2, float, int, bool, out gl_TextureFootprint2DNV);bool textureFootprintClampNV(sampler3D, vec3, float, int, bool, out gl_TextureFootprint3DNV);bool textureFootprintClampNV(sampler2D, vec2, float, int, bool, out gl_TextureFootprint2DNV, float);bool textureFootprintClampNV(sampler3D, vec3, float, int, bool, out gl_TextureFootprint3DNV, float);bool textureFootprintLodNV(sampler2D, vec2, float, int, bool, out gl_TextureFootprint2DNV);bool textureFootprintLodNV(sampler3D, vec3, float, int, bool, out gl_TextureFootprint3DNV);bool textureFootprintGradNV(sampler2D, vec2, vec2, vec2, int, bool, out gl_TextureFootprint2DNV);bool textureFootprintGradClampNV(sampler2D, vec2, vec2, vec2, float, int, bool, out gl_TextureFootprint2DNV);\n
struct mismatch
struct spvComponentBits
struct spvDynamicImageSampler
struct spvStorageMatrix
struct spvUnsafeArray
struct spvYCbCrSampler
struct_H
struct_declaration
struct_declaration_list
struct_declarator
struct_declarator_list
struct_specifier
structure
stub_helper
stubs
style initializers
subBorrow
subRez.slice
subRez.slice + varyings.v_layer
subgroup op
subgroupAdd
subgroupAll
subgroupAllEqual
subgroupAnd
subgroupAny
subgroupBallot
subgroupBallotBitCount
subgroupBallotBitExtract
subgroupBallotExclusiveBitCount
subgroupBallotFindLSB
subgroupBallotFindMSB
subgroupBallotInclusiveBitCount
subgroupBarrier
subgroupBroadcast
subgroupBroadcastFirst
subgroupClusteredAdd
subgroupClusteredAnd
subgroupClusteredMax
subgroupClusteredMin
subgroupClusteredMul
subgroupClusteredOr
subgroupClusteredXor
subgroupElect
subgroupExclusiveAdd
subgroupExclusiveAnd
subgroupExclusiveMax
subgroupExclusiveMin
subgroupExclusiveMul
subgroupExclusiveOr
subgroupExclusiveXor
subgroupH
subgroupInclusiveAdd
subgroupInclusiveAnd
subgroupInclusiveMax
subgroupInclusiveMin
subgroupInclusiveMul
subgroupInclusiveOr
subgroupInclusiveXor
subgroupInverseBallot
subgroupMax
subgroupMemoryBarrier
subgroupMemoryBarrierBuffer
subgroupMemoryBarrierImage
subgroupMemoryBarrierShared
subgroupMin
subgroupMul
subgroupOr
subgroupPartitionNV
subgroupPartitionedAddNV
subgroupPartitionedAndNV
subgroupPartitionedExclusiveAddNV
subgroupPartitionedExclusiveAndNV
subgroupPartitionedExclusiveMaxNV
subgroupPartitionedExclusiveMinNV
subgroupPartitionedExclusiveMulNV
subgroupPartitionedExclusiveOrNV
subgroupPartitionedExclusiveXorNV
subgroupPartitionedInclusiveAddNV
subgroupPartitionedInclusiveAndNV
subgroupPartitionedInclusiveMaxNV
subgroupPartitionedInclusiveMinNV
subgroupPartitionedInclusiveMulNV
subgroupPartitionedInclusiveOrNV
subgroupPartitionedInclusiveXorNV
subgroupPartitionedMaxNV
subgroupPartitionedMinNV
subgroupPartitionedMulNV
subgroupPartitionedOrNV
subgroupPartitionedXorNV
subgroupQuadBroadcast
subgroupQuadSwapDiagonal
subgroupQuadSwapHorizontal
subgroupQuadSwapVertical
subgroupShuffle
subgroupShuffleDown
subgroupShuffleUp
subgroupShuffleXor
subgroupXor
subgroup_uniform_control_flow
subgroup_uniform_control_flow\n
subgroupcoherent
subpass
subpass input
subpassIK
subpassInput
subpassInput was remapped, but remap_components is not set correctly
subpassInputMS
subpassLoad
subpassLoadMS
subpass_inputs
subroutine
subsat
substituting 'mediump
subtract
subtract second child into first child
subtractSaturate
superclass
superlayer
superp
supports32BitFloatFiltering
supports32BitMSAA
supportsBCTextureCompression
supportsCounterSampling
supportsDestination
supportsDynamicLibraries
supportsFamily
supportsFeatureSet
supportsFunctionPointers
supportsFunctionPointersFromRender
supportsPrimitiveMotionBlur
supportsPullModelInterpolation
supportsQueryTextureLOD
supportsRasterizationRateMapWithLayerCount
supportsRaytracing
supportsRaytracingFromRender
supportsRenderDynamicLibraries
supportsShaderBarycentricCoordinates
supportsTextureSampleCount
supportsVertexAmplificationCount
suppress-warnings
surface
switch
switch (c
switch (s
switch (spvSwizzle((sw >> (uint(c) * 8)) & 0xFF
switch (spvSwizzle(sw & 0xFF
switch (ycbcr_samp.get_resolution
switch (ycbcr_samp.get_x_chroma_offset
switch (ycbcr_samp.get_y_chroma_offset
switch (ycbcr_samp.get_ycbcr_model
switch (ycbcr_samp.get_ycbcr_range
switch statements
switch_statement
switch_statement_list
switch_statement_nonattributed
swizzle
swizzleH
swizzleInvocations
swizzleInvocationsAMD
swizzleInvocationsMasked
swizzleInvocationsMaskedAMD
swizzleInvocationsWithPatternAMD
swizzleTemp
synchronizeResource
synchronizeTexture:slice:level
syntax error
syntax error, unexpected %s
syntax error, unexpected %s, expecting %s
syntax error, unexpected %s, expecting %s or %s
syntax error, unexpected %s, expecting %s or %s or %s
syntax error, unexpected %s, expecting %s or %s or %s or %s
sysconf
t #pragma once
t L9`@u
t \t&\t,\t2\t8\t>\tD\tJ\tP\tV\t\\\tb\th\tn\tt\tz\t
t fff
t ffff
t ffffff
t!I9F0v
t!I9F0v~I
t!ffff
t"ffffff
t#ffff
t#ffffff
t$(fff
t$fff
t%IcG8I
t%ffffff
t&I9D$0v
t&fff
t&ffffff
t'ffffff
t(ffff
t(ffffff
t)HǃP\b
t)I9F0v#I
t*M;7u~O
t,fff
t.H9O0v&H
t.fffff
t/ffffff
t0L9h8v*H
t0fff
t1[A^A
t2E9g
t2[A^A
t3<*uV
t4fff
t4ffff
t4ffffff
t5M;.udH
t5M;.ugH
t61\bCTH
t64_t bitCount(uint64_t);i64vec2 bitCount(u64vec2);i64vec3 bitCount(u64vec3);i64vec4 bitCount(u64vec4);int64_t findLSB(int64_t);i64vec2 findLSB(i64vec2);i64vec3 findLSB(i64vec3);i64vec4 findLSB(i64vec4);int64_t findLSB(uint64_t);i64vec2 findLSB(u64vec2);i64vec3 findLSB(u64vec3);i64vec4 findLSB(u64vec4);int64_t findMSB(int64_t);i64vec2 findMSB(i64vec2);i64vec3 findMSB(i64vec3);i64vec4 findMSB(i64vec4);int64_t findMSB(uint64_t);i64vec2 findMSB(u64vec2);i64vec3 findMSB(u64vec3);i64vec4 findMSB(u64vec4);\n
t6ffff
t7L;(ukH
t7L;(ulJ
t7L;)ukJ
t7SPIRVToMSLConversionOptions
t8E9|$\bu1A;L$pr\aA;L$tv
t;9t\n t>9t\n0tA9t\n@tDH
t;H\fu+H
t;L;)uoJ
t;\ns_H
t=L;)ulJ
t=M;.uhJ
t=M;.ukJ
t=M;.ulH
t=M;.uoH
t=fff
t?L;*usJ
t@0@0
t@L;)upJ
t@L;)usJ
t@M;.umJ
t@fff
t@fffff
tAffffff
tB[A\\A^A
tCalibrateableTimeDomainsEXT
tD9t\nPtC9t\n`tF9t\nptIH
tDHǃP\b
tDL;(urJ
tD[A\\A^A
tEL;(utJ
tEM;.uqJ
tEM;.utJ
tFL;)uvJ
tF[A^A
tFffff
tIK\b[A
tLfff
tP[A\\A^A
tPfff
tScissorH
tU<,u
tZ[A\\A^A
t\\fff
t\b9y\bu
t\bAƆ0
t\bD;\bv
t\bP]\t
t\b\apu\b
t\efff
t\fE;N
t\fHc@8L
t\nA9F
t\nD9
t\nE9
t\nH;B
t\nH;X
t\nL;a
t\nL;q
t\t ]\t\t
t\t1Ƀz
t\tAƄ$E
t\tAƄ$F
t\tAƄ$H
t\tAƄ$I
t\tAƄ$J
t\tAƄ$L
t\t[A
t\t\t\t\t\t\t\t\t\t\t\n#include <metal_stdlib>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nusing namespace metal;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ntypedef struct {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4x4 mvpMtx;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n} Uniforms;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ntypedef struct {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat2 a_position\t[[attribute(0)]];\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat2 a_texCoord\t[[attribute(1)]];\t\t\t\t\t\t\t\t\t\t\t\t\n} Attributes;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ntypedef struct {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 v_position [[position]];\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat2 v_texCoord;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 v_fragColor;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n} Varyings;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nvertex Varyings watermarkVertex(Attributes attributes [[stage_in]],\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tconstant Uniforms& uniforms [[ buffer(0) ]]) {\t\t\t\n\tVaryings varyings;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tvaryings.v_position = uniforms.mvpMtx * float4(attributes.a_position, 0.0, 1.0);\t\n\tvaryings.v_fragColor = uniforms.color;\t\t\t\t\t\t\t\t\t\t\t\t\n\tvaryings.v_texCoord = attributes.a_texCoord;\t\t\t\t\t\t\t\t\t\t\n\treturn varyings;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nfragment float4 watermarkFragment(Varyings varyings [[stage_in]],\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t  texture2d<float> texture [[ texture(0) ]],\t\t\t\n\t\t\t\t\t\t\t\t  sampler sampler  [[ sampler(0) ]]) {\t\t\t\t\t\n\treturn varyings.v_fragColor * texture.sample(sampler, varyings.v_texCoord);\t\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n
t\v[A^A
t_array2H
t_depth_coverageGL_ARB_post_dept_draw_parametersGL_ARB_shader_drGL_ARB_fragment
t_ffffff
t_maskedH
t_unrollH3P
talFeaturesMVK
tamp2KHRH
tangent
target
target-env opengl
target-env spirv1.1
target-env spirv1.2
target-env spirv1.3
target-env spirv1.4
target-env spirv1.5
target-env spirv1.6
target-env spirvUnknown
target-env vulkan1.0
target-env vulkan1.1
target-env vulkan1.2
target-env vulkan1.3
target-env vulkanUnknown
task shaders
taskNV
taskNV variables can be declared only as blocks
taskPayloadSharedEXT
taskPayloadSharedEXT variables should not be declared as interface blocks
task_info
tc=Xߛ;u
tcE9o<u
td9B H
td[A\\A^A
teBufferH
teDeviceH
teEnableH
te_imageH
tempArg
tempReturn
template
template <> struct SpvHalfTypeSelector<float> { public: using H = half
template <typename F> struct SpvHalfTypeSelector
template <typename... LodOptions
template<typename F, typename H = typename SpvHalfTypeSelector<F>::H
template<typename T
template<typename T, int Cols, int Rows
template<typename T, int Cols, int Rows=Cols
template<typename T, int LCols, int LRows, int RCols, int RRows
template<typename T, size_t Num
template<typename T, template<typename, access = access::sample, typename = void> class Tex, typename... Ts
template<typename T, typename E = typename enable_if<is_integral<T>::value>::type
template<typename T, typename... LodOptions
template<typename T> inline constexpr thread T&& spvForward(thread typename spvRemoveReference<T>::type& x
template<typename T> inline constexpr thread T&& spvForward(thread typename spvRemoveReference<T>::type&& x
template<typename T> struct spvRemoveReference { typedef T type
template<typename T> struct spvRemoveReference<thread T&&> { typedef T type
template<typename T> struct spvRemoveReference<thread T&> { typedef T type
template<typename Tx, typename Ty
template<typename lod_options
template<typename... LodOptions
template<typename... Ts
template<uint N
template<uint N> struct SpvHalfTypeSelector<vec<float, N>> { using H = vec<half, N
tencilFormat
ter::linH
ter::neaH
terProduct(dvec4, dvec4);dmat2x3 outerProduct(dvec3, dvec2);dmat3x2 outerProduct(dvec2, dvec3);dmat2x4 outerProduct(dvec4, dvec2);dmat4x2 outerProduct(dvec2, dvec4);dmat3x4 outerProduct(dvec4, dvec3);dmat4x3 outerProduct(dvec3, dvec4);dmat2   transpose(dmat2);dmat3   transpose(dmat3);dmat4   transpose(dmat4);dmat2x3 transpose(dmat3x2);dmat3x2 transpose(dmat2x3);dmat2x4 transpose(dmat4x2);dmat4x2 transpose(dmat2x4);dmat3x4 transpose(dmat4x3);dmat4x3 transpose(dmat3x4);double determinant(dmat2);double determinant(dmat3);double determinant(dmat4);dmat2 inverse(dmat2);dmat3 inverse(dmat3);dmat4 inverse(dmat4);bvec2 lessThan(dvec2, dvec2);bvec3 lessThan(dvec3, dvec3);bvec4 lessThan(dvec4, dvec4);bvec2 lessThanEqual(dvec2, dvec2);bvec3 lessThanEqual(dvec3, dvec3);bvec4 lessThanEqual(dvec4, dvec4);bvec2 greaterThan(dvec2, dvec2);bvec3 greaterThan(dvec3, dvec3);bvec4 greaterThan(dvec4, dvec4);bvec2 greaterThanEqual(dvec2, dvec2);bvec3 greaterThanEqual(dvec3, dvec3);bvec4 greaterThanEqual(dvec4, dvec4);bvec2 equal(dvec2, dvec2);bvec3 equal(dvec3, dvec3);bvec4 equal(dvec4, dvec4);bvec2 notEqual(dvec2, dvec2);bvec3 notEqual(dvec3, dvec3);bvec4 notEqual(dvec4, dvec4);\n
terminateInvocation
terminateRayEXT
terminateRayKHR
terminateRayNV
tessellation control
tessellation control barrier() cannot be placed after a return from main
tessellation control barrier() cannot be placed within flow control
tessellation control barrier() must be in main
tessellation evaluation
tessellation input array size must be gl_MaxPatchVertices or implicitly sized
tessellation shaders
tessellation-control per-vertex output l-value must be indexed with gl_InvocationID
tessellationOutputWindingOrder
tested first
tex [[texture(0
texIndexH
texIndexI
texel offset
texelFetH3\b
texelFetch
texelFetch not supported in legacy ES
texelFetch without sampler was found, but no dummy sampler has been created with build_dummy_sampler_for_combined_images
texelFetchOffset
textA3F
texture
texture%@<uint> stencilTex [[texture(1
texture*D
texture-rectangle sampler keyword
texture1D
texture1DArray
texture1DGradARB
texture1DLod
texture1DProj
texture1DProjGradARB
texture1DProjLod
texture1d
texture1d_array
texture2D
texture2DArray
texture2DDescriptorWithPixelFormat:width:height:mipmapped
texture2DGradARB
texture2DGradEXT
texture2DLod
texture2DLodEXT
texture2DMS
texture2DMSArray
texture2DProj
texture2DProjGradARB
texture2DProjGradEXT
texture2DProjLod
texture2DProjLodEXT
texture2DRect
texture2DRectGradARB
texture2DRectProj
texture2DRectProjGradARB
texture2H
texture2d
texture2d<T> plane0
texture2d<T> plane1
texture2d<T> plane2
texture2d_array
texture2d_ms
texture2d_ms_array
texture3D
texture3DGradARB
texture3DLod
texture3DProj
texture3DProjGradARB
texture3DProjLod
texture3d
textureBarrier
textureBuffer
textureBufferDescriptorWithPixelFormat:width:resourceOptions:usage
textureClamp
textureClampARB
textureCube
textureCubeArray
textureCubeGradARB
textureCubeGradEXT
textureCubeLod
textureCubeLodEXT
textureFetch
textureFetchOffset
textureFootprintClampNV
textureFootprintGradClampNV
textureFootprintGradNV
textureFootprintLodNV
textureFootprintNV
textureGH32H
textureGH3\bH
textureGI3F
textureGI3V
textureGather
textureGather requires ESSL 310
textureGather with component requires GLSL 400
textureGather with depth compare requires GLSL 400
textureGatherLod
textureGatherLodAMD
textureGatherLodOffset
textureGatherLodOffsetAMD
textureGatherLodOffsets
textureGatherLodOffsetsAMD
textureGatherOffset
textureGatherOffsets
textureGrad
textureGradClamp
textureGradClampARB
textureGradOffset
textureGradOffsetClamp
textureGradOffsetClampARB
textureH
textureLH3
textureLH3\b
textureLI3F
textureLI3V
textureLod
textureLod on sampler2DArrayShadow is not constant 0.0. This cannot be expressed in GLSL
textureLodOffset
textureLodOffsetfset
textureOffset
textureOffsetClamp
textureOffsetClampARB
texturePH1
texturePH3
texturePI3N
textureProj
textureProjGrad
textureProjGradOffset
textureProjLod
textureProjLodOf
textureProjLodOffset
textureProjOffset
textureQueryLOD
textureQueryLevels
textureQueryLevels not supported in ES profile
textureQueryLod
textureQueryLod not supported in legacy ES
textureSH3\bH
textureSamples
textureSamples and imageSamples
textureSamples and imageSamples not supported in ES profile
textureSize
textureSize is not supported in ESSL 100
textureSize not supported in legacy ES
textureSize not supported on shadow sampler in legacy GLSL
textureType
texture_buffer
texturecube
texturecube_array
textures
tffff
tgamma
there is no such layout identifier for this stage taking an assigned value
this type not allowed
thread
thread T& operator [] (size_t pos) thread
thread cH
thread const
thread vec<T, Rows>* col
thread()H
threadExecutionWidth
thread_bss
thread_execution_width
thread_index_in_quadgroup
thread_index_in_simdgroup
thread_index_in_simdgroup requires Metal 2.2 in fragment shaders
thread_index_in_threadgroup
thread_position_in_grid
thread_position_in_threadgroup
thread_vars
threadgrH3\bH
threadgroup
threadgroup T& operator [] (size_t pos) threadgroup
threadgroup const
threadgroup_barrier
threadgroup_barrier(mem_flags::mem_threadgroup
threadgroup_imageblock
threadgroup_position_in_grid
threadgroups_per_grid
threads_per_simdgroup
threads_per_simdgroup requires Metal 2.2 in fragment shaders
thref
tializerH
tibilityH1
ties2KHRH
tiesH\t
tileImageEXT
timeAMD
timeAMD(H
tionsInclusiveScanNonUniformAMD(i64vec4);uint64_t minInvocationsInclusiveScanNonUniformAMD(uint64_t);u64vec2  minInvocationsInclusiveScanNonUniformAMD(u64vec2);u64vec3  minInvocationsInclusiveScanNonUniformAMD(u64vec3);u64vec4  minInvocationsInclusiveScanNonUniformAMD(u64vec4);float16_t minInvocationsInclusiveScanNonUniformAMD(float16_t);f16vec2   minInvocationsInclusiveScanNonUniformAMD(f16vec2);f16vec3   minInvocationsInclusiveScanNonUniformAMD(f16vec3);f16vec4   minInvocationsInclusiveScanNonUniformAMD(f16vec4);int16_t minInvocationsInclusiveScanNonUniformAMD(int16_t);i16vec2 minInvocationsInclusiveScanNonUniformAMD(i16vec2);i16vec3 minInvocationsInclusiveScanNonUniformAMD(i16vec3);i16vec4 minInvocationsInclusiveScanNonUniformAMD(i16vec4);uint16_t minInvocationsInclusiveScanNonUniformAMD(uint16_t);u16vec2  minInvocationsInclusiveScanNonUniformAMD(u16vec2);u16vec3  minInvocationsInclusiveScanNonUniformAMD(u16vec3);u16vec4  minInvocationsInclusiveScanNonUniformAMD(u16vec4);float minInvocationsExclusiveScanNonUniformAMD(float);vec2  minInvocationsExclusiveScanNonUniformAMD(vec2);vec3  minInvocationsExclusiveScanNonUniformAMD(vec3);vec4  minInvocationsExclusiveScanNonUniformAMD(vec4);int   minInvocationsExclusiveScanNonUniformAMD(int);ivec2 minInvocationsExclusiveScanNonUniformAMD(ivec2);ivec3 minInvocationsExclusiveScanNonUniformAMD(ivec3);ivec4 minInvocationsExclusiveScanNonUniformAMD(ivec4);uint  minInvocationsExclusiveScanNonUniformAMD(uint);uvec2 minInvocationsExclusiveScanNonUniformAMD(uvec2);uvec3 minInvocationsExclusiveScanNonUniformAMD(uvec3);uvec4 minInvocationsExclusiveScanNonUniformAMD(uvec4);double minInvocationsExclusiveScanNonUniformAMD(double);dvec2  minInvocationsExclusiveScanNonUniformAMD(dvec2);dvec3  minInvocationsExclusiveScanNonUniformAMD(dvec3);dvec4  minInvocationsExclusiveScanNonUniformAMD(dvec4);int64_t minInvocationsExclusiveScanNonUniformAMD(int64_t);i64vec2 minInvocationsExclusiveScanNonUniformAMD(i64vec2);i64vec3 minInvocationsExclusiveScanNonUniformAMD(i64vec3);i64vec4 minInvocationsExclusiveScanNonUniformAMD(i64vec4);uint64_t minInvocationsExclusiveScanNonUniformAMD(uint64_t);u64vec2  minInvocationsExclusiveScanNonUniformAMD(u64vec2);u64vec3  minInvocationsExclusiveScanNonUniformAMD(u64vec3);u64vec4  minInvocationsExclusiveScanNonUniformAMD(u64vec4);float16_t minInvocationsExclusiveScanNonUniformAMD(float16_t);f16vec2   minInvocationsExclusiveScanNonUniformAMD(f16vec2);f16vec3   minInvocationsExclusiveScanNonUniformAMD(f16vec3);f16vec4   minInvocationsExclusiveScanNonUniformAMD(f16vec4);int16_t minInvocationsExclusiveScanNonUniformAMD(int16_t);i16vec2 minInvocationsExclusiveScanNonUniformAMD(i16vec2);i16vec3 minInvocationsExclusiveScanNonUniformAMD(i16vec3);i16vec4 minInvocationsExclusiveScanNonUniformAMD(i16vec4);uint16_t minInvocationsExclusiveScanNonUniformAMD(uint16_t);u16vec2  minInvocationsExclusiveScanNonUniformAMD(u16vec2);u16vec3  minInvocationsExclusiveScanNonUniformAMD(u16vec3);u16vec4  minInvocationsExclusiveScanNonUniformAMD(u16vec4);float maxInvocationsNonUniformAMD(float);vec2  maxInvocationsNonUniformAMD(vec2);vec3  maxInvocationsNonUniformAMD(vec3);vec4  maxInvocationsNonUniformAMD(vec4);int   maxInvocationsNonUniformAMD(int);ivec2 maxInvocationsNonUniformAMD(ivec2);ivec3 maxInvocationsNonUniformAMD(ivec3);ivec4 maxInvocationsNonUniformAMD(ivec4);uint  maxInvocationsNonUniformAMD(uint);uvec2 maxInvocationsNonUniformAMD(uvec2);uvec3 maxInvocationsNonUniformAMD(uvec3);uvec4 maxInvocationsNonUniformAMD(uvec4);double maxInvocationsNonUniformAMD(double);dvec2  maxInvocationsNonUniformAMD(dvec2);dvec3  maxInvocationsNonUniformAMD(dvec3);dvec4  maxInvocationsNonUniformAMD(dvec4);int64_t maxInvocationsNonUniformAMD(int64_t);i64vec2 maxInvocationsNonUniformAMD(i64vec2);i64vec3 maxInvocationsNonUniformAMD(i64vec3);i64vec4 maxInvocationsNonUniformAMD(i64vec4);uint64_t maxInvocationsNonUniformAMD(uint64_t);u64vec2  maxInvocationsNonUniformAMD(u64vec2);u64vec3  maxInvocationsNonUniformAMD(u64vec3);u64vec4  maxInvocationsNonUniformAMD(u64vec4);float16_t maxInvocationsNonUniformAMD(float1
tionƅt
tl[A^A
tlv_atexit
tlv_bootstrap
tmHǃP\b
tmp = fma(vec<T, RCols>(r[i][j]), l[j], tmp
tmp[j] = m[j][i - 1
to unsigned integer
token pasting
tolower
too largH
too large for fragment output
too large, must be less than
too large, must be less than gl_MaxGeometryOutputVertices
too large, see
too large; see gl_MaxComputeWorkGroupSize
too many SPIR-V decorate qualifiers
too many SPIR-V instruction qualifiers
too many SPIR-V requirements
too many arguments
too many storage qualifiers
topLevelArrayStride %d
toupper
tpM9t
tpp\bp`p\bp`p\bp`p\bp`p\bp`p\bp
tqL;8u
trL;(u
traceNV
traceRayEXT
traceRayKHR
traceRayMotionNV
transform feedback qualifier
translation_unit
transpose
triangle
triangle order
triangleH
triangle_strip
triangles
triangles_adjacency
tribute(H
tributesI
trinsicsH
truct
true case is null\n
true case\n
true, discard_fragment
trueƅE
trunc
truncated
tsL;0u
tstatic const uint32_t
tten3P
tten3S
ttenH\t
ture3q
tureA3N
tureGradH
tureGradH3P
tureGradH3z
tureGradI3N
tureGradI3v
tureProjH3P
tureProjI3N
tureSizeH3P
turesKHRH
tvL;0u
tv[A\\A^A
txL; u
txL;!u
tyM;0u
tyfffff
type ID
type cannot have precision qualifier
type contains double or 64-bit integer; xfb_offset must be a multiple of 8
type contains half float or 16-bit integer; xfb_offset must be a multiple of 2
type conversion on return values was not explicitly allowed until version 420
type does not match, or is not convertible to, the function's return type
type mismatch in initializer list
type must be an array
type overflows the available 4 components
type parameter
type requires declaration of default precision qualifier
type.1d.image
type.2d.image
type.3d.image
type.cube.image
type.image
type.sampled.image
type.sampler
type_name_list
type_parameter_specifier
type_parameter_specifier_list
type_parameter_specifier_opt
type_qualifier
type_specifier
type_specifier_nonarray
typedef
typedef H
typedef spvStorageMatrix<float, 2, 2> spvStorage_float2x2
typedef spvStorageMatrix<float, 2, 3> spvStorage_float2x3
typedef spvStorageMatrix<float, 2, 4> spvStorage_float2x4
typedef spvStorageMatrix<float, 3, 2> spvStorage_float3x2
typedef spvStorageMatrix<float, 3, 3> spvStorage_float3x3
typedef spvStorageMatrix<float, 3, 4> spvStorage_float3x4
typedef spvStorageMatrix<float, 4, 2> spvStorage_float4x2
typedef spvStorageMatrix<float, 4, 3> spvStorage_float4x3
typedef spvStorageMatrix<float, 4, 4> spvStorage_float4x4
typedef spvStorageMatrix<half, 2, 2> spvStorage_half2x2
typedef spvStorageMatrix<half, 2, 3> spvStorage_half2x3
typedef spvStorageMatrix<half, 2, 4> spvStorage_half2x4
typedef spvStorageMatrix<half, 3, 2> spvStorage_half3x2
typedef spvStorageMatrix<half, 3, 3> spvStorage_half3x3
typedef spvStorageMatrix<half, 3, 4> spvStorage_half3x4
typedef spvStorageMatrix<half, 4, 2> spvStorage_half4x2
typedef spvStorageMatrix<half, 4, 3> spvStorage_half4x3
typedef spvStorageMatrix<half, 4, 4> spvStorage_half4x4
typedef struct
tzL;:u
t}L;0u
t}M;0u
tā8Yߛ;u
u (%s
u = 0.5 * (u/ProjectionAxis + 1
u = P.x
u = P.x >= 0 ? -P.z : P.z
u = P.z >= 0 ? P.x : -P.x
u fffff
u)int16 types can only be in uniform block or buffer storage
u)int8 types can only be in uniform block or buffer storage
u16vec
u16vec2
u16vec3
u16vec4
u32vec2
u32vec3
u32vec4
u4A;V8u
u64image1D
u64image1DArray
u64image2D
u64image2DArray
u64image2DMS
u64image2DMSArray
u64image2DRect
u64image3D
u64imageBuffer
u64imageCube
u64imageCubeArray
u64vec
u64vec2
u64vec3
u64vec4
u8vec2
u8vec3
u8vec4
u<ffffff
u?ffffff
u@z>fH
uBI+^0H
uMulExtended
uZD8{ u
u\b1ۀx
u\b\aPv\b
u\eI3E\bH
u\fIǄ$0\e
u\fIǄ$P
u\fIǄ$p
u\n<\tv9I
u\nF\bA2E\b
u\rfA
u\vHǃ \r
u\vHǃ0
u\vHǃ0\e
u\vHǃ0\f
u\vHǃ8
u\vHǃH
u\vHǃP
u\vHǃP\n
u\vHǃX
u\vHǃ\b
u\vHǃ\b\a
u\vHǃp
u\vHǃp\b
u\vIǅX
u\vIǅp
u\vIǆ0
u\vIǆ0\f
u\vIǆ8
u\vIǆH
u\vIǆp\b
u\vIǇp
u_abs_diff
u_add_sat
u_clamp
u_hadd
u_mad24
u_mad_hi
u_mad_sat
u_mul24
u_mul_hi
u_rhadd
u_sub_sat
u_upsample
uaddCarry
uattachmentEXT
uchar value : 6
ucoopmatNV
ueSubmitH
uery_lodH
ugI9G0
uimage1D
uimage1DArray
uimage2D
uimage2DArray
uimage2DMS
uimage2DMSArray
uimage2DRect
uimage3D
uimageBuffer
uimageCube
uimageCubeArray
uint atomicAdd(coherent volatile inout uint, uint, int, int, int); int atomicAdd(coherent volatile inout  int,  int, int, int, int);uint atomicMin(coherent volatile inout uint, uint, int, int, int); int atomicMin(coherent volatile inout  int,  int, int, int, int);uint atomicMax(coherent volatile inout uint, uint, int, int, int); int atomicMax(coherent volatile inout  int,  int, int, int, int);uint atomicAnd(coherent volatile inout uint, uint, int, int, int); int atomicAnd(coherent volatile inout  int,  int, int, int, int);uint atomicOr (coherent volatile inout uint, uint, int, int, int); int atomicOr (coherent volatile inout  int,  int, int, int, int);uint atomicXor(coherent volatile inout uint, uint, int, int, int); int atomicXor(coherent volatile inout  int,  int, int, int, int);uint atomicExchange(coherent volatile inout uint, uint, int, int, int); int atomicExchange(coherent volatile inout  int,  int, int, int, int);uint atomicCompSwap(coherent volatile inout uint, uint, uint, int, int, int, int, int); int atomicCompSwap(coherent volatile inout  int,  int,  int, int, int, int, int, int);uint atomicLoad(coherent volatile in uint, int, int, int); int atomicLoad(coherent volatile in  int, int, int, int);void atomicStore(coherent volatile out uint, uint, int, int, int);void atomicStore(coherent volatile out  int,  int, int, int, int);\n
uint atomicCounterAdd(atomic_uint, uint);uint atomicCounterSubtract(atomic_uint, uint);uint atomicCounterMin(atomic_uint, uint);uint atomicCounterMax(atomic_uint, uint);uint atomicCounterAnd(atomic_uint, uint);uint atomicCounterOr(atomic_uint, uint);uint atomicCounterXor(atomic_uint, uint);uint atomicCounterExchange(atomic_uint, uint);uint atomicCounterCompSwap(atomic_uint, uint, uint);\n
uint atomicCounterAdd(volatile coherent uint, uint);uint atomicCounterSubtract(volatile coherent uint, uint);uint atomicCounterMin(volatile coherent uint, uint);uint atomicCounterMax(volatile coherent uint, uint);uint atomicCounterAnd(volatile coherent uint, uint);uint atomicCounterOr(volatile coherent uint, uint);uint atomicCounterXor(volatile coherent uint, uint);uint atomicCounterExchange(volatile coherent uint, uint);uint atomicCounterCompSwap(volatile coherent uint, uint, uint);\n
uint atomicCounterAddARB(atomic_uint, uint);uint atomicCounterSubtractARB(atomic_uint, uint);uint atomicCounterMinARB(atomic_uint, uint);uint atomicCounterMaxARB(atomic_uint, uint);uint atomicCounterAndARB(atomic_uint, uint);uint atomicCounterOrARB(atomic_uint, uint);uint atomicCounterXorARB(atomic_uint, uint);uint atomicCounterExchangeARB(atomic_uint, uint);uint atomicCounterCompSwapARB(atomic_uint, uint, uint);\n
uint atomicCounterIncrement(atomic_uint);uint atomicCounterDecrement(atomic_uint);uint atomicCounter(atomic_uint);\n
uint atomicCounterIncrement(volatile coherent uint);uint atomicCounterDecrement(volatile coherent uint);uint atomicCounter(volatile coherent uint);\n
uint countLeadingZeros(uint);uvec2 countLeadingZeros(uvec2);uvec3 countLeadingZeros(uvec3);uvec4 countLeadingZeros(uvec4);uint countTrailingZeros(uint);uvec2 countTrailingZeros(uvec2);uvec3 countTrailingZeros(uvec3);uvec4 countTrailingZeros(uvec4);uint absoluteDifference(int, int);uvec2 absoluteDifference(ivec2, ivec2);uvec3 absoluteDifference(ivec3, ivec3);uvec4 absoluteDifference(ivec4, ivec4);uint16_t absoluteDifference(int16_t, int16_t);u16vec2 absoluteDifference(i16vec2, i16vec2);u16vec3 absoluteDifference(i16vec3, i16vec3);u16vec4 absoluteDifference(i16vec4, i16vec4);uint64_t absoluteDifference(int64_t, int64_t);u64vec2 absoluteDifference(i64vec2, i64vec2);u64vec3 absoluteDifference(i64vec3, i64vec3);u64vec4 absoluteDifference(i64vec4, i64vec4);uint absoluteDifference(uint, uint);uvec2 absoluteDifference(uvec2, uvec2);uvec3 absoluteDifference(uvec3, uvec3);uvec4 absoluteDifference(uvec4, uvec4);uint16_t absoluteDifference(uint16_t, uint16_t);u16vec2 absoluteDifference(u16vec2, u16vec2);u16vec3 absoluteDifference(u16vec3, u16vec3);u16vec4 absoluteDifference(u16vec4, u16vec4);uint64_t absoluteDifference(uint64_t, uint64_t);u64vec2 absoluteDifference(u64vec2, u64vec2);u64vec3 absoluteDifference(u64vec3, u64vec3);u64vec4 absoluteDifference(u64vec4, u64vec4);int addSaturate(int, int);ivec2 addSaturate(ivec2, ivec2);ivec3 addSaturate(ivec3, ivec3);ivec4 addSaturate(ivec4, ivec4);int16_t addSaturate(int16_t, int16_t);i16vec2 addSaturate(i16vec2, i16vec2);i16vec3 addSaturate(i16vec3, i16vec3);i16vec4 addSaturate(i16vec4, i16vec4);int64_t addSaturate(int64_t, int64_t);i64vec2 addSaturate(i64vec2, i64vec2);i64vec3 addSaturate(i64vec3, i64vec3);i64vec4 addSaturate(i64vec4, i64vec4);uint addSaturate(uint, uint);uvec2 addSaturate(uvec2, uvec2);uvec3 addSaturate(uvec3, uvec3);uvec4 addSaturate(uvec4, uvec4);uint16_t addSaturate(uint16_t, uint16_t);u16vec2 addSaturate(u16vec2, u16vec2);u16vec3 addSaturate(u16vec3, u16vec3);u16vec4 addSaturate(u16vec4, u16vec4);uint64_t addSaturate(uint64_t, uint64_t);u64vec2 addSaturate(u64vec2, u64vec2);u64vec3 addSaturate(u64vec3, u64vec3);u64vec4 addSaturate(u64vec4, u64vec4);int subtractSaturate(int, int);ivec2 subtractSaturate(ivec2, ivec2);ivec3 subtractSaturate(ivec3, ivec3);ivec4 subtractSaturate(ivec4, ivec4);int16_t subtractSaturate(int16_t, int16_t);i16vec2 subtractSaturate(i16vec2, i16vec2);i16vec3 subtractSaturate(i16vec3, i16vec3);i16vec4 subtractSaturate(i16vec4, i16vec4);int64_t subtractSaturate(int64_t, int64_t);i64vec2 subtractSaturate(i64vec2, i64vec2);i64vec3 subtractSaturate(i64vec3, i64vec3);i64vec4 subtractSaturate(i64vec4, i64vec4);uint subtractSaturate(uint, uint);uvec2 subtractSaturate(uvec2, uvec2);uvec3 subtractSaturate(uvec3, uvec3);uvec4 subtractSaturate(uvec4, uvec4);uint16_t subtractSaturate(uint16_t, uint16_t);u16vec2 subtractSaturate(u16vec2, u16vec2);u16vec3 subtractSaturate(u16vec3, u16vec3);u16vec4 subtractSaturate(u16vec4, u16vec4);uint64_t subtractSaturate(uint64_t, uint64_t);u64vec2 subtractSaturate(u64vec2, u64vec2);u64vec3 subtractSaturate(u64vec3, u64vec3);u64vec4 subtractSaturate(u64vec4, u64vec4);int average(int, int);ivec2 average(ivec2, ivec2);ivec3 average(ivec3, ivec3);ivec4 average(ivec4, ivec4);int16_t average(int16_t, int16_t);i16vec2 average(i16vec2, i16vec2);i16vec3 average(i16vec3, i16vec3);i16vec4 average(i16vec4, i16vec4);int64_t average(int64_t, int64_t);i64vec2 average(i64vec2, i64vec2);i64vec3 average(i64vec3, i64vec3);i64vec4 average(i64vec4, i64vec4);uint average(uint, uint);uvec2 average(uvec2, uvec2);uvec3 average(uvec3, uvec3);uvec4 average(uvec4, uvec4);uint16_t average(uint16_t, uint16_t);u16vec2 average(u16vec2, u16vec2);u16vec3 average(u16vec3, u16vec3);u16vec4 average(u16vec4, u16vec4);uint64_t average(uint64_t, uint64_t);u64vec2 average(u64vec2, u64vec2);u64vec3 average(u64vec3, u64vec3);u64vec4 average(u64vec4, u64vec4);int averageRounded(int, int);ivec2 averageRounded(ivec2, ivec2);ivec3 averageRounded(ivec3, ivec3);ivec4 averageRounded(ivec4, ivec4);int16_t averageRounded(int16_t, int16_t);i16vec2 averageRounded(i16vec2, i1
uint firstLive = subgroupBallotFindLSB(activeMask
uint fragmentMaskFetchAMD(sampler2DMS,       ivec2);uint fragmentMaskFetchAMD(isampler2DMS,      ivec2);uint fragmentMaskFetchAMD(usampler2DMS,      ivec2);uint fragmentMaskFetchAMD(sampler2DMSArray,  ivec3);uint fragmentMaskFetchAMD(isampler2DMSArray, ivec3);uint fragmentMaskFetchAMD(usampler2DMSArray, ivec3);vec4  fragmentFetchAMD(sampler2DMS,       ivec2, uint);ivec4 fragmentFetchAMD(isampler2DMS,      ivec2, uint);uvec4 fragmentFetchAMD(usampler2DMS,      ivec2, uint);vec4  fragmentFetchAMD(sampler2DMSArray,  ivec3, uint);ivec4 fragmentFetchAMD(isampler2DMSArray, ivec3, uint);uvec4 fragmentFetchAMD(usampler2DMSArray, ivec3, uint);\n
uint fragmentMaskFetchAMD(subpassInputMS);uint fragmentMaskFetchAMD(isubpassInputMS);uint fragmentMaskFetchAMD(usubpassInputMS);vec4  fragmentFetchAMD(subpassInputMS,  uint);ivec4 fragmentFetchAMD(isubpassInputMS, uint);uvec4 fragmentFetchAMD(usubpassInputMS, uint);\n
uint layer%s
uint shifted = value.x >> index
uint shifted = value[index >> 5u] >> (index & 0x1fu
uint slice
uint stencil [[stencil
uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent uint8_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent uint16_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent uint32_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent uint64_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent float16_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent float[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent float64_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent i8vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent i16vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent i32vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent i64vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent u8vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent u16vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent u32vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent u64vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent f16vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent f32vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent f64vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent i8vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent i16vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent i32vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent i64vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent u8vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent u16vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent u32vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent u64vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent f16vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent f32vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent f64vec4[] buf, uint element, uint stride, int matrixLayout);\ncoopmat coopMatMulAdd(coopmat A, coopmat B, coopmat C);\ncoopmat coopMatMulAdd(coopmat A, coopmat B, coopmat C, int matrixOperands);\n
uint subgroupBallotBitCount(uvec4 value
uint subgroupBallotExclusiveBitCount(uvec4 value
uint subgroupBallotFindLSB(uvec4 value
uint subgroupBallotFindLSB(uvec4 value) { return findLSB(value.x
uint subgroupBallotFindMSB(uvec4 value
uint subgroupBallotFindMSB(uvec4 value) { return findMSB(value.x
uint subgroupBallotInclusiveBitCount(uvec4 value
uint swizzle = 0
uint total = gl_SubgroupSize / 2u
uint total = subgroupBallotBitCount(gl_SubgroupLeMask
uint total = subgroupBallotBitCount(gl_SubgroupLtMask
uint uaddCarry(highp  uint, highp  uint, out lowp  uint carry);uvec2 uaddCarry(highp uvec2, highp uvec2, out lowp uvec2 carry);uvec3 uaddCarry(highp uvec3, highp uvec3, out lowp uvec3 carry);uvec4 uaddCarry(highp uvec4, highp uvec4, out lowp uvec4 carry); uint usubBorrow(highp  uint, highp  uint, out lowp  uint borrow);uvec2 usubBorrow(highp uvec2, highp uvec2, out lowp uvec2 borrow);uvec3 usubBorrow(highp uvec3, highp uvec3, out lowp uvec3 borrow);uvec4 usubBorrow(highp uvec4, highp uvec4, out lowp uvec4 borrow);void umulExtended(highp  uint, highp  uint, out highp  uint, out highp  uint lsb);void umulExtended(highp uvec2, highp uvec2, out highp uvec2, out highp uvec2 lsb);void umulExtended(highp uvec3, highp uvec3, out highp uvec3, out highp uvec3 lsb);void umulExtended(highp uvec4, highp uvec4, out highp uvec4, out highp uvec4 lsb);void imulExtended(highp   int, highp   int, out highp   int, out highp   int lsb);void imulExtended(highp ivec2, highp ivec2, out highp ivec2, out highp ivec2 lsb);void imulExtended(highp ivec3, highp ivec3, out highp ivec3, out highp ivec3 lsb);void imulExtended(highp ivec4, highp ivec4, out highp ivec4, out highp ivec4 lsb);  int bitfieldReverse(highp   int);ivec2 bitfieldReverse(highp ivec2);ivec3 bitfieldReverse(highp ivec3);ivec4 bitfieldReverse(highp ivec4); uint bitfieldReverse(highp  uint);uvec2 bitfieldReverse(highp uvec2);uvec3 bitfieldReverse(highp uvec3);uvec4 bitfieldReverse(highp uvec4);\n
uint v_layer [[render_target_array_index
uint(-1
uint(1
uint(spvCubemapTo2DArrayFace
uint(ushort
uint16BitsToFloat16
uint16BitsToFloat16(u16vec3);f16vec4   uint16BitsToFloat16(u16vec4);float16_t int16BitsToHalf(int16_t);f16vec2   int16BitsToHalf(i16vec2);f16vec3   int16BitsToHalf(i16vec3);f16vec4   int16BitsToHalf(i16vec4);float16_t uint16BitsToHalf(uint16_t);f16vec2   uint16BitsToHalf(u16vec2);f16vec3   uint16BitsToHalf(u16vec3);f16vec4   uint16BitsToHalf(u16vec4);int      packInt2x16(i16vec2);uint     packUint2x16(u16vec2);int64_t  packInt4x16(i16vec4);uint64_t packUint4x16(u16vec4);i16vec2  unpackInt2x16(int);u16vec2  unpackUint2x16(uint);i16vec4  unpackInt4x16(int64_t);u16vec4  unpackUint4x16(uint64_t);bvec2 lessThan(i16vec2, i16vec2);bvec3 lessThan(i16vec3, i16vec3);bvec4 lessThan(i16vec4, i16vec4);bvec2 lessThan(u16vec2, u16vec2);bvec3 lessThan(u16vec3, u16vec3);bvec4 lessThan(u16vec4, u16vec4);bvec2 lessThanEqual(i16vec2, i16vec2);bvec3 lessThanEqual(i16vec3, i16vec3);bvec4 lessThanEqual(i16vec4, i16vec4);bvec2 lessThanEqual(u16vec2, u16vec2);bvec3 lessThanEqual(u16vec3, u16vec3);bvec4 lessThanEqual(u16vec4, u16vec4);bvec2 greaterThan(i16vec2, i16vec2);bvec3 greaterThan(i16vec3, i16vec3);bvec4 greaterThan(i16vec4, i16vec4);bvec2 greaterThan(u16vec2, u16vec2);bvec3 greaterThan(u16vec3, u16vec3);bvec4 greaterThan(u16vec4, u16vec4);bvec2 greaterThanEqual(i16vec2, i16vec2);bvec3 greaterThanEqual(i16vec3, i16vec3);bvec4 greaterThanEqual(i16vec4, i16vec4);bvec2 greaterThanEqual(u16vec2, u16vec2);bvec3 greaterThanEqual(u16vec3, u16vec3);bvec4 greaterThanEqual(u16vec4, u16vec4);bvec2 equal(i16vec2, i16vec2);bvec3 equal(i16vec3, i16vec3);bvec4 equal(i16vec4, i16vec4);bvec2 equal(u16vec2, u16vec2);bvec3 equal(u16vec3, u16vec3);bvec4 equal(u16vec4, u16vec4);bvec2 notEqual(i16vec2, i16vec2);bvec3 notEqual(i16vec3, i16vec3);bvec4 notEqual(i16vec4, i16vec4);bvec2 notEqual(u16vec2, u16vec2);bvec3 notEqual(u16vec3, u16vec3);bvec4 notEqual(u16vec4, u16vec4);  int16_t bitfieldExtract(  int16_t, int16_t, int16_t);i16vec2 bitfieldExtract(i16vec2, int16_t, int16_t);i16vec3 bitfieldExtract(i16vec3, int16_t, int16_t);i16vec4 bitfieldExtract(i16vec4, int16_t, int16_t); uint16_t bitfieldExtract( uint16_t, int16_t, int16_t);u16vec2 bitfieldExtract(u16vec2, int16_t, int16_t);u16vec3 bitfieldExtract(u16vec3, int16_t, int16_t);u16vec4 bitfieldExtract(u16vec4, int16_t, int16_t);  int16_t bitfieldInsert(  int16_t base,   int16_t, int16_t, int16_t);i16vec2 bitfieldInsert(i16vec2 base, i16vec2, int16_t, int16_t);i16vec3 bitfieldInsert(i16vec3 base, i16vec3, int16_t, int16_t);i16vec4 bitfieldInsert(i16vec4 base, i16vec4, int16_t, int16_t); uint16_t bitfieldInsert( uint16_t base,  uint16_t, int16_t, int16_t);u16vec2 bitfieldInsert(u16vec2 base, u16vec2, int16_t, int16_t);u16vec3 bitfieldInsert(u16vec3 base, u16vec3, int16_t, int16_t);u16vec4 bitfieldInsert(u16vec4 base, u16vec4, int16_t, int16_t);  int16_t bitCount(  int16_t);i16vec2 bitCount(i16vec2);i16vec3 bitCount(i16vec3);i16vec4 bitCount(i16vec4);  int16_t bitCount( uint16_t);i16vec2 bitCount(u16vec2);i16vec3 bitCount(u16vec3);i16vec4 bitCount(u16vec4);  int16_t findLSB(  int16_t);i16vec2 findLSB(i16vec2);i16vec3 findLSB(i16vec3);i16vec4 findLSB(i16vec4);  int16_t findLSB( uint16_t);i16vec2 findLSB(u16vec2);i16vec3 findLSB(u16vec3);i16vec4 findLSB(u16vec4);  int16_t findMSB(  int16_t);i16vec2 findMSB(i16vec2);i16vec3 findMSB(i16vec3);i16vec4 findMSB(i16vec4);  int16_t findMSB( uint16_t);i16vec2 findMSB(u16vec2);i16vec3 findMSB(u16vec3);i16vec4 findMSB(u16vec4);int16_t  pack16(i8vec2);uint16_t pack16(u8vec2);int32_t  pack32(i8vec4);uint32_t pack32(u8vec4);int32_t  pack32(i16vec2);uint32_t pack32(u16vec2);int64_t  pack64(i16vec4);uint64_t pack64(u16vec4);int64_t  pack64(i32vec2);uint64_t pack64(u32vec2);i8vec2   unpack8(int16_t);u8vec2   unpack8(uint16_t);i8vec4   unpack8(int32_t);u8vec4   unpack8(uint32_t);i16vec2  unpack16(int32_t);u16vec2  unpack16(uint32_t);i16vec4  unpack16(int64_t);u16vec4  unpack16(uint64_t);i32vec2  unpack32(int64_t);u32vec2  unpack32(uint64_t);\n
uint16BitsToHalf
uint16_t
uint2
uint2 spvTexelBufferCoord(uint tc
uint2(gl_FragCoord.xy
uint3
uint3(0
uint32_t
uint4 mask = uint4(extract_bits(0xFFFFFFFF, 0, gl_SubgroupInvocationID + 1), uint3(0
uint4 mask = uint4(extract_bits(0xFFFFFFFF, 0, gl_SubgroupInvocationID), uint2(0
uint4 mask = uint4(extract_bits(0xFFFFFFFF, 0, gl_SubgroupSize), uint3(0
uint4 mask = uint4(extract_bits(0xFFFFFFFF, 0, min(gl_SubgroupInvocationID + 1, 32u)), extract_bits(0xFFFFFFFF, 0, (uint)max((int)gl_SubgroupInvocationID + 1 - 32, 0)), uint2(0
uint4 mask = uint4(extract_bits(0xFFFFFFFF, 0, min(gl_SubgroupInvocationID, 32u)), extract_bits(0xFFFFFFFF, 0, (uint)max((int)gl_SubgroupInvocationID - 32, 0)), uint2(0
uint4 mask = uint4(extract_bits(0xFFFFFFFF, 0, min(gl_SubgroupSize, 32u)), extract_bits(0xFFFFFFFF, 0, (uint)max((int)gl_SubgroupSize - 32, 0)), uint2(0
uint4(1
uint4(extract_bits(0xFFFFFFFF, 0
uint4(extract_bits(0xFFFFFFFF, 0, min
uint4(insert_bits(0u, 0xFFFFFFFF
uint4(insert_bits(0u, 0xFFFFFFFF, min
uint64BitsToDouble
uint64_t
uint64_t atomicMin(coherent volatile inout uint64_t, uint64_t); int64_t atomicMin(coherent volatile inout  int64_t,  int64_t);uint64_t atomicMin(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicMin(coherent volatile inout  int64_t,  int64_t, int, int, int);float16_t atomicMin(coherent volatile inout float16_t, float16_t);float16_t atomicMin(coherent volatile inout float16_t, float16_t, int, int, int);   float atomicMin(coherent volatile inout float, float);   float atomicMin(coherent volatile inout float, float, int, int, int);  double atomicMin(coherent volatile inout double, double);  double atomicMin(coherent volatile inout double, double, int, int, int);uint64_t atomicMax(coherent volatile inout uint64_t, uint64_t); int64_t atomicMax(coherent volatile inout  int64_t,  int64_t);uint64_t atomicMax(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicMax(coherent volatile inout  int64_t,  int64_t, int, int, int);float16_t atomicMax(coherent volatile inout float16_t, float16_t);float16_t atomicMax(coherent volatile inout float16_t, float16_t, int, int, int);   float atomicMax(coherent volatile inout float, float);   float atomicMax(coherent volatile inout float, float, int, int, int);  double atomicMax(coherent volatile inout double, double);  double atomicMax(coherent volatile inout double, double, int, int, int);uint64_t atomicAnd(coherent volatile inout uint64_t, uint64_t); int64_t atomicAnd(coherent volatile inout  int64_t,  int64_t);uint64_t atomicAnd(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicAnd(coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicOr (coherent volatile inout uint64_t, uint64_t); int64_t atomicOr (coherent volatile inout  int64_t,  int64_t);uint64_t atomicOr (coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicOr (coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicXor(coherent volatile inout uint64_t, uint64_t); int64_t atomicXor(coherent volatile inout  int64_t,  int64_t);uint64_t atomicXor(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicXor(coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicAdd(coherent volatile inout uint64_t, uint64_t); int64_t atomicAdd(coherent volatile inout  int64_t,  int64_t);uint64_t atomicAdd(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicAdd(coherent volatile inout  int64_t,  int64_t, int, int, int);float16_t atomicAdd(coherent volatile inout float16_t, float16_t);float16_t atomicAdd(coherent volatile inout float16_t, float16_t, int, int, int);   float atomicAdd(coherent volatile inout float, float);   float atomicAdd(coherent volatile inout float, float, int, int, int);  double atomicAdd(coherent volatile inout double, double);  double atomicAdd(coherent volatile inout double, double, int, int, int);uint64_t atomicExchange(coherent volatile inout uint64_t, uint64_t); int64_t atomicExchange(coherent volatile inout  int64_t,  int64_t);uint64_t atomicExchange(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicExchange(coherent volatile inout  int64_t,  int64_t, int, int, int);float16_t atomicExchange(coherent volatile inout float16_t, float16_t);float16_t atomicExchange(coherent volatile inout float16_t, float16_t, int, int, int);   float atomicExchange(coherent volatile inout float, float);   float atomicExchange(coherent volatile inout float, float, int, int, int);  double atomicExchange(coherent volatile inout double, double);  double atomicExchange(coherent volatile inout double, double, int, int, int);uint64_t atomicCompSwap(coherent volatile inout uint64_t, uint64_t, uint64_t); int64_t atomicCompSwap(coherent volatile inout  int64_t,  int64_t,  int64_t);uint64_t atomicCompSwap(coherent volatile inout uint64_t, uint64_t, uint64_t, int, int, int, int, int); int64_t atomicCompSwap(coherent volatile inout  int64_t,  int64_t,  int64_t, int, int, int, int, int);uint64_t atomicLoad(coherent volatile in uint64_t, int, int, int); int64_t
uint64_t ballotARB(bool);float readInvocationARB(float, uint);vec2  readInvocationARB(vec2,  uint);vec3  readInvocationARB(vec3,  uint);vec4  readInvocationARB(vec4,  uint);int   readInvocationARB(int,   uint);ivec2 readInvocationARB(ivec2, uint);ivec3 readInvocationARB(ivec3, uint);ivec4 readInvocationARB(ivec4, uint);uint  readInvocationARB(uint,  uint);uvec2 readInvocationARB(uvec2, uint);uvec3 readInvocationARB(uvec3, uint);uvec4 readInvocationARB(uvec4, uint);float readFirstInvocationARB(float);vec2  readFirstInvocationARB(vec2);vec3  readFirstInvocationARB(vec3);vec4  readFirstInvocationARB(vec4);int   readFirstInvocationARB(int);ivec2 readFirstInvocationARB(ivec2);ivec3 readFirstInvocationARB(ivec3);ivec4 readFirstInvocationARB(ivec4);uint  readFirstInvocationARB(uint);uvec2 readFirstInvocationARB(uvec2);uvec3 readFirstInvocationARB(uvec3);uvec4 readFirstInvocationARB(uvec4);\n
uint64_t conversion to acclerationStructureEXT
uint8_t
uintBitsToFloat
uintBitsToFloat(packFloat2x16
uintƅu
ullModeFromVkCullModeFlags
ulong types in buffers are only supported in MSL 2.3 and above
umulExtended
unary_expression
unary_operator
uncalledH
undeclared identifier
undef
undef _SPIRV_CROSS_SUBGROUP_ALL_EQUAL_WORKAROUND
undefined macro in expression not allowed in es profile
unexpected
unexpected initializer-list type
unexpected location
unexpected location; end of argument
unexpected location; end of replacement list
unexpected number type parameters
unexpected token
unexpected tokens following #ifdef directive - expected a newline
unexpected tokens following directive
unexpected type parameters
unexpected use of .length
unexpected_MTLPixelFormatInvalid
uniform
uniform block
uniform buffer-member align
uniform gl_DepthRangeParameters gl_DepthRange;\n
uniform initializers must be constant
uniform int SPIRV_Cross_BaseInstance
uniform int SPIRV_Cross_BaseVertex
uniform int gl_NumSamples
uniform lowp int gl_NumSamples
uniform mat4  gl_ModelViewMatrix;uniform mat4  gl_ProjectionMatrix;uniform mat4  gl_ModelViewProjectionMatrix;uniform mat3  gl_NormalMatrix;uniform mat4  gl_ModelViewMatrixInverse;uniform mat4  gl_ProjectionMatrixInverse;uniform mat4  gl_ModelViewProjectionMatrixInverse;uniform mat4  gl_ModelViewMatrixTranspose;uniform mat4  gl_ProjectionMatrixTranspose;uniform mat4  gl_ModelViewProjectionMatrixTranspose;uniform mat4  gl_ModelViewMatrixInverseTranspose;uniform mat4  gl_ProjectionMatrixInverseTranspose;uniform mat4  gl_ModelViewProjectionMatrixInverseTranspose;uniform float gl_NormalScale;struct gl_PointParameters {float size;float sizeMin;float sizeMax;float fadeThresholdSize;float distanceConstantAttenuation;float distanceLinearAttenuation;float distanceQuadraticAttenuation;};uniform gl_PointParameters gl_Point;struct gl_MaterialParameters {vec4  emission;vec4  ambient;vec4  diffuse;vec4  specular;float shininess;};uniform gl_MaterialParameters  gl_FrontMaterial;uniform gl_MaterialParameters  gl_BackMaterial;struct gl_LightSourceParameters {vec4  ambient;vec4  diffuse;vec4  specular;vec4  position;vec4  halfVector;vec3  spotDirection;float spotExponent;float spotCutoff;float spotCosCutoff;float constantAttenuation;float linearAttenuation;float quadraticAttenuation;};struct gl_LightModelParameters {vec4  ambient;};uniform gl_LightModelParameters  gl_LightModel;struct gl_LightModelProducts {vec4  sceneColor;};uniform gl_LightModelProducts gl_FrontLightModelProduct;uniform gl_LightModelProducts gl_BackLightModelProduct;struct gl_LightProducts {vec4  ambient;vec4  diffuse;vec4  specular;};struct gl_FogParameters {vec4  color;float density;float start;float end;float scale;};uniform gl_FogParameters gl_Fog;\n
uniform mat4  gl_TextureMatrix[gl_MaxTextureCoords];uniform mat4  gl_TextureMatrixInverse[gl_MaxTextureCoords];uniform mat4  gl_TextureMatrixTranspose[gl_MaxTextureCoords];uniform mat4  gl_TextureMatrixInverseTranspose[gl_MaxTextureCoords];uniform vec4  gl_ClipPlane[gl_MaxClipPlanes];uniform gl_LightSourceParameters  gl_LightSource[gl_MaxLights];uniform gl_LightProducts gl_FrontLightProduct[gl_MaxLights];uniform gl_LightProducts gl_BackLightProduct[gl_MaxLights];uniform vec4  gl_TextureEnvColor[gl_MaxTextureImageUnits];uniform vec4  gl_EyePlaneS[gl_MaxTextureCoords];uniform vec4  gl_EyePlaneT[gl_MaxTextureCoords];uniform vec4  gl_EyePlaneR[gl_MaxTextureCoords];uniform vec4  gl_EyePlaneQ[gl_MaxTextureCoords];uniform vec4  gl_ObjectPlaneS[gl_MaxTextureCoords];uniform vec4  gl_ObjectPlaneT[gl_MaxTextureCoords];uniform vec4  gl_ObjectPlaneR[gl_MaxTextureCoords];uniform vec4  gl_ObjectPlaneQ[gl_MaxTextureCoords
uniform uint gl_SubGroupSizeARB;flat in uint     gl_SubGroupInvocationARB;flat in uint64_t gl_SubGroupEqMaskARB;flat in uint64_t gl_SubGroupGeMaskARB;flat in uint64_t gl_SubGroupGtMaskARB;flat in uint64_t gl_SubGroupLeMaskARB;flat in uint64_t gl_SubGroupLtMaskARB;\n
uniform uint gl_SubGroupSizeARB;in uint     gl_SubGroupInvocationARB;in uint64_t gl_SubGroupEqMaskARB;in uint64_t gl_SubGroupGeMaskARB;in uint64_t gl_SubGroupGtMaskARB;in uint64_t gl_SubGroupLeMaskARB;in uint64_t gl_SubGroupLtMaskARB;\n
uniform volatile uint gl_SubGroupSizeARB;in volatile uint     gl_SubGroupInvocationARB;in volatile uint64_t gl_SubGroupEqMaskARB;in volatile uint64_t gl_SubGroupGeMaskARB;in volatile uint64_t gl_SubGroupGtMaskARB;in volatile uint64_t gl_SubGroupLeMaskARB;in volatile uint64_t gl_SubGroupLtMaskARB;\n
uniform/buffer blocks require layout(binding=X
unimplemented GLSL op
unimplemented SPV AMD gcn shader op
unimplemented SPV AMD shader ballot op
unimplemented SPV AMD shader explicit vertex parameter op
unimplemented SPV AMD shader trinary minmax op
unimplemented ext op
unimplemented op
unknown
unknown SPIR-V instruction qualifier
unknown SPIR-V requirement
unknown blend equation
unknown built-in variable
unknown glslang aggregate
unknown glslang binary operation
unknown glslang unary
unknown op
unknown operation with no arguments
unknown precision qualifier
unknown profile
unknown qualifier
unknown requalification
unknown stage
unknown swizzle selection
unknown type
unknown_depth_texture_type
unknown_texture_type
unknown_type
unordered_map::at: key not found
unpack16
unpack32
unpack8
unpackDouble2x32
unpackFloat2x16
unpackFloat2x16(floatBitsToUint
unpackHalf2x16
unpackHalf2x16(packHalf2x16
unpackHalf2x16(packHalf2x16(vec2
unpackInt2x16
unpackInt2x32
unpackInt4x16
unpackSnorm2x16
unpackSnorm4x8
unpackUint2x16
unpackUint2x32
unpackUint4x16
unpackUnorm2x16
unpackUnorm4x8
unpack_snorm2x16_to_float
unpack_snorm4x8_to_float
unpack_unorm2x16_to_float
unpack_unorm4x8_to_float
unrecognized layout identifier, or qualifier requires assignment (e.g., binding = 4
unro3K
unro3\b
unroll
unrolled
unsigned
unsigned integer
unsigned integer vector
unsigned literal
unsignedIntValue
unsized
unsized array
unsupported
unsupported construction
unsupported-built-in
unsupported-built-in-type
unsupported_GLSLstd450PackDouble2x32
unsupported_GLSLstd450UnpackDouble2x32
unsupported_gradient_dimension
unwind_info
updateFence
updateFence:afterStages
upported
usageMVK
usampler1D
usampler1DArray
usampler2D
usampler2DArray
usampler2DMS
usampler2DMSArray
usampler2DRect
usampler3D
usamplerBuffer
usamplerCube
usamplerCubeArray
use-variable-pointers
use-vulkan-memory-model
useResource:usage
useResource:usage:stages
use_storage_buffer
use_variable_pointers
use_vulkan_memory_model
used at end of comment, but this version does not provide line continuation
used at end of comment; the following line is still part of the comment
useless application of layout qualifier
user(clip
user(cull
user(locn
userInfo
ushort
ushort val
using
using ES precision qualifier keyword
using array
using early_fragment_tests\n
using future keyword
using future non-square matrix type keyword
using future reserved keyword
using future type keyword
using namespace metal
using namespace metal::raytracing
using non_coherent_color_attachment_readEXT\n
using non_coherent_depth_attachment_readEXT\n
using non_coherent_stencil_attachment_readEXT\n
using point mode\n
using post_depth_coverage\n
usiveScanNonUniformAMD(f16vec4);int16_t maxInvocationsExclusiveScanNonUniformAMD(int16_t);i16vec2 maxInvocationsExclusiveScanNonUniformAMD(i16vec2);i16vec3 maxInvocationsExclusiveScanNonUniformAMD(i16vec3);i16vec4 maxInvocationsExclusiveScanNonUniformAMD(i16vec4);uint16_t maxInvocationsExclusiveScanNonUniformAMD(uint16_t);u16vec2  maxInvocationsExclusiveScanNonUniformAMD(u16vec2);u16vec3  maxInvocationsExclusiveScanNonUniformAMD(u16vec3);u16vec4  maxInvocationsExclusiveScanNonUniformAMD(u16vec4);float addInvocationsNonUniformAMD(float);vec2  addInvocationsNonUniformAMD(vec2);vec3  addInvocationsNonUniformAMD(vec3);vec4  addInvocationsNonUniformAMD(vec4);int   addInvocationsNonUniformAMD(int);ivec2 addInvocationsNonUniformAMD(ivec2);ivec3 addInvocationsNonUniformAMD(ivec3);ivec4 addInvocationsNonUniformAMD(ivec4);uint  addInvocationsNonUniformAMD(uint);uvec2 addInvocationsNonUniformAMD(uvec2);uvec3 addInvocationsNonUniformAMD(uvec3);uvec4 addInvocationsNonUniformAMD(uvec4);double addInvocationsNonUniformAMD(double);dvec2  addInvocationsNonUniformAMD(dvec2);dvec3  addInvocationsNonUniformAMD(dvec3);dvec4  addInvocationsNonUniformAMD(dvec4);int64_t addInvocationsNonUniformAMD(int64_t);i64vec2 addInvocationsNonUniformAMD(i64vec2);i64vec3 addInvocationsNonUniformAMD(i64vec3);i64vec4 addInvocationsNonUniformAMD(i64vec4);uint64_t addInvocationsNonUniformAMD(uint64_t);u64vec2  addInvocationsNonUniformAMD(u64vec2);u64vec3  addInvocationsNonUniformAMD(u64vec3);u64vec4  addInvocationsNonUniformAMD(u64vec4);float16_t addInvocationsNonUniformAMD(float16_t);f16vec2   addInvocationsNonUniformAMD(f16vec2);f16vec3   addInvocationsNonUniformAMD(f16vec3);f16vec4   addInvocationsNonUniformAMD(f16vec4);int16_t addInvocationsNonUniformAMD(int16_t);i16vec2 addInvocationsNonUniformAMD(i16vec2);i16vec3 addInvocationsNonUniformAMD(i16vec3);i16vec4 addInvocationsNonUniformAMD(i16vec4);uint16_t addInvocationsNonUniformAMD(uint16_t);u16vec2  addInvocationsNonUniformAMD(u16vec2);u16vec3  addInvocationsNonUniformAMD(u16vec3);u16vec4  addInvocationsNonUniformAMD(u16vec4);float addInvocationsInclusiveScanNonUniformAMD(float);vec2  addInvocationsInclusiveScanNonUniformAMD(vec2);vec3  addInvocationsInclusiveScanNonUniformAMD(vec3);vec4  addInvocationsInclusiveScanNonUniformAMD(vec4);int   addInvocationsInclusiveScanNonUniformAMD(int);ivec2 addInvocationsInclusiveScanNonUniformAMD(ivec2);ivec3 addInvocationsInclusiveScanNonUniformAMD(ivec3);ivec4 addInvocationsInclusiveScanNonUniformAMD(ivec4);uint  addInvocationsInclusiveScanNonUniformAMD(uint);uvec2 addInvocationsInclusiveScanNonUniformAMD(uvec2);uvec3 addInvocationsInclusiveScanNonUniformAMD(uvec3);uvec4 addInvocationsInclusiveScanNonUniformAMD(uvec4);double addInvocationsInclusiveScanNonUniformAMD(double);dvec2  addInvocationsInclusiveScanNonUniformAMD(dvec2);dvec3  addInvocationsInclusiveScanNonUniformAMD(dvec3);dvec4  addInvocationsInclusiveScanNonUniformAMD(dvec4);int64_t addInvocationsInclusiveScanNonUniformAMD(int64_t);i64vec2 addInvocationsInclusiveScanNonUniformAMD(i64vec2);i64vec3 addInvocationsInclusiveScanNonUniformAMD(i64vec3);i64vec4 addInvocationsInclusiveScanNonUniformAMD(i64vec4);uint64_t addInvocationsInclusiveScanNonUniformAMD(uint64_t);u64vec2  addInvocationsInclusiveScanNonUniformAMD(u64vec2);u64vec3  addInvocationsInclusiveScanNonUniformAMD(u64vec3);u64vec4  addInvocationsInclusiveScanNonUniformAMD(u64vec4);float16_t addInvocationsInclusiveScanNonUniformAMD(float16_t);f16vec2   addInvocationsInclusiveScanNonUniformAMD(f16vec2);f16vec3   addInvocationsInclusiveScanNonUniformAMD(f16vec3);f16vec4   addInvocationsInclusiveScanNonUniformAMD(f16vec4);int16_t addInvocationsInclusiveScanNonUniformAMD(int16_t);i16vec2 addInvocationsInclusiveScanNonUniformAMD(i16vec2);i16vec3 addInvocationsInclusiveScanNonUniformAMD(i16vec3);i16vec4 addInvocationsInclusiveScanNonUniformAMD(i16vec4);uint16_t addInvocationsInclusiveScanNonUniformAMD(uint16_t);u16vec2  addInvocationsInclusiveScanNonUniformAMD(u16vec2);u16vec3  addInvocationsInclusiveScanNonUniformAMD(u16vec3);u16vec4  addInvocationsInclusiveScan
usr/lib/libSystem.B.dylib
usr/lib/libc++.1.dylib
usr/lib/libobjc.A.dylib
ustness
usubBorrow
usubpassInput
usubpassInputMS
utexture1D
utexture1DArray
utexture2D
utexture2DArray
utexture2DMS
utexture2DMSArray
utexture2DRect
utexture3D
utextureBuffer
utextureCube
utextureCubeArray
uvec2 clock2x32ARB();uint64_t clockARB();uvec2 clockRealtime2x32EXT();uint64_t clockRealtimeEXT();\n
uvec2 conversion to accelerationStructureEXT
uvec2 conversion to reference
uvec2 v = value.xy & gl_SubgroupLeMask.xy
uvec2 v = value.xy & gl_SubgroupLtMask.xy
uvec2(0u
uvec2(0uH
uvec2(1u
uvec2(1uH
uvec3(0u
uvec3(0uH
uvec3(1u
uvec3(1uH
uvec4  subgroupPartitionNV(%s);\n
uvec4 activeMask = subgroupBallot(true
uvec4 active_threads = subgroupBallot(true
uvec4 subgroupBallot(bool v) { return uvec4(ballotThreadNV(v), 0u, 0u, 0u
uvec4 subgroupBallot(bool v) { return uvec4(unpackUint2x32(ballotARB(v)), 0u, 0u
uvec4(0u
uvec4(0uH
uvec4(1u
uvec4(1uH
uvec4(unpackUint2x32(ballotARB
uŋH\bD
uȉỦM
v = -P.y
v = 0.5 * (v/ProjectionAxis + 1
v = P.y >= 0 ? P.z : -P.z
v"\v'\v-\v2\v7\v=\vC\vH\vM\vR\vX\v]\vb\vg\vm\vr\vw\v|\v
v(ffff
v16@0:8
v16@?0@"<MTLCommandBuffer>"8
v16@?0@"<MTLDrawable>"8
v20@0:8c16
v24@0:8@"NSString"16
v24@0:8@16
v24@0:8Q16
v24@0:8^{__CFString=}16
v24@?0@"<MTLComputePipelineState>"8@"NSError"16
v24@?0@"<MTLFunction>"8@"NSError"16
v24@?0@"<MTLLibrary>"8@"NSError"16
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v24@?0@"<MTLSharedEvent>"8Q16
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v32@0:8@"MTLStitchedLibraryDescriptor"16@?<v@?@"<MTLLibrary>"@"NSError">24
v32@0:8@16@24
v32@0:8@16@?24
v32@0:8^Q16^Q24
v32@0:8^{?=ff}16Q24
v32@?0@"<MTLComputePipelineState>"8@"MTLComputePipelineReflection"16@"NSError"24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
v40@0:8@"MTLMeshRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
v40@0:8@16@24@?32
v40@0:8@16Q24@?32
v40@?0@"NSString"8@16@"NSDictionary"24^v32
v48@0:8@16@24@32^v40
vE(t"J
vH9K\bt)E1
v\atQI
v\atYI
v\at\rH
v\b[A
v\b\t`x\b
valid = valid && (i < total
valid ? s
value
value is out of range
value must be 0 or 1
value) { return readFirstInvocationARB(value
value) { return shuffleNV(value, findLSB(ballotThreadNV(true)), gl_WarpSizeNV
value, uint id) { return readInvocationARB(value, id
value, uint id) { return shuffleNV(value, id, gl_WarpSizeNV
variable index
variable indexing buffer block array
variable indexing fragment shader output array
variable indexing sampler array
variable indexing uniform block array
variable name expected
variableH
variable_id
variable_identifier
variables with qualifier 'const' must be initialized
variables with reference type can't have qualifier 'const
varying
varying vec4  gl_Color;varying vec4  gl_SecondaryColor;varying vec4  gl_TexCoord[];varying float gl_FogFragCoord
varyings.layer = uint(attributes.a_position.w
varyings.v_position = float4(attributes.a_position.x, -attributes.a_position.y, ccIn.colors[%d].r, 1.0
vec2 gl_PointCoord
vec2 textureQueryLOD
vec2 textureQueryLod
vec2 unpackHalf2x16(highp uint);\n
vec2(0.0), vec2(0.0
vec2(0.0H
vec2(0.0f
vec2(1.0H
vec2(1.0f
vec3(0.0), vec3(0.0
vec3(0.0H
vec3(0.0f
vec3(1.0H
vec3(1.0f
vec4  gl_ClipVertex;out vec4  gl_FrontColor;out vec4  gl_BackColor;out vec4  gl_FrontSecondaryColor;out vec4  gl_BackSecondaryColor;out vec4  gl_TexCoord[];out float gl_FogFragCoord;\n
vec4  gl_ClipVertex;varying vec4  gl_FrontColor;varying vec4  gl_BackColor;varying vec4  gl_FrontSecondaryColor;varying vec4  gl_BackSecondaryColor;varying vec4  gl_TexCoord[];varying float gl_FogFragCoord;\n
vec4  gl_FragCoord;bool  gl_FrontFacing;float gl_FragDepth
vec4 colorAttachmentReadEXT(attachmentEXT);vec4 colorAttachmentReadEXT(attachmentEXT, int);ivec4 colorAttachmentReadEXT(iattachmentEXT);ivec4 colorAttachmentReadEXT(iattachmentEXT, int);uvec4 colorAttachmentReadEXT(uattachmentEXT);uvec4 colorAttachmentReadEXT(uattachmentEXT, int);\n
vec4 ftransform
vec4 gl_ClipVertex;vec4 gl_FrontColor;vec4 gl_BackColor;vec4 gl_FrontSecondaryColor;vec4 gl_BackSecondaryColor;vec4 gl_TexCoord[];float gl_FogFragCoord
vec4 gl_FragColor
vec4 gl_Position
vec4 gl_Position;float gl_PointSize
vec4 gl_SecondaryPositionNV;int  gl_SecondaryViewportMaskNV[];vec4 gl_PositionPerViewNV[];int  gl_ViewportMaskPerViewNV
vec4 imageLoad(readonly volatile coherent
vec4 imageLoadLodAMD(readonly volatile coherent
vec4 subpassLoad
vec4 texture1D(sampler1D, float);vec4 texture1DProj(sampler1D, vec2);vec4 texture1DProj(sampler1D, vec4);vec4 shadow1D(sampler1DShadow, vec3);vec4 shadow2D(sampler2DShadow, vec3);vec4 shadow1DProj(sampler1DShadow, vec4);vec4 shadow2DProj(sampler2DShadow, vec4);vec4 texture2DRect(sampler2DRect, vec2);vec4 texture2DRectProj(sampler2DRect, vec3);vec4 texture2DRectProj(sampler2DRect, vec4);vec4 shadow2DRect(sampler2DRectShadow, vec3);vec4 shadow2DRectProj(sampler2DRectShadow, vec4);\n
vec4 texture1D(sampler1D, float, float);vec4 texture1DProj(sampler1D, vec2, float);vec4 texture1DProj(sampler1D, vec4, float);vec4 shadow1D(sampler1DShadow, vec3, float);vec4 shadow2D(sampler2DShadow, vec3, float);vec4 shadow1DProj(sampler1DShadow, vec4, float);vec4 shadow2DProj(sampler2DShadow, vec4, float);\n
vec4 texture1DLod(sampler1D, float, float);vec4 texture1DProjLod(sampler1D, vec2, float);vec4 texture1DProjLod(sampler1D, vec4, float);vec4 shadow1DLod(sampler1DShadow, vec3, float);vec4 shadow2DLod(sampler2DShadow, vec3, float);vec4 shadow1DProjLod(sampler1DShadow, vec4, float);vec4 shadow2DProjLod(sampler2DShadow, vec4, float);vec4 texture1DGradARB(sampler1D, float, float, float);vec4 texture1DProjGradARB(sampler1D, vec2, float, float);vec4 texture1DProjGradARB(sampler1D, vec4, float, float);vec4 texture2DGradARB(sampler2D, vec2, vec2, vec2);vec4 texture2DProjGradARB(sampler2D, vec3, vec2, vec2);vec4 texture2DProjGradARB(sampler2D, vec4, vec2, vec2);vec4 texture3DGradARB(sampler3D, vec3, vec3, vec3);vec4 texture3DProjGradARB(sampler3D, vec4, vec3, vec3);vec4 textureCubeGradARB(samplerCube, vec3, vec3, vec3);vec4 shadow1DGradARB(sampler1DShadow, vec3, float, float);vec4 shadow1DProjGradARB( sampler1DShadow, vec4, float, float);vec4 shadow2DGradARB(sampler2DShadow, vec3, vec2, vec2);vec4 shadow2DProjGradARB( sampler2DShadow, vec4, vec2, vec2);vec4 texture2DRectGradARB(sampler2DRect, vec2, vec2, vec2);vec4 texture2DRectProjGradARB( sampler2DRect, vec3, vec2, vec2);vec4 texture2DRectProjGradARB( sampler2DRect, vec4, vec2, vec2);vec4 shadow2DRectGradARB( sampler2DRectShadow, vec3, vec2, vec2);vec4 shadow2DRectProjGradARB(sampler2DRectShadow, vec4, vec2, vec2);\n
vec4 texture2D(sampler2D, vec2);vec4 texture2DProj(sampler2D, vec3);vec4 texture2DProj(sampler2D, vec4);vec4 texture3D(sampler3D, vec3);vec4 texture3DProj(sampler3D, vec4);vec4 textureCube(samplerCube, vec3);\n
vec4 texture2D(sampler2D, vec2, float);vec4 texture2DProj(sampler2D, vec3, float);vec4 texture2DProj(sampler2D, vec4, float);vec4 texture3D(sampler3D, vec3, float);vec4 texture3DProj(sampler3D, vec4, float);vec4 textureCube(samplerCube, vec3, float);\n
vec4 texture2D(samplerExternalOES, vec2 coord);vec4 texture2DProj(samplerExternalOES, vec3);vec4 texture2DProj(samplerExternalOES, vec4);\n
vec4 texture2DGradEXT(sampler2D, vec2, vec2, vec2);vec4 texture2DProjGradEXT(sampler2D, vec3, vec2, vec2);vec4 texture2DProjGradEXT(sampler2D, vec4, vec2, vec2);vec4 textureCubeGradEXT(samplerCube, vec3, vec3, vec3);float shadow2DEXT(sampler2DShadow, vec3);float shadow2DProjEXT(sampler2DShadow, vec4);\n
vec4 texture2DLod(sampler2D, vec2, float);vec4 texture2DProjLod(sampler2D, vec3, float);vec4 texture2DProjLod(sampler2D, vec4, float);vec4 texture3DLod(sampler3D, vec3, float);vec4 texture3DProjLod(sampler3D, vec4, float);vec4 textureCubeLod(samplerCube, vec3, float);\n
vec4 texture2DLodEXT(sampler2D, vec2, float);vec4 texture2DProjLodEXT(sampler2D, vec3, float);vec4 texture2DProjLodEXT(sampler2D, vec4, float);vec4 textureCubeLodEXT(samplerCube, vec3, float);\n
vec4 unpackSnorm4x8(highp uint);vec4 unpackUnorm4x8(highp uint);\n
vec4(0.0H
vec4(0.0f
vec4(1.0H
vec4(1.0f
vec4);\n
vec<T, 4> do_sample(float2 coord, LodOptions... options) const thread
vec<T, 4> gather(float2 coord, int2 offset = int2(0), component c = component::x) const thread
vec<T, 4> read(uint2 coord, uint lod = 0) const thread
vec<T, 4> rgba
vec<T, 4> s = spvTextureSwizzle(do_sample(coord, spvForward<LodOptions>(options)...), swizzle
vec<T, 4> sample(float2 coord, LodOptions... options) const thread
vec<T, 4> sample(float2 coord, bias b, min_lod_clamp min_lod, int2 offset) const thread
vec<T, 4> sample(float2 coord, gradient2d grad, min_lod_clamp min_lod, int2 offset) const thread
vec<T, 4> sample(float2 coord, int2 offset) const thread
vec<T, 4> sample(float2 coord, lod_options options, int2 offset) const thread
vec<T, 4> ycbcr = vec<T, 4>(0, 0, 0, 1
vec<T, Cols> res = vec<T, Cols>(0
vec<T, Cols> tmp(0
vec<T, RCols> tmp(0
vec<T, Rows> columns[Cols
vec<T, Rows> operator[](size_t idx) const
vec<T, Rows> res = vec<T, Rows>(0
vec<T, Rows>& operator[](size_t idx
vector
vector index out of range '%d
vector scale second child into first child
vector swizzle
vector swizzle selection out of range
vector swizzle selectors not from the same set
vector swizzle too long
vector-scale
vector-times-matrix
vendor-id
ventƅL
version
version <= 420
version not supported
version: Desktop shaders for OpenGL SPIR-V require version 330 or higher
version: Desktop shaders for Vulkan SPIR-V require version 140 or higher
version: ES shaders for SPIR-V require version 310 or higher
version: compilation for SPIR-V does not support the compatibility profile
version: compute shaders require es profile with version 310 or above, or non-es profile with version 420 or above
version: geometry shaders require es profile with version 310 or non-es profile with version 150 or above
version: mesh/task shaders require es profile with version 320 or above, or non-es profile with version 450 or above
version: only version 300, 310, and 320 support the es profile
version: ray tracing shaders require non-es profile with version 460 or above
version: statement must appear first in es-profile shader; before comments or newlines
version: tessellation shaders require es profile with version 310 or non-es profile with version 150 or above
version: versions 300, 310, and 320 require specifying the 'es' profile
version: versions 300, 310, and 320 support only the es profile
version: versions before 150 do not allow a profile token
versus
vertClear
vertex
vertex VaryingsPos %@(AttributesPos attributes [[stage_in]], constant ClearColorsIn& ccIn [[buffer(0
vertex index
vertex input arrays
vertex input cannot be further qualified
vertex output block
vertex spacing
vertex-shader `double` type
vertex-shader `double` type input
vertex-shader array-of-array output
vertex-shader array-of-struct output
vertex-shader struct output
vertex-shader struct output containing an array
vertex-shader struct output containing structure
vertexDescriptor
vertex_i
vertex_id
vertices
verticesH
vhp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXphp\bpXp\bpXp\bp\bpHp\bp\bpHp\bpXp\bpXp\bpXp\bp\bpHp\bp\bpHphphp\bpXp\bpXphphp\bpXphp\bpXp\bpXp\bpXphp\bp\bpHp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bpXp\bp\bpHp\bp\bpHp\bp\bpHp\bp\bpHp\bpXphphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXphp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpXp\bpX
view port array2
view range
viewport_array_index
viewport_relative
vkAcquireNextImage2KHR
vkAcquireNextImageKHR
vkAcquireNextImageKHR CommandBuffer
vkAllocateCommandBuffers
vkAllocateDescriptorSets
vkAllocateMemory
vkAllocateMemory(): Could not allocate VkDeviceMemory of size %llu bytes
vkAllocateMemory(): Could not allocate a host-coherent VkDeviceMemory of size %llu bytes. The maximum memory-aligned size of a host-coherent VkDeviceMemory is %llu bytes
vkAllocateMemory(): Could not allocate a host-coherent or exportable VkDeviceMemory of size %llu bytes. The maximum memory-aligned size of a host-coherent VkDeviceMemory is %llu bytes
vkAllocateMemory(): External memory requires a dedicated VkBuffer or VkImage
vkAllocateMemory(): Host-coherent VkDeviceMemory objects cannot be associated with optimal-tiling images
vkAllocateMemory(): Imported memory must be host-visible
vkAllocateMemory(): Only external memory handle types VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_KHR or VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR are supported
vkBeginCommandBuffer
vkBindBufferMemory
vkBindBufferMemory2
vkBindBufferMemory2KHR
vkBindImageMemory
vkBindImageMemory2
vkBindImageMemory2KHR
vkCmdBegH
vkCmdBeginDebugUtilsLabelEXT
vkCmdBeginQuery
vkCmdBeginQuery(): The maximum number of queries in a single Vulkan command submission is %llu
vkCmdBeginQuery(): The query offset value %lu is larger than the maximum offset value %lu available on this device
vkCmdBeginRenderPass
vkCmdBeginRenderPass RenderEncoder
vkCmdBeginRenderPass2
vkCmdBeginRenderPass2KHR
vkCmdBeginRendering
vkCmdBeginRendering RenderEncoder
vkCmdBeginRenderingKHR
vkCmdBindDescriptorSets
vkCmdBindIndexBuffer
vkCmdBindPipeline
vkCmdBindVertexBuffers
vkCmdBindVertexBuffers2
vkCmdBindVertexBuffers2EXT
vkCmdBliH
vkCmdBliL
vkCmdBlitImage
vkCmdBlitImage RenderEncoder
vkCmdBlitImage(): Scaling or inverting to a linear destination image is not supported
vkCmdBlitImage2
vkCmdBlitImage2KHR
vkCmdClear%sImage(): Format %s cannot be cleared on this device
vkCmdClear%sImage(): Native 1D images cannot be cleared on this device. Consider enabling MVK_CONFIG_TEXTURE_1D_AS_2D
vkCmdClearAttachments
vkCmdClearColorImage
vkCmdClearColorImage ComputeEncoder
vkCmdClearColorImage RenderEncoder
vkCmdClearDepthStencilImage
vkCmdClearDepthStencilImage RenderEncoder
vkCmdCopH
vkCmdCopyBuffer
vkCmdCopyBuffer BlitEncoder
vkCmdCopyBuffer ComputeEncoder
vkCmdCopyBuffer2
vkCmdCopyBuffer2KHR
vkCmdCopyBufferToImage
vkCmdCopyBufferToImage BlitEncoder
vkCmdCopyBufferToImage ComputeEncoder
vkCmdCopyBufferToImage2
vkCmdCopyBufferToImage2KHR
vkCmdCopyImage
vkCmdCopyImage BlitEncoder
vkCmdCopyImage(): Cannot copy between incompatible formats, such as formats of different pixel sizes, or between images with different sample counts
vkCmdCopyImage2
vkCmdCopyImage2KHR
vkCmdCopyImageToBuffer
vkCmdCopyImageToBuffer BlitEncoder
vkCmdCopyImageToBuffer ComputeEncoder
vkCmdCopyImageToBuffer2
vkCmdCopyImageToBuffer2KHR
vkCmdCopyQueryPoolResults
vkCmdCopyQueryPoolResults BlitEncoder
vkCmdCopyQueryPoolResults ComputeEncoder
vkCmdDebugMarkerBeginEXT
vkCmdDebugMarkerEndEXT
vkCmdDebugMarkerInsertEXT
vkCmdDisH
vkCmdDispatch
vkCmdDispatch ComputeEncoder
vkCmdDispatchBase
vkCmdDispatchBaseKHR
vkCmdDispatchIndirect
vkCmdDraH
vkCmdDraw
vkCmdDraw (convert indirect buffers) ComputeEncoder
vkCmdDraw (vertex and tess control stages) ComputeEncoder
vkCmdDraw(): The current device does not support drawing with a non-zero base instance
vkCmdDrawIndexed
vkCmdDrawIndexed(): The current device does not support drawing with a non-zero base instance
vkCmdDrawIndexed(): The current device does not support drawing with a non-zero base vertex
vkCmdDrawIndexedIndirect
vkCmdDrawIndexedIndirect(): The current device does not support indirect drawing
vkCmdDrawIndexedIndirect(): The current device does not support indirect tessellated drawing
vkCmdDrawIndexedIndirectCount
vkCmdDrawIndexedIndirectCountAMD
vkCmdDrawIndexedIndirectCountKHR
vkCmdDrawIndirect
vkCmdDrawIndirect(): The current device does not support indirect drawing
vkCmdDrawIndirect(): The current device does not support indirect tessellated drawing
vkCmdDrawIndirectCount
vkCmdDrawIndirectCountAMD
vkCmdDrawIndirectCountKHR
vkCmdEndDebugUtilsLabelEXT
vkCmdEndH
vkCmdEndQuery
vkCmdEndRenderPass
vkCmdEndRenderPass2
vkCmdEndRenderPass2KHR
vkCmdEndRendering
vkCmdEndRenderingKHR
vkCmdExecuteCommands
vkCmdFilH
vkCmdFillBuffer
vkCmdFillBuffer BlitEncoder
vkCmdFillBuffer ComputeEncoder
vkCmdFillBuffer(): Buffer fill size must fit into a 32-bit unsigned integer. Fill size %llu is too large
vkCmdInsertDebugUtilsLabelEXT
vkCmdNextSubpass
vkCmdNextSubpass RenderEncoder
vkCmdNextSubpass2
vkCmdNextSubpass2KHR
vkCmdPipelineBarrier
vkCmdPipelineBarrier BlitEncoder
vkCmdPipelineBarrier2
vkCmdPipelineBarrier2KHR
vkCmdPushConstants
vkCmdPushDescriptorSet/vkCmdPushDescriptorSetWithTemplate(): Tried to push an immutable sampler
vkCmdPushDescriptorSetKHR
vkCmdPushDescriptorSetWithTemplateKHR
vkCmdResH
vkCmdResetEvent
vkCmdResetEvent2
vkCmdResetEvent2KHR
vkCmdResetQueryPool
vkCmdResetQueryPool BlitEncoder
vkCmdResolveImage
vkCmdResolveImage (copy stage) RenderEncoder
vkCmdResolveImage (expand stage) RenderEncoder
vkCmdResolveImage (resolve stage) RenderEncoder
vkCmdResolveImage(): %s cannot be used as a resolve destination on this device
vkCmdResolveImage2
vkCmdResolveImage2KHR
vkCmdSetBlendConstants
vkCmdSetCullMode
vkCmdSetCullModeEXT
vkCmdSetDepthBias
vkCmdSetDepthBiasEnable
vkCmdSetDepthBiasEnableEXT
vkCmdSetDepthBounds
vkCmdSetDepthBounds(): The current device does not support setting depth bounds
vkCmdSetDepthBoundsTestEnable
vkCmdSetDepthBoundsTestEnableEXT
vkCmdSetDepthCompareOp
vkCmdSetDepthCompareOpEXT
vkCmdSetDepthTestEnable
vkCmdSetDepthTestEnableEXT
vkCmdSetDepthWriteEnable
vkCmdSetDepthWriteEnableEXT
vkCmdSetDeviceMask
vkCmdSetDeviceMaskKHR
vkCmdSetEvent
vkCmdSetEvent2
vkCmdSetEvent2KHR
vkCmdSetFrontFace
vkCmdSetFrontFaceEXT
vkCmdSetH
vkCmdSetL
vkCmdSetLineWidth
vkCmdSetLineWidth(): The current device does not support wide lines
vkCmdSetPrimitiveRestartEnable
vkCmdSetPrimitiveRestartEnableEXT
vkCmdSetPrimitiveTopology
vkCmdSetPrimitiveTopologyEXT
vkCmdSetRasterizerDiscardEnable
vkCmdSetRasterizerDiscardEnableEXT
vkCmdSetSampleLocationsEXT
vkCmdSetScissor
vkCmdSetScissorWithCount
vkCmdSetScissorWithCountEXT
vkCmdSetStencilCompareMask
vkCmdSetStencilOp
vkCmdSetStencilOpEXT
vkCmdSetStencilReference
vkCmdSetStencilTestEnable
vkCmdSetStencilTestEnableEXT
vkCmdSetStencilWriteMask
vkCmdSetViewport
vkCmdSetViewportWithCount
vkCmdSetViewportWithCountEXT
vkCmdUpdateBuffer
vkCmdUpdateBuffer BlitEncoder
vkCmdWaiH
vkCmdWaitEvents
vkCmdWaitEvents2
vkCmdWaitEvents2KHR
vkCmdWriteTimestamp
vkCmdWriteTimestamp2
vkCmdWriteTimestamp2KHR
vkCreateBuffer
vkCreateBuffer(): Only external memory handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_KHR is supported
vkCreateBufferView
vkCreateCommandPool
vkCreateComputePipelines
vkCreateDebugReportCallbackEXT
vkCreateDebugUtilsMessengerEXT
vkCreateDeferredOperationKHR
vkCreateDescriptorPool
vkCreateDescriptorPool(): The requested descriptor storage of %d MB is larger than the maximum descriptor storage of %d MB per VkDescriptorPool
vkCreateDescriptorSetLayout
vkCreateDescriptorUpdateTemplate
vkCreateDescriptorUpdateTemplateKHR
vkCreateDevice
vkCreateDevice(): Requested physical device feature specified by the %zu%s flag in %s is not available on this device
vkCreateEvent
vkCreateEvent(): MTLSharedEvent is not available on this platform
vkCreateEvent(): MTLSharedEvent is not available with VkSemaphores that use CPU emulation
vkCreateEvent(): MTLSharedEvent is not available with VkSemaphores that use implicit synchronization
vkCreateFence
vkCreateFramebuffer
vkCreateGraphicsPipelines
vkCreateH
vkCreateImage
vkCreateImage() : Chroma-subsampled formats may only have one array layer
vkCreateImage() : If tiling is VK_IMAGE_TILING_LINEAR, arrayLayers must be 1
vkCreateImage() : If tiling is VK_IMAGE_TILING_LINEAR, format must not be a compressed format
vkCreateImage() : If tiling is VK_IMAGE_TILING_LINEAR, format must not be a depth/stencil format
vkCreateImage() : If tiling is VK_IMAGE_TILING_LINEAR, format must not be a single-plane chroma subsampled format
vkCreateImage() : If tiling is VK_IMAGE_TILING_LINEAR, imageType must be VK_IMAGE_TYPE_2D
vkCreateImage() : If tiling is VK_IMAGE_TILING_LINEAR, mipLevels must be 1
vkCreateImage() : If tiling is VK_IMAGE_TILING_LINEAR, samples must be VK_SAMPLE_COUNT_1_BIT
vkCreateImage() : Metal does not allow uncompressed views of compressed images
vkCreateImage() : Metal does not support rendering to native 1D attachments. Consider enabling MVK_CONFIG_TEXTURE_1D_AS_2D
vkCreateImage() : Metal does not support split-instance memory binding
vkCreateImage() : This device does not support multisampled array textures. Setting sample count to 1
vkCreateImage() : This device does not support rendering to linear (VK_IMAGE_TILING_LINEAR) images
vkCreateImage() : Under Metal, GBGR and BGRG images cannot use mipmaps. Setting mip levels to 1
vkCreateImage() : Under Metal, chroma subsampled formats may not be used with cube images
vkCreateImage() : Under Metal, chroma subsampled formats may only be used with 2D images
vkCreateImage() : Under Metal, depth/stencil formats may only be used with 2D images
vkCreateImage() : Under Metal, multisampling can only be used with a 2D image type. Setting sample count to 1
vkCreateImage() : Under Metal, multisampling cannot be used with chroma subsampled images. Setting sample count to 1
vkCreateImage() : Under Metal, multisampling cannot be used with compressed images. Setting sample count to 1
vkCreateImage() : Under Metal, native 1D images cannot use mipmaps. Setting mip levels to 1. Consider enabling MVK_CONFIG_TEXTURE_1D_AS_2D
vkCreateImage(): Only external memory handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_KHR is supported
vkCreateImageView
vkCreateImageView() : Image view swizzling for multi planar formats is not supported
vkCreateImageView() : This device does not support rendering to array (layered) attachments
vkCreateImageView() : This device does not support rendering to multisampled array (layered) attachments
vkCreateImageView(): 2D views on 3D images can only be used as color attachments
vkCreateImageView(VkImageViewCreateInfo
vkCreateInstance
vkCreateL
vkCreateMacOSSurfaceMVK
vkCreateMetalSurfaceEXT
vkCreatePipelineCache
vkCreatePipelineLayout
vkCreatePrivateDataSlot
vkCreatePrivateDataSlotEXT
vkCreateQueryPool
vkCreateQueryPool(): A maximum of %d total queries are available on this device in its current configuration. See the API notes for the MVKConfiguration.supportLargeQueryPools configuration parameter for more info
vkCreateQueryPool(): Each occlusion query pool can support a maximum of %d queries
vkCreateQueryPool: Unsupported query pool type: %d
vkCreateQueryPool: VK_QUERY_TYPE_PIPELINE_STATISTICS is not supported
vkCreateRenderPass
vkCreateRenderPass(): Attachment format %s is not supported on this device
vkCreateRenderPass(): Attachment format %s on this device does not support the VkFormat attachment capabilities required by the subpass at index %d
vkCreateRenderPass2
vkCreateRenderPass2KHR
vkCreateSampler
vkCreateSamplerYcbcrConversion
vkCreateSamplerYcbcrConversionKHR
vkCreateSemaphore
vkCreateShaderModule
vkCreateShaderModule(): Shader module contains no shader code
vkCreateShaderModule(): The SPIR-V contains an invalid magic number %x
vkCreateSwapchainKHR
vkCreateSwapchainKHR(): Metal does not support VkColorSpaceKHR value %d
vkDebugMarkerSetObjectNameEXT
vkDebugMarkerSetObjectTagEXT
vkDebugReportMessageEXT
vkDeferredOperationJoinKHR
vkDestroL
vkDestroyBuffer
vkDestroyBufferView
vkDestroyCommandPool
vkDestroyDebugReportCallbackEXT
vkDestroyDebugUtilsMessengerEXT
vkDestroyDeferredOperationKHR
vkDestroyDescriptorPool
vkDestroyDescriptorSetLayout
vkDestroyDescriptorUpdateTemplate
vkDestroyDescriptorUpdateTemplateKHR
vkDestroyDevice
vkDestroyEvent
vkDestroyFence
vkDestroyFramebuffer
vkDestroyImage
vkDestroyImageView
vkDestroyInstance
vkDestroyPipeline
vkDestroyPipelineCache
vkDestroyPipelineLayout
vkDestroyPrivateDataSlot
vkDestroyPrivateDataSlotEXT
vkDestroyQueryPool
vkDestroyRenderPass
vkDestroySampler
vkDestroySamplerYcbcrConversion
vkDestroySamplerYcbcrConversionKHR
vkDestroySemaphore
vkDestroyShaderModule
vkDestroySurfaceKHR
vkDestroySwapchainKHR
vkDeviceWaitIdle
vkDeviceWaitIdle CommandBuffer
vkEndCommandBuffer
vkEndCommandBuffer (Prefilled) CommandBuffer
vkEnumerateDeviceExtensionProperties
vkEnumerateDeviceLayerProperties
vkEnumerateInstanceExtensionProperties
vkEnumerateInstanceLayerProperties
vkEnumerateInstanceVersion
vkEnumeratePhysicalDeviceGroups
vkEnumeratePhysicalDeviceGroupsKHR
vkEnumeratePhysicalDevices
vkExportMetalObjectsEXT
vkFlushMappedMemoryRanges
vkFreeCommandBuffers
vkFreeDescriptorSets
vkFreeMeH
vkFreeMemory
vkGetBufferDeviceAddress
vkGetBufferDeviceAddressEXT
vkGetBufferDeviceAddressKHR
vkGetBufferMemoryRequirements
vkGetBufferMemoryRequirements2
vkGetBufferMemoryRequirements2KHR
vkGetBufferOpaqueCaptureAddress
vkGetBufferOpaqueCaptureAddressKHR
vkGetCalibratedTimestampsEXT
vkGetDeferredOperationMaxConcurrencyKHR
vkGetDeferredOperationResultKHR
vkGetDescriptorSetLayoutSupport
vkGetDescriptorSetLayoutSupportKHR
vkGetDeviceBufferMemoryRequirements
vkGetDeviceBufferMemoryRequirementsKHR
vkGetDeviceGroupPeerMemoryFeatures
vkGetDeviceGroupPeerMemoryFeaturesKHR
vkGetDeviceGroupPresentCapabilitiesKHR
vkGetDeviceGroupSurfacePresentModesKHR
vkGetDeviceImageMemoryRequirements
vkGetDeviceImageMemoryRequirementsKHR
vkGetDeviceImageSparseMemoryRequirements
vkGetDeviceImageSparseMemoryRequirementsKHR
vkGetDeviceMemoryCommitment
vkGetDeviceMemoryOpaqueCaptureAddress
vkGetDeviceMemoryOpaqueCaptureAddressKHR
vkGetDeviceProcAddr
vkGetDeviceQueue
vkGetDeviceQueue2
vkGetEventStatus
vkGetFenceStatus
vkGetIOSurfaceMVK
vkGetImageMemoryRequirements
vkGetImageMemoryRequirements2
vkGetImageMemoryRequirements2KHR
vkGetImageSparseMemoryRequirements
vkGetImageSparseMemoryRequirements2
vkGetImageSparseMemoryRequirements2KHR
vkGetImageSubresourceLayout
vkGetInstanceProcAddr
vkGetMTLBufferMVK
vkGetMTLCommandQueueMVK
vkGetMTLDeviceMVK
vkGetMTLTextureMVK
vkGetMemoryHostPointerPropertiesEXT
vkGetMoltenVKConfigurationMVK
vkGetPastPresentationTimingGOOGLE
vkGetPerformanceStatisticsMVK
vkGetPhysicalDeviceCalibrateableTimeDomainsEXT
vkGetPhysicalDeviceExternalBufferProperties
vkGetPhysicalDeviceExternalBufferPropertiesKHR
vkGetPhysicalDeviceExternalFenceProperties
vkGetPhysicalDeviceExternalFencePropertiesKHR
vkGetPhysicalDeviceExternalSemaphoreProperties
vkGetPhysicalDeviceExternalSemaphorePropertiesKHR
vkGetPhysicalDeviceFeatures
vkGetPhysicalDeviceFeatures2
vkGetPhysicalDeviceFeatures2KHR
vkGetPhysicalDeviceFormatProperties
vkGetPhysicalDeviceFormatProperties2
vkGetPhysicalDeviceFormatProperties2KHR
vkGetPhysicalDeviceImageFormatProperties
vkGetPhysicalDeviceImageFormatProperties2
vkGetPhysicalDeviceImageFormatProperties2KHR
vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDeviceImageViewSupportEXTX
vkGetPhysicalDeviceMemoryProperties
vkGetPhysicalDeviceMemoryProperties2
vkGetPhysicalDeviceMemoryProperties2KHR
vkGetPhysicalDeviceMetalFeaturesMVK
vkGetPhysicalDeviceMultisamplePropertiesEXT
vkGetPhysicalDevicePresentRectanglesKHR
vkGetPhysicalDeviceProperties
vkGetPhysicalDeviceProperties2
vkGetPhysicalDeviceProperties2KHR
vkGetPhysicalDeviceQueueFamilyProperties
vkGetPhysicalDeviceQueueFamilyProperties2
vkGetPhysicalDeviceQueueFamilyProperties2KHR
vkGetPhysicalDeviceSparseImageFormatProperties
vkGetPhysicalDeviceSparseImageFormatProperties2
vkGetPhysicalDeviceSparseImageFormatProperties2KHR
vkGetPhysicalDeviceSurfaceCapabilities2KHR
vkGetPhysicalDeviceSurfaceCapabilitiesKHR
vkGetPhysicalDeviceSurfaceFormats2KHR
vkGetPhysicalDeviceSurfaceFormatsKHR
vkGetPhysicalDeviceSurfacePresentModesKHR
vkGetPhysicalDeviceSurfaceSupportKHR
vkGetPhysicalDeviceToolProperties
vkGetPhysicalDeviceToolPropertiesKHR
vkGetPipelineCacheData
vkGetPrivateData
vkGetPrivateDataEXT
vkGetQueryPoolResults
vkGetRefreshCycleDurationGOOGLE
vkGetRenderAreaGranularity
vkGetSemaphoreCounterValue
vkGetSemaphoreCounterValueKHR
vkGetSwapchainImagesKHR
vkGetVersionStringsMVK
vkInvalidateMappedMemoryRanges
vkInvalidateMappedMemoryRanges CommandBuffer
vkMapMemH
vkMapMemL
vkMapMemory
vkMapMemory2KHR
vkMergePipelineCaches
vkQueueBeginDebugUtilsLabelEXT
vkQueueBindSparse
vkQueueBindSparse(): Sparse binding is not supported
vkQueueEndDebugUtilsLabelEXT
vkQueueInsertDebugUtilsLabelEXT
vkQueuePresentKHR
vkQueuePresentKHR CommandBuffer
vkQueueSH
vkQueueSL
vkQueueSubmit
vkQueueSubmit CommandBuffer
vkQueueSubmit2
vkQueueSubmit2KHR
vkQueueWH
vkQueueWaitIdle
vkQueueWaitIdle CommandBuffer
vkReleaseSwapchainImagesEXT
vkResetCommandBuffer
vkResetCommandPool
vkResetDescriptorPool
vkResetEH
vkResetEvent
vkResetFH
vkResetFences
vkResetQueryPool
vkResetQueryPoolEXT
vkSetDebugUtilsObjectNameEXT
vkSetDebugUtilsObjectTagEXT
vkSetEveH
vkSetEvent
vkSetHdrMetadataEXT
vkSetMTLTextureMVK
vkSetMoltenVKConfigurationMVK
vkSetPrivateData
vkSetPrivateDataEXT
vkSetWorkgroupSizeMVK
vkSignalSemaphore
vkSignalSemaphoreKHR
vkSubmitDebugUtilsMessageEXT
vkTrimCommandPool
vkTrimCommandPoolKHR
vkUnmapMH
vkUnmapMemory
vkUnmapMemory2KHR
vkUpdateDescriptorSetWithTemplate
vkUpdateDescriptorSetWithTemplateKHR
vkUpdateDescriptorSets
vkUpdateDescriptorSets(): Tried to push an immutable sampler
vkUseIOSurfaceMVK
vkUseIOSurfaceMVK() : IOSurface bytes per element %zu does not match VkImage bytes per element %d
vkUseIOSurfaceMVK() : IOSurface bytes per element %zu of plane %d does not match VkImage bytes per element %d
vkUseIOSurfaceMVK() : IOSurface element height %zu does not match VkImage element height %d
vkUseIOSurfaceMVK() : IOSurface element height %zu of plane %d does not match VkImage element height %d
vkUseIOSurfaceMVK() : IOSurface element width %zu does not match VkImage element width %d
vkUseIOSurfaceMVK() : IOSurface element width %zu of plane %d does not match VkImage element width %d
vkUseIOSurfaceMVK() : IOSurface height %zu does not match VkImage height %d
vkUseIOSurfaceMVK() : IOSurface height %zu of plane %d does not match VkImage height %d
vkUseIOSurfaceMVK() : IOSurface plane count %zu does not match VkImage plane count %lu
vkUseIOSurfaceMVK() : IOSurface width %zu does not match VkImage width %d
vkUseIOSurfaceMVK() : IOSurface width %zu of plane %d does not match VkImage width %d
vkUseIOSurfaceMVK() : IOSurfaces are not supported on this platform
vkWaitFoH
vkWaitForFences
vkWaitSemaphores
vkWaitSemaphoresKHR
vk_icdGetInstanceProcAddr
vk_icdGetPhysicalDeviceProcAddr
vk_icdNegotiateLoaderICDInterfaceVersion
vload_half
vload_halfn
vloada_halfn
vloadn
void EmitMeshTasksEXT(uint, uint, uint);\n
void EmitStreamVertex(int);void EndStreamPrimitive(int
void EmitVertex();void EndPrimitive();\n
void SetMeshOutputsEXT(uint, uint);\n
void barrier
void beginInvocationInterlockARB(void);void endInvocationInterlockARB(void
void controlBarrier(int, int, int, int);\nvoid memoryBarrier(int, int, int);\n
void coopMatLoad(out coopmat m, volatile coherent int8_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent int16_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent int32_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent int64_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent uint8_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent uint16_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent uint32_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent uint64_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent float16_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent float[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent float64_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent i8vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent i16vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent i32vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent i64vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent u8vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent u16vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent u32vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent u64vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent f16vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent f32vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent f64vec2[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent i8vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent i16vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent i32vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent i64vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent u8vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent u16vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent u32vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent u64vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent f16vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent f32vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatLoad(out coopmat m, volatile coherent f64vec4[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent int8_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent int16_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent int32_t[] buf, uint element, uint stride, int matrixLayout);\nvoid coopMatStore(coopmat m, volatile coherent int64_t[] buf, uint element
void coopMatLoadNV(out fcoopmatNV m, volatile coherent float16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent float[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent float16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent float[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent float64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nfcoopmatNV coopMatMulAddNV(fcoopmatNV A, fcoopmatNV B, fcoopmatNV C);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent int8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent int16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent int[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent int64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent ivec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent ivec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent int8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent int16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent int[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent int64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent ivec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent ivec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stri
void debugPrintfEXT();\n
void executeCallableNV(uint, int);void executeCallableEXT(uint, int);\n
void function cannot return a value
void ignoreIntersectionNV();void terminateRayNV();\n
void imageAtomicStore(volatile coherent
void imageAtomicStore(writeonly volatile coherent
void imageStore(writeonly volatile coherent
void imageStoreLodAMD(writeonly volatile coherent
void main
void memoryBarrier
void memoryBarrierAtomicCounter
void memoryBarrierBuffer
void memoryBarrierImage
void memoryBarrierShared();void groupMemoryBarrier
void rayQueryInitializeEXT(rayQueryEXT, accelerationStructureEXT, uint, uint, vec3, float, vec3, float);void rayQueryTerminateEXT(rayQueryEXT);void rayQueryGenerateIntersectionEXT(rayQueryEXT, float);void rayQueryConfirmIntersectionEXT(rayQueryEXT);bool rayQueryProceedEXT(rayQueryEXT);uint rayQueryGetIntersectionTypeEXT(rayQueryEXT, bool);float rayQueryGetRayTMinEXT(rayQueryEXT);uint rayQueryGetRayFlagsEXT(rayQueryEXT);vec3 rayQueryGetWorldRayOriginEXT(rayQueryEXT);vec3 rayQueryGetWorldRayDirectionEXT(rayQueryEXT);float rayQueryGetIntersectionTEXT(rayQueryEXT, bool);int rayQueryGetIntersectionInstanceCustomIndexEXT(rayQueryEXT, bool);int rayQueryGetIntersectionInstanceIdEXT(rayQueryEXT, bool);uint rayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetEXT(rayQueryEXT, bool);int rayQueryGetIntersectionGeometryIndexEXT(rayQueryEXT, bool);int rayQueryGetIntersectionPrimitiveIndexEXT(rayQueryEXT, bool);vec2 rayQueryGetIntersectionBarycentricsEXT(rayQueryEXT, bool);bool rayQueryGetIntersectionFrontFaceEXT(rayQueryEXT, bool);bool rayQueryGetIntersectionCandidateAABBOpaqueEXT(rayQueryEXT);vec3 rayQueryGetIntersectionObjectRayDirectionEXT(rayQueryEXT, bool);vec3 rayQueryGetIntersectionObjectRayOriginEXT(rayQueryEXT, bool);mat4x3 rayQueryGetIntersectionObjectToWorldEXT(rayQueryEXT, bool);mat4x3 rayQueryGetIntersectionWorldToObjectEXT(rayQueryEXT, bool);void rayQueryGetIntersectionTriangleVertexPositionsEXT(rayQueryEXT, bool, out vec3[3]);\n
void subgroupBarrier() { memoryBarrierShared
void subgroupBarrier();void subgroupMemoryBarrier();void subgroupMemoryBarrierBuffer();void subgroupMemoryBarrierImage();bool subgroupElect();bool   subgroupAll(bool);\nbool   subgroupAny(bool);\nuvec4  subgroupBallot(bool);\nbool   subgroupInverseBallot(uvec4);\nbool   subgroupBallotBitExtract(uvec4, uint);\nuint   subgroupBallotBitCount(uvec4);\nuint   subgroupBallotInclusiveBitCount(uvec4);\nuint   subgroupBallotExclusiveBitCount(uvec4);\nuint   subgroupBallotFindLSB(uvec4);\nuint   subgroupBallotFindMSB(uvec4);\n
void subgroupMemoryBarrier() { groupMemoryBarrier
void subgroupMemoryBarrier() { memoryBarrier
void subgroupMemoryBarrierBuffer() { groupMemoryBarrier
void subgroupMemoryBarrierBuffer() { memoryBarrierBuffer
void subgroupMemoryBarrierImage() { groupMemoryBarrier
void subgroupMemoryBarrierImage() { memoryBarrierImage
void subgroupMemoryBarrierShared() { memoryBarrierShared
void subgroupMemoryBarrierShared();\n
void traceNV(accelerationStructureNV,uint,uint,uint,uint,uint,vec3,float,vec3,float,int);void traceRayMotionNV(accelerationStructureNV,uint,uint,uint,uint,uint,vec3,float,vec3,float,float,int);void traceRayEXT(accelerationStructureEXT,uint,uint,uint,uint,uint,vec3,float,vec3,float,int);void executeCallableNV(uint, int);void executeCallableEXT(uint, int);void hitObjectTraceRayNV(hitObjectNV,accelerationStructureEXT,uint,uint,uint,uint,uint,vec3,float,vec3,float,int);void hitObjectTraceRayMotionNV(hitObjectNV,accelerationStructureEXT,uint,uint,uint,uint,uint,vec3,float,vec3,float,float,int);void hitObjectRecordHitNV(hitObjectNV,accelerationStructureEXT,int,int,int,uint,uint,uint,vec3,float,vec3,float,int);void hitObjectRecordHitMotionNV(hitObjectNV,accelerationStructureEXT,int,int,int,uint,uint,uint,vec3,float,vec3,float,float,int);void hitObjectRecordHitWithIndexNV(hitObjectNV, accelerationStructureEXT,int,int,int,uint,uint,vec3,float,vec3,float,int);void hitObjectRecordHitWithIndexMotionNV(hitObjectNV, accelerationStructureEXT,int,int,int,uint,uint,vec3,float,vec3,float,float,int);void hitObjectRecordMissNV(hitObjectNV,uint,vec3,float,vec3,float);void hitObjectRecordMissMotionNV(hitObjectNV,uint,vec3,float,vec3,float,float);void hitObjectRecordEmptyNV(hitObjectNV);void hitObjectExecuteShaderNV(hitObjectNV,int);bool hitObjectIsEmptyNV(hitObjectNV);bool hitObjectIsMissNV(hitObjectNV);bool hitObjectIsHitNV(hitObjectNV);float hitObjectGetRayTMinNV(hitObjectNV);float hitObjectGetRayTMaxNV(hitObjectNV);vec3 hitObjectGetWorldRayOriginNV(hitObjectNV);vec3 hitObjectGetWorldRayDirectionNV(hitObjectNV);vec3 hitObjectGetObjectRayOriginNV(hitObjectNV);vec3 hitObjectGetObjectRayDirectionNV(hitObjectNV);mat4x3 hitObjectGetWorldToObjectNV(hitObjectNV);mat4x3 hitObjectGetObjectToWorldNV(hitObjectNV);int hitObjectGetInstanceCustomIndexNV(hitObjectNV);int hitObjectGetInstanceIdNV(hitObjectNV);int hitObjectGetGeometryIndexNV(hitObjectNV);int hitObjectGetPrimitiveIndexNV(hitObjectNV);uint hitObjectGetHitKindNV(hitObjectNV);void hitObjectGetAttributesNV(hitObjectNV,int);float hitObjectGetCurrentTimeNV(hitObjectNV);uint hitObjectGetShaderBindingTableRecordIndexNV(hitObjectNV);uvec2 hitObjectGetShaderRecordBufferHandleNV(hitObjectNV);void reorderThreadNV(uint, uint);void reorderThreadNV(hitObjectNV);void reorderThreadNV(hitObjectNV, uint, uint);\n
void traceNV(accelerationStructureNV,uint,uint,uint,uint,uint,vec3,float,vec3,float,int);void traceRayMotionNV(accelerationStructureNV,uint,uint,uint,uint,uint,vec3,float,vec3,float,float,int);void traceRayEXT(accelerationStructureEXT,uint,uint,uint,uint,uint,vec3,float,vec3,float,int);void executeCallableNV(uint, int);void executeCallableEXT(uint, int);void hitObjectTraceRayNV(hitObjectNV,accelerationStructureEXT,uint,uint,uint,uint,uint,vec3,float,vec3,float,int);void hitObjectTraceRayMotionNV(hitObjectNV,accelerationStructureEXT,uint,uint,uint,uint,uint,vec3,float,vec3,float,float,int);void hitObjectRecordHitNV(hitObjectNV,accelerationStructureEXT,int,int,int,uint,uint,uint,vec3,float,vec3,float,int);void hitObjectRecordHitMotionNV(hitObjectNV,accelerationStructureEXT,int,int,int,uint,uint,uint,vec3,float,vec3,float,float,int);void hitObjectRecordHitWithIndexNV(hitObjectNV,accelerationStructureEXT,int,int,int,uint,uint,vec3,float,vec3,float,int);void hitObjectRecordHitWithIndexMotionNV(hitObjectNV, accelerationStructureEXT,int,int,int,uint,uint,vec3,float,vec3,float,float,int);void hitObjectRecordMissNV(hitObjectNV, uint, vec3, float, vec3, float);void hitObjectRecordMissMotionNV(hitObjectNV,uint,vec3,float,vec3,float,float);void hitObjectRecordEmptyNV(hitObjectNV);void hitObjectExecuteShaderNV(hitObjectNV, int);bool hitObjectIsEmptyNV(hitObjectNV);bool hitObjectIsMissNV(hitObjectNV);bool hitObjectIsHitNV(hitObjectNV);float hitObjectGetRayTMinNV(hitObjectNV);float hitObjectGetRayTMaxNV(hitObjectNV);vec3 hitObjectGetWorldRayOriginNV(hitObjectNV);vec3 hitObjectGetWorldRayDirectionNV(hitObjectNV);vec3 hitObjectGetObjectRayOriginNV(hitObjectNV);vec3 hitObjectGetObjectRayDirectionNV(hitObjectNV);mat4x3 hitObjectGetWorldToObjectNV(hitObjectNV);mat4x3 hitObjectGetObjectToWorldNV(hitObjectNV);int hitObjectGetInstanceCustomIndexNV(hitObjectNV);int hitObjectGetInstanceIdNV(hitObjectNV);int hitObjectGetGeometryIndexNV(hitObjectNV);int hitObjectGetPrimitiveIndexNV(hitObjectNV);uint hitObjectGetHitKindNV(hitObjectNV);void hitObjectGetAttributesNV(hitObjectNV,int);float hitObjectGetCurrentTimeNV(hitObjectNV);uint hitObjectGetShaderBindingTableRecordIndexNV(hitObjectNV);uvec2 hitObjectGetShaderRecordBufferHandleNV(hitObjectNV);\n
void writePackedPrimitiveIndices4x8NV(uint, uint);\n
void)0
voidƅE
volatile
volatileH
vsnprintf
vstore_half
vstore_half_r
vstore_halfn
vstore_halfn_r
vstorea_halfn
vstorea_halfn_r
vstoren
vtxCmdBlitImage
vtxCmdBlitImageLayered
vulkan1.0
vulkan1.1
vulkan1.1spv1.4
vulkan1.2
vulkan1.3
vw$Hc
w'ffff
w(fff
w) * 0.5;       // Adjust clip-space for Metal
waitForFence
waitUntilCompleted
wantsExtendedDynamicRangeContent
wantsExtendedDynamicRangeContentMVK
warning
watermarkFragment
watermarkVertex
when more than one fragment shader output, all must have location qualifiers
while
while in source code it is
while loops not available
while(false
window
windows
with FastMath enabled
with bias argument
with expression\n
with layout(location
words
words instead
words instead of
words long
words, but found
words, but stated word count is
words, but the limit is
workgrouH
workgroup_size
workgroup_size_is_spec_constant_id
workgroupcoherent
wrap) { return wrap
write
writeInvocation
writeInvocationAMD
writePackedPrimitiveIndices4x8NV
writeonlH
writeonly
wrong number of arguments
wrong number of matrix columns
wrong number of structure members
wrong operand type
wrong operand types
wrong vector size (or rows in a matrix column
x L;x(t
x, 0.0
x,!u9I
x//<CPWdk
x9|1\bs
xBuffersH
xE9|<\bs
xInvocationsExclusiveScanAMD(int64_t);i64vec2 maxInvocationsExclusiveScanAMD(i64vec2);i64vec3 maxInvocationsExclusiveScanAMD(i64vec3);i64vec4 maxInvocationsExclusiveScanAMD(i64vec4);uint64_t maxInvocationsExclusiveScanAMD(uint64_t);u64vec2  maxInvocationsExclusiveScanAMD(u64vec2);u64vec3  maxInvocationsExclusiveScanAMD(u64vec3);u64vec4  maxInvocationsExclusiveScanAMD(u64vec4);float16_t maxInvocationsExclusiveScanAMD(float16_t);f16vec2   maxInvocationsExclusiveScanAMD(f16vec2);f16vec3   maxInvocationsExclusiveScanAMD(f16vec3);f16vec4   maxInvocationsExclusiveScanAMD(f16vec4);int16_t maxInvocationsExclusiveScanAMD(int16_t);i16vec2 maxInvocationsExclusiveScanAMD(i16vec2);i16vec3 maxInvocationsExclusiveScanAMD(i16vec3);i16vec4 maxInvocationsExclusiveScanAMD(i16vec4);uint16_t maxInvocationsExclusiveScanAMD(uint16_t);u16vec2  maxInvocationsExclusiveScanAMD(u16vec2);u16vec3  maxInvocationsExclusiveScanAMD(u16vec3);u16vec4  maxInvocationsExclusiveScanAMD(u16vec4);float addInvocationsAMD(float);vec2  addInvocationsAMD(vec2);vec3  addInvocationsAMD(vec3);vec4  addInvocationsAMD(vec4);int   addInvocationsAMD(int);ivec2 addInvocationsAMD(ivec2);ivec3 addInvocationsAMD(ivec3);ivec4 addInvocationsAMD(ivec4);uint  addInvocationsAMD(uint);uvec2 addInvocationsAMD(uvec2);uvec3 addInvocationsAMD(uvec3);uvec4 addInvocationsAMD(uvec4);double  addInvocationsAMD(double);dvec2   addInvocationsAMD(dvec2);dvec3   addInvocationsAMD(dvec3);dvec4   addInvocationsAMD(dvec4);int64_t addInvocationsAMD(int64_t);i64vec2 addInvocationsAMD(i64vec2);i64vec3 addInvocationsAMD(i64vec3);i64vec4 addInvocationsAMD(i64vec4);uint64_t addInvocationsAMD(uint64_t);u64vec2  addInvocationsAMD(u64vec2);u64vec3  addInvocationsAMD(u64vec3);u64vec4  addInvocationsAMD(u64vec4);float16_t addInvocationsAMD(float16_t);f16vec2   addInvocationsAMD(f16vec2);f16vec3   addInvocationsAMD(f16vec3);f16vec4   addInvocationsAMD(f16vec4);int16_t addInvocationsAMD(int16_t);i16vec2 addInvocationsAMD(i16vec2);i16vec3 addInvocationsAMD(i16vec3);i16vec4 addInvocationsAMD(i16vec4);uint16_t addInvocationsAMD(uint16_t);u16vec2  addInvocationsAMD(u16vec2);u16vec3  addInvocationsAMD(u16vec3);u16vec4  addInvocationsAMD(u16vec4);float addInvocationsInclusiveScanAMD(float);vec2  addInvocationsInclusiveScanAMD(vec2);vec3  addInvocationsInclusiveScanAMD(vec3);vec4  addInvocationsInclusiveScanAMD(vec4);int   addInvocationsInclusiveScanAMD(int);ivec2 addInvocationsInclusiveScanAMD(ivec2);ivec3 addInvocationsInclusiveScanAMD(ivec3);ivec4 addInvocationsInclusiveScanAMD(ivec4);uint  addInvocationsInclusiveScanAMD(uint);uvec2 addInvocationsInclusiveScanAMD(uvec2);uvec3 addInvocationsInclusiveScanAMD(uvec3);uvec4 addInvocationsInclusiveScanAMD(uvec4);double  addInvocationsInclusiveScanAMD(double);dvec2   addInvocationsInclusiveScanAMD(dvec2);dvec3   addInvocationsInclusiveScanAMD(dvec3);dvec4   addInvocationsInclusiveScanAMD(dvec4);int64_t addInvocationsInclusiveScanAMD(int64_t);i64vec2 addInvocationsInclusiveScanAMD(i64vec2);i64vec3 addInvocationsInclusiveScanAMD(i64vec3);i64vec4 addInvocationsInclusiveScanAMD(i64vec4);uint64_t addInvocationsInclusiveScanAMD(uint64_t);u64vec2  addInvocationsInclusiveScanAMD(u64vec2);u64vec3  addInvocationsInclusiveScanAMD(u64vec3);u64vec4  addInvocationsInclusiveScanAMD(u64vec4);float16_t addInvocationsInclusiveScanAMD(float16_t);f16vec2   addInvocationsInclusiveScanAMD(f16vec2);f16vec3   addInvocationsInclusiveScanAMD(f16vec3);f16vec4   addInvocationsInclusiveScanAMD(f16vec4);int16_t addInvocationsInclusiveScanAMD(int16_t);i16vec2 addInvocationsInclusiveScanAMD(i16vec2);i16vec3 addInvocationsInclusiveScanAMD(i16vec3);i16vec4 addInvocationsInclusiveScanAMD(i16vec4);uint16_t addInvocationsInclusiveScanAMD(uint16_t);u16vec2  addInvocationsInclusiveScanAMD(u16vec2);u16vec3  addInvocationsInclusiveScanAMD(u16vec3);u16vec4  addInvocationsInclusiveScanAMD(u16vec4);float addInvocationsExclusiveScanAMD(float);vec2  addInvocationsExclusiveScanAMD(vec2);vec3  addInvocationsExclusiveScanAMD(vec3);vec4  addInvocationsExclusiveScanAMD(vec4);int   addInvocationsExclusiveScanAMD(int);ivec2
x[A^A
x\bH+8H
x\bL+8I
x\b\ru=H
x\b\vu$H
x\bt'I
x\busH
x\f\atTH
x\f\busH
x_strideH
xecuteCommands
xfb layout qualifier
xfb_buffer
xfb_offset
xfb_stream
xfb_stride
xfb_stride is too large
xfb_stride is too small to hold all buffer entries
xfb_stride must be multiple of 2 for buffer holding a half float or 16-bit integer
xfb_stride must be multiple of 4
xfb_stride must be multiple of 8 for buffer holding a double or 64-bit integer
xfffff
xffffff
xture
xy += get_sample_position
y = 1.0
y(00DQXel
y0fffff
ySamplerH
y\bH+9H
y\bI+9H
y\f\buG1
y\f\bu`=5
y_reset
y_shaderH
ycbcr.b = T(mix(mix(plane1.sample(samp, coord, spvForward<LodOptions>(options)...), plane1.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 0)), ab.x), mix(plane1.sample(samp, coord, spvForward<LodOptions>(options)..., int2(0, 1)), plane1.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 1)), ab.x), ab.y).r
ycbcr.b = T(mix(plane1.sample(samp, coord, spvForward<LodOptions>(options)...), plane1.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 0)), 0.5).r
ycbcr.b = T(mix(plane1.sample(samp, coord, spvForward<LodOptions>(options)...), plane1.sample(samp, coord, spvForward<LodOptions>(options)..., offs), 0.25).r
ycbcr.b = plane1.sample(samp, coord, spvForward<LodOptions>(options)...).r
ycbcr.br -= exp2(T(n-1))/(exp2(T(n))-1
ycbcr.br = (ycbcr.br * (exp2(T(n)) - 1) - ldexp(T(128), n - 8))/ldexp(T(224), n - 8
ycbcr.br = plane1.sample(samp, coord, spvForward<LodOptions>(options)...).rg
ycbcr.br = vec<T, 2>(mix(mix(plane1.sample(samp, coord, spvForward<LodOptions>(options)...), plane1.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 0)), ab.x), mix(plane1.sample(samp, coord, spvForward<LodOptions>(options)..., int2(0, 1)), plane1.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 1)), ab.x), ab.y).rg
ycbcr.br = vec<T, 2>(mix(plane1.sample(samp, coord, spvForward<LodOptions>(options)...), plane1.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 0)), 0.5).rg
ycbcr.br = vec<T, 2>(mix(plane1.sample(samp, coord, spvForward<LodOptions>(options)...), plane1.sample(samp, coord, spvForward<LodOptions>(options)..., offs), 0.25).rg
ycbcr.g = (ycbcr.g * (exp2(T(n)) - 1) - ldexp(T(16), n - 8))/ldexp(T(219), n - 8
ycbcr.g = plane0.sample(samp, coord, spvForward<LodOptions>(options)...).r
ycbcr.r = T(mix(mix(plane2.sample(samp, coord, spvForward<LodOptions>(options)...), plane2.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 0)), ab.x), mix(plane2.sample(samp, coord, spvForward<LodOptions>(options)..., int2(0, 1)), plane2.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 1)), ab.x), ab.y).r
ycbcr.r = T(mix(plane2.sample(samp, coord, spvForward<LodOptions>(options)...), plane2.sample(samp, coord, spvForward<LodOptions>(options)..., int2(1, 0)), 0.5).r
ycbcr.r = T(mix(plane2.sample(samp, coord, spvForward<LodOptions>(options)...), plane2.sample(samp, coord, spvForward<LodOptions>(options)..., offs), 0.25).r
ycbcr.r = plane2.sample(samp, coord, spvForward<LodOptions>(options)...).r
ycbcr_bt_2020
ycbcr_bt_601
ycbcr_bt_709
ycbcr_identity
ycbcr_samp.get_chroma_filter() == spvChromaFilter::nearest
yfffff
ypeFromVkPrimitiveTopology
ytesPer
z) + (uint
z)1=EYYfm
z\ftuQL
zle::one
zle::redH
