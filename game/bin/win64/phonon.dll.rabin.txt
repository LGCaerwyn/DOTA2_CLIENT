0 ACr
0%:I7
0&>\vxe
0(J>a
0(¼2K
0*=tP
0+<5oϻU
0,u\eA
0/8;&jt
00000000@@@@@@@@PPPPPPPP
0000@@@@PPPP
00=Ps
00cfg
0123456789
0123456789-+Ee
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789ABCDEFabcdef-+Xx
0123456789ABCDEFabcdef-+XxPp
0123456789abcdefghijklmnopqrstuvwxyz
02"P2h624>8
02<N`N
040904b0
045>,D
04d8r:F2R
06*>L
07T:R
08Y;zQ\n
08ܻM\nB;i
09G|\t;i
09kP\n
09})C
0: =p
0:'E9
0:8\r#8
0:<q6r
0:=Mg
0:HQo
0:Yk\a
0:qg 8
0:zh#;L
0:ďI9
0:ѳn86
0;!AI
0;7zA
0;?aq
0;B1ͺR
0;C8j8
0;Ts#:d
0;Z$D
0;hLw
0;iZ-:X
0;nU\r;f
0;vn2
0;xCg
0< l\f
0<4xS7
0<4~O
0<>2!<kRZ
0<QIx
0<\azJ
0<\boX;z
0<\tw\b
0=!cl
0=>yJ
0=s!N
0=􀒽\ttK
0><[cZUg
0>H8B
0>\bQ
0>\nW4
0>\rg
0?K;1F
0@>1j4
0A+ËȉD$HH
0A_A]A
0A_A^A
0A_A^A\\I
0A_A^A]A
0B:;n
0E|;Ox
0FV:6
0G=·l=G
0H+=i
0H;3L
0H;E0
0H;O\br
0H;^\br
0H;w\br
0Hc\aH
0Hq;qj\v
0I9_\b
0I;G\br
0I;X\b
0II;6
0JV;\f
0K:y\a
0L+]\bH
0L9s0tKL9s8tEH
0L;c\br
0L;g\br
0L;k\b
0L;p\b
0L;}\br
0M;f\br
0M;h\b
0M;i\b
0N;shY
0Pr<o\f
0R:;xW
0S,;iJM
0S;BF
0S;\tw2
0S_;f
0To:@75
0X8b?~\e
0Xh:u95
0Yr709
0\aba|H
0\eY8(iA
0\fѸS
0\n001
0\rD;0
0\tJ= H
0]A^A
0]A^A]A
0]A_A
0]A_A]A
0]A_A^A
0]A_A^A]A
0^;MzP:Q
0_:7r5
0_M Ÿ]E
0_M Ÿ]E0
0b!|H
0b!}Hp4
0b1\v0\t
0bA|H
0ba|H
0c1\v0\t
0df=Ŗ\n
0e1\v0\t
0e=;a
0e\\9f
0eɺB\v
0fffffff
0gû[x
0h<nBp
0hU<a
0i1\v0\t
0l:<z
0m;YG
0pU;ͲA
0r\a=FF
0r\r<,4
0s; $5
0sh;K
0t\e;U
0u;6B
0u;ȺJ;C
0w0c1\v0\t
0y<2\r6
0zD;wD
0zj;V
0}0i1\v0\t
0}<LB
0ġx_\f0
0ġz~4
0ŻQ!v
0ż\tk
0ȹq!O:B
0Ϭ8Uh
0҇8,q
0ڼvYмr
0ފ;Rj
0籼d#3
1!;5jf
1#QNAN
1#SNAN
1*̽ Z
1+;\tk<Tt
1,\bd
1-8=M8I
1.2.11
1/;Be
1/;hR
100.00
100.0f * cache_hits / cache_accesses
10=`M
119[V
13,<j
14;&Q
15:g7E
18?FMT[bi
18H\núy
18a18b79f993039aeef572dca0a86f782561e4c1
19>]4
19eď9 Y
1:3\ae
1:\rh
1:a^l
1:f\tV
1;5`b
1;^u8
1;pOe:f
1<Egd;"m
1<\bL
1<\r2
1<]HB
1<tŨ;wvp
1<樫=H2E
1=hǽW
1=wgֻaQ<O
1=Ϻp\b2
1>:Do
1><pM
1>c\v8>gp
1>vER=\a
1B=!e
1BLQXC?l
1C;pW\n
1C<ID\r
1D8G\buIH
1D8G\buQH
1D<)T
1DZ<jF\n
1F;F碻-i
1FW:C
1G3;yWY
1H;>u?I
1I27K
1IL$LD
1IL$TD
1IL$\\D
1IL$lD
1Iw<C3
1J9rt纀T
1L9O7n8
1M;*S
1N;dC
1NI;K
1O);k
1Q:ay
1T'::1q
1T;=}88
1V";Bw
1Wz<cl
1\\>14C
1\\z9
1\n9t
1\t:QG3
1\t>\faS
1b!|H
1b!}Hp,ұb
1b1, X
1b1}Hp,бb
1bO;d
1ba4@X\tba|H
1ba\\ X
1ba\f
1bq}HpԱbQ$@Y
1b{9eV
1e;y\aW
1e\a:^M
1gt;O
1h$:\eZy
1hq<Jp\v
1hq<Y
1i]9{K
1j=\n
1jx;5\bλQE
1kG:y5
1l;(8G
1m><uE
1rE;k
1rd>y
1t\t9
1tں&s
1u0;t`b9
1wP=%Id
1wX:<n
1yD{z
1{S;c
1{q;kq
1|U;eG
1ºH=58
1ûZ\a\f
1żah6
1˻UEV
1ֻ\bC6
1ֻuQ\b
1צ;zoR
1ٗ<V7\f
2 ;k/p
2!:Xs
2"A:j
2+=-tG=br
2,S;TS
2.17.2
2.8OVd
2.=jiD
2/x;Oq
20:WϽ;3
20l;g
21];ZD
21a;?H8:6
22:RNz
2333333
23=Dͳ=\tJ
26K;$N
27:ȵO
27<AFK
27O;P
29&b\f9
29[yi
2:6W\v:3ľ8
2:F_b
2:L`o9L
2:YFk:k
2:b=m<f
2:gDx
2;*l8
2;0"e
2;7i̻C
2;TiJ83CR
2;Ue绳w
2;\bT
2;\bZ8
2;` w
2;arX
2;s=2
2;sNL
2;vM\v
2;}w5
2<2\tźO
2<4>6<8
2<6r⼐kz
2<D@L
2<KB\r
2<j)i
2<u\bt
2<vdR
2<xD2BNF
2<۽CK
2=i>3
2>~m6
2>ʚo>J2
2>۽vx
2A;sZ\v
2C\t9U
2DE=au
2DigiCert Trusted G4 RSA4096 SHA256 TimeStamping CA
2DigiCert Trusted G4 RSA4096 SHA256 TimeStamping CA0
2E=82R<d
2Ee<pI8
2Ej;?l3
2F=\f
2FҺ^J
2G8ƶy90
2GG>!B
2I;"bA
2I;\f
2J\f=Ԉ2
2Js;~n
2Jw;r􈺅Tb
2Ky;Un
2M¼\a\e
2Q;rf\r
2R=\fӽ<au
2T*<6
2TK;>nE
2T~:CS\b9
2Tлl8
2U1<J
2V1;(%v
2V:ϥC:M
2Vv=F
2W">`92
2YL\a|Ģa
2Y|2d
2\a<K
2\b:OZ\b
2\e>vc\a
2\e\v
2\f:p4q
2\f<1W
2\n[:S0e
2\rp\f`\vP
2\v<X\v9
2\v=\n X
2\vL$PL
2]fQ\t?5
2^˼78
2`ġJYt2d
2a\v:)YD
2b!<HY
2b!|H
2b!}Hp
2b'>Q8
2bF;y
2b\b<Z
2ba}Hp\f
2bq}Hp
2dh=(X
2f<w\r7
2g/:G
2h9sp
2http://crl3.digicert.com/DigiCertTrustedRootG4.crl0
2izj|4
2jG:z
2jP;3hN
2p;V+n
2p</MT
2r*9U
2wx:rd
2xk:F
2yY9u&U
2z<#k
2{A\vDcC
2|8Et
2ǼzSO<n
2Ɉ9dcz
2μcRƼc
2ֺ8WG
2ٻZᙻmg
2ݺv>F
2捻rF2<f\v
2蚻ǰV9NJ
3 :\v
3 ;4T
3 H=t
3!y:G
3$m<3
3%0=9
3%I;wDb
3%P;Ul
3)ƼkWy
3*V<gL
3+r:ߨ2;Qq
3- =cO
3-:MPN
3/C>R
30;th
31<(M
32źs౻a
333333
3333E
35i<sC
36;3\vR:Y
36A;rn5
36`=s\b
37ܻ4h
38$Dk9
38(3q;τr
38:\vk
38;qwZ
38غ%F
39.6v
396js
39\aq@;4
3:8me
3:JpV;l\v
3:}3w
3;&vh
3;7\bS
3;:HF\a
3;CScs
3;TWɻs
3;\n N
3;\tTʺK
3;atH
3<!lN
3<Cܮ<WP
3<dF\b
3<dU\r
3<y8B
3=:w2
3=N\f
3=h\a\t
3>4A\a
3>N;kU
3A-;w
3A;XI6
3A</a
3A\a;^ᇻ8d1
3BڼlxǼG
3D{7ýt
3E9>l
3E<tF
3F:Nڂ:4m
3G*=1
3GV;VL
3Gܻ\r7
3Hc\f\bH
3I9)ZZ
3I:OP8
3JcT\b`H
3Jg;d
3L:<h
3L;2V
3LA<n,\e
3O<qoW
3OIX:0w*:\f
3P=\v1`<ci1
3P>=U
3Q;\e/t
3Q\r<n
3Sk>r
3TF<F
3W<HF
3YY:4F
3\bD$ H
3\bD$BH
3\bD$QH
3\bD$TD
3\f<L
3\fW;T
3\n=Fw\n
3\n\t;Q
3\r<p6L
3\tD$ H
3\tD$09G
3\tD$0E3
3\tD$X3
3_<2l\r
3a\n<ZB
3b,;V2
3b1|\b
3b:NSm
3bA|H
3bad@X
3batHX
3c*:"u09\n
3c,:KFӺv
3eG<rb
3hZ;\aX
3hi:٢b
3iD:P
3jȺ!eX<ܻV
3k;'N4
3k>Sgq
3kg;iX
3mo=EX
3oƻrn
3q;dŦ;E
3r=:WB
3t::T
3tD;\a
3t\b<kg
3v9\\sZ
3vQ:6˿;O
3xźOH4
3y->W
3zϺqh
3z꠩7Z\b
3}b;\nCR;eL
3~:yS
3ɉD$8H
3ɉL$HE
3ѻNgQ
3ѻadl:e
3҉T$ A
3҉T$ I
3҉T$0A
3҉T$8H
3ҋD$(Mc
3ۉT$HD
3ۻD\vb<N
3J\n
4 <(Xx
4!<VE
4"4&N,N2l8 :\t
4"T:PD
4%V<2u
4/bA~\b
4/bbUH
40<k5
40{;N
41<zgE
42:|\fv
42;YAg
42B>F
43b!|\b
44?:S
45X9.H0
469;}X
47;0^68r
47\b=x
47bA~\b
47c#\e
49G%\a;bi
49HoKC
49u O
4:HmݼH
4:bFܺ7F
4;,Ip
4;K\v\b
4;Y/l;\n6
4;\nCs
4;bA|H
4;bBu
4;ba$@X
4;mA\n;Q
4;qH+:h
4;t }956
4;ʼuc\f
4</fb
4<4;ZvջA
4<>\v0A
4<G,ӼQkj
4<X8A
4<YP6
4<cZ44<\t
4<k:F
4=7#=5Z
4=D}Q
4=HH3
4=\tJ
4=rUľ}p
4>%4m
4>3RO
4>5IF>_X
4>PQ\a
4>b!L
4>v<r
4@=m0\r
4@bb}H
4A;!q
4B;$y
4Bo;n
4D8l$2u
4G3<%E
4GE:m
4Gbr}H
4Iڻ/A\f
4JB:킩8
4L廉zN
4M*<e
4M8Y?6
4M<D\nL
4N8=C
4N;Y*\r
4NŻ|6\a;s
4Q<\a8Y
4QY=M
4R):wvҺJ
4R9\v]5
4R<K3
4R=i7
4T5I:3
4TԄWak>E
4Uʻa*w
4VR=ޗp
4Vc70d
4Xϻ7cu
4Y,96r
4Y\rdjK
4Ym ŬX
4Y̺Dis
4Z\n;1
4[<WH
4\\i7n
4\abq|H
4\b6\n@\f
4\f<z<K
4\f^;mS
4\nbA|H
4\r<0Li
4\r>v
4\t<QU4
4\tbrm
4\tbr}H
4\vb;_Y
4_Q;2
4`q9P\r
4a<S\aF
4b;<l
4bA|H
4bL<dM
4bQ4HX
4df<W_9
4e;[h
4g<k\a5
4h:oW\v
4hG<"0
4hT<\r
4http://crl3.digicert.com/DigiCertAssuredIDRootCA.crl0
4i9CdS
4i;w9
4j;6\t
4j\v:\t{k
4k!:C8
4l;G{f
4l<\nt
4p:jCH;y
4p[7w
4q<+3U
4q<+l
4r<ܽ˽Sx
4s\b>Z4ԽO
4t;3u\n
4u9Ig
4ve;x
4x*9S
4xt;ђ9
4z<4/Q
4|λ8YŻ8
4ӺVڅ;p啻pW
4Թ:Qi
4ػOz\n<rg
4ݯ>28
5 ;=dU
5!D=6
5#:r\eO
5#\b<Yt
5%9ZKK
5&b?B1s
5';Z4\f
5(96N\r
5)m:F^k
5+;ruL
5,$0H
5,,0H
5,40M
5,O<w
5-;e1
5-C:r
5.\f\bI
5.\f\bM
5.\f\tM
509;k
51+<Y
51:`k\a
51:sk
54;Djp
55M>vG
56*;n0
58\ej
58ٻ\tx
58ᓍ:紻92
59Z;\et
59ZEz
5: ]O
5:'4o
5:/F1
5:PAY
5:\vqY
5;+,v9C\f
5;6\r4:u
5;B\\c9
5;D\e
5;X(o
5;e5X=L
5;f\b
5;kc1<4H
5;n4b:\n
5;om컠\v
5;r\vb8hr
5;}SZ
5<FE.:TP
5<[ E
5<\f>лuxk
5<^ZA
5<e+L=H
5<eB0
5<m(3
5>'MX
5>cQW
5?5=A
5?l 6?#:7
5@D;OJ
5B:\b
5C3=f3
5C;\nN
5D0<dr\f
5Dۺvg
5E>haR
5F=4u
5FB;[Jz
5FM<5tE
5Fj;q i
5GJ:ʍg
5J;҇u
5JO<s
5Lv;E
5M;j2\f
5M\t;O
5N9t.y9
5NC<Dz
5Pһ\eM
5RC9!Ŵ9
5TK;c>d
5U!;Y
5UC7֚A
5Ul<"V
5V9;4
5V;'di
5VӼL\fl
5\aS<c
5\b:yώ9
5\bY:hǱ9P
5\e=lOf
5\f4:T
5\nJ:U
5\nk=e
5\v;hag
5\v<x6\v3h7\v*tx
5\vʻ_2h
5b691n6
5bt;\n
5cI<S
5e"=k!z=Y
5e:)N6
5e:\t
5h5<d
5http://cacerts.digicert.com/DigiCertTrustedRootG4.crt0C
5k>\rW\f=v
5l˽F{P
5lԽLX
5m8>8=t
5n:"f8
5n<<99Q
5o< I
5pME:i
5q1;R
5qB=g
5r:Q}4
5rv;S
5s0;B
5t:\\K6:U
5tĻrD
5w<6A
5xA9E
5xF;+gE
5xm?\a
5x¼@E
5{˻kN
5ºs0\t
5Ǻ033
5ʎ:Y5
5ʻG]9;a
5̸n[λNuM:9B
5պ91n;h
5ڹ\nG
5ڽp3Q
5ۺ:Q2
5蝽,4z=Fks
6!x<0R
6!»Br
6$)2Az
6';pIY
6*p;d
6,\f>brg
60u\rA
61f;\tMK
61̼M\n
62F;u
64ι_e\v
666<jHv
68^dh<f\\A<2
68tGS
6:%Q6
6:;Uu
6:C8*;acy
6:CI1
6:\v\ae
6:enZ
6:iSB:V
6:scM9
6;!Iz;p
6;O\f\e
6;\t M
6;hVH
6<'(4;nAK
6<,|n=XQ1=3Y
6</in
6<2wN
6<Pr3
6<\to\e
6<cNx
6<k\rP
6=3D\a
6=4iＨxp
6=K웼S
6=X t
6>D\rF
6>v쓼L
6?<Vj
6@1<8
6A$:r
6C9>L
6D:\a_O
6E:Eo
6F#>\ff
6F;Dd\t
6FQ=47
6F½{o
6Gg;E.C
6Go;\v
6H<=Y
6I;uBV
6Ix=5
6Lc;R
6N<? q
6NK>\e\r
6OB,n
6Rɼ<X
6UļVJǼ1Hۼ42
6W绱}d
6X[;dIR;S
6Z_;4
6\\\e<Va7
6\a ;c
6\b>s
6\e;+C9
6\f9<'L
6\fA=\e
6\fXO>\ntA
6\fw9
6\nR<u
6\nܼt
6\v;r45
6_8<u
6`h;C
6`tl:hO
6a<\erb=6
6aR;5
6aͼ`8F
6b!F\bX
6bB;n
6d;zܩ9j
6d<HMr
6e;vu
6e}:}Ru:t
6f&;Y
6f?;\vu
6g=$Y
6gU9f
6iZ<vb
6iӻ`wh
6jG<,Q
6ko;T%;j
6l8\eQ
6m:\e
6mZ<DgJ
6nB;r\v
6nd<f
6oh;\f
6p7MOf
6q;fUR
6qO<F
6r9 5
6rǻ Y
6t:$2t
6t;FY
6tX<\v21
6wo=e
6x<Q\nX
6ys\b$;o
6yк%S
6zz<c
6}3= 5
6Ó;pC
6Ƿ;L\v9
6ͻqy"<3
6κj侺*Es9
6Ҽ46Żvt
6յ;vH
6㔻>SS;9
6璻UAۼU\t
7 :IƝ;du
7#bI;nR
7$\eD:g
7%;+xe9
7&n>h\fn
7'\a7=A
7+G;C
7+u:PH
7,;UX
7-:Zu\n
700WP\a
70:Y@4:I
70?Hz\e
72-<f\e
729:g
72L=L
72r=AY
73<q\f
75AJ9\n
75{V:\n
77;tc
78`_:V\bx9
79$畺3B$;E
7909b
79?G8
79bp\r:(L
7: 6J;@75
7:!8J
7:!X1
7:<7L
7:LRιr4
7:Z-f
7:\nn89
7:qZ9
7:vbA
7:vrt:0
7;%La
7;0\t
7;B|Q;R
7;l\n\t
7;rnպu
7<Q)5
7<RLK
7<dDW=v
7=7gS
7=<\ey7
7=\bK\a
7=dUt
7=wRj>K
7=}Jp
7>HֺBz
7?Լ\a3t
7AP:!o4
7BƼ|o
7BھXSB
7Cu<d
7E>9Lo=d
7F!;E
7H9x\fY
7HcD$(L
7I3:\b
7Ld:I
7PR;D)k
7Q;E#i
7Q<F[l
7QC;\v5n
7R[<` p
7S>;s
7U:;X
7Uʻ/c
7V;g3
7Vmq:w
7Vӹ'Zt
7Xd<ηz
7YJ;~V
7Z1|9e
7\aǻ0Y
7\aɼ=KC
7\bu;C
7\e:Y
7\e{U;n
7\eջ1
7\fؘvOV
7ae:%z
7b!|H
7bA~\b
7bJ;C7
7ba|H
7e:\f
7fi9\aYG
7h[;\e7
7h\e1;V
7http://cacerts.digicert.com/DigiCertAssuredIDRootCA.crt0E
7hz\a
7i:lp
7iݽg\v
7j,<KDa
7jnj;D
7mh:h
7n?ǺM
7ni&9N
7nuH8
7p;f 3;q
7p<<xq
7q:42i;a
7q;8\\y9
7s1<R1\a
7s\t0
7sƜ:\b߉9m
7u<NT\a
7ur;yI
7vf;AJ
7x<\n
7{KV\nU
7~:\nTW
7ƍ;hND
7ơ<AY
7˺8`89\v
7˼*Es<V
7ͷ9kD
7φ:U9ֹa
7л<wH<v
7ӏ<H8Ȼ2z
7Ս<vZ
7ݻJ\e
7ޗ<b\eE=Ys
7릻yFF<m
7뻆\bڻ1V
8 V<bz
8"&08l
8#J\f
8#Po:M
8$ $9D
8$v2;E
8%h&;gn
8&#89K
8&GS9
8(Wһj\e
8(\tC;B
8(e=E0
8)B\a>8B
8,3M:QN
8,\rk;S
8-Z\v:H
8/;in
8/NG8
8/Uĺ2
80d\t
80pR<pIQ
81!;cr
81;*^C9~6B
81Eɻ~\vc
81¼R9？h
82AI9
82˦9R\r\n
83:aN
83;9M
84<HAJ
84XŹ7
85<ιL
85G<r\a\f
86:u6
86;rJ2
86>V9\f0
87t\nH
88/\ve
88u\bL
897}:I3G
89H`fD
89I`fD
89Z6{[u<;w
89\\$pfD
89\n0w
89whS<\v
89|$0fA
89~n0;h
8:1%Z;c
8:6,:5!m96
8:;dd
8:OBc
8:\bc\t;n
8:b\eg
8:dIj
8:q\t\n
8;'qw
8;)xV
8;3)D
8;5G\t
8;Bt::gW
8;PBA
8;W:p
8;XM8
8;\a^9X
8;e\b:U
8;fy3;r\e
8;jMa:aX
8;mH793
8;o.v
8;q`9:\vT
8;w{s
8;xNw;m
8;yHc
8;zsM
8;zʭ;of
8< .f
8<A?5
8<TYf
8<\f6t;͚T
8<]p3
8<aik
8<f<f9
8=#xѼa4
8=D$pD
8=E fA
8=E0fA
8=L$PfA
8=Qsg
8=RY\t
8=XPfA
8=YPfA
8=aPfD
8=hPfA
8=pPfA
8=qPfA
8=x$5>Y
8>9:k
8>G2\e=mf
8>\ew\t
8>c\eքBC?>6t9^\tc
8>~08
8?oЈ>Vc
8@%\e46
8@Hd;L
8A;\b;f0
8A^A]A
8A_A]A
8A_A^A]A
8B"\e<l
8B+59&pt9
8BNK:Z
8BYV;Nٰ8
8B\r=[L
8Bh\e;\eH
8Bko9f
8C\buAH
8C\buGH
8Cj;<s
8Csinf
8Cؼ}98
8D<<2
8D=V;C
8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA1
8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA10
8G\a\e=\r
8G\buAH
8G\buBH
8G\buGH
8GdH;z
8H9_\bvF
8H;E!Q
8H;x\b
8H=E;y
8HS2:A
8I*\v
8I;x\b
8I;x\bsp
8I?=&UN
8Ia\n;u
8IջO/0
8J\f<qJ
8KyD9
8L#O\bt
8L$ܹz
8L:{r\f
8M,;Iw
8M\v;X1
8Ms;\fTf
8N>u\e[>e
8NG1:'}\b
8NS`:iVR
8N\vɻV
8PX\a\b
8R"L;x
8Sf<\ap
8T$Ht\fH
8U)zj
8U;\ncN
8UL<ޭ\v
8UUUUU
8V;ŹR
8Vk;J
8W;2o
8Ww;z
8X0u\fH
8X0u\tH
8Xüy\f
8Xޠ;VY\e
8Y3<:fc
8YD6 Ģy
8YT 0
8YT 0ŐW5f
8YT(0
8YT(@ŐW5
8Z0u\tL
8Z0Ļu
8Z6\t:m
8Z;y\v
8Z=M1o>C*0
8ZüK|G
8[yǺTq
8\a;s
8\aj躥$u
8\b\a
8\bg88ew
8\eIN:7
8\eQq7
8\eǻZOp
8\n<[Hm
8\n<_Dp
8\nӺyqg
8\t'0:_sd9
8\t:^9U
8\tpw9q\ee
8\v$=KO
8\v?m9y
8\vؼ"72
8\vߺ"S6
8]:\vo9
8];f\nB
8]A_A
8]A_A^A
8]A_A^A]A
8]ｾxD
8_9"3a
8_\bu?H
8_\bu@H
8_\buAH
8_\buEH
8`gԸBt
8b!|H
8b!}Hp
8b!}Hp4
8b:c{p
8bf=`a8
8bunz8
8bwE:O
8d;k活^as:L
8d=?9Y
8d>:v㐻Q
8e:u:c
8eY<L
8e\b<kw
8fޗ:Gؠ9
8g=ʹi
8gnu;!~N
8h;;R
8hВ82Pa8
8iV=ˣP
8i\a=6x
8kqp;H
8kz[91
8l$8t\fH
8lA99c
8m+:it
8m5йвd
8m:StY
8m=OSb
8n<PnZ
8nݹ>0r9
8o)u2H
8o;EIJ
8o_9^Q
8p4[;=0
8p6y:\n
8pb0;S
8s)u2H
8t;e13
8tR/;R
8tZJ;P\tV;E
8u\e:tf
8u{b;\b
8v?Q:X
8vH<\vPZ
8vL96W
8vL;\bX
8v\tۺZw:J
8w(;s
8w:]C2
8w\bu?H
8w\buAH
8wpv0H
8wع]x
8x0u\fH
8x0u\tH
8x;\e
8x?I:z
8y tmH
8z0u\tH
8zq(;X
8{\bt
8|$Pt
8|$PtN
8|$PtP
8~!tKH
8»MHa<L
8ÐATAUAVAWH
8ŻqGx
8ɺUr5
8˺8hC
8˻ë99
8̮e9\tL
8̶9)o
8ʹv72
8֖S:VX
8ֽwSt<R
8ؼI7\r
8ܧ9lM
8ދ\b9
8ျ\vJr8p
8ṉ;4op
9 ;Ԣi;O
9 OҺ]ej
9!6N:q
9!AF:\t
9!r9:U
9"2ԺEH0
9"]Q;tY
9"o&8+Pj:4T
9"ҼrB
9"٘;rBI
9#WùWiC
9$x[<Ac
9%/C9
9%?9j
9%B<2$c
9'I:0F
9(D>O
9(e;aP
9)eA:ڧ2
9)v<z
9*K:r
9*QY:\a
9*|G<uG
9+l\a
9,c :\a
9-W\n:Vk69
9.}c:Mi
9/5i:\a
9/Q 9y
9/x9l
9/}M9u
90-\v8B
90;Hc
90f#<0hm
90|ƺU
90Ì;yK
90ܳ:0?j:Id
91#v:4
91C-:a
92$n9c
929ںOD
92;d\tr
92<T;v
92B;F_k;gl
92B\r;F
92_J8
92i;9d
92ճ:fp
932;A
93;fK
93R;\a
93Y\e;'t
949^;2
94UzPW
94ݻ31
951\t:J
96;MC\e
96<Ns
96K"<i
96VR;v
96qe8
96ލ:ͤa9
9738;L
97\r; AS
97d]:=w
97ڻZB
98/ºza5:B
98VŻ^I
98Wdu
98m:$J
99-9X
991%ڹ\b\n
99\bS;.G
99\fu:U
99fɹmL
99q\a:a
9:R\r?9
9:[i59
9:ck\n
9:rM9vG
9:rл#\tV9
9:x\tK
9;&QH
9;)NN;k
9;3V;\fV\f
9;7Nz
9;\n;jk
9;\va:4K5:`iX
9;_\aS9iY0;0
9;a?9
9;jm7<Cp
9;m_J
9;qtE
9;|P;eW
9;|\nHcC\bH
9<'md
9<)M72
9<1*:F4
9<1;B
9<90o
9<H8d
9=8H;J
9=\tuȼp
9>=N9
9>LXN
9>uQ[;Y
9?]X9\v
9?m8:7
9@@Y9ZS
9@We:>5
9@\nY9
9@мYF
9A';o
9A\bs
9A\b~6Hc
9Ar-:{f;9
9B J:s
9B<\bI5
9B\ef9
9C\b~)D
9C\b~4HcR\bD
9C빔Zƻm
9D$ r\r
9D$0r
9D%W9
9D*\v
9DBu9
9DE\f;aUF
9D\t/9a
9D_\v:G
9DgX;STU
9E,E:G
9E;3r8
9EE.9Y
9ES9\n5c
9E\b=B\t
9F) 90
9F:cJA
9FF>\\d
9FHtJH
9F\bt\fI
9G:P᭺\e
9G:hO
9G\bt\vI
9G\vS:$f)9
9Gg:m\e
9H7&;1
9HPu9*ms
9Hn%:U
9H}\n:5N
9HŻyTw:D
9Idɺu
9Ig:Y
9Iڢ;LN
9J;N3W
9J>t9
9JHi:w
9Jk<jw
9JÊ:j\v
9K :#R
9K%{<0lj
9K-R;ys
9KG?;GD
9K\eg;C
9K\nM
9K\r:a
9K];7
9L>bN2
9L\bF
9Lj\f
9Lڂ;U\ag9
9MI+;{C
9Msd87
9N%|6
9N7w9}G
9NIz:G
9N\rC9
9NeغVb
9O';S
9O5S;q
9ODp;l
9PSc;Y
9Pa]9(,H9
9Pwָ\b
9Pʫ;A
9Q.ȺPE
9Q4:)I6
9Rp:k#\n
9Rͻ:P
9S1ֹAC
9S7]d
9S>K<C
9SP<Q
9Sk\n
9Sz\e9q9
9T1[:}LQ
9T9]:x
9TF;loQ
9U9¹eO\e9
9U;6[v
9U;\e
9U[C87
9Udչm\rV
9V<7;Kt
9VBA;2
9VL;W
9W!s;{m
9W6!;x
9WQ;DVԻ\n
9W獷mf\r
9W裺Q>\v
9XEC8Ii
9XbN:9R
9XɹyH
9Y$v:D
9Y(1;bk
9Y_Q8
9Z3ʻeG
9Z47<75C
9Z<;Dp
9ZQK9J
9Zzɷb
9ZӠ9i
9\\\vh94
9\\dk9R
9\a><kY
9\aXN;m
9\az;bpj
9\b4B
9\b\ed;\b
9\b\fT9T
9\bqm:z
9\bwn
9\e:H
9\f;qK\n
9\fyͺR
9\nd7
9\nh_9I
9\r\tp
9\rz^;5
9\tRD
9\tx&;z
9\v j9hKU
9\v.S:V
9\v:x9\b
9\vFz9v
9\vQx
9\vde:U;:t5
9\vhe
9\v~8
9]!/9\txD
9]\am
9]o?9]o
9^ t"H
9_\b~4L
9_hs'H
9_ns:i3
9`C;No
9a*p:\n
9a,\a;Z
9aw\t;RA
9b!}Hp
9b;nj1
9ba4 Y
9ba|H
9bdt;vCb
9bl-:3l
9br%<7
9c-d:7
9c-m;A
9c\\99E
9csb9w
9d;e4
9e9O:e
9e:\rf\n
9et~;l
9e{\b
9e|I:P
9f.X8\a
9fQT:q
9gN>9N
9gfr9
9hG5:f
9hPJ;4
9hU<?km
9h\\F
9h\b9
9h\r;\alS
9ha\t:j
9i?>H
9iL$:-p
9ia{90
9ih\r:I
9j;i}W
9j<\e;9
9jK;Tl
9j`M;p
9kB\b:F
9kEM;v9
9khO9ad
9kv\b
9kwͺAB
9k{I:c
9kO[x:T
9lDŻط\f
9lt\e6
9m2?<W
9mN캘UQ
9mP/:U
9mRӹ\f
9mXZ:L
9mu8;#q
9n4\t:T
9nD=wD
9nT":B
9oE#9
9oF-:p|V:6
9oF\v:I1
9otx:7
9o|;967
9pS[7z
9p\aJ
9pfM:(\e
9p}\v
9q+B;nn
9q;tx
9q\aڻs:\t
9q\r8;$V
9rcE9V
9r~?9
9rļ8,w
9s\aԻ{O
9s\b~63
9s\vY:n\v8
9s`A;L
9t$Pu\t
9t$P~58
9t6%;w
9t:VW
9t:qY\n
9tL)9'e
9tVK9
9t\v96
9u@u\nH
9u@u\tH
9uve9
9v J;*0
9v.ƼS%B
9v\te9
9v\vE9M
9v\vz
9v_u;h
9vg@:A
9vů9tH
9vԼR5ȼri
9w3/:ͥs
9w8=H\v\n
9w9\t:lϏ9
9wPA:V
9w\bt'HcW\bH
9w\b~tL
9w\eS
9x,<dy
9x9;P
9x>\f
9xxr9SYo8
9yH9B
9yI?:r-ȹm
9y\b~\\Hc
9z8OH
9z\e5:{K
9z\eպ2
9zmp;oH\t
9{ M9Y
9{6r:u\n
9{\bu\b9
9{\fu\t9
9|7[9Uu
9~0t\vH
9~6ѺJ
9~C:9
9~D1;d
9~\tD
9·L0x:b
9ĉA:q
9Ļ]1q
9Ż;Zb
9ƎD;7\e
9Ƭ49hky
9ǘy9&\rw9
9ȮB80I
9ɖI;gu
9ɫѺ4t
9ɲi:kJW
9ɾCF8
9ʁ:pAv:3
9ʙF;'Aa
9ʚ˺GV|9Q0
9̔E<c
9Ϫλ iX8
9Ͼ1:U\r
9ӽr|ȽT0C
9Ժd=m:r
9դ?89
9ջrF2<J
9اB:J
9طx:9
9ٽ2Va
9ݙ-9X7
9ݶg;H|U
9ߛ?9F
9ߟ=x3
9ờy\e
9鷬9>H
9:Z\tI
9:uXQ
A :\a.L
A ;\f\r
A HcA
A"Yt/4
A$¼1b0
A$ƻP7
A'i:E
A(H+A H
A(L+A H
A*D;iײ9
A+=p7
A+_0A
A+ƉD$hD
A,8`e
A,ba~\b
A.5<sx
A0H+A(H
A0H9i8u\vH
A2a<\\w
A2ٸcʞ8pm
A5;"f
A5g;e
A81t@@8r
A86taH
A8<$u~M
A8G\buBI
A8G\buGI
A8H+A0I
A8H90t
A8L9 t
A8L9(t
A8L90t
A8W\v|$X
A8h\bu
A8z,u\bH
A8{,u\bH
A9(݊9\n
A90~(3
A99R\fH
A99~*3
A99~6H
A9<C;\e
A9F+\e;a
A9P t\nI
A9\riֻ5
A9v|$\b
A9}8~,H
A:HBι5
A:\at\vI
A;2#z
A;>M3
A;>VP
A;H7,:x
A;Jk\a
A;M8v"A
A;W\e
A;\aʆ93
A;\e7F
A;^Pc
A;czC
A;v<s;Kq
A;|$lu4A
A<$90
A<GfS
A<GmO
A<HrH<\a
A<l;5
A=!U༾JL
A=:t9
A=\ews
A=\rw
A=cT9
A=k"N
A>{rS=t
A@K=q6I
AAW:uk
ABCDEFGHIJKLMNOPQRSTUVWXYZ
AC\b<\bU\e
ACh B`z
AC˹Y&2;C
AD4<;tH
ADVAPI32.dll
AG:^3
AHH+A
AHH+A@H
AHL;[\b
AHԻgɬ;q
AI(9%s
AI99C`N3A
AJ9"ݬ:R
AJC<w
AK;Hv
AKZ<X
AKi;)lr
AKn:h
AM:am:PM:pm
AMFInit
AMFQueryVersion
AN;`U
AOڻUx
AP9\f g:O
APD90
APD9\b
APIName
APIVersion
AP\r;li
APi9+\a
ARI SOFA API for Matlab/Octave
ARY\\/4
ATAUAVAWH
ATAUAVAWUA
ATAUAVAWUH
ATAUAW
ATAVAWD
ATAVAWH
ATAVAWUH
ATVU`E
AT}9dI3
AU?$BVHNBuilderFastSpatialSAH@$03UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$07UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03ULineSegments@embree@@U?$LineMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03ULineSegments@embree@@U?$LineMi@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03VAccelSet@embree@@UObject@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$07ULineSegments@embree@@U?$LineMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAH@$03ULineSegments@embree@@U?$LineMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03ULineSegments@embree@@U?$LineMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UNativeCurves@embree@@UBezier1i@2@@avx@embree
AU?$BVHNBuilderSAH@$03UNativeCurves@embree@@UBezier1i@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UNativeCurves@embree@@UBezier1v@2@@avx@embree
AU?$BVHNBuilderSAH@$03UNativeCurves@embree@@UBezier1v@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAH@$03VAccelSet@embree@@UObject@2@@sse2@embree
AU?$BVHNBuilderSAH@$07ULineSegments@embree@@U?$LineMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAHQuantized@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAHQuantized@$07UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$LineMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$LineMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UBezier1i@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UBezier1i@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UBezier1v@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UBezier1v@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UObject@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UObject@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$LineMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07UObject@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$QuadMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$BVHNBuilderT@V<lambda_52e266aadf8432d50fa5ff3fa51f43ee>@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@V<lambda_8bbfff9e82cd1eff6b393972856c8533>@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@V<lambda_a6bfdd88d0c8dbe164163150fa0e2d47>@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@V<lambda_b16d1d523e4acc8bb8c8d8536077e7c7>@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNHairBuilderSAH@$03UBezier1i@embree@@@avx@embree
AU?$BVHNHairBuilderSAH@$03UBezier1i@embree@@@sse2@embree
AU?$BVHNHairBuilderSAH@$03UBezier1v@embree@@@avx@embree
AU?$BVHNHairBuilderSAH@$03UBezier1v@embree@@@sse2@embree
AU?$BVHNHairBuilderSAH@$07UBezier1i@embree@@@avx@embree
AU?$BVHNHairBuilderSAH@$07UBezier1v@embree@@@avx@embree
AU?$BVHNHairMBlurBuilderSAH@$03UBezier1i@embree@@@avx@embree
AU?$BVHNHairMBlurBuilderSAH@$03UBezier1i@embree@@@sse2@embree
AU?$BVHNHairMBlurBuilderSAH@$07UBezier1i@embree@@@avx@embree
AU?$BVHNSubdivPatch1CachedBuilderSAH@$03@avx@embree
AU?$BVHNSubdivPatch1CachedBuilderSAH@$03@sse2@embree
AU?$BVHNSubdivPatch1CachedMBlurBuilderSAH@$03@avx@embree
AU?$BVHNSubdivPatch1CachedMBlurBuilderSAH@$03@sse2@embree
AU?$BVHNSubdivPatch1EagerBuilderSAH@$03@avx@embree
AU?$BVHNSubdivPatch1EagerBuilderSAH@$03@sse2@embree
AU?$ClosureTaskFunction@V<lambda_00727614aa193b14703250a115bb8c39>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0079212b3ddbd8745611cce8e85a936a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_00e03fb6325f0101a3dca39c55b82573>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_010e0574d9fa63531e8f47e9f8cf836d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_01f92756ba40f1669b003f05ea64f16e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_024b7f1dcd9077a1e4c0f006ed185dbe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_02a97af09a1ece19c3002713188d71b2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_02b4535950151687397e1767c8ff1730>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_02ef727abba9baf050cb44766040526f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_033f9f74bf714e51cea83fcb31a49a4a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_035848ee7e784bda1d4f15c27f65a3a2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_03c03cc506e5e34ffe4f9a0d960ec1e8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_04d6e1d8434c6c6a3a15542d10e5b484>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_050b646956caed7fdaa67b1d4ef38836>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0524eb59e13f434278e10891f0b91e31>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_056f1b340c3b313213fbc393d63ba36b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_05f7f128ee7872304d5d7aa2902c7d91>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_06354bc56ca261bdf4726ce4762ec487>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_074f612bd59227133ba9e0f474b0e221>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_078885fd1a95db7c569784819c9f39e5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_07b078d399adbf3e97f1470c5ee51bb3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0843bfad3e1ebc03663becc40d98cdee>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0888ba26503ba0f763cecbe734e1771a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_090fe644b001a4804259d5fa5690e787>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_094d4201ec4160ac75bac6cfee668abb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_09536d372b75dc3a3984d545a59d4432>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_098e576495678e7460c89533466b4d8f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0a5d6f00e92d274a3f35e95b3afb8ac3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0bdf0e4de8d79027c6ab431d534bc1b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0c0c5adf30281f0aa9ceb59bcf67c50e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0c1875bb629a7a5979b5ccb734fe7f0c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0c59624570b9bf3ef3ce99490c60c482>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0d3b0622ebe9e303f5b3688dc36d2961>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0d9816577c66ed0e5876af74f65ec1db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0d9ca2543338f979ac57e25413f49afe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0de4bbc9f6965c7f6b6b7f319eb9ecc3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0def0b62fd5dc518a73f30dbe27c151e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0e6f7eb7d752f4bc7a0948cbbd0941f2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0f63a07e52ba288868b0a7d36503d0bc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0f7d48f0f13c849ea2f5d5d06cc32f61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_104a0b3f03d43920c888c35c46aae093>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_10edfa8ff134489e84f7d6842fbc9e53>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_110b81e12910ae56f9bf6176e979f1b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_117eb0051cdfd32fb1f2d812ac6b4cf2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_120f0bc8bb721f3115c81821bb929341>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_123182362c2a73eaed6ded9518f65c61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_12bf1f51af4ce1c02e5d497e2bdc6046>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_138b9591e49b2888887ac9487092c177>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1393b5adec419286175685534c302c36>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_14a6a369c0ec5da4842004953696788c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_14c24d839fb2330f944934ffb45cc5f5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_15165f876bab0eaf99e58ee4e810ba04>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_151c07742b89234f5d191d6d1f364ec8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1538973e99550adc78028ffe9a574a0c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_16686f0a1d8ca697bab95807470dfd0b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_16bd739913477f65c3b295a4a9a3f780>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_175d320dbe5f7aeb321af608022b585c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_178c89f909790cfca6eead30b8f1646f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_17e6ecaac71b0bdba4217501afd1e0a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_183a2c3a7c55988bc7b50d5d84c7cf4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1880cd30ca9875de576e86fdcbc9aea9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_18bb6897cf4f0221c942708f4cea6d39>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1a1e99c71a49b4971561b09934ad67fa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1b881d296a37095bf2ba4916f5766bb9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1bdc49e25e3be253c96433cfcd0c476c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c44939038d58f165566885fd84cb0f1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c7d7fa76e2ecd4691d00f6774bb98cc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c8de36b5cd957878c703d3695f54c34>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c90dc5a491e3e4750706ff9e754d57b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1e4859f33cc101bb139d2d68512ab37f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1e5c8797227e1230cc67b3ff66103472>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1e6dcd6d0aa98232565903bdb19096c1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1f46050e6def5493d08d82c4c48bdaed>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1f808a54aacdd9e680ff9f5f639e0942>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1fc9d08cdac8fd12bae7ee1471fb44cb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_201f19e08e2c747d6e0be5045015fa55>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_204d86ced2f23a82c36fd5491b168795>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2063c310319b66d285af5f8479ce2c23>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_20b5444d8a71999ae45d694a70987844>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_20b7a01addee53bd0869dc9f5d292022>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2238d15c00e015c417c029c44f77a5eb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_225b1fd8597681675a712fa1b427bcf9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_22c989a7f7f9cad4f3a00bc5c3b88e11>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_22eff0194c4959ef284bfa4b4420e48d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_22f62f46daf7ed15abbb65819a63bdd8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_232f736fe4aa52e942e9cc65d3c4dfb2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_237a8dac36ab9cef0f09490973046d65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_24240202ad95757deb8d0dd0c0226c8f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2490c3d213371eb204cb084a52f2ab76>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_24ea089fbc87c35ba04d5a0bb8276d5c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2564acea42ca70f5289378535b1a5fda>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_25818e8b46e81478b20a71647dce67b0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_25ead581555fce50dcd5d14679e1cd9b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2639628081d1ddba289477eaf6dc1235>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2677d45e256cbc5245133bf19d977731>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_268ca72f02fd37d3e92b9ef05bba16ce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_26c6da919e4172ef77c2fa9ec98bc67f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_27a6add7901883689dc3a87b58fab026>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_27c91a095042b60e69d6859e08879426>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_281a5ded969e9b201062e179d1ac7b8f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_285ac3b52302746f3361555965dd87fc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_28a4ac0c239a99db152838b8ec1f8066>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_28bd0d9fb52e4cbc5b8a8d150267130f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_292077e7a78eb317a06f7b99ceb6cd81>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_29e879a70a5c87ddad399569fa292fec>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2a504d3eb34d360a2972c340ac9860d8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2bb301f1893ca03b9f0c9ac3c8ea60ee>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2c3dd22c2f093695bb553ddbab4cedf8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2c54de8bf13bc5b2c6a49258613a0f9e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2c5572af198b37fcb199b4609a37bae4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2c82bcb6ca326d2b323f977c3d74a815>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2cdbaf800cff23a84e8cde4e5febb7d5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d423a668fc9167849f38a0859c3f936>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d4f244b7e192fa43e226589d452c701>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2eebba4634f99d4722efcb197e612f81>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2f1a84cd769cdaf119ff64e0db1ac73f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2f4fa6b6285509b657a9a1146c780880>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3008700636587259a92b39df23550bd3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_304a01b373a60dd3af9215cee853ddad>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3150c976d5fe52c1d4fb75cefbbe159f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_315a5f94a797c655380ee80f871e063a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_31f0093011f3d21bde164e3064e7cb5e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_32f81e5255e62bc533a25a851f1a46c8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_336c76c3ef0ed84834422a1803047961>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_347e56008af4ec01e2820ec4891300fc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34c14151fe48f82f073e3146bbecf687>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34ef3d7f3a0122efbce2cde76bafbedd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34f6c0c15de95f59ebc592d1a646999f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3503ed049d2edd4e5874adfc7e17bd41>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_357682cc18343631cbd24442d11672ff>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_36217dcd2846ea9faebca7fecb8e09e8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_368faf6ba102d673218276ecfbc34444>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_36d192ec4c56e9df0060dbd486f9ba7c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_37ccad2be810a26706c32ec205e3bfa4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_38102958105071310bec2866fc97f17b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3843b5873c6887574f04d0899f0b0ca1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_385ef1f5866c37445e92b2e612cde63e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_38b40d48bdca78afa7f2ba1d9fb5fb68>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3919d087ca501e9c974714d021e3f492>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3933d8f0ccee8bd1455682f74b24e921>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_394c30a0d2d6bef6a02f98f3ec956faf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_397758765b2e0a90bf182776ec8f383d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_398cc6c4cbd0f6645a81e8edf8881635>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3995f7f3ff9f8aa213e35dd6e4b584d1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_39c10d416ef7b7edd0c9a617cbc87a24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3a36e867893211ff204520d9f83438a4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3a3dbe47c1375d6c1635f4f63d0e3f06>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3a6e8ea7e0c564e22758a101d75437a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3bc5ff048e1e2f476b84543661427626>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3bd0c96da5514a2302191768f990c5b6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3bdc883fa8b5d9f7ceb854286e7a8f24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3becc4b17eecf4024543e5772dd147e4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3bf6dbbfa27fcd585f246e455d9164d3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3bf8695663c9222f5473292328766cff>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3c183140e38f6db62b774fd8bd404466>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3c2cc625f5005302ec7f0229ab5c21ff>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3c91c779d2b8ad958212ad48d1bc70b0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3ca9579cdb7256b7817ef3fa1ef5169b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3dc49f9a80eb9d6a2ca9dc4b73f6df9d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3e0c119e21eed2faf4a5a927b7fe8a6f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3e1e63f3faea9ed192fce447c4bac9cd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3e52b8c63300cd110fa13ae0b7c1cd60>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3f44841068e22b4faae9412767d807b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3f4fda3449f88c70dba9a79effc60ca1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3f87dd23b41205b9c070dc59b9ded898>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_400665dbb253fa214eea6b4e29950f39>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4019ef4b11105db1b5343b7f18c18453>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_402a737f13eafe9fe16d70ff6a894992>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_40845830eed773233b2942955217836c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_40cd012d320d6fc8444313e58e9c5387>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_41609da4b7e8dfd7b606fbb2e129f162>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_42713ce089d47d172c86eb872a16c9aa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_42c9421bc80bcd1f9404dc5e1edd0878>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_42d7c154b7594b18960527370e5bebe8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_438f53e966ae83ced9fe1a4007d07665>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_439ac24f2a80e91d590bc81bfeb47afc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_43e0420db8074c721f86496af5421da5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_44435ab5f31ea13282b6c81880f54208>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_445f8df142f48d9d8ae42f3dd108c948>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_448b47e8e8e7f72e622ed0c30fa5951f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_44af00fb44318d658e02c8c1625393c8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_454ff74e7bd73c27416d41d187b7696f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_45f4dc352239ef938cd3e00e6791413b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_460ed0c9b139aaca8b3833147e764181>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_465d9809cd37bc684c63bc392b1a8d43>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_46764d6fbce053dd828f081e535045d4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4700bfc19b336e83ce1658ccfdd47769>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4764ec3910e02f84ce45742b3c0a6827>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4797e10b6095be151daa3dd2136024b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4849abaf079798cf4c4c3538babc64a7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_493c4fcd97d59cfa23518cfe7cef909b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_496aa81bb5d799d54bef11d25fe5a08f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49fad9e0f38466a9c4fa2209c0881a6e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4a59c69664a4a952c6b6dfd777480571>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4a85bbaa2ea6c0c395ffa4df429a50d2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4aabb963d5464f6657d45f99c2909342>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4ac0b297c5d9e9785a7be9f3b410c3b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4b29dba0e571001138ce2805a793f4a1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4b2caff77192f9bd6a5f736f85148b5e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4b48f40d8ffc225a46070cf025ff1350>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4bc4f243a38d1296acc9d6ce05d361b2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4bfba0a08514859d0b8a7d2b45fbf4c9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4c09c780d1c23c4be6ef9f0906c92c13>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4ce5fe55aaf0bd438a7ba072bf8c019d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4d9cd9f3cb3e97c00069e615a701f820>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4dc969c963ee779b95cdee2f0dedabad>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4e9a920d3a0e8077c04dbbeaba34d69b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4ea4b82819444dab34df007937df74be>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4f1bdd31251672f3b843c56d15162dc9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4fd58b3c6013f03ea35ca46867f3926c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5040f198f70fb7711905cc6364b27149>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5141d5962fbafa4acc99acc0689990bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_518bc669f26eec5ef49b6e111938813a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_51c09c7d2e87a3d1c6f598d9c7fe324b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_521ce67d9c4514d2cc90a13bfa229f45>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_52a975c5d818e1aef59712ece57a43db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_52c1f1021399b9956ed81c595c4a482f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_52fe7e542f21e2dbf7b6b976244fba56>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_531b78b0b37a365efe3fba1f831e2889>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_53b050396b412cc5ef049e5daeda41ea>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_55c41622391e31e083c414da23aa48b6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_55e84305b391b88d57b672ca7631a1a9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_564de4b1bf9631effeb9e4c080275993>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_56b23de10179c22dcffbdc3a19ff0b7e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_56bca96278a7550b70404d5274c2c878>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_56c0df1b74d1d0bb7ffbe50396fd4b63>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5728b555c81fc25a70e6d5e081545611>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_57bc994bb03940ae16f168888284b8ae>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_57d713aafb36025bf4cf7a8d92e0486b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_585fe2c1531e50d592ba659fba91f7ac>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_587c3387fd00b5c47d777280f639ccbb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_58e30b60297f435bbf9cdbdae941bf5f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_59708c2094bd10121cdb0d0feee13575>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_599cfee851a096ec60cf5ccad2f25107>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_59d69d6f0bcfe374748eecd67fa6773a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a0524ed438dbc7d7d456d8cb5a33703>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a1ecd293af6fb614e6230a8f0d23e86>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a2d306f63e66136301b8cb97ab48878>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a6267377bd15686c07f0b220b0d7129>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a6a4b649fee3fc11f6c99f5e6a302ce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a6fd1460cfe0c837c6432c6602575f2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a98022d81a7417d6c4235d589f91c11>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5aa56128e576631053ff2d037a1b307a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5ad67ec739a7b327b16e1e3389944b66>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5af9560d247ae45bce65b927bf3b9284>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5b1bea156177607a441098c4f1d06950>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5b205f904e6a5e922c78b0780f6595fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5b26f6db740f8f05574d4d906b0ad90c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5ba39d52cb3c4116d4adc7c409109432>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5bd8002d7e70632c9d53b643682799e4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5be9eefdde74c88b31370c58795a6e7a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5cad73db1ee851f4f913c38c67a28cfc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5e91cb3d62b3bdb46c3a8d3fd4576006>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5ef1383cfa4a2cc4e3c1fea52bd42cb5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5f057fc8dd507ba4420188be12b864a7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5fb6326b01f26cf75c708b7eb3c9251d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_603808f13bbf46796717eaa7cd0aee75>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_610bbbb59e52e484ea2ee2f65e12a1fa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_61398a8ad9e1c0de104feef5bee854a2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6210dd25d037f5c0c5e052d65e6c7616>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6217917626afcc35bf6b1b5c672f1784>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_62818b8ef3899c0b3c69aa532a9c7601>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_64a975ac0f17570b2341378ce2b6b3a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_65891ffcc7ec5d14cb2128a797b8237e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_660a4af34481ff2404ff8ce0416f2856>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_662edb52320f7d64486c211d709d24fa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_664c5c71030909c576c7574ed5f92836>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6745af9a1f7e729993c8d7ae28e56888>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_67ad3aa8245870085cdff7561119dd7f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6889ad526bb3457d81ffb63c079eb2cb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6938b06a3a496d9dd5443c305726886a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_69517119a4f97ed1b711550db189e639>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6993f47fcb2b403df84931c0d88124a9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6a4f9f009330b23e069b3540a0f5319b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6a7e386fb0ca09b97847fdf14bf2807a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6c3a1d4354df0582cb7f39b0431e404a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6c5a78468d46624da02f0d9e019e11dd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6c5c51baecb7b6a555662e3283943375>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6c7694796be8b8634a524b2a54f66a4f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6d304ef76d443622f7113c89b5e51d41>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e12b1e7ea1c3cabb970d9aad37b880e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6ed41f301f36454bcf74e1932375056a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f0ecc6bccaf11389d3ccb239220d7c8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f1e52204c97eb4935ea096adee98865>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f395463036b9f2ef27cb319ec541679>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6ffea1e26fc61475c82a269c9412ff7c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_705a85847bb356d1fe1a7b9b1d54a163>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7196ffdce97f54e9760df13dc4a464fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_71addab47ece46a645d63e9bca1976af>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_71b2f61402b431d654b8bb1ddddfac43>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_71edef998c092f48d46251d73a66d545>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7202ca434a96b832fd7427612591ecc5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_722e0962da9d42930847db48bf0cc553>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7254dd110d87e96462d1ed568cf9e9c8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_73bb2ca069658d4b951cd7abc1163703>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7433e9e07eb02c26dd3683e0f91d498c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7510ba17ca2a29465265361d9277a724>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7535455a612d961cb7762c61b8ac75a9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_75a2e87de5b3d6c19d02897de2e36716>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_75e43915eb115ebf9a376ec9124dd104>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_76400dbacd0747deb3febc189e99455f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7705a536dc6b9ab5337a09eeec4d1e6f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_77f6450d95bd8064e78ce0066285095e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_784452e75b8960722c95b74f4eb9a2f8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_787305e537b4785cecb099605c563cbc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_78c7d0829a272b947fa4f44fefcfcdbe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7926a52cb91716c6e9c7b46e42baf2b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_79f42c2b6be1040e0e17a524f68194b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7a50d96da7ea682c9a73859df64ab77a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7a5e01c5d6456c480461a33d9a226dab>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7acaf74d0c107fc106d4ca00aff18ad3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7af530efb09ac0a147c40aed31642187>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7afa72d7c22e157085fe8ba331f5ee84>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7c247d75d5584eab5859e56c837b5d10>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7cc4d544aac62649560791f9550221aa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7ce6ac932d597a37a713521393cb88dd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7ce74b1ec8a954ae473913662bc9dade>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d13bebc2f076de4103def33919a378c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d177b4737a974973408296c50a61c59>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d55766e0e469e727c2759ec695e0f7c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d9785477292a4fa1596197114fae097>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7dbf2b53c44747423e75aea34b95d82d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f03c5f9bc9ad8ad8ab436cb6c8e43f8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f5034a00b64803d5058a5fe10c255b2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f6f702b7fe49cad21de4c21b34f8d0f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f726af7e9c507833cec51d421e2c510>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f763bf19756ab4360666c9dac522e92>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7fb192dd8045681aa1ce0785efbf13e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7fc5686e97dfe5e50b8082defb2774a5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7ffdb4b2275c5857c9368a81e1c7833f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_80b65a1e2d64411940fa56670e7e02c6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_80dccd5b674c413f2371e2da68a9889a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_810209ba1c5ac9bb358557cbdd396b42>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_814dcbb698e5477c0cd2d52210df03eb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_817577d3bcf935817ad0bb281f2c5995>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_819f04f7983925af6f5abe746452fdff>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_81ba5e6dc6893469fb829e3e5ef5606e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_81f572e300a9a5430ad6dbd7814d51fa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_82f44bf085fe83988536c56ffe856489>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8309e65440b9f0302679061baa315188>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83743a4f871b15f1a702394e12997bf4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83a3b0f98c03e48c698257128811a288>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83a7c2f6b5ff8e257e1b732d645dc29a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83b875dec9f89e3bd59dba30d62e4018>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_84b6c724f2443266e7ce254992f9c5da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8535727457d5075fe99cb2a70fe5df2e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_864fe1c42ce97edbb4f99df8d0bbd480>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_869ce95d276aa5f0e5ad098cae581aed>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_86d8b9c789c03bfa5157975756ab13e1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_875710cf045bf724b2b6c67f332a11d1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_87f0b905dbb71905b3a252f8f6a41cf2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_88052a6c259693fe42eed27379cfacb1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_881194d5bcdf56d290b5a3890c7a7fd9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8816d0e2e07df46aedc86472386cd155>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_88815198c2a58dc16ce4c22605b79ab2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_89380b23a5122e9ed1a186ebf787c219>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a0d0e1a26bc2e612400cfbfc52d4d05>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a6f7d40767aad6609d3ca0b66f1dee7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a8a13518d5c58d3551e7c4c35ae9a76>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8b17dfb74e4f07741007f7a1803573d9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8b8d7bdc0350d5ca99ff86da49d813c7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c6c15c8f7d95b65109ce13171713e3b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c73507aad286028b6059eb192af892d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8cc2b536a046cc8ac89776f7a665e528>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8cf17f0003b91a8c47ecc79c6e95f40a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8cf8b2f923405b916cabfa24ed4e30bf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8d6431937acfa2b8785ee46f0b152579>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8daaed72989bd35f4c86fc214612958c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8ea43531e6c9a4721f268f5d9570f320>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8ed031d58df0e78a27ef623119673e80>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8ed4786fd66e0a9e3d71e8a1fc3a8c3d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8f4468cc3bcf8df7fd22d4e490737392>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8f503f9def87b9cca2bae293487c8550>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8f9b602fa03129a7ea6dc9920825ab46>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_902db867e351b9541a6c53e23705cdf2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9043d4f72a6c306135b867210364d128>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_914b061034df664197f53fa73f4484fc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_917d66d1e554d47fe65632b645af645f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_921854c5e6170b5d0917111ee012fa4d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_921de3a05999a1e539488ddb1754e629>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9249e8aa16a2d29a7983072b56338515>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_925f4d133894d9d36f414de19933eba1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_92c14606664f951fa492bd9fd202dae3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_93e34ab486724dbe759dde9e4d0b6856>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_943576034df25ad54b025192b8cffb10>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9579d629f7027e0f820dda5ddb6b951e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_95c0aedff85433a8de546a5ae6edb094>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_95cc731380b2fab9d8d1b177110fb7f9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_95f8d3acb587516d436898004657cd0c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_960aab8825076d1b652aabe877dfdfad>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_97dd86322bd219adde160d8ffc7291db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_98bd49c24585c5059e0dc2c6c3e766e8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_990c779232bd977a2fdd16b107bc03cf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_99c9911304bae8176521fc402b5ba162>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9a7f37be5c1ad52f9340af54cb35ee00>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9aca0f6540e6642090075ab469571ba7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9af5f73e64fafc9195d92f88a44f6375>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9b3364620a94ff9819438d0276559261>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9b519704fdea93cc8da87b6deaf24dca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9b9e7253ad6dd547aad239c66b5bed06>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9c35fd2a8037960874cc1d7ab44a2f88>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9c40f5a99f7f6f30c3d60baecce78d4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9d48138f6d7ea1b171757f4117bb9409>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9d5acbc953c6e71a67dd8de703f4a388>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9db83e7e70a7c8ba33a06ed4b85b3976>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e0dc55079d5915cdf39e4e0689defcd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e1b0c1d4f37825716630f67a2282b86>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e3935a442c74cd8c324a8e6f6130286>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e9848263c3599815ba8b73a69ce2700>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9f34415866d1e974a6847985edd6627e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a0824bb0b9341e49525eb60e9168f890>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a1768133f30e50de9e88b7cfb99cd83e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a1a1e92c5870cf372937cc6fdcc7f51a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a1cdea1efd259319f5c615570aac8523>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a20a7cd3b166750bfe9a7917ebfe484f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a22cd002aa951bf3d1f04c271d866dd9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a2411fbc768b1127f34cffa5d96f29de>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a27a77919004bebf2ad3897c05a8bcfa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a30af543c2e0aaf277a74d0cba24479f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a348f70b88cc1c2e907654dcde6a8d53>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a38927f86d3176cbbdb7f80dd5b0a8ec>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a3ada31bcf3a9f0fadb409b1f0893349>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a4208c0a8979a608aca52e893a4df9b8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a502243adff14fa4ca01b1d33f9684e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a506632a0478e305a2a9e0fb82c9a6ba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a52c2e7a52921bcebcf347831f82d5c6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a59a3d2e8d8e324b6655a1f42cfc4a5f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a5e979f25614f353000e5d2b0855f93d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a66f6428d532bef6c55e3ba92c600fdc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a69b3495a54f013f442137d360e2f1b6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a710457c22bef8673725e813b6f07bfb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a7b5469ed7bc5f47eee8717dd69cf795>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a7bc2963e36297ba0cf57fe4092d39e8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a7c826f3e82e808a18562b298e752e25>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a8117f21608dcf55d0f91d1b429156cd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a89a46fdf7c50b7643090e23bcf0d624>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a8b2023aa1b4d1a7199f8af3bb7763ee>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a949907e2b1949f142d0de22cf2e6912>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a949c6200b52f0b125eb7db102d84c94>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a9b8f854d4747416f8c42abcbdac47a4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aa8880c2b1359cbdae4ada69e7d661aa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_abccc4ccd8ceb684994842db279a3241>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ac78e1351597c9b210bbc64d5c67dfd5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ad1709fe169598d69589a6b107adab77>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ad9ce3f03f60b9e18bfee3e3dd0baf65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_adacce0f9416d02b841a4cd8506626ae>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ae421c411f4b313954fd7d20bab1ced9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ae69be045a714a9e42acc665d432a40e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ae8dceb17daf14cc5b0f12f8aa15d572>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af04d385bc9c83d170b5f5f16e2a19d2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b01601f1fbb2c422d13b886eaecafd45>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b09cab66583fe345fb0070b210c42e98>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b1b2809f1a86d6306a4dd04d37c8ccce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b255a1acc9156cab5d021df2a3782521>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b27e0ec0f8bdcef4f63be8e1e34cbdd8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b2f92e09f2317aa70587e755355db620>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b32bcb440d3673b8990f304eaec37bb8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b3c5fe648db78053f48b242c27df9697>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b3efceeb55ebf3757311b76215fafc06>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b4cd2aca1bbac98ba795a14d230855ce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b54f90a2ba8f1a05cc380aa59604f334>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b5fb09fb5c2887e123e5a137db6745b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b7350302d51dfa8cc5ce0a470174de2f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b74a79d095d5a50412501474799978f3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b763c0412907f95b2fc76b2c069248e6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b774447057103998c10802750b81022e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b7a4de5271a5815b20c6fc21a557e08d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b7b7233e04244ecb8bff03fe12b2d345>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b834f678e645cda14abd52da0200c1b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b8dc84b19129e7e19b1a01b71068e3b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b8f20f256466d2b811e0f961a5c08989>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b9a0204969d59174d65ef2a9f3dcac29>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b9c1a3f2cb89939eb64be6f13bcf0055>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ba0069a5d9713a6afd0add0241d1ad58>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ba11a5935e2a0ad0f5b0151297439f49>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ba89094546527bb5b629a0a485cdffc7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_baf7c96c352f3f95b2758e26cffefcf7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bafb0995df5d06226cad3960d0b05f8f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bb0c234d6323ae662a95d1ca167bd9e0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bbb9b06a91acbe8e1caac4de6a02edbc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bbcad67226b2e94a2d7e3925d7a6af04>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bd00524397062dc6d4e20fb4f00b31de>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bd39a3a5ccd3e6867cfa10c452b4fca0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bd44f00a06da24c73f8a5a3fb10e100a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bd9c228d2453fc98ec80c3c330dc4e87>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_be7f50964f1f705c689bfcd0a3371540>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bf7de9a504d037ad24edbdc46b15fad9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c078e5f8e2b86c97f39c6ab21160852b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c0955aedf17321d1ddb93318daf5508e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c09e0df67468d3b2b60f757c49fc89a0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c1a2d3426a39302e5fc0bf9dc152eef2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c1b8d624c00228d996df1196de08c9d8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c1ff65aa81b9e050dfd442d969493b20>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c1ff80f2ce7780723f74969c22f185a5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c2280ac99a9ae84605b08d171f06da58>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c2cdd3d7182b6d9efafe4d32945b4e33>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c3098d9d50a2889091ec6a56c8974d19>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c31ed38c92da0f0af5655254c8f6107f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c36c84b6bc2c81fabea62cc5aa6fff9e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c3b871ba619538cbf13acb8f6887e7ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c4c03e8578e9f43a1670b8dbeb0ba279>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c5b30c68d5aa9d93b16c30aafe727cbc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c763ccec0437d264bf897738bebd6088>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c7a2e929408f0fe05b554ed2e2c60b4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c7d6e3a01ab6b20f72e75237bade2e7d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c84f64ce8cd5acc734edb89a7325517d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c931a6ba565fddc960e7577814245717>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c95af42c833f8d07aabeac8d4942d8b2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c9d47d2a6c0ca0586e511764ee2a2660>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ca3dcfa697a55408c605f1382f88789e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cb0b673290f3ffb7b0d9066c6ab85b20>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cb3462bc78f37b419e46ec70a21de20a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cb77eb499fb610ae121ddd493c15dc8c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cb9eb83f77269ad229ee8eca631842c0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cc0550cacd0e26dcbee934735dd7c566>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cc05cd0245d907d289b27079cf3006d2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cd93f68efd2ea073304d25d9798328d5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cea7a13f240e46dd48f28025473d645f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cefc669779302b8832c5890ec0712bcb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cf58a1aee42c79cda68c62e4a6435c1c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cfb4df5bdda74f8f01e37a4dd9fb02fa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d05aca3e22c6432019cb3ce0957fb9da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d10fcda4176a96cab30af4ee472314a1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d17109694e3c9cc0a13b204f712bd8d1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d1837da88aa491f37f2fd4712e074cc3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d1a3c92959ad5a4ae6bad73a737c8ea3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d1aa5966c6b0f9baed433e5ae134fd3c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d24f14bb1d7ad3d3629aca73e884f297>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d2d657a84635790daa02f3fdbbaa6452>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d2e3d31d8a8cd389a6b3b37a5868c890>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d3169a222c4e1c498e79007f717be061>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d3a79ae9a7c795bc21fe0a5439608329>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d3d6aacb1bd398f95be0fbfaa36c1417>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d5bece6c89acbb8df90d8ec123eac904>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d620ffeea6adbae30b98781f8cbeae76>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d6ab2fbe324757bca3e59c679ab4d637>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d6c74795314111aecbd701850ed1e1ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d70841043b76c4196fdcedc5a486db1f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d83a620e72a2df6ae99237dc1b138676>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8b0e877573f60f5c7f98d41b6e912c0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8bf7531551fd906ae24fcffe76011e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8ece633b1894c61c1e0ae53793ea4ab>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d92359c66c55a70127aefec480c7e11a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d94852c296e2fd2af06c68d8a6d051d1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d99266d96c7f6b0fb060b432db11d2f8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d9be18e87487112b5332555887bdaec9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dad532609650176d4ceb3eab9a0bcc4d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_db178e3416e91bca00b2d14091a8170b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_db967712e71caefa8e33936d55982bb9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dcde766fe97c484418f6025de0162d98>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dd60030835f36931c097bb24abd7f9f5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ddbebbb160a6ae81d704f9af51105e8a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dedb486250e3e63a7afc247feed19afa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_df8c1754b72bbf87f122519bb875c90f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dfd5a53ca3ab3bd5635463a42dfa1723>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e03b19d5759904d96c11cd392cb121ac>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e0518c94692270d68a8bc445c176346d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e0cd4179ccb986fe30e51c91dbfaf4d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e21f118415f1f156e630a92647bf4aac>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e33fcfb80239c082170f2fc0adc11ce8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e382abf9b0a6b49cc975c5a18960416e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e4a9f51848acb5fb71ae488b2fb032e6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e5301accbe5bea464b80aeb68626b593>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e538107ac42333aea629f17d4e98f07a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e57246e5a30fd9d64427031698efc15d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e62d435ebd54a98109efa112f9ce956c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e65a7842956ef3a3937e93191cc42d4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e77e16e52fdae1c267ee76475bbdec72>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e836342ae4af7b2e85a7d855f8b01cf9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eac977bbfffe53e4b74535a02900a3e5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eb39a86fdc1d670220bbfc650ffc07ca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ebf517599632e53ba0240a81d2dc38a6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ebf7bfcc2de3cafd194877039f34ff84>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ec4c8c147918a8d768009fd5b551b5ed>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ec4d0eb5b6fed30b55121dbb7767792c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ec780c65afde2a9e576c356e72cc763a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ecaf0da6470494d8972033a51ea6668d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ed06d57402fcd4556726013dcd304a80>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ed23203128c93fb16e43970b11b30a70>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ed441f54edd89643f6a300a261b60b72>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ed6a9e367534bea0e3dfc8df4b633b9c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_edbf18a8d1047a48b98c44feaec8311c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ee6601152a28022af3746782b7f6ab54>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eea41e83b5826c7f8513485ebc45336d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eec4454cb1ad7a196228621ee7b26b25>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ef18f371e61c415367e882acb768e785>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ef2a3efe4c0a6a022def0cb2673d4c16>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ef3f298615dec5702bcb6dd80eb1ac1b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ef898ea2632144416495fe547276a5bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_efef4156e3a9fd6c22e1e9b93713d7ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f00b3e603ea11311f5697fa28b689599>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f035ab843647e98a8c72603effe69b12>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f04708e304e1dda45b0bc35f49a141f4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f15a7a7c656879bd1ca857536dd83145>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f176e0f30d685b750646c0a2baccf296>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f21411e49b7e92c2bc04fbd6005c1532>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f25be54770459a8bbeeaefd8755fad51>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f2d28e934df836c4657d899c89aaa0b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f2dcb02961639c56eb2ca22a991357d3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f36116f58a11e95be6bae72ab159513a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f3ac239f183ff2aae5b2f0d30fa11119>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f3c2c2050023a513ec2a079395228217>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f3eb69b11fcd9a25a8f712cf84755c70>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f3fdda649d5c6450d55761a9d69fdf50>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f4252df8df4f16215e54d17f5be48d22>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f43e124b8878efd414b93cc926abcda8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f45dc9a6f646ec1b7b48393534dcabb7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f530c43bb3d8d845162ac90cf4dbd834>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f61572c5e60fa44a1eccf0b214345c2d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f678e84645974562a0a78cd97e4cb143>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f6ac5344eba6547021cfaaad7e8b3141>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8811fe34ede6d660a21427044c1acba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f88463fd0457bc8a0d627e9556616632>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f88ae08a2029976ce7528f4fce7ce407>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8aed9c70924e61b413f0ef14704f70b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8fa0d76bf6846da50700a400af0a5ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f93a98053a99f55f5a76e34ae49505e0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9c9d2e87cd66f42c75f50f430def7f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9f0bab5d448810eee5808d354c2f0f1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_faaf346ec214df5d3eec86adea6bad0d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fb2a92d209d7c9c5aeedf613c461ee2b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fd3b61b076a6fda731f25479d1ed4867>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fd6b2199b544d2617ce4a20ca60b5730>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fd9a83c4b20252f5580c7e06f707c439>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fda3769582440d59c66ab3ddc3ad5a24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fdbd198e5b4ebd72dcf16140169c88c4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fdbfb1701e22648d1b9a5600b4eb1f8d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ffd78b0766bbe949c09c3de4b4e84835>@@@TaskScheduler@embree
AU?$ProgressMonitorClosure@V<lambda_094efb559f9074e245578e282cf551d3>@@@embree
AU?$ProgressMonitorClosure@V<lambda_0ea63e6d6bc624ddf04afba055282470>@@@embree
AU?$ProgressMonitorClosure@V<lambda_c2595fec36c3d9cdc4561b490786767f>@@@embree
AU?$ProgressMonitorClosure@V<lambda_ea627c1e1fac3114e131c584f117e9c1>@@@embree
AUAVAWH
AUAVAWUH
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@avx@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@sse2@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$07@avx@embree
AUBuildProgressMonitor@embree
AUBuildProgressMonitorInterface@Scene@embree
AUCalcBufferHolder@RadeonRays
AUCalcEventHolder@RadeonRays
AUCurvesBSpline@avx@embree
AUCurvesBSpline@sse2@embree
AUCurvesBezier@avx@embree
AUCurvesBezier@sse2@embree
AUGeometryGroup@embree
AUGeometryInstance@embree
AUInstance@embree
AULeafBoundsInterface@?$BVHNRefitter@$03@avx@embree
AULeafBoundsInterface@?$BVHNRefitter@$03@sse2@embree
AULeafBoundsInterface@?$BVHNRefitter@$07@avx@embree
AULineSegments@embree
AULineSegmentsISA@avx@embree
AULineSegmentsISA@sse2@embree
AUMemoryMonitorInterface@embree
AUNativeCurves@embree
AUNativeCurvesISA@avx@embree
AUNativeCurvesISA@sse2@embree
AUPrimitiveType@embree
AUQuadMesh@embree
AUQuadMeshISA@avx@embree
AUQuadMeshISA@sse2@embree
AURegressionTest@embree
AUState@embree
AUSubdivMeshISA@avx@embree
AUSubdivMeshISA@sse2@embree
AUTaskFunction@TaskScheduler@embree
AUTaskScheduler@embree
AUTriangleMesh@embree
AUTriangleMeshISA@avx@embree
AUTriangleMeshISA@sse2@embree
AUType@?$LineMi@$03@embree
AUType@?$QuadMi@$03@embree
AUType@?$QuadMv@$03@embree
AUType@?$TriangleM@$03@embree
AUType@?$TriangleMi@$03@embree
AUType@?$TriangleMv@$03@embree
AUType@?$TriangleMvMB@$03@embree
AUType@Bezier1i@embree
AUType@Bezier1v@embree
AUType@Object@embree
AUType@SubdivPatch1Cached@embree
AUTypeCached@SubdivPatch1Cached@embree
AUUUUUU
AUUserGeometry@embree
AU_Crt_new_delete@std
AUbarrier_sys_regression_test@embree
AUcache_regression_test@embree
AUctype_base@std
AUdeleter@ipl
AUfast_allocator_regression_test@embree
AUmessages_base@std
AUmoney_base@std
AUrtcore_error@embree
AUtime_base@std
AV<lambda_081ca0496a4617227558c690037022b7
AV<lambda_0b237fb88318a2c5a2569350bfa1edb5
AV<lambda_258caa2aa93fdeed38b7932ab14ce555
AV<lambda_498b6f04f2beccab8c714618b3ad669c
AV<lambda_500571d1f9d0a65aa1db1f219ecd57cd
AV<lambda_518c57bafb0abf8786f646ed93f8d4df
AV<lambda_62a9d32afc8d6b63df56e96e440ec261
AV<lambda_be12e81c125b702ef2e41724fd1f6d30
AV<lambda_d9cc229929455c8f29444ad9f7024193
AV<lambda_dff3c1b6999eee227e24249907461f6e
AV<lambda_fe89cc8dd20d17b87ff8094e4c964cc6
AV?$BVHN@$03@embree
AV?$BVHN@$07@embree
AV?$BVHNBuilderInstancing@$03UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderInstancing@$03UTriangleMesh@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03ULineSegments@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$03ULineSegments@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03VAccelSet@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$03VAccelSet@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$07VAccelSet@embree@@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03VAccelSet@embree@@UObject@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07VAccelSet@embree@@UObject@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNRefitT@$03ULineSegments@embree@@U?$LineMi@$03@2@@avx@embree
AV?$BVHNRefitT@$03ULineSegments@embree@@U?$LineMi@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNRefitT@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNRefitT@$03VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNRefitT@$03VAccelSet@embree@@UObject@2@@sse2@embree
AV?$BVHNRefitT@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNRefitT@$07VAccelSet@embree@@UObject@2@@avx@embree
AV?$CLWBuffer@D
AV?$CLWBuffer@H
AV?$CLWBuffer@M
AV?$CLWBuffer@Tcl_float4
AV?$ReferenceCounter@PEAU_cl_command_queue@@$1?clRetainCommandQueue@@YAHPEAU1@@Z$1?clReleaseCommandQueue@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_context@@$1?clRetainContext@@YAHPEAU1@@Z$1?clReleaseContext@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_device_id@@$1?clRetainDevice@@YAHPEAU1@@Z$1?clReleaseDevice@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_event@@$1?clRetainEvent@@YAHPEAU1@@Z$1?clReleaseEvent@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_kernel@@$1?clRetainKernel@@YAHPEAU1@@Z$1?clReleaseKernel@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_mem@@$1?clRetainMemObject@@YAHPEAU1@@Z$1?clReleaseMemObject@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_platform_id@@$0A@$0A
AV?$ReferenceCounter@PEAU_cl_program@@$1?clRetainProgram@@YAHPEAU1@@Z$1?clReleaseProgram@@YAH0@Z
AV?$Stream@H@embree
AV?$Stream@VToken@embree@@@embree
AV?$_Ebco_base@V?$allocator@V?$TripleBuffer@VOverlapSaveFIR@ipl@@@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VBinauralEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VContext@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VDirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VDirectSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeInstancedMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHRTFDatabase@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHybridReverbEstimator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectMixer@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VInstancedMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOpenCLDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOpenCLDeviceList@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOverlapSavePartitioner@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPanningEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPathEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPathSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeArray@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeBatch@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeNeighborhood@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VRadeonRaysDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VScene@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSerializedObject@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSimulationData@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSimulationManager@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VTANDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VVirtualSurroundEffect@ipl@@@ipl@@$00@std
AV?$_ExceptionPtr_static@Vbad_alloc@std@@@?A0x626bcf6a
AV?$_ExceptionPtr_static@Vbad_exception@std@@@?A0x626bcf6a
AV?$_Func_base@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_base@XPEAVBuffer@Calc@@@std
AV?$_Func_base@XPEAVDevice@Calc@@@std
AV?$_Func_base@XPEAVEvent@Calc@@@std
AV?$_Func_impl@V<lambda_498b6f04f2beccab8c714618b3ad669c>@@V?$allocator@H@std@@XPEAVBuffer@Calc@@@std
AV?$_Func_impl@V<lambda_518c57bafb0abf8786f646ed93f8d4df>@@V?$allocator@H@std@@XPEAVBuffer@Calc@@@std
AV?$_Func_impl@V<lambda_62a9d32afc8d6b63df56e96e440ec261>@@V?$allocator@H@std@@XPEAVDevice@Calc@@@std
AV?$_Func_impl@V<lambda_dff3c1b6999eee227e24249907461f6e>@@V?$allocator@H@std@@XPEAVEvent@Calc@@@std
AV?$_Func_impl_no_alloc@V<lambda_081ca0496a4617227558c690037022b7>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_0b237fb88318a2c5a2569350bfa1edb5>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_258caa2aa93fdeed38b7932ab14ce555>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_500571d1f9d0a65aa1db1f219ecd57cd>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_be12e81c125b702ef2e41724fd1f6d30>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_d9cc229929455c8f29444ad9f7024193>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_fe89cc8dd20d17b87ff8094e4c964cc6>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Iosb@H@std
AV?$_LaunchPad@V?$unique_ptr@V?$tuple@V<lambda_466ed8038b590a8d8bdab0fcad5ec46c>@@@std@@U?$default_delete@V?$tuple@V<lambda_466ed8038b590a8d8bdab0fcad5ec46c>@@@std@@@2@@std@@@std
AV?$_Mpunct@D@std
AV?$_Mpunct@G@std
AV?$_Mpunct@_W@std
AV?$_Ref_count@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std
AV?$_Ref_count_obj_alloc3@V?$TripleBuffer@VOverlapSaveFIR@ipl@@@ipl@@V?$allocator@V?$TripleBuffer@VOverlapSaveFIR@ipl@@@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsBinauralEffect@ipl@@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsDecodeEffect@ipl@@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsEncodeEffect@ipl@@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsPanningEffect@ipl@@V?$allocator@VAmbisonicsPanningEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsRotateEffect@ipl@@V?$allocator@VAmbisonicsRotateEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VBinauralEffect@ipl@@V?$allocator@VBinauralEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VContext@ipl@@V?$allocator@VContext@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VDirectEffect@ipl@@V?$allocator@VDirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VDirectSimulator@ipl@@V?$allocator@VDirectSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeDevice@ipl@@V?$allocator@VEmbreeDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeInstancedMesh@ipl@@V?$allocator@VEmbreeInstancedMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeStaticMesh@ipl@@V?$allocator@VEmbreeStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHRTFDatabase@ipl@@V?$allocator@VHRTFDatabase@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHybridReverbEstimator@ipl@@V?$allocator@VHybridReverbEstimator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectEffect@ipl@@V?$allocator@VIndirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectMixer@ipl@@V?$allocator@VIndirectMixer@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VInstancedMesh@ipl@@V?$allocator@VInstancedMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOpenCLDevice@ipl@@V?$allocator@VOpenCLDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOpenCLDeviceList@ipl@@V?$allocator@VOpenCLDeviceList@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOverlapSavePartitioner@ipl@@V?$allocator@VOverlapSavePartitioner@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPanningEffect@ipl@@V?$allocator@VPanningEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPathEffect@ipl@@V?$allocator@VPathEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPathSimulator@ipl@@V?$allocator@VPathSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeArray@ipl@@V?$allocator@VProbeArray@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeBatch@ipl@@V?$allocator@VProbeBatch@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeNeighborhood@ipl@@V?$allocator@VProbeNeighborhood@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VRadeonRaysDevice@ipl@@V?$allocator@VRadeonRaysDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VRadeonRaysStaticMesh@ipl@@V?$allocator@VRadeonRaysStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VScene@ipl@@V?$allocator@VScene@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSerializedObject@ipl@@V?$allocator@VSerializedObject@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSimulationData@ipl@@V?$allocator@VSimulationData@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSimulationManager@ipl@@V?$allocator@VSimulationManager@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VStaticMesh@ipl@@V?$allocator@VStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VTANDevice@ipl@@V?$allocator@VTANDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VVirtualSurroundEffect@ipl@@V?$allocator@VVirtualSurroundEffect@ipl@@@2@@std
AV?$_Ref_count_resource@PEAVEnergyField@ipl@@Udeleter@2@@std
AV?$_Ref_count_resource@PEAVIReconstructor@ipl@@Udeleter@2@@std
AV?$_Ref_count_resource@PEAVIReflectionSimulator@ipl@@Udeleter@2@@std
AV?$_Ref_count_resource@PEAVIScene@ipl@@Udeleter@2@@std
AV?$_Ref_count_resource@PEAVImpulseResponse@ipl@@Udeleter@2@@std
AV?$allocator@V?$TripleBuffer@VOverlapSaveFIR@ipl@@@ipl@@@ipl
AV?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl
AV?$allocator@VBinauralEffect@ipl@@@ipl
AV?$allocator@VContext@ipl@@@ipl
AV?$allocator@VDirectEffect@ipl@@@ipl
AV?$allocator@VDirectSimulator@ipl@@@ipl
AV?$allocator@VEmbreeDevice@ipl@@@ipl
AV?$allocator@VEmbreeInstancedMesh@ipl@@@ipl
AV?$allocator@VEmbreeStaticMesh@ipl@@@ipl
AV?$allocator@VHRTFDatabase@ipl@@@ipl
AV?$allocator@VHybridReverbEstimator@ipl@@@ipl
AV?$allocator@VIndirectEffect@ipl@@@ipl
AV?$allocator@VIndirectMixer@ipl@@@ipl
AV?$allocator@VInstancedMesh@ipl@@@ipl
AV?$allocator@VOpenCLDevice@ipl@@@ipl
AV?$allocator@VOpenCLDeviceList@ipl@@@ipl
AV?$allocator@VOverlapSavePartitioner@ipl@@@ipl
AV?$allocator@VPanningEffect@ipl@@@ipl
AV?$allocator@VPathEffect@ipl@@@ipl
AV?$allocator@VPathSimulator@ipl@@@ipl
AV?$allocator@VProbeArray@ipl@@@ipl
AV?$allocator@VProbeBatch@ipl@@@ipl
AV?$allocator@VProbeNeighborhood@ipl@@@ipl
AV?$allocator@VRadeonRaysDevice@ipl@@@ipl
AV?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl
AV?$allocator@VScene@ipl@@@ipl
AV?$allocator@VSerializedObject@ipl@@@ipl
AV?$allocator@VSimulationData@ipl@@@ipl
AV?$allocator@VSimulationManager@ipl@@@ipl
AV?$allocator@VStaticMesh@ipl@@@ipl
AV?$allocator@VTANDevice@ipl@@@ipl
AV?$allocator@VVirtualSurroundEffect@ipl@@@ipl
AV?$basic_filebuf@DU?$char_traits@D@std@@@std
AV?$basic_ifstream@DU?$char_traits@D@std@@@std
AV?$basic_ios@DU?$char_traits@D@std@@@std
AV?$basic_iostream@DU?$char_traits@D@std@@@std
AV?$basic_istream@DU?$char_traits@D@std@@@std
AV?$basic_ostream@DU?$char_traits@D@std@@@std
AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$basic_streambuf@DU?$char_traits@D@std@@@std
AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$codecvt@DDU_Mbstatet@@@std
AV?$codecvt@GDU_Mbstatet@@@std
AV?$codecvt@_WDU_Mbstatet@@@std
AV?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std
AV?$collate@D@std
AV?$collate@G@std
AV?$collate@_W@std
AV?$ctype@D@std
AV?$ctype@G@std
AV?$ctype@_W@std
AV?$enable_shared_from_this@VIScene@ipl@@@std
AV?$messages@D@std
AV?$messages@G@std
AV?$messages@_W@std
AV?$money_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$money_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$money_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$money_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$money_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$money_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$moneypunct@D$00@std
AV?$moneypunct@D$0A@@std
AV?$moneypunct@G$00@std
AV?$moneypunct@G$0A@@std
AV?$moneypunct@_W$00@std
AV?$moneypunct@_W$0A@@std
AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$num_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$num_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$numpunct@D@std
AV?$numpunct@G@std
AV?$numpunct@_W@std
AV?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$time_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$time_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$time_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$time_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$wstring_convert@V?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std@@_WV?$allocator@_W@2@V?$allocator@D@2@@std
AVAWUF
AVAWUH
AVAccel@embree
AVAccelData@embree
AVAccelInstance@embree
AVAccelN@embree
AVAccelSet@embree
AVAllocator@flatbuffers
AVBakedPathData@ipl
AVBakedReflectionsData@ipl
AVBatchedReflectionSimulator@ipl
AVBuffer@Calc
AVBuffer@RadeonRays
AVBufferClw@Calc
AVBuilder@embree
AVBvh@RadeonRays
AVCAmbisonicsBinauralEffect@api
AVCAmbisonicsDecodeEffect@api
AVCAmbisonicsEncodeEffect@api
AVCAmbisonicsPanningEffect@api
AVCAmbisonicsRotationEffect@api
AVCBinauralEffect@api
AVCContext@api
AVCDirectEffect@api
AVCEmbreeDevice@api
AVCHRTF@api
AVCInstancedMesh@api
AVCLWCommandQueue
AVCLWContext
AVCLWDevice
AVCLWEvent
AVCLWException
AVCLWKernel
AVCLWPlatform
AVCLWProgram
AVCOpenCLDevice@api
AVCOpenCLDeviceList@api
AVCPanningEffect@api
AVCPathEffect@api
AVCProbeArray@api
AVCProbeBatch@api
AVCRadeonRaysDevice@api
AVCReflectionEffect@api
AVCReflectionMixer@api
AVCScene@api
AVCSerializedObject@api
AVCSimulator@api
AVCSource@api
AVCStaticMesh@api
AVCTrueAudioNextDevice@api
AVCVirtualSurroundEffect@api
AVCalc@0
AVCalcClw@Calc
AVCalcIntersectionDevice@RadeonRays
AVCalcIntersectionDeviceCl@RadeonRays
AVCustomScene@ipl
AVDefaultAllocator@flatbuffers
AVDevice@Calc
AVDevice@embree
AVDeviceCl@Calc
AVDeviceClw@Calc
AVEmbreeInstancedMesh@ipl
AVEmbreeReflectionSimulator@ipl
AVEmbreeScene@ipl
AVEmbreeStaticMesh@ipl
AVEnergyField@ipl
AVEvent@Calc
AVEvent@RadeonRays
AVEventClw@Calc
AVException@Calc
AVException@RadeonRays
AVException@ipl
AVExceptionClw@Calc
AVExceptionImpl@RadeonRays
AVExecutable@Calc
AVExecutableClw@Calc
AVFileStream@embree
AVFlatBuffersAllocator@ipl
AVFunction@Calc
AVFunctionClw@Calc
AVGeometry@embree
AVHRTFMap@ipl
AVHlbvh@RadeonRays
AVIAmbisonicsBinauralEffect@api
AVIAmbisonicsDecodeEffect@api
AVIAmbisonicsEncodeEffect@api
AVIAmbisonicsPanningEffect@api
AVIAmbisonicsRotationEffect@api
AVIBakedData@ipl
AVIBinauralEffect@api
AVIContext@api
AVIDirectEffect@api
AVIEmbreeDevice@api
AVIHRTF@api
AVIHRTFMap@ipl
AVIInstancedMesh@api
AVIInstancedMesh@ipl
AVIOpenCLDevice@api
AVIOpenCLDeviceList@api
AVIPanningEffect@api
AVIPathEffect@api
AVIProbeArray@api
AVIProbeBatch@api
AVIRadeonRaysDevice@api
AVIReconstructor@ipl
AVIReflectionEffect@api
AVIReflectionMixer@api
AVIReflectionSimulator@ipl
AVIScene@api
AVIScene@ipl
AVISerializedObject@api
AVISimulator@api
AVISource@api
AVIStaticMesh@api
AVIStaticMesh@ipl
AVITrueAudioNextDevice@api
AVIVirtualSurroundEffect@api
AVImpulseResponse@ipl
AVInstance@RadeonRays
AVInstancedMesh@ipl
AVIntersectionApi@RadeonRays
AVIntersectionApiImpl@RadeonRays
AVIntersectionDevice@RadeonRays
AVIntersector@RadeonRays
AVIntersectorHlbvh@RadeonRays
AVIntersectorLDS@RadeonRays
AVIntersectorSkipLinks@RadeonRays
AVIntersectorTwoLevel@RadeonRays
AVLineCommentFilter@embree
AVMesh@RadeonRays
AVOpenCLEnergyField@ipl
AVOpenCLImpulseResponse@ipl
AVOpenCLReconstructor@ipl
AVPrimitives@Calc
AVPrimitivesClw@Calc
AVRadeonRaysReflectionSimulator@ipl
AVRadeonRaysScene@ipl
AVRadeonRaysStaticMesh@ipl
AVReconstructor@ipl
AVRefCount@embree
AVReflectionSimulator@ipl
AVSOFAHRTFMap@ipl
AVScene@embree
AVScene@ipl
AVShape@RadeonRays
AVShapeImpl@RadeonRays
AVSplitBvh@RadeonRays
AVStaticMesh@ipl
AVStrStream@embree
AVSubdivMesh@embree
AVTokenStream@embree
AVVWUSH
AVWorld@RadeonRays
AVX512BW
AVX512CD
AVX512DQ
AVX512ER
AVX512F
AVX512IFMA
AVX512KNL
AVX512PF
AVX512SKX
AVX512VBMI
AVX512VL
AV_ExceptionPtr_normal@?A0x626bcf6a
AV_Facet_base@std
AV_Generic_error_category@std
AV_Iostream_error_category@std
AV_Locimp@locale@std
AV_Pad@std
AV_Ref_count_base@std
AV_System_error@std
AV__non_rtti_object@std
AVbad_alloc@std
AVbad_array_new_length@std
AVbad_cast@std
AVbad_exception@std
AVbad_function_call@std
AVbad_typeid@std
AVbad_weak_ptr@std
AVcodecvt_base@std
AVerror_category@std
AVexception@std
AVfacet@locale@std
AVfailure@ios_base@std
AVios_base@std
AVlength_error@std
AVlogic_error@std
AVout_of_range@std
AVrange_error@std
AVruntime_error@std
AVstl_condition_variable_interface@details@Concurrency
AVstl_condition_variable_vista@details@Concurrency
AVstl_condition_variable_win7@details@Concurrency
AVstl_critical_section_interface@details@Concurrency
AVstl_critical_section_vista@details@Concurrency
AVstl_critical_section_win7@details@Concurrency
AVsystem_error@std
AVtype_info
AW&qB
AWAVATVWUSH
AWAVAUATVWUSH
AWAVVWUSH
AX:gex:J
AXH+APH
AXH+APH;C
AXH+APH;C w\n
AXH+APH;C w\t
AXH9p\bt
AXHc\bM
AXI+APH;C
AXI+APIk
AXI+APL
AXL+APH
AYAXZY
AY_MASK \n                    } \n#endif // RR_RAY_MASK \n                } \n \n                addr = lds_stack[--lds_sptr]; \n \n                if (addr == INVALID_ADDR && sptr > stack_bottom) \n                { \n                    sptr -= LDS_STACK_SIZE; \n                    for (int i = 1; i < LDS_STACK_SIZE; ++i) \n                    { \n                        lds_stack[lds_stack_bottom + i] = stack[sptr + i]; \n                    } \n \n                    lds_sptr = lds_stack_bottom + LDS_STACK_SIZE - 1; \n                    addr = lds_stack[lds_sptr]; \n                } \n            } \n \n            // Finished traversal, but no intersection found \n            hits[index] = MISS_MARKER; \n        } \n    } \n} \n
A[YƋL$0H
A\a9Ћi
A\b9B\b
A\b9B\bs
A\bA9@\b
A\bA9@\bs
A\bA9A\bs
A\bA9C\bs
A\bA;B\bs
A\bA;ŋI\fA
A\bH;C\b
A\bH;\bu
A\bL;\bu
A\bba|\b
A\bi:L
A\eP;g
A\fba~\b
A\nYL
A\nYT
A\nba|\b
A\nba~\b
A\ny:\a
A\rba|H
A\t8;:X\a
A\t;vk
A\t<&a0
A\v:O)3
A]A\\]_^[ÐSVWUATAUH
A^A]A
A_A]A
A_A^A
A_A^A]A
A_H<r
A`Lcw
AbYd/4
AccelN::intersector1
AccelN::intersector16
AccelN::intersector4
AccelN::intersector8
AccelN::intersectorN
Access violation - no RTTI data
AcquireSRWLockExclusive
AdjustTokenPrivileges
Advanced Micro Devices
Ady;.s
Af<ZXk
AfC`ěA
Ag5<I
Ah\f;o
Ai<ִv
Ak==9
Ak\f<\a
Ak»mS
AmQ,BP\a
Am\a9D
An>uCv
Anot supported node type in bvh_statistics
AoҼh9
Aq:UV
Aq:k\n
AreFileApisANSI
As< g
Asg<0gk
Assertion failed
Assertion failed: %Ts, file %Ts, line %d\n
Attempted to create SOFA HRTF without either a file name or a data buffer
August
Auu:L
Aw9/1
Awj;:m\e
Ax)D$p
Ax5;U
Ay<xeV
Aynt\f0
Ayn|\fd
A{A=dg
A{L.B
A|(TD
A|(tE
A|=T2P
A}oKL$X
A}oȉL$X
AƼCNϼ\fc
Aʼ;\vdb
A˻bC3<\aHN
A̪;VB
A̻fsv<?c
À:bf
A֟;Sr
Aໂi\a
A酼Xto
A튺r*o
B :;NM0
B :UsK
B HcA
B r/H
B(<t5A
B(I9A(u\r
B)bA|\b
B+N>ZaS
B+Q4\a
B-H<WP
B0;0=k
B0I;~\b
B0i9B
B0ɼ"7
B1<J\aJ
B93)\v
B9<ybl
B9dڕ8nO
B9ᑙ:7m
B:BbZ:R
B:\f0u M
B; rs9
B;"3J;g
B;(kW
B;0JH
B;Q医9
B;RbT
B;WO5
B;XNN;$9J;6
B;Y)Y;2N
B;ZwH
B;\bEO
B;jOH
B;peL
B;íc8hxs
B<;YV1
B<\t\r\b8
B<xym<[\nM
B=2}\t=Cٞ=i6h=JC
B=Jk8
B=R67
B>Bh9?\a
B>F\fE
B>\tSԽe
B>zZ\v
B>{Pn
B?d!\vY
B?d"C
B@bQ|\n
BB:;o\t
BB<.m
BCŻHl5
BCױbc}IC
BC߱bc}IC
BD>Lɏ<s
BD\v7
BF8<pjM
BF>XoT
BH;% H
BHI+B
BHM;J\b
BJ8=R
BJƼ{K
BK=\b
BL0<:;H
BLv\vH
BM<mcW
BM];Ha
BMa=!9
BMr:Km
BN9"X
BN:;lY
BNe<\v@P
BNi;\b
BOO<̊r
BP<p\r
BQ#"C\n
BQZ:K:G
BSp<fm0;\a
BT{zb
BUY:P
BUμVx
BVH4VirtualIntersectorStream
BXHc\bI
BXI+BPI
BXI+BPL
BXI+KPI+BPH
BXQ<ŊXy
BXm:|v
BY,T,L
BY\t>w
BYԀB8B
B\\s;Mse<\vu0
B\a8pUx
B\bA9@\bs
B\bA9A\bs
B\bA9B\bs
B\bA;@\bs
B\bH9A\bu
B\bH9A\bu\rH
B\bH;C\b
B\bHcEgH
B\bbQ
B\bba|\b
B\e>fH\b
B\eCW&qB
B\n:Q+K
B\nba|\b
B\nba~\b
B\r;Lnm
B\r;oN9
B\rV:9
B\rbA|\b
B\t;n*l
B\t=L\v3
B\vba~\b
B]\n>wZU
B`ěAi\\BB
Bad dynamic_cast
Base Class Array
Base Class Descriptor at
Bd#<miE
Bdefault
Bfڻm`3
Bg; T7
Bhba|\b
Bi'LCNאB
BitHistogram
Bj'?I
Bj:\vB5ڻBI
Bjûoc
Bk(#B3
Bm\b> H
Bm^<C\ef
Bn<pZ
BnB=^D
BnE;UN
BnI<Bb
Bpֹ=7G;Z
BqȻ"s
Br!<35
Br=/y
Bu<\a|p
Build
BuilderFastSpatialSAH
BuilderInstancing
BuilderMBlurSAH
BuilderSAH
BuilderTwoLevel
Bw:<F
Byź`2
BzŰC*!3B0y
B{t:6
B|nZB\r
B}ļ G
B~0GB
B~Z=Q
Bŕ\rB
BȻoH뻎A
B̻w\fлJ
BϻLd0
BЋA(I
Bґ<mg
BһR1q;\e
Bպ+TO
Bք\tAl1"B
B۸YI>9
B⽦qG;t
C 9t$0
C ruH
C rvH
C!p;l
C$ɺ12
C&:5Q\f
C(D;i2
C(H+C H
C):4Z\e
C);PNO
C);nnA;p
C*!3B
C+;87
C09p\btU
C0;^F
C0F;<\n
C0H+C(H
C0HcH\bL
C0HcH\fH
C0Hc\tH
C1<tA
C23;}K
C2j:v
C2u<ӐK
C4=mwV
C8;C4s
C8O:;Ŵ6
C9_S8
C9n,.;8j
C:&\fS9
C:/Program Files/libmysofa/share/libmysofa/default.sofa
C:70W:ﯸ7sK
C:GpK
C:\\buildslave\\phonon_deps_win64\\build\\mysofa\\src\\hrtf\\easy.c
C:\\buildslave\\phonon_main_win64\\build\\core\\build\\windows-vs2019-x64\\src\\core\\Release\\phonon.pdb
C:oMt
C;%La
C;=Db
C;L\v0
C;Mub
C;S\t
C;XDb;S
C;e৺HB
C;i,N;4
C;i{j
C;t嬺0
C<2sR
C<;C4A
C<CPX7
C<G;g
C<Tzv
C=8,z
C=B \b
C=M5)=7
C=\v8
C=p\eཛྷ6
C=z"d9
C>5x=h4
C>7hk
C>9^a6
C>\b84>eJ
C>t}C
C@H90t%H
C@H98t%H
C@H9\bt
C@I=5P
C@f91H
C@f99H
CA< t(<#t
CB';t
CC>/b
CD:\nE2
CG<UlX
CGj:zK
CH;\n
CHH+C
CHH+C@H
CHH+C@I;B
CHH+C@I;F
CHٹ`N7
CI9y\bi;)o\a
CJ>sm
CKW;b
CKc=YC
CL interop not supported
CLv\vH
CM:TkJ
CMF}A
CN@=!kC
CO ;qd
CO9`2
CONOUT
CPH+K@H
CPH;CHt0H+CHH
CPHc\bI
CPU does not support SSE2
CQȺ0\\Ǻty
CRT$XCA
CRT$XCC
CRT$XCL
CRT$XCU
CRT$XCZ
CRT$XDA
CRT$XDZ
CRT$XIA
CRT$XIC
CRT$XIZ
CRT$XLA
CRT$XLC
CRT$XLD
CRT$XLZ
CRT$XPA
CRT$XPX
CRT$XPXA
CRT$XPZ
CRT$XTA
CRT$XTZ
CS;"i
CW&qB쾩C
CWD>~3
CXA+ȉ\bH
CXH+CPH
CXH+OPH+CPH
CXHc8H
CXHc\bI
CXI+CPM
CXI+KPH+CPH
CYA>HM
CZ滘dٻO
C\\,50J
C\a>8B\a
C\a>8B\r
C\b9B\bs
C\b9D
C\b9F\bs
C\b9G\bs
C\b;C\bs
C\b;G\bs
C\b;e4ƹZ
C\b<xD\b3hE\b*t
C\b@8
C\b@80u#H
C\bA9C\bs
C\bA9F\bs
C\bA9G\bs
C\bA;A\bs
C\bH+D$hH
C\bH+D$xH
C\bH+E8H
C\bH;Z\b
C\fA]A
C\fbA
C\nżi3
C\r\r;M
C\v$9!J
C\v;f7
C`H+CX
C`H;CXt#I
C`H;CXt)I
C`N3A
C`N3Gs
Ca;=\nJ
Cached
Cannot read the contents of a file
Caｎ ~=7
CcR;9
Cf;4AC
CfC=&p
CfνP\\T
Cg8\t
ChH+\aL
ChLcK\bH
Ch\n=*S
CiK=>N
Ci^;XW
Cj:\vBs\t
Ck(#B
Ck(#Bsx
Class Hierarchy Descriptor
Class name
CloseHandle
CloseThreadpoolTimer
CloseThreadpoolWait
CloseThreadpoolWork
ClŻBq
Co:}j
CoTaskMemFree
CompanyName
CompareStringEx
CompareStringW
Compiler
Complete Object Locator
Config
Conventions
CorExitProcess
CoҺcP
CpHcB
CqY:Y
Cr;Npl
Cr;WVz
CreateEventA
CreateEventExW
CreateEventW
CreateFileW
CreateSemaphoreExW
CreateSemaphoreW
CreateSymbolicLinkW
CreateThread
CreateThread failed
CreateThreadpoolTimer
CreateThreadpoolWait
CreateThreadpoolWork
Ct;ti
Cu0f9w
Cw:\b
Cw;CD:\t
Cy2@K
Cy9LH$9\r
Cz,;\nfS
Cz\e<L
C|nZB
C}żDiмo
Cú9eo
CŻ9AE
CȈD$8H
Cȼ=8Q;g
CʺfhƺeY5
C˽YL\e=F
CЉC<I
Cӷ;fYt
Cք\tA
Cڳ; \fm<Q
Cߺ\vo0
C㏻|h编ZR
D  fB
D  ġpY
D @ġpY
D AMD
D AMD_MEDIA_OPS
D PġpY
D W?{W
D WIN32
D"<k7
D$ 9A
D$ D+E
D$ D3
D$ H;Q
D$ H;W
D$ H;\r
D$ H;z\b
D$ HcL
D$ b!|M
D$ fA
D$ fD
D$ t!B
D$ t%ġx
D$$bb}H
D$(L;x\bH
D$(fff
D$0D;L$(u
D$0H;G
D$0HcB
D$0HcH
D$0HcL
D$0Hi0
D$0IcD
D$0L9H s\n
D$0Lcf
D$0Mcf
D$0fE
D$0ǅH\f
D$2E3
D$4Lc
D$8D8T$1u\f
D$8E3\tD$0
D$8E3ɋB$I
D$8H;A\b
D$8H;S
D$8HcJ
D$8IcD
D$8L98
D$8tQH
D$8t\eH
D$@HcH
D$@HcL
D$@IcD
D$@IcE
D$@IcF
D$@L;D$Hu
D$@fA
D$@fD
D$D+ȉL$TD
D$DDtRH
D$HHcF
D$HL9gXt
D$Ht\eH
D$PHcB
D$PHcH
D$PHcX H
D$PL;D$Xu
D$PL;\r
D$PLcR
D$Pfff
D$XD8p\bH
D$XD90
D$XHc
D$XHcE
D$XL;F
D$Xt&B
D$XtQH
D$\nba~\b
D$`3\bEP
D$`D9;u
D$`HcF
D$`HcH
D$`tGM
D$`tKM
D$`t\eL
D$`t\fH
D$d:v
D$hHcC(H
D$ht&A
D$n<od
D$pA;w
D$pE3
D$pH+H@I
D$pH;E
D$pH;P\b
D$pHcB
D$pHcH
D$pHcL
D$pHc\bL
D$pLc
D$pfA
D$pfD
D$pt\eH
D$pu\bH
D$pŸYE
D$pŸYM
D$xHcA
D$xI;Y\b
D$xba
D$xfff
D%;m5\r
D%<V7
D%k;w
D&pA;l$l
D';kzT
D(8Ht
D(:s8
D(T=FD\n
D*0fB
D*\r<3y
D+T$Hfff
D.\ab!D
D.ǻJH
D0 fD
D08@t\t
D1HH+D1@H
D2ٺV\a\v
D2庈-p
D3 b1
D39\aW-;R
D3мuxc
D4S<U
D6\v:߬B
D6r:w`w
D8 fD
D8&t4H
D8+t\nD8k
D82u&H
D83t\tH
D88Ht
D88Hte
D88t=H
D88u\rH
D8APttH
D8G\buBH
D8G\buIH
D8G\buOH
D8L$0uP
D8W\buOH
D8Y:uEH
D8\\$8uOH
D8\atl
D8]\v
D8a:uDH
D8d$8t\fH
D8d$Ht\fH
D8d$ht\fH
D8g\buAH
D8l$<tNI
D8l$@tOI
D8l$@t\fH
D8l$ht\nH
D8o\bu@H
D8o\buFH
D8o\buHH
D8o\buNH
D8t$8t\fH
D8t$Ht\fH
D8|$Ht\fH
D8|$Pt\fH
D9!t\tH
D91AO<zDy;ɛ\r
D92<a
D97~.A
D98Ht;H
D9HH+D9@H
D9I ~wHc
D9K\b~+A
D9S\f~J
D9\vucL
D9c4t\bH
D9s4u\f
D9s\bu\t9k\f
D9|8\ft3
D9} ~t
D:#)g:rEy9
D:E7\n
D:H\b
D:M+B
D:Q<r\t
D:UT\e
D:\b| D8R
D:\b|$D8R
D:\f0u6H
D:\f0u:H
D:vXh:Y6
D;#rg
D;-Bb
D;H$t\n
D;L$h}\aO
D;M<J
D;RN8=0r
D;S\b}8A
D;bY\e
D;iHJ
D;yLj:Sj
D;y\b|:A91
D;}CQ
D<\bW59\n
D=7@U
D=;\axb
D=maQ
D>#U7
D?\f<fVO:5
D?\v9:U
D@Q=s
DA9wX3
DAb<eE
DBY^uB
DB]8Ta
DC:th
DC;ӫ7
DCh9js
DFԽNk
DG9:N2
DGл\r}ܻsD
DH>=h
DI;?mQ8
DIMENSION_LIST
DJQ;Bƅ:وn
DJ\b=<a
DK8ɠ\t
DK;n5
DKO;g
DKf:5
DLڻL\f\n
DN];h
DOm;c
DQa<Ua
DQ»߃ͻKF
DR;97
DRB<b
DS<tl1
DSp;d
DVe@A\v
DW=vB3
DWغ*o
DX(global_id)].next; \n    } \n} \n \n// Propagate bounds up to the root \nKERNEL void refit_bounds_main( \n    // Node bounds \n    GLOBAL bbox* bounds, \n    // Number of nodes \n    int num_prims, \n    // Nodes \n    GLOBAL HlbvhNode* nodes, \n    // Atomic flags \n    GLOBAL int* flags \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Start from leaf nodes \n    if (global_id < num_prims) \n    { \n        // Get my leaf index \n        int idx = LEAFIDX(global_id); \n \n        do \n        { \n            // Move to parent node \n            idx = nodes[idx].parent; \n \n            // Check node's flag \n            if (atomic_cmpxchg(flags + idx, 0, 1) == 1) \n            { \n                // If the flag was 1 the second child is ready and  \n                // this thread calculates bbox for the node \n \n                // Fetch kids \n                int lc = nodes[idx].left; \n                int rc = nodes[idx].right; \n \n                // Calculate bounds \n                bbox b = bbox_union(bounds[lc], bounds[rc]); \n \n                // Write bounds \n                bounds[idx] = b; \n            } \n            else \n            { \n                // If the flag was 0 set it to 1 and bail out. \n                // The thread handling the second child will \n                // handle this node. \n                break; \n            } \n        } \n        while (idx != 0); \n    } \n} \n
DX4"H
DX<"H
DXƻ&1y
D\a fD
D\a\aba|H
D\at͆mC
D\b;o1o;f
D\eƻp
D\f;rb
D\f<Sa
D\n Ocl\n
D\n=OQK
D\n\abq|H
D\n\bbA|H
D\n\e;U
D\n\nba|H
D\t<4W6
D\v\nba|H
D\vf:%b
D^F<n
D^ӻmq
D_ԼW6q
Da<ll{;d
Data.Delay
Data.IR
Data.SamplingRate
DataType
December
DecodePointer
DeleteCriticalSection
Dfb:'Q
Dgi;d
DigiCert Timestamp 20230
DigiCert Trusted Root G40
DigiCert, Inc.1 0
DigiCert, Inc.1;09
DigiCert, Inc.1A0
Dk;hYn
Dm4<x5
DoG;R
DoL9I
DpɹjYj
Dqt=c
Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                            // otherwise skip the subtree \n                            if (!shapeDisabled \n#ifdef RR_RAY_MASK \n                                && ray_get_mask(&r) != shapeId \n#endif // RR_RAY_MASK \n                                ) \n                            { \n                                // Fetch bottom level BVH index \n                                addr = shapes[shape_idx].bvh_idx; \n                                shape_id = shapeId; \n \n                                // Fetch BVH transform \n                                float4 wmi0 = shapes[shape_idx].m0; \n                                float4 wmi1 = shapes[shape_idx].m1; \n                                float4 wmi2 = shapes[shape_idx].m2; \n                                float4 wmi3 = shapes[shape_idx].m3; \n \n                                r = transform_ray(r, wmi0, wmi1, wmi2, wmi3); \n                                // Recalc invdir \n                                invdir = safe_invdir(r); \n                                // And continue traversal of the bottom level BVH \n                                continue; \n                            } \n                            else \n                            { \n                                addr = INVALID_IDX; \n                            } \n                        } \n                    } \n                    // Traverse child nodes otherwise. \n                    else \n                    { \n                        // This is an internal node, proceed to left child (it is at current + 1 index) \n                        addr = addr + 1; \n                    } \n                } \n                else \n                { \n                    // We missed the node, goto next one \n                    addr = NEXT(node); \n                } \n \n                // Here check if we ended up traversing bottom level BVH \n                // in this case idx = -1 and topidx has valid value \n                if (addr == INVALID_IDX && top_addr != INVALID_IDX) \n                { \n                    //  Proceed to next top level node \n                    addr = NEXT(nodes[top_addr]); \n                    // Set topidx \n                    top_addr = INVALID_IDX; \n                    // Restore ray here \n                    r = top_ray; \n                    // Restore invdir \n                    invdir = invdirtop; \n                } \n            } \n \n            // Check if we have found an intersection \n            if (closest_shape_id != INVALID_IDX) \n            { \n                // Update hit information \n                hits[global_id].shape_id = closest_shape_id; \n                hits[global_id].prim_id = closest_prim_id; \n                hits[global_id].uvwt = make_float4(closest_barycentrics.x, closest_barycentrics.y, 0.f, t_max); \n            } \n            else \n            { \n                // Miss here \n                hits[global_id].shape_id = MISS_MARKER; \n                hits[global_id].prim_id = MISS_MARKER; \n            } \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL void occluded_main( \n    // BVH nodes \n    GLOBAL bvh_node const* restrict nodes, \n    // Vertices \n    GLOBAL float3 const* restrict vertices, \n    // Faces \n    GLOBAL Face const* restrict faces, \n    // Shapes \n    GLOBAL Shape const* restrict shapes, \n    // BVH root index \n    int root_idx, \n    // Rays \n    GLOBAL ray const* restrict rays, \n    // Number of rays in ray buffer \n    GLOBAL int const* restrict num_rays, \n    // Hits  \n    GLOBAL int* hits \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Handle only working subset \n    if (global_id < *num_rays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (ray_is_active(&r)) \n        { \n            // Precompute invdir for bbox testing \n            float3 invdir = safe_invdir(r); \n            float3 i
Duf<"`4
Dva<R
Dvc:e4
Dvz;N
Dw<\r\a
DyH<B
D|;qyf
D|>9f
D~ "H<O
D~9q\n
D¼9\vr
Dƨ:pR1<2
Dƻ0\ae
DɺlNv
D˻mĥ8
DЋ;M4
Dйl\e;b
DҼl9ؼD
Dܼ1x̼2
DމD$ M
D眻F뗻4w
E 3\bD$T
E 9A\bs
E 9D$0r
E HcT$0H
E I;A\b
E ŜYU
E"(<ZOw
E$G=@Mt=w6
E%9/q3
E'@6?2s
E(3\bD
E(9A\bs
E(G<R
E(HcEXI
E);I\ni
E)B:In
E*:Vh
E*ѼL7
E+ىEDH
E+܉t$ D
E.ѻ2j
E09A\bs
E0HcH\fD
E0I9A\bt
E0Lc`\fI
E0M9q\bt
E0fff
E0ŠXm`ŘX}pŐX
E2S9>E
E2[<oO
E2\f<@b
E2j:?z
E3\nS\tI
E3\nW\tI
E3\vD$8A
E3\vQ$H
E3\vT$<L
E3ɉ|$ D
E3ɸVUUUA
E3҉U(N
E4;"y
E4?;H
E6;Mm
E6x<E\b\a
E83\bD$d
E8E\buHI
E8E\buLI
E8E\buQI
E8E\buWI
E8HcЋK,H
E8L+HE8I
E8]\buXI
E8a>9
E9.u\aA
E91~)3
E92:W
E99~4H
E9<$A
E9N:5\a
E9e\b~i3
E9}\b~h3
E9}\b~t3
E:+cW
E:2dB
E:6QP
E:<2P
E:<9o
E:Zfl
E:\t=680
E:r?ԻXT
E:yu;29Y
E;*dݺx\ny
E;3>F
E;?tv
E;Fh}AO
E;J+x
E;O䴹R
E;P\n
E;S\rһB
E;Wtg
E;X (;+Zy
E;`2Q
E;kW2
E;}$tXH
E<<uw
E<MF3
E<P\et
E<nZ\r
E<sS;y
E<tdp
E<uZ*<z
E<xQv
E=E*a
E=WIf
E>p;v
E@3\bD
E@98u,A
E@9A\bs
E@H;P\b
E@KcT8 H
EA5;Ɗs
EACǱb#eAC
EBN9[Bo
EBs<YV6
EDw>P
EGԼ)G
EH3\bD$S
EH9A\bs
EHI+E@H;C
EHI+E@H;G
EHI+EHI
EHL+HEHI
EI;zL
EID$8H
EJ;8N\t;vj<;nN
EJ;D]\f:M
EJ;^i\t
EJӻegk
EKa;q
ELH9dR{9N
ELv"H
EMcɃ~\b
EMcɃ~\f
EOʼ.s
EPIcE
EPM;HD$0L
ERROR
ERV:8DN
ES:2k
ET;#Pz;ѸU
ET;OB7
EU*?N
EU;&C
EU=\ve
EUG;0c
EVٻ4rY
EWb"e
EX"<f&9
EX3\bD$W
EX3ҋM`D
EX6;RV
EX9A\bs
EXI;@\bsXI
EXL+HEXI
EXufE3
E[;V3
E[S;i
E[\rn?gc
E[b"m
E\abQ|H
E\auNH
E\b9A\bs
E\b:_h6
E\bHc]`M
E\bL;F
E\bbA|J
E\bbQ5H
E\bba}Hp
E\bfA9]\n
E\btGE3
E\bĢm.\f0
E\e<GQպh
E\ebQT
E\fbA|H
E\n::cXG
E\r<j e:Q&F
E\t|$PH
E\v<xF\v3hG\v*t
E\vbA|H
E\vbQ|H
E_<two
E`9A\bs
E`H;Up
E`bbu
Eb>>Hu
Ec:ud9
Ecb>aS
Ed<+8G
Eg1<rK
EgL+HEgI
Eg\n;a
EhH+E
EhH+S@L
EhHcЋO,H
Ei:݈0;x
EkZ;Q
Em1>ap
Em\t:f
Embree Ray Tracing Kernels
Embree: Invalid argument
Embree: Invalid error code
Embree: Invalid operation
Embree: No error
Embree: Out of memory
Embree: Unknown error
Embree: Unsupported CPU
EmitterPosition
En[vP
En\b>w
EncodePointer
EnterCriticalSection
EnumSystemLocalesEx
EnumSystemLocalesW
Eo;Ki
Eo<\e:3
EoL+HEoI
Ep9A\bs
EpIcC
EpL+M`H
Ep\a>9
EpŠXm ŘX
Et9Z\v
Et;Z( ;x
Et<]0M
Eu+=V
Eu:Ovûv7Y
EvD<l
Ev\a;6;J
Ew8<AF
Ewx:kۜ7
ExH+EpHi
ExitProcess
ExitThread
Expression
Ez=uB$>0
EzR;Oo
E{:cAq
E|#9A
E|H9q
E|\f;Zr
E»QZ9P
EûmME
Eǣ=B\v7
EȉD$h
EʉL$\\fff
EʉMPfff
EʉM`fff
EΎ<z6Z
EӍZ\bD
E؉D$x
Eٹ\tn0
F HcT$0H
F LcL$4I
F#<2z|8r0
F%:Xy0
F&p;bH
F'<nBJ
F(,:Ts3
F(9=lt
F(D+F0D+ËF
F(I<U
F):o4\e
F)n;rW
F-N;ro
F19:\n
F2\a1wsHp
F6:LUP:~so8Ì8;\n
F6û\b2
F8}-L
F9!\aֹP
F9N֑:M
F9Z39
F9`;p
F9o<BwV
F: PӺ\nX
F:4Gǻ\f
F:CVH
F:OKzԣW
F:^Gk
F:j\v
F;8;sG
F;D6S
F;Iy(;De
F;Og{9ޞH
F;Psb;j
F;Q\fL
F;YR3
F;gS¼ʤu
F;nL0;-g
F;tZǺt
F;wr\\6
F;~SS
F<B1v
F<ptO
F<x$Y=zI
F=%=034
F=0;1
F=;AkV
F>qUxv
F?b;yU
F@LcN\bI
FB;:L
FBݻ,DE
FC>yR\t
FDH+F<H
FDƼ\e
FE?>G
FF\n@acosf
FH8;xI
FHD:]T
FHH+F
FHH+F@I
FI;d]N8Qo
FIg=k4
FJ ;>'k
FL_;eS
FLv"H
FLv\vH
FOϹLC*;rF
FPH+FHH
FPH;FHt,H
FPH;FHt,L
FT;IXY
FVN;\f
FWӻǎg
FX=rV?=0
FXH+FPH;C
FXH+FPH;C w\n
FXH+FPH;C w\t
FXH+FPH;C0w
FXH+FPH;C8w
FXH+KPH+FPH
FZ$:Ue9
FZ<Th9
FZ_9\a
F[6:f
F\\V9^J
F\a;R\b¹v
F\a<EG
F\a=LH\e
F\b9A\bs
F\b9B\bs
F\b9D$(}s
F\b;C\bs
F\bA;C\bs
F\bH90u
F\bL90u
F\em;Y
F\fHcOLH
F\n:5V
F\n;F
F\t;RwN
F\tl<a
F\v;Dq
F\v;q
F\v=u
Fa;Q}p
Fc*99
FdU</3\b
Features
February
Feẜo蹠k
Ff;ivv
Ffջ(zQ;mv
Fg9\bZ
Fh 9e
Fh:O"c<-W
Fh<9̓=w
FhY<\nKX
FileDescription
FileVersion
FindClose
FindFirstFileExA
FindNextFileA
Fj!;o5F
Fj9lmc
FjB:C2
Fk.9db
FlsAlloc
FlsFree
FlsGetValue
FlsSetValue
FlushFileBuffers
FlushProcessWriteBuffers
Flº\t
FoO;pb
Foj;w
For information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts
Fpbal
Fq;_S
FreeEnvironmentStringsW
FreeLibrary
FreeLibraryAndExitThread
FreeLibraryWhenCallbackReturns
Friday
Fu:.T
Fv;T\f
F{$gT
F|w;b\a
F};AS5
FͼV\t
FкZ"G
FջN(J=S
FֻK^N
Fܺ#3R<co
Fݻ3kU;L
Fޘ;Ftf;rJ
G"e;D
G(A+G0A
G(E+G0E
G-;wX
G0HcH\bL
G1m:4I
G20=l
G4l;9k
G6<3yp
G6<ʺL
G7:B6
G7;TO
G8);M
G8;XW
G8z:qW
G9Z!¹p
G9zn7<T
G:$eC
G:UL0
G:j-۸kQ
G:ncG
G:~lD
G:~mQ:U
G:՚ϺZJ6;q
G;0=x
G;M1s
G;Shd
G;brD
G;j,S
G<)mk
G<1\a
G<P\b\f
G<VO+<K
G<\aVлd
G<`Q0
G=0~K
G>l\f
G@H90t%H
GB:h38
GC;.X\b:3
GEG;\rs
GFw<5W
GG=2{ĽV
GG??L
GGR8|Q
GH;#H
GH='l
GHH+G
GHH+G@H
GHH+G@L
GI\a<s
GJ:F\b
GJ繭?G
GJ켟u!=8
GL9\rXѹcv
GL;M\e,;L
GLv!H
GLv\vI
GM;\vL
GNp:W
GPH;GXw
GPHcW\bH
GPUUtilities.dll
GRC<r
GSλiPg
GU\r=L
GX$8aQ
GXH+GPH
GXH+GPH;C0w
GXH+GPI
GXI+GPI
GX˻.zֻXJ
GYd;em
GZu<M
G[<Ax
G[I;y"g
G\a:Hd
G\aO;\ehs
G\b9A\b
G\b9B\bs
G\b9C\bs\f
G\bA;C\bs
G\bH+\aH
G\bH9D$x
G\bH9D$xs
G\bH9D$xsoH
G\bI+\aH
G\bL+\aI
G\bba|H
G\n;[wD
G\nf;E\ttT
G\nf;E\ttW
G\r<i
G\r=t|s
G\ri;0
G\t4;H
G\t:E\btK
G\t:E\btO
G\t:E\ftO
G\t:E\ntO
G\t:E\nu`H
G\t:E\nubA
G\t<I
G]H;I
G_ rr\e
G_a=6
Gbb}H
GdͽUW\n
Generated by Steam Audio\n
Genuu\aH
GetACP
GetActiveProcessorCount
GetActiveProcessorGroupCount
GetActiveWindow
GetCPInfo
GetCommandLineA
GetCommandLineW
GetConsoleCP
GetConsoleMode
GetCurrentPackageId
GetCurrentProcess
GetCurrentProcessId
GetCurrentProcessorNumber
GetCurrentThreadId
GetDateFormatEx
GetDateFormatW
GetEnvironmentStringsW
GetExitCodeThread
GetFileInformationByHandleEx
GetFileType
GetLargePageMinimum
GetLastActivePopup
GetLastError
GetLocaleInfoEx
GetLocaleInfoW
GetModuleFileNameA
GetModuleFileNameW
GetModuleHandleExW
GetModuleHandleW
GetNativeSystemInfo
GetOEMCP
GetProcAddress
GetProcessHeap
GetProcessWindowStation
GetStartupInfoW
GetStdHandle
GetStringTypeW
GetSystemInfo
GetSystemTimeAsFileTime
GetSystemTimePreciseAsFileTime
GetTickCount64
GetTimeFormatEx
GetTimeFormatW
GetTimeZoneInformation
GetUserDefaultLCID
GetUserDefaultLocaleName
GetUserObjectInformationW
Gez\es$;J
Gf<@s
Gg;Ӎo
Giy:S
Gj;Wk0
Gk:cd
Gk<D\eS
GkӼ\bHN
Gl;h3
Glu?A
GlubA
Gm轜ls
GnC<O
Gn\t>\b
Gr@;vA
GrJoq
Gr\r<G
Gs:97
Gs;k~\a
Gv;|J1
Gv<3;N
Gvκ6d
Gx9]uP
Gyƻq5
G|b=52
G}F92wu
G}G;S
GĒ:WL
Gɹq@a:t
Gݾ\bWB
GᅻD\e
H : %M
H : %M : %S
H A;\bt
H SVWH
H UATAUAVAWH
H UVWATAUAVAWH
H WATAUAVAWH
H!D$ E
H!K=eC
H!T$0D
H"<jV\t
H#L$8H
H$6t\e\t
H%B;IM4:G
H(% 8
H(۸33
H)G0E3
H*0"ZOW
H*:IE
H*=I8
H+BPH
H+BPI
H+CPH
H+D$hH
H+D$xH
H+D$xL
H+K(H
H+L$ D
H+L$ xFH
H+L$XH
H+L$hH
H+L$pH
H+P0H
H+Q\bI
H+T$XH
H+T$hH
H+T$pH
H+T$xH
H+r;pq
H+ЋG0
H0:~bV
H1<sF\b
H1ʻ;9
H2\t;c44
H30;t
H39dYk
H3E H3E
H3ɉL0\bM
H3̋D$ H;\r
H3ۉl$P
H5<M\bv
H5<mN
H5ڻ>1M
H7;5Ӫ:Z\n
H8DQ7;s
H8|UT
H9'wٻP
H92t\tI
H9:t\fH
H9>&X
H9A u\bH
H9A\bs
H9A\btzH
H9C s(H
H9H s
H9KPv4
H9Khv
H9L$Ht?H
H9M tSD
H9MPtDeH
H9ZHvD
H9\at\tH
H9_\b
H9c(8
H9i\bvVD
H9q\bt\a3
H9s\bt\vH;C\bv
H9s`t6H
H9t$@t\f
H9yXv5
H9y\bv+H
H9{ u
H9溅s
H:7-9
H:<qkv
H:H=I
H:y\n\t
H;0c4
H;5\bB:\eL
H;A w&H
H;A\bt\e
H;B\btY
H;B\bt\e
H;C w/I
H;C wKI
H;C wMI
H;C w\n
H;C w\t
H;CHt!L
H;CXt\e
H;C\bt\aH
H;C\bu\f
H;C\bv\bA
H;C\bw(H
H;C\bwfH
H;C\bwkL
H;D$Pu\bM
H;E(L
H;E0L
H;E8L
H;EHL
H;EXL
H;E`L
H;EhH
H;ExL
H;G\btO
H;H\bu\rL
H;H\bv\a
H;L$xM
H;O\bt/H
H;P\bu\fL
H;P\bu\rL
H;Qz";R
H;V(u
H;W t\t
H;XXs\v
H;\asPD
H;\at$H
H;\n8
H;\r#cJ
H;\r&AM
H;\r+uK
H;\r-1E
H;\r/Kr
H;\r1WL
H;\r4jp
H;\r6P
H;\r:XV
H;\r<lM
H;\r@EJ
H;\rA-p
H;\rE@H
H;\rEQH
H;\rEcJ
H;\rI!M
H;\rJzL
H;\rL4G
H;\rM.F
H;\rP[I
H;\rQ(M
H;\rQKr
H;\rY$K
H;\r\bWL
H;\r\fop
H;\r\tuK
H;\r\v1E
H;\r]EG
H;\r]RM
H;\r`lq
H;\ra\a
H;\rd3M
H;\re&s
H;\rgcJ
H;\rjAM
H;\rj|M
H;\rk$D
H;\rkQH
H;\rmNq
H;\rn
H;\rouK
H;\rq)s
H;\rq1E
H;\rs(M
H;\rs(p
H;\rsNr
H;\rtyi
H;\ruvi
H;\ruxi
H;\rx'q
H;\rxjp
H;\rxkM
H;\rx|i
H;^ w'A
H;h s\bH
H;l$8
H;m(0
H;p s\bH
H;s s[H
H;t$0L
H;t$0t
H;t$Pt
H;tjy
H;w\bsFB
H;w\bsRB
H;w\bs`L
H;w\bsaB
H;w\bsaL
H;xXu5
H;yNa
H;z\bs5f
H;{ sOH
H;|80u\nK
H<(i1
H<8La
H<9&l
H<=wU9ܾc
H<Z깻L4
H<cmV
H=e<Ui
H=hSm
H>*OA
H>7T켆F
H>hl\f
H>́h?5u
H@E3ɐH
HA=\f/A
HA^A]A
HA_A]A
HA_A^A]A
HB廨}ȻA\bx
HC<VX
HCL;o
HD$>A
HFX=ej
HG<?wQ
HGݻsp
HH9_0vBfff
HH:mm:ss
HH;A0
HHL;hXH
HHM+H
HHM+H@A
HI;3H
HIԼ\nK\f
HJ\n?J
HL#O\bt
HL:Ƅp
HLBVH setup + construction CPU time
HLc@\fIc
HM9\bJJ;(\f
HMARK_BUILD
HMcɃ~\b
HMcɃ~\f
HO<A!R
HR;xu
HR><y5
HS伳q\r=0
HT9)\a
HT\a;H
HV:N<H
HV^<1
HW:m,ݻ6
HWҼ6j
HX%9V3
HX%M`3
HX%lM3
HX56g3
HX5E_3
HX5X 6
HX=W"Q
HX=\\ 6
HX=k"6
HX=o 6
HX\r$M3
HX\r%C3
HX\r9P3
HX\r;i3
HX\rFK3
HX\rGo3
HX\rOq3
HX\r\ez3
HX\rza3
HX\r{q3
HX|$R
HY%TWD
HY%ViE
HY&:g
HY,+bA
HY,\ebA
HY1:Q
HY:.G
HYD P
HYD Pġ@YL
HYD `ġ@YL
HYD(P
HYD(p
HYL P
HYM\nbQtHY
HYT p
HYe\fbAT@Ye
HYt\a\fb
HYu\fbA
HZ%ȳ8
HZh<s
H\a\b;u
H\b9b\f
H\b:Z
H\bH+\bH
H\bL9I\bu\bD9
H\bSUVWATAUAVAWH
H\bSUVWATH
H\bUATAUAVAWH
H\bUATAVH
H\bUAVAWH
H\bUSATAWH
H\bUSAUAVH
H\bUSVWATAUAVAWH
H\bUSVWAUH
H\bUSWAUH
H\bUVWATAUAVAWH
H\bUVWAUH
H\bUWATAUH
H\bVATH
H\bVWATAUAVAWL
H\bVWATAVAWH
H\bVWAUH
H\bVWAVH
H\bWATAUAVAWH
H\bWATAVH
H\bWAVAWH
H\e/=n9
H\f;xz6
H\f<C|8
H\r4:k
H\r<w*f
H\t#;8A
H\t<gT\t
H\vT$PH3
H]A]A
H]A^A
H]A_A
H]A_A^A
H]A_A^A]A
H^=NTm
H^T<u
H_D8f
H`3\bD$8H
Ha=RjR
HaL;K
HairBuilderSAH
HairMBlurBuilderSAH
Haswell
HcA\bH
HcD$(H
HcD$(Mc
HcD$0LcL$(H
HcD$0LcT$(H
HcD$8LcT$0Lc\\$(H
HcD$`Hk
HcD$xLi
HcD$xM
HcE`I
HcEhI
HcG(Hk
HcG(Lk
HcIMDH
HcL$p3
HcL$pL
HcS\fHcK
HcT$`H
Hc\\$pA
Hc\\$pE3
Hc\tt$H
HciHH
Hcl$`LcT$pLc|$h
Hcq;:&g
Hct$pD
HcȉD$0
HcȋB\bA
HcˉD$P
HcҋE0H
HcҋEHH
Hcҋl$`M
HcډM\vD
Hd<BZ\n
Hd<g{7
Hd\e:hE
Hdͻ\rr
Hdлp/\r
He3<9
HeapAlloc
HeapFree
HeapReAlloc
HeapSize
Hfǹ4IX
Hg%;e5
Hi1:I
Hjֻ*Jn
HkUhpA
Hkv=k_E
Hm<x\vw
Hmm>\r
Hn\v:v
Hnռ\ajX
Ho5%\r
Ho;lJ5
Ho@;i
HoK=eM
Hp$1b
Hp$qH
Hp$qb!}Hp\f
Hp$±b
Hp$±b!4HY
Hp$±b!D@Y
Hp$ñb
Hp$ȱb
Hp$ȱb!4HY
Hp$ʱL
Hp$ʱbq\\H
Hp$˱H
Hp$˱b
Hp$رb
Hp$ٱb
Hp$ڱH
Hp$ڱb
Hp$ܱbQ}Hp\fԱbR\r
Hp,qb
Hp,qba}Hp
Hp,ñb
Hp,ȱb
Hp,ɱb
Hp,ʱb
Hp,ʱbAT@YU
Hp,˱b
Hp,˱ba<@Y
Hp,бI
Hp,бb
Hp,бb"E
Hp,бba4@Y
Hp,ұb
Hp,ԱbA}Hp
Hp,رb
Hp,رb!}Hp4бb!tHY
Hp,ڱb"5H
Hp,۱I
Hp,۱ba|H
Hp1b!}HpԱb
Hp1b!}Hpرb
Hp1b2M
Hp1bA|H
Hp1bA}Hpձbq|H
Hp1ba|H
Hp1ba}Hpʱbr}H
Hp1bq|H
Hp4±bQL@Yu\nb
Hp4ñbq
Hp4ıbQ}Hp\fܱb
Hp4ȱb
Hp4ʱL
Hp4ʱb
Hp4ԱbQ}Hp<ܱb
Hp4ֱI
Hp4ֱbQ}Hp<ƱbA}Hp
Hp4رb
Hp4رbq
Hp4ڱL
Hp4ڱb
Hp4ޱb
Hp<1b
Hp<1bq$HY
Hp<qb
Hp<±b
Hp<ñbq$HY
Hp<ıb
Hp<ƱbA}Hp\f
Hp<ȱb
Hp<ʱb
Hp<ʱbQDHYM\fb
Hp<ʱba}Hp,ڱbQDHYM\fbA
Hp<̱bA}Hp
Hp<бb
Hp<ұb!}Hp
Hp<ұbQ|H
Hp<ֱbq,HY
Hp<ױb
Hp<ڱL
Hp<ڱb
Hp<ڱb!}Hp
Hp<ܱb
Hp<ޱb
Hp<߱b
Hp\f1L
Hp\f1b
Hp\f±b
Hp\fƱbQDHY
Hp\fȱb
Hp\fʱb
Hp\fʱb!}Hp
Hp\fʱbAtHYE
Hp\fϱbQDHY
Hp\fбbat@Y
Hp\fұb
Hp\fұb"EH
Hp\fرb
Hp\fڱf
Hp\fܱb
Hpqb!D@Y
HpqbA|H
Hp±b!}Hp
Hp±bA|H
Hp±ba}Hp
Hpñb2
Hpñba|I
Hpñbqt@Y
HpıbA|I
Hpűb!L@Y
HpűbQ}Hp
Hpűba|H
HpƱb2E
HpƱbA
HpƱbQ}Hp
HpƱba|H
HpǱb1}Hpӱb
HpǱbA
HpǱbQ}Hp
HpǱba}Hp
HpǱba}Hpѱb
Hpȱb!|H
Hpȱba\f@Y
Hpɱb!|H
Hpɱb!}Hp1b
HpɱbQ|H
HpɱbQ}Hp
Hpɱba
Hpɱba|H
Hpɱbb
Hpɱbq}Hp̱b1}Hp߱b1}Hp
Hpɱbr}H
Hpʱb"U
HpʱbA|H
Hpʱba|H
Hpʱbr}H
Hp˱bA|H
Hp̱bA4H
Hp̱ba|H
HpͱbAD@Y
Hpͱbq}Hp1b
Hpαb!}Hpбb
Hpϱb!|H
Hpϱb!}Hp1batH
Hpϱba}Hp
Hpбb!|H
Hpбb1
Hpбba|H
Hpѱb!TH
HpѱbA,@YU
HpѱbAD@Y
HpѱbQ}Hp
Hpѱba
Hpұb!|H
Hpұb!}Hp
Hpұb2UH
HpұbA|H
HpұbQ,HYU
HpұbQ}Hp
Hpұba|H
Hpұbr
Hpӱb!|H
HpӱbA}Hp
HpӱbQ\\HY
HpӱbQ}Hpݱb
Hpӱba}Hp
Hpӱbq|H
HpԱbA,@YU\vbB
HpԱbQ,HYU\rbB-H
HpԱbr
Hpձb"=H
HpձbA,@YU\abB
HpձbQ,HYU\tbB-H
Hpձba|H
HpֱbA}Hp
HpֱbQ,HYU
Hpֱbr}H
Hpױb!|H
Hpױb1|H
HpױbA,@YU\rbB
HpױbQ
HpױbQd@Y
Hpرb!}Hp
HpرbA}Hp
HpرbaD@X
HpرbaL@X
Hpٱb!|H
Hpٱb1,HY
Hpڱb!\fHY
Hpڱb!}HpԱbrM
Hpڱb1
Hpڱb1|H
Hpڱba}Hp
Hp۱b!|H
Hp۱bA|H
Hp۱bBUH
Hp۱bQ}Hp
Hp۱ba
Hp۱ba|H
Hp۱bbE
HpܱbAl@Yu\bb
HpܱbQ,@Y
Hpܱba|H
Hpܱba}Hp
Hpݱb1,HY
Hpݱb1|H
Hpݱba|H
Hpݱba}Hp
HpޱbQ}Hp
Hpޱba4@Y
Hp߱bAd@Y
Hp߱ba|H
HqP:\ai
Hq\e9\a
Ht:;HA
Hu;`4F
HvvGa
HyͻKR
H{<no6
H{\f<OUv<8Ra
H|I;B\b
H|m;J
H~S=ita
Hǽ:pJe
H͛:pL
HлLj\t9j
Hա:Fo
Hܐ> 8o>d
H廼 \a
H쐼l6ϼD
I : %M : %S %p
I ;64
I HcG\f
I \v; x1:H
I!>HuR
I"9U/x
I#<ILK
I#=fW
I%7M\f\r7
I'9J\r
I(<4K
I(H+H H
I(L+I H
I+3;c
I,<zuH
I.Q;<ZI9Q
I/:6BB
I0T<UO
I0ŪXi
I2ּak
I3=8I
I3?;1
I3s:Ɂ\f:5u
I6<3b
I7,QG9d
I7v9#rX=O
I87:F:G:s
I90t\tH
I91t\tH
I96t4H
I98u*A
I99C\eG
I9<$v0
I9@\bu I
I9D$\bt
I9JxMc
I9N8v9
I9\f$tHI
I9kj^;b
I9q sEI
I9rPtWE
I9rPtZE
I9vPtZ
I9|$\bt
I9}(tiH
I:'kh
I:2T\r9
I:5r:q
I:U+i
I:c:3ޙ9
I:k\f69c)4;x
I:ýND\v
I;6\nw;uL
I;:\vje
I;;DC
I;@\bsWI
I;@\bsZI
I;C w$M
I;C w+I
I;C w/I
I;\bH
I;\bt\aH
I;is\n
I;pf7
I;q s?I
I;s8A
I<$wh
I<N:8
I<RRĻ8
I=0\aW
I=Xwm
I=jm\b
I=xvW
I=|WZ
I>TtɾI
I>[eL>G
I?N;j
I@uDB
I@uMB
I@uUB
IA:)Nx
IC;Z{k
ICMF}A
ICμyj
ICܱb!}Lp
ID$@H
ID<d-\n
IEHHc
IEXHc
IE\bHc
IEpHc
IG4=>V
IH9;MK\r
IH9B\ftEHcR\fI
IHHcB\fJcL\b
IHcH\bM
IHŪ\\yP
IIcO\bM
IIݻEQ
IKD:fx
IKg<k
IM1:MT
IM<\e%2
IND)ind
IP<ga
IP<qN
IPL;O0
IPLSIMDLevel
IPPCODE
IPPDATA
IQj=n
IS8Lpn:\nb
ISӻ\e\t
IXH;J(H
IXI;HXI
IZ;gFE
I\\\e;VYJ
I\aba|H
I\aba|\b
I\aba~\b
I\b<xJ\b3hK\b*t
I\bI+\tH
I\bL+\vI
I\bba~\b
I\f@;z0u
I\fA+I\b
I\nba^\bX
I\nкH
I\rba~\b
I\v<K6M
I\vڻXa
I`W<b
Ia<\t
Ib&:0\b
Ib:2\vP
Ib\t<2
Ic@\bIcP
IcD$\fH
IcD$lL
IcElL
IcL$ E
IcL$ L
IcL$lF
IcY\fIcI
Ic}\bIcu
Id7;9O
IdP=s
Ig8-QʹD19
Ihttp://crl3.digicert.com/DigiCertTrustedG4RSA4096SHA256TimeStampingCA.crl0
IiGM>nw
Ij$>P
Ij;#mD:K
IjL;C
Ik?<g
Iks:og
Il(;R
Il?333333c
Il\n;x
Ilu;Q
Index is out of bounds
InitOnceExecuteOnce
InitializeConditionVariable
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
InitializeCriticalSectionEx
InitializeSListHead
InitializeSRWLock
Initialized AMD Advanced Media Framework v%d.%d.%d.%d
Initialized Embree v%lld.%02lld.%02lld
Initialized OpenCL device: %s %s (%s
Initialized OpenCL platform: %s %s (%s
Initialized Radeon Rays v%.2f
InterlockedFlushSList
Internal error
InternalName
Io;<W
Io;mS
IpŢ\\i0
IpƱba}Jpqb
Ipɱba}Jpڱb
Ip˱bA|H
Ip̱bA|H
Ip̱ba|H
Ipͱba|H
Ipαba}Jp±b
Ipѱba}Jp۱b
IpԱbA|H
IpݱbA|H
Ipݱba|H
Iq~;Y
Ir==s
IsDebuggerPresent
IsProcessorFeaturePresent
IsValidCodePage
IsValidLocale
IsValidLocaleName
Is\t;n
Iv*;zy
IvމL$p
Iw\bZ
Iz!4\a
Iz&94Z
Iz\t;OJ
I}ļm\vs
IƟ;Zo
Iɾy?ԽDC
I˔;\agi
I̺\epF
Iͤ:oq\t
Iιy9o
IϼX>R
Iм)lv
Iػ3ld;R79
IⱾ" V
J }Uʖwi\v
J"bA|\b
J%:9J
J(=Y\tu
J(ba|\b
J):\bzs
J)\r;xhX
J,ba~\b
J-;kUQ
J-;mhۻg
J.i:_TC
J0:LN
J0:fQ
J0I;~\b
J0W;%\t
J0úJM
J2<2h
J4ba~\b
J5<#h\a
J5ջ\rFz
J79 X
J93ζ9
J9\re+:\e
J9`?Y
J:;5W;dw
J:@ž7v6z
J:B9\t
J:`\nx9
J;8n9d
J;D10t\tH
J;K[U9ly
J;Lk5;9
J;Un#;J
J<0"0i3
J<Q2F
J<UP6
J<X[A
J<Ӻju
J=<qX
J>F*j=s
J?:RFk
J?\v<Xb
J@1;C
J@>HBh
JAKgdB
JAj;P
JBԓpBXchB
JCmQ,B
JG1>jY
JG<zf
JHL;G\b
JIU<:O
JJ:2uQ
JK\t;H
JL\v;C㍻qB\a;m\b5
JLνn;\b
JO2<i7y
JS9\fuq
JSv:J
JT:wx\t
JU/9F=3
JVC;fN
JVͻM(1
JW,:IYK
JW,:k
JWP:>О7t
JWP;\a
JWĻCb
JX.<C
JXH+JPH
JXI źXy
JY;.iF;\rl
JY\rtjE
JYk;\n
JYl\al
JZ;pm
J\a;rd\v
J\ab!|H
J\abA|\b
J\aba|\b
J\b?ZU1
J\bba|\b
J\bba~\b
J\f=d3a
J\f\b
J\fba~\b
J\nbA
J\nba|\b
J\nba~\b
J\r6m
J\r9<c
J\rLZ
J\rbA|\b
J\rkEk
J\t:4
J]f=Dh
J`;3j
Ja':q
Ja8N؍:\vn
Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December
January
JbT:;ZB
Jbk9f
Jc,;_Yc;Gd6
JcD0\fI
JcL( B
JcL8 B
JcT"`E
JcT"`F
JcT"`H
JcT( F
JcT*`E
JcT*`F
JcT*`G
JcT*`H
JcT:`H
JcT\n`G
JcT\n`H
Jgv<p
Jgн˜3=F\a
JhH+\bL
JhȽ|z
JkS>1C
Jl<MnA
Jnj:.N
Jo;ZQK
Jpαba}Ip
Jq<ٴN
Jq=\bt
JqӽoA
Jr5<P
Js\e;$E
Js~<b\t
JtC=L
Ju/fq
Jv,=H5
JwH;k5
JxѻPK
Jy:<P
J|iNd
J~A<q\vi
Jž1k\t
Jƞ;\v6T
JʻamȻf
Jώ;M7
Jј<z1
JӰ9+Y9;4
Jӻv}i
Jԋ>I0
JֺVT98
Jٹ?Zi:7
JڹF\v
K SUVWAVH
K"ԺWT
K#̈bS-J
K#͈bC\rL
K%2;V
K%Z;h
K(y:j
K)=2m
K*;1r\b
K*w;B
K+U<_jr
K-;EzY
K-k<C$C
K.Z9R
K.Ϻ5 ݻJe
K0HcQ\f
K0HcQ\fD
K0I;t$\b
K0I;~\b
K0IcF\bH
K0M;u\b
K4:{e
K4w;E
K7r:3`9:%0
K8:˾Q
K90;\f
K9Hu^9
K9Tљ9n
K9Y3u
K9k_(;mA4
K9v4%;Fu&:G
K;"bH
K;7`8
K;A\a@9
K;GqY
K;Nٰ8S"5;N=6
K;T3L
K;j2ļyP8
K;zj\r
K<V=s
K<aXG;0
K<gOo;k
K=9ev
K=o64=y\bc
K={wl>r1
K>H(L>Sg
K>exU?3
K>g'9
K@Hc\aD
K@Ic@\bH
K@ŘYS
K@ŠYS
KAF:0
KB;1R\v
KD$ E3
KD=;k
KD?;h
KE; H
KERNEL32.DLL
KERNEL32.dll
KEѻSN
KF:)uV
KG\n;I
KHH+K@H
KHf9}rx9
KHi;\\h
KI;)hR
KIڽ02
KJ;7-\a
KJ;?U
KJj;Z
KJn>EN
KM:\r
KM:^C\b
KN;\eN
KT,>w
KTW;Xr
KW;0'\t:T
KW;wy
KW\r;Υu;i
KWc;jۛ;a
KXI;~\b
KZI:5\t
KZ[:i!N
K[:cc
K\aU:3Of
K\b;b
K\b<ic
K\b<xL\b3hM\b*t
K\b=CŹ=Yg
K\bH+L$`H
K\bH+L$pH
K\bH+M0H
K\bH+M@H
K\bSUVWATAUAVAWH
K\bUATH
K\bUAUAVI
K\bUAWH
K\bUVAVAWH
K\bUVWATAUAVAWH
K\bVATAVH
K\bVATAWH
K\bVAUAWH
K\bWATAUAVAWH
K\bbA|H
K\n9[M
K\r<3S\a
K\r?z
K\tF H
K]F;^3O
K]o9\v4
K]taM
K^a9ma
Ka=tCP
Ka|ptt
KbP9v
KcT'`G
KcT( I
KcT,`E
KcT,`F
KcT.`F
KcT.`G
KcT/`E
KcT/`F
KcT/`G
KcT/`H
KcT8 G
KcT8 H
KcT<`G
KcT\a H
Kd %f %f %f\n
Kd:>J
Kernel32
Kj:\f[H
Kk;\\S39
Klh:Rw
Klɻ22\r
KmV<3
Km|;jV7
Knights Landing
Knջdx
Ko\v=Y
KpI;J
Kq6:_\r
Ks %f %f %f\n
Ks9\n
Kt@<TN
Kw!=>h8
KxL+HE
KxS:HQ
Kxɻ.U17n
Kz<1fS
Kz_;Zk
K{J9y
KŻ9\vo;\f
K˼g%7
KѼ\vC
Kѽ8:t
KԻY{G
KֻO\eͻz
Kּ]bK
KݻbW9
Kޢ;FM
L  fB
L 0fC
L 0ŠW5ΚI
L <gtȻl
L @ŠW5
L" fC
L#IT$T
L#IT$t
L#O\bt
L#\tM$I
L#\tM(I
L#ȉM0I
L#ȉMDI
L#ȉMTI
L#ɉU\fI
L#ɉu K
L#܈bs]I
L$ E3\v1
L$ H9K0vNf
L$ H9K0vRf
L$ H;K0r
L$ L;b\b
L$ L;z\b
L$ Lc\\$4L
L$ SUVWH
L$ SVWH
L$ UATAUAVAW
L$ UATAWH
L$ UATH
L$ UAUAVH
L$ UAVH
L$ UAWH
L$ USATH
L$ USAUH
L$ USH
L$ USVH
L$ USVWATAUAVAW
L$ USVWATAUAVAWH
L$ USWH
L$ UVATAVH
L$ UVATAWH
L$ UVATH
L$ UVH
L$ UVWATAUAVAWH
L$ UWATH
L$ UWAUH
L$ UWAVAWH
L$ UWAVH
L$ UWAWH
L$ UWH
L$ VATAUH
L$ WATAUAVAWH
L$ fA
L$ fD
L$(3ɉD$ D
L$(A2
L$(H+L$0H
L$(H9K@v@fff
L$(H9KXvBfff
L$(H9KXvFfff
L$(H9V\bv
L$(H;KXr
L$0H9Khv@fff
L$0H;K\bt\nH
L$0H;Khr
L$0HcQ
L$0I;h\b
L$0fA
L$0fff
L$0t\rA
L$89L
L$8;G
L$8H+L$0H
L$8H;u
L$8L;H\b
L$8LcȋQ
L$@H9N0vBfff
L$@H;N0r
L$@H;N8r
L$@Hc
L$@HcL
L$@I9N8vBfff
L$@I;N8r
L$@L9n8vBfff
L$@Lk
L$@fA
L$@s1H
L$@tyC
L$D;L$T
L$HH;O0r
L$HH;\r
L$Hb!|H
L$Hs!E
L$P+L$8
L$P+L$H
L$P3\tD$8H
L$PD9v
L$PH+L$HH
L$PHc
L$PHcL
L$PIcD
L$PMk
L$PfA
L$PfC
L$PfE
L$Pfff
L$PġjYD
L$PŰYE
L$PŰYEP
L$PŰYM0
L$THc
L$TL#\v
L$XH+S
L$XL;\tH
L$Xt\rI
L$\bATAVAWH
L$\bAVH
L$\bE
L$\bH
L$\bI9\f
L$\bIc\aI
L$\bSATAUH
L$\bSUVWATAUAVAWH
L$\bSUVWATAUAVAWL
L$\bSUVWATAUAVAWM
L$\bSUVWATAVAWH
L$\bSUVWAVAWH
L$\bSUVWAVH
L$\bSUVWH
L$\bSUWATAUH
L$\bSVWATAUAVAWH
L$\bSVWAVAWH
L$\bSVWAVH
L$\bSVWH
L$\bUATAUAVAWH
L$\bUSAVH
L$\bUSVWATAUAVAW
L$\bUSVWATAUAVAWH
L$\bUSVWAVAWH
L$\bUSVWH
L$\bUSWH
L$\bUVAWH
L$\bUVW
L$\bUVWATAUAVAW
L$\bUVWATAUAVAWH
L$\bUVWAVAWH
L$\bUVWH
L$\bUWATAVAWH
L$\bUWAUH
L$\bUWAVH
L$\bVATAUAVAWH
L$\bVWATAVAWH
L$\bVWAUAVAWH
L$\bVWAVH
L$\bWATAUAVAWH
L$\bWAVAWH
L$`E+P D
L$`M9bXtF
L$`Mk
L$`fA
L$`fD
L$`tyC
L$dL#\v
L$pH#Љt$0I
L$pH;z\b
L$pIcF
L$pM9rPtR
L$pfA
L$pfB
L$pfff
L$x3ۉT$XD
L$xH+M
L'3>7
L( fB
L* fC
L*b.r0R2R
L+@9\nu
L+HEgI
L+IPH+BPI
L+L$xL
L+d$8I
L+w>p{B
L. >Y
L0;CV\b
L3 b1
L38;<d
L3:\a
L3;Kp
L3=,J
L5#;48
L5;Wp
L5<4끼<o
L6<v|Q
L7=Vo
L7A@V
L8<wNb
L9!t\tH
L9"t\rH
L90u H
L9;0ʍ:Y
L9;<T
L9@JL;4w
L9M`tAeH
L9c\bt\vH;C\bv
L9eXtEeH
L9hc\n
L9n t;H
L9n0v9
L9n8v9
L9nPt
L9nPta
L9n\bv
L9p\bt H
L9s.λJ
L9vPtY
L9x s\nD
L9}HtFeH
L:%kM
L:Bx\f
L:E\bC:Tv
L:Zfc
L:nl~:85\f
L:x\e
L:{Lr9
L; u9H
L;9Bl;.u
L;<\r9j
L;CPr
L;G0r
L;PPZ
L;X-x
L;\eH
L;\rI
L;\t8g
L;\tM&9
L;a\ac:C
L;g\bsmI
L;i%R
L;o\bs{I
L;sMi9䳮8
L;s\bsaM
L;s\bscM
L;u\bs`M
L;u}W
L;x\b
L<%OW
L<iWj
L<j_J
L<pAͺNt
L<q\fs<8
L<tsF
L=C\e
L?UUUUUUU
L?n(Zy
L@Y<9b
L@YA\vbaL@Yi
L@YI\fb
L@YQ\bb
L@Ya\tbaL@Ya\rbaL@Yq\nb
LA;$H
LAѼ\tx
LB(9J\bMc
LBʺ,1
LCIDToLocaleName
LCMapStringEx
LCMapStringW
LCW&qB
LC_ALL
LC_COLLATE
LC_CTYPE
LC_MONETARY
LC_NUMERIC
LC_TIME
LCr;xp
LEv;B
LGλߞ4:nF
LHYu\bb
LHYu\fbBMH
LHYu\nb
LJ;t*6;\r
LL(;sd
LLS;D\n
LM>:Gs
LO=IKR=i
LQ::3F;U
LQ<\fm
LR;xP
LT fC
LT$L;L$D
LTW;zh
LTϻpz
LU fC
LV{;z
LX<"H
LXֻK\t
LY\e<<A
LZ6;Dc
LZ><5
LZCNT
L[:u5
L\a;h
L\a\nbQ|H
L\af;w
L\b0ŠW5
L\b;J\aU
L\b@ŠW5
L\b@ŠW5/Ia
L\bt;n
L\e:\ep\b
L\n\\;oPZ:rq
L\n\vba|H
L\r+;22
L\r<oK8
L\t<c(Y
L\t>J沾fQ
L\vN;Ye39
L`;wm
La9;F
LcA<E3
LcB\fHcJ
LcD$4I
LcD$HI
LcD$xH
LcL0\bL
LcSlI
LcT$(Mc
LcT$@H
LcT$DH
LcT$`Lc\\$pLc|$h
Lc]lI
Lcʍ\fRL
LcщL$HI
Lc҉T$4I
Ld;6,R
Ldy<x4
LeaveCriticalSection
LegalCopyright
Leպj'g
Lf ;1
LfH;xR
LgQ<R
Lgk<pMm
Lhttp://cacerts.digicert.com/DigiCertTrustedG4RSA4096SHA256TimeStampingCA.crt0\r
ListenerPosition
ListenerUp
ListenerView
LjȼF0
Lk6;S
LkڻA\n
Ll;=Z
LoadLibraryA
LoadLibraryExA
LoadLibraryExW
LoadLibraryW
LocaleNameToLCID
LookupPrivilegeValueW
Lpd9\b
LsY;w
Lt:-q
Lu:/vR
Lu;4\a
LuȻS!T
Lw#;aR
LwCԓpB
LwZ:\aa
Lx4;V
LzdA9
L{;JlA
L{=R7
L}7;R
L~Z<9
Lú,vE
LǼhE強U
LȺ`FU
L۾=kmT
Lܟ<Fi
Lܻ/h0<S
L毺#$p9M
L溬U2<2
L뢺HCA;(sպ\tG
M H;;L
M#Q\btѐA
M#Y\btѐA
M#Z\btѐA
M%;3J}6i
M&t:Z
M'y>0y
M(L+M H
M(L;\tH
M(f95
M)\r=Dk
M+2;5V
M09L8\bu
M0H;A0
M0ȹ6,h
M19uA
M1ػ\r
M2\e>(G0
M5D:\t
M6%:V\b
M8H;A
M8H;A0
M8J<^N
M8LcC\bI
M9,<o
M9bPtU
M9bXtF
M9bXtI
M9l$\bt
M9n t:H
M9n t:Hǅx
M9n t;H
M9rPtO
M9rPtQD
M9rPtTD
M9rPtU
M9t$\bt
M9zPtU
M::\fR6=F0
M:FWC9\a
M:F\t
M:F]T;i
M:i\r
M:mZI
M:~\aO9
M; Tz
M;=0c
M;Cis
M;D$0u
M;Iq
M;Q\br
M;Q\bs I
M;Q\bs"I
M;Q\bs)I
M;Q\bs,I
M;\vC
M;\vu.H
M;_\n0<d7
M;a)Y:cWa
M;g\bsnI
M;gzѻj
M;uZ)9
M;yKL
M;~\bsdM
M<Z⣼je
M<g-7
M<okk
M<u\a
M<v4S=dp
M<|nZ
M<Ū_U4L
M=F\rp
M>9rT
M>N:hO
M>jYX
M?H;MGs H
M?ؼ5T
M@3\bD
M@H;A0
M@H;x\b
M@L;C\b
M@ŔYq
M@żWM
MA!;b
MAh9k
MB (100.00
MB(iVR
MC'<x
MC|D\t
MD#Έb3}D
ME\r<*j
MFغBV
MJ\rAk
MJ\rZz
MJ\rnk
MK&;A
MLŪ_UDL
MM/dd/yy
MM<-r
MM[<\fb
MM\v;S
MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON
MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON
MN(;n\bI
MO=#II
MOy:O
MP9'/r
MP;4nf
MP;H(s\bD
MP;H8s\bD
MP>9(4
MPH;A0
MPH;x\b
MPIcE
MPŌWU
MQ(;q\b
MQO;AG
MR:}U8
MS:DP
MVC9bj
MW(;a\v
MW\\;yP
MXCSR
MXH;A0
MYZ=t
MZC;\b\n
M\\Z:Zc
M\a>LmB
M\abQ|H
M\bH9K@v9
M\bH9V\bv
M\bH;K@r
M\bH;O0r
M\bH;OXr
M\bI9N8v9
M\bI;N8r
M\bL;j\b
M\bbA|H
M\e"<Pp
M\e;C3B:r
M\fC:E
M\fbA|H
M\nbQ4HV
M\nbQ|H
M\r=e
M\rb"eH
M\rbQ|H
M\t<T3
M\t\f
M\tbA\\@YE\fbbu
M\tbA|H
M\tbb
M\vb"5H
M\vbQ|H
M]k9đ9;,h
M_L;O\b
M_M;O\b
M`H;x\b
M`L;c\b
M`M9bXtI
M`M9zPtU
M`M;a\b
M`ŌYK
M`ŠYK0
M`ŬYK
Ma%=sQ
Max split depth
MaxRealTimeComputeUnits
Mc<$JcT
Mc<$fff
McD$lL
McL$l3
McL$lI
McL$lL
McU\fMc
Mc\rL
MessageBoxA
MessageBoxW
Mf:\nVD:1
MgH+}o
Mh<<l
MhI;O8r
MhL+M`I
MhL+M`L
Mhttp://crl3.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0S
Mhttp://crl4.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0
Microsoft Visual C++ Runtime Library
Min node overlap
Mi̻OT
Mj: <;e
Mkd;`8
Mkλ\f
Ml><\rm
MlJ;DhE
MmE;=\t
Mn,<e
MnY>g
Mnݺ?K
Monday
MpH;x\b
MpM9bXtI
MpM9rPtU
Mp\e<I⩼K
Mpqba}Npɱb
Mprim/s
Mp±ba}Npѱb
Mpȱb!}Np1b
Mpбb!}Npqb
Mpܱb!}Np
Mpݱb!}Np
Mpޱb!}Np
Mp߱b!}Np
MtR:gTK9
MultiByteToWideChar
Mw黋hºY
Mx=;81
MxHcB,Hi
MxL+MpL
M{<g5\b
M~ӻeD\r
MÅ9bs
M˻Voû9B
MЈD$0H
Mѻf'N
MԺXH:U
Mވ;TI
N 6:f
N"7<aX3
N()8Ix
N(A9O(A
N(IcG\fIc
N*;eaL;A
N+h:J\t
N-<odm
N.9c\fu
N0M;t$\b
N0M;w\b
N0l;g\a\n
N12:T\rz
N2JVR2PjT
N2Lɭ3
N3;:qV
N5:<3
N7w:\a
N8=?3w
N9Ɏm;q
N9ꚨ9*x
N:"l9;H0
N:&kK
N:,ZX
N:6hҺI
N:@ok
N:Bnz:l
N:I\n
N:\fJ
N:d$p9
N:xV 9lwm:L
N;2]P
N;:3S
N;EN\f<Wm
N;\eu\t;oV
N;yF(;d
N<<O0
N>?mt
N>O=I9
N?6;\t9
N?m;WN\n
N@Z.82h
NA;Re0
NAN(IND
NAN(SNAN
NB;9*\e
NC<\r&O
NCŻrB
NEչ;F9
NF-;FE
NGV:ps
NHv<\b4
NK"<4
NK=XiG
NO+;p
NP:DJt
NS[;\br
NU:tv
NUֺRv
NVG<j
NW;Jʘ:I
NWW=D
NXH+NPH
NXH+NPL
NXL;`\b
NXL;u\b
NXM;g\b
NXM;u\b
NXM;}\b
NXM;~\b
NZt>R
N\a7>YP
N\bH+L$XH
N\bHc^\f
N\bL+HE
N\eh;nD
N\f<5\e
N\n<6,u
N\n<g蚻=sM;Ez
N\n>m
N\v;S
N\vk;d5
N\vxV
Nb!|H
Nb!}Hp
Nb!}Ip
Nb!}Jp
Nb!}Kp
Nb!}Lp
Nb!}Mp
Nb!}Np
Nb!}Op
Nb"5@6
Nb"5Ce
Nb"]Oe
Nb"uMe
Nb1|H
Nb1}Hp
Nb1}Jp
Nb1}Kp
Nb2\rOe
Nb;f4
Nb<]f
NbA|H
NbA}Hp
NbA}Jp
NbA}Kp
NbA}Lp
NbA}Mp
NbA}Np
NbA}Op
NbB-Be
NbB-Ce
NbBMKe
NbBUCe
NbB]Me
NbBeDe
NbBmDe
NbB}Me
NbQ|H
NbQ}Jp
NbQ}Kp
NbQ}Lp
NbQ}Mp
NbQ}Np
NbQ}Op
NbR5Ce
NbRMKe
NbR]Me
NbR}Me
Nba|H
Nba}Hp
Nba}HpP
Nba}Jp
Nba}Kp
Nba}Lp
Nba}Mp
Nba}Np
Nbb5@6
NbbE@6
NbbUMe
Nbb}Me
Nbq|H
Nbq}Hp
Nbq}Jp
Nbq}Kp
Nbq}Lp
Nbq}Mp
Nbq}Np
Nbr%Le
Nbr%Ne
Nbr\rMe
Nbr]Me
Nbr}Me
NcD( F
NcD* F
NcD*`D
NcD8 F
NcD: F
Nc\\\b\fF
Nc|0\fA
Nehalem
Nf\a<@\n1
Nfffff
Ng;a7a
Ni)9sW3
Nj7<h
Nl/7D\e
Nm,:p3
No such kernel in program
Node overhead
November
Npqba}Mpɱb
Np±ba}Mpѱb
Npȱb!}Mp1b
Npбb!}Mpqb
Npܱb!}Mp
Npݱb!}Mp
Npޱb!}Mp
Np߱b!}Mp
Nq);p
Nr维iT
Nso<Uh <[EF
Number of nodes
Number of nodes in corresponding non-split BVH
Number of triangle refs
Number of triangles
Nv<v\b
Nwܻ[Q
Nxr;z}C
NzQ759
NÒ9a/ֺG
NʹKwR
Nʼ8\r
NʽqQ;<b
Nйh4L
Nѫ8F k
NӹE0ٺ[YF
N֖<Hj
NֻM?c
Nސ:aG
N߈<7m\e
N꺑了9w
O +O0
O <6qﻁ?8
O!9u\tr
O"<Fox
O%<bZ7
O&G=GM
O(A+O0
O(D;O,L
O(IcG\fIc
O*u;C
O+ԻFcU
O,;42
O/;2R
O/M:Yj
O0I;u\b
O0L;p\b
O0M;t$\b
O0M;w\b
O0S:#Q
O2\r:T
O3 <9
O34<u
O3<\rL
O7;CN\a
O8eq۹9
O9$\au\eH
O9:\e
O9>g+̾F~C
O9k\eL;7
O:L`z;6G
O:OI\t
O:XZ0
O:\rI
O:j\vκ\f6
O:n%I
O:n&c
O;)Kh97H
O;0JV
O;3eu
O;>Kf
O;EMX:L1
O;Q;0S
O;xY~:3
O;ʊZ9I
O<+Ch
O<I8r<55
O<PTS
O<RoL
O<\nm\a;U
O<o|x
O=Эl=rf
O>'Nz
O>A\v
O>a4\e
O@H+GHH
OB9>&L
OC;Ox
OE:;Cmɺn
OF<;AX
OFȻQ=\n
OI2;#C#8T9
OI>4v
OK;)n
OMs9Gr
OP4=q
OR<nNE
OS<\eoS
OT9IGU9
OU=\t9
OUA:\v
OXH+OPH
OXH+OPL
OXL;x\b
OXLc\aI
OXM;}\b
OY;;T
O\b<xP\b3hQ\b*t
O\bH99u
O\e{dP\r<u
O\r?e
O\ru>O\r
O\v⼋G
Obk:nz
OcE9H
Ocd.`B
Ocd.`C
Oci;60
October
Od:KF
Of ;EKr
Oh6>I
Oh:t84;˴A
Oh;1O
Oi;Ǒs
Ok˻\n}4
Ol\f>k
Ol{gN
Om;Fq29"U
Oo<C`2
Oos<"m
Ooy:G9c
OpenCL 1.0
OpenCL 1.1
OpenCL.dll
OpenProcessToken
OriginalFilename
Osq<%\e
Ou:|J\a
Ou=g[P
OutputDebugStringA
OutputDebugStringW
OwR<H
Oxb;V
Oy;_R\n
OyR=MI
OyT]Z
Oz;80\b
O}'<soV
O}Q;\ec
O}|8x
OŸdxp
Oȹa5\a
OȺaOι/x7
Oɻ\fS
Oλh%S
Oμ\btF
OϺ+i1
Oջ\fN
OܼRZȼS:S
OܼYGƼ9
O춻_xB;d
P#8\bUo
P$;5vc
P%- p3
P%8=R
P%;7vy
P&u:.Qs
P':Udo
P)e:J
P*;0pz
P+z;%\nP9
P,9E5
P.<dcm
P.T:X
P2<C.s
P2L|R2
P4Ի.Co
P5=BM
P7%Cs
P7*;Y
P7g<hVB
P88EB8j
P90p»N2
P9ue!9
P9v_W
P9vۊ:y
P:;VNZ
P:KH2;v`\n
P:PYi
P:bB|:N^i
P:c!F
P:glm9
P:o!w
P:o/9
P;-sp;Q
P;2p-:cY
P;5\t
P;9G\b
P;:u6
P;;%z9P
P;;uD
P;HSr=P65
P;\eZ
P;nRǻ\b
P;ތh9
P<6{e
P<;pVq;y
P<_zûx8
P<x:C
P<zZ\t
P=X&a
P=id1=u
P> {r
P>FDO=mJg
P>q_Y
PA^A]A
PA_A^A
PA_A^A]A
PAq=?Mp
PC6>g
PC<C\r
PCż<0
PD@?h
PE:WGO
PE:[U
PE:ߴf
PG;82
PH+O@H
PH;;L
PH;|$pL
PH;}8L
PHL+P
PHL;hXH
PHM+P
PHcB M
PI;@H
PI;^\br
PJ;I:qE
PJ;ug5;mɤ:|\r6
PJ<\f>ʻTH0
PKS;L
PL>\e7J
PLci\fM
PM<H\eW
PME<NT
POPCNT
PO˴@N
PPPPPPP
PQN;n
PS;RG
PS~;ok
PT:\bnL
PUUUUU
PV:R3\f
PX2?q\v
PXI+PPI
PYT$pŸY
PYU`ŸY
PZ)>0X\b
P\aX=db
P\bG<A\f2
P\bJ<"ac
P\eR;g
P\rT91
P\rbA
P\t:YN9
P\v;I7\f
P\vT8D5
P\v˻b
P]A_A
P]A_A^A
P]DSH
P_ËD$ H
P`m8ս\t
Pb!|H
Pb3]A
PbQ;y
PbQ}Hp
Pc;J,Z
Pc<mf\t
Pd=J=j
Pe?9ȭ9
Ph=\tcw
Phttp://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt0\f
Pl;=r
Pl>FE\e
Platform
Pm<̱g
Pn_;A\fݺ9
PoԻ\b
PpH;G\btpH
Pr3<1
Press Retry to debug the application - JIT must be enabled
ProductName
ProductVersion
Program
Ps >O2
PsӼ{Q
Pt*9Z
Pv\f;n
Pw;D\a
PwK:7
Px$9ϧH;[Fs;M:B;6
Px:1IN
Px\e=5
Pxm=b
Pz}b!\n
P{;tiO
P{\b80\r
P}W9c\n
P~|94
Pũ;jR
Pƹ:HV9b/x
PʽJX@=1\b
Pꁺz1\r
Pﺜkn;TB
Q ba|\b
Q g;#a39e
Q)9&T
Q)G>v
Q*;9fͻ5
Q*\n8
Q,9mv
Q.>39
Q09ز1
Q0\n;Q
Q2;Wg
Q2\v>r
Q5rHg
Q6:%E
Q6:jkf
Q8+<\rp
Q8:@uZ9
Q8Kڐ:s
Q9-LM
Q99Ȋ9o
Q: 䙻l^K;v
Q:(ky
Q:@8R
Q:D=J
Q:Xji
Q:nDa
Q:|mH9
Q;3ң9
Q;9\e
Q;i\t4;8
Q;k$K
Q;rP,;9
Q;v#N
Q<6;˹hs
Q<Ee5
Q<LL㻷M
Q>)Hu
Q>.3Z
Q>9;D
Q?;4v
QA;ll
QC<CL\a
QCN:J
QC{;b
QDI:w
QF<k\nϻ,O
QF<wt9
QGջ}7;T
QH;Af;=jlG
QHI+Q@H
QI);mF
QJI?me
QJr<h$4
QJ ~;F$I
QK[;pe
QL"<z
QM:&WJ
QO<^UC
QQH:Nj
QRAPAQ
QRU=$m
QS:o|2
QT;3RB
QUٻtv
QW1<|KؼY
QXX9l
QXz<%V
Q\a:RM6
Q\aba~\b
Q\bI9Q\bu
Q\b\f0\vP
Q\bba~\b
Q\f:z
Q\fba|\b
Q\fba~\b
Q\v=\tx\a
Q\v>'QP
Q\vb!f\bX
Q\vbaN
Q\vba~\b
Q]2<4
Q`1<l3
Q`H+QXH
Q`O;F
Qa;\rE
Qa湥\fY
Qc<rGP
Qd~;lM
Qg;]bĺn
Qg\t;\b
Qg󻤍f<P
Qh٢%v
Qi9<`N
Qi<;qӼf
Qj2<2
Qkkbal
Qk}9UHĻP
Qlp9iFٺ[Uk
QlغT7G
Qm9\b
QoF9vG
Qp:P3W
Qp;4^B
Qp\v;\f
Qq@<k`9
Qt"=3
Qu;|k99
QueryPerformanceCounter
QueryPerformanceFrequency
QwI;2
Qx$=nE
Qx:+BF
QzhÐ;3
Q{:re
Q~N;I
QĹh1F96(6
QŌ=ZF\a
QȻP1L
Qɼf+l
Qѻ6,L
Qڊ;\e 8
Qܼg1Z
Q於o~t<z
R!;6K
R$ba|\b
R$p;K
R&:1L
R&ٺrO
R(ȻTL
R+<cD
R-;\rqE
R-L;4
R-b:Z
R0<^2
R0<`6
R2<S1r
R3#;q
R3:#6
R4.:;bF
R6;:E膺8
R6;S+O
R8?Bh9
R8bXźN
R8sjz9
R8|=r
R9.vӹ\a
R9=Io9<}D5
R9A\f\f
R9D:U
R9NPh
R9Wd9
R9m>,P
R:7=K
R:=uo
R:o1j
R;F\n
R;JIG
R;[x~9\fA
R;g\eN
R;zY<h
R;ĹmS
R<jeźO%4
R<l6y=E`0
R<omۻ@} :zhg
R=xRl
R>B/e
R>z☿i
RA4;9
RAA;z\b
RC=hb
RCF;Z
RD=6>k
RDATA
RDRAND
RE\n;zD
RF:9RL
RH<PX\e<ڀ=2Bk
RHлBnk
RIQ:az
RK>VWI=N
RM:PS
RN;Q5u
RNP=eN
RO;Uk
RPܻ=K
RRG<F0
RRX8Cv
RSDS\\m
RX;u1n
R[<bRl<v`p=4
R[N;n
R\aba|\b
R\bHcUwH
R\bHc\aH
R\bba|\b
R\bbb
R\ebA|\b
R\fba~\b
R\fӻA@\t8
R\nK9r#M
R\nba|\b
R\r4:BF
R\r;C
R\rp\f`\v0
R\rp\f`\vP
R\rϺi\aC
R\t:f3
R\tba|\b
R\v:V
R\vۊk
R`Q<l\r
R`bA|\b
Ra;-jf
Ra\e:dB
RaiseException
Rays \n    GLOBAL const ray *restrict rays, \n    // Number of rays in rays buffer \n    GLOBAL const int *restrict num_rays, \n    // Stack memory \n    GLOBAL uint *stack, \n    // Hit results: 1 for hit and -1 for miss \n    GLOBAL int *hits) \n{ \n    __local uint lds_stack[GROUP_SIZE * LDS_STACK_SIZE]; \n \n    uint index = get_global_id(0); \n    uint local_index = get_local_id(0); \n \n    // Handle only working subset \n    if (index < *num_rays) \n    { \n        const ray my_ray = rays[index]; \n \n        if (ray_is_active(&my_ray)) \n        { \n            const float3 invDir = safe_invdir(my_ray); \n            const float3 oxInvDir = -my_ray.o.xyz * invDir; \n \n            // Current node address \n            uint addr = 0; \n            // Intersection parametric distance \n            const float closest_t = my_ray.o.w; \n \n            uint stack_bottom = STACK_SIZE * index; \n            uint sptr = stack_bottom; \n            uint lds_stack_bottom = local_index * LDS_STACK_SIZE; \n            uint lds_sptr = lds_stack_bottom; \n \n            lds_stack[lds_sptr++] = INVALID_ADDR; \n \n            while (addr != INVALID_ADDR) \n            { \n                const bvh_node node = nodes[addr]; \n \n                if (INTERNAL_NODE(node)) \n                { \n                    float2 s0 = fast_intersect_bbox2( \n                        node.aabb_left_min_or_v0_and_addr_left.xyz, \n                        node.aabb_left_max_or_v1_and_mesh_id.xyz, \n                        invDir, oxInvDir, closest_t); \n                    float2 s1 = fast_intersect_bbox2( \n                        node.aabb_right_min_or_v2_and_addr_right.xyz, \n                        node.aabb_right_max_and_prim_id.xyz, \n                        invDir, oxInvDir, closest_t); \n \n                    bool traverse_c0 = (s0.x <= s0.y); \n                    bool traverse_c1 = (s1.x <= s1.y); \n                    bool c1first = traverse_c1 && (s0.x > s1.x); \n \n                    if (traverse_c0 || traverse_c1) \n                    { \n                        uint deferred = INVALID_ADDR; \n \n                        if (c1first || !traverse_c0) \n                        { \n                            addr = GetAddrRight(node); \n                            deferred = GetAddrLeft(node); \n                        } \n                        else \n                        { \n                            addr = GetAddrLeft(node); \n                            deferred = GetAddrRight(node); \n                        } \n \n                        if (traverse_c0 && traverse_c1) \n                        { \n                            if (lds_sptr - lds_stack_bottom >= LDS_STACK_SIZE) \n                            { \n                                for (int i = 1; i < LDS_STACK_SIZE; ++i) \n                                { \n                                    stack[sptr + i] = lds_stack[lds_stack_bottom + i]; \n                                } \n \n                                sptr += LDS_STACK_SIZE; \n                                lds_sptr = lds_stack_bottom + 1; \n                            } \n \n                            lds_stack[lds_sptr++] = deferred; \n                        } \n \n                        continue; \n                    } \n                } \n                else \n                { \n#ifdef RR_RAY_MASK \n                    if (ray_get_mask(&my_ray) != convert_int(GetMeshId(node))) \n                    { \n#endif // RR_RAY_MASK \n                        float t = fast_intersect_triangle( \n                            my_ray, \n                            node.aabb_left_min_or_v0_and_addr_left.xyz, \n                            node.aabb_left_max_or_v1_and_mesh_id.xyz, \n                            node.aabb_right_min_or_v2_and_addr_right.xyz, \n                            closest_t); \n \n                        if (t < closest_t) \n                        { \n                            hits[index] = HIT_MARKER; \n                            return; \n                        } \n#ifdef RR_R
Rb=ib>>s
ReadConsoleW
ReadFile
Reb;,9
ReceiverPosition
Ref duplication
Release
ReleaseSRWLockExclusive
ResetEvent
ResetEvent failed
RhbR%H6
RiF7B4
RjԻ6bM
Rk/<r
Rn黵_s9
RoInitialize
RoUninitialize
RoomType
Rp3\tD$4I
RpL;W0
Rs\e>$i
Rt>Y\v
RtlCaptureContext
RtlLookupFunctionEntry
RtlPcToFileHeader
RtlUnwind
RtlUnwindEx
RtlVirtualUnwind
Rx.:M
RxL;l$P
RyV;I7
Rzh;~օ9%SP;iO
R~R;o
RĢ: x
RźE_M:j
RƺZWg
R˷cu*:Q
R֞:PC
Rݻ\eYP
R􂻬9ɻ1
S$\r;ua
S%2;n
S%R;1mi
S)<:GO;4W
S,, <Zw
S,f<Ma
S-K=5
S03\tD$03
S0<CwS
S0H+L$pH
S0Lcs
S19=-o
S1<H6Y
S2<!fE
S2D<U
S38u\f
S76ƛ:G
S7;31
S8-pԺ7g
S8pŕ:r3\t
S9US}9Do
S9\e1ƺx_u;d
S9b,T:G
S9bmD:M
S:5\fI
S:RRݻʇE
S:^6O
S:a5B
S:jg.;O
S:nHJ
S:orA
S:tJ\a
S:u{q
S;AT5
S;ThM
S;XUѺ\r
S;\nKa
S;\vK
S;p\eg:ya
S<0M\e
S<;NI
S<DQӽ?\aQ
S<dl\f
S<dxU
S=E砽\f4\v
S>$hkDh$h>[2
S>ɽ\v5R
S?ۺuj
S@bR5@6
S@bR=@6
SAH bins
SATAUAVAWH
SATAUAVAWUH
SATAUAVH
SATAUAVUH
SATAUAWH
SATAWH
SAVAWH
SAVAWUH
SAVAWUI
SBx;L
SD<\fs6
SE,<1x
SE˻E\f
SG;t'\e
SHARED TESSELLATION CACHE
SHH+S
SHH;~\br
SJ:U]\r
SJ;uK0
SL:o\vu
SLD<;d
SLY:Ca
SMٻEG
SOFA file %s contains non-zero values for Data.Delay; this is not currently supported
SOFAConventions
SQ@>X
SR=:\bB
SS<J\f
SSE4.1
SSE4.2
SSSE3
STJ>T
SU;CB
SUATAVAWH
SUAVH
SUAWH
SUVATAUAVAWH
SUVATAUAVH
SUVAVAWH
SUVWATAUAVAW
SUVWATAUAVAWH
SUVWATAUAWH
SUVWATAVAWH
SUVWATAWH
SUVWAVAWH
SUVWAVH
SUVWAWH
SUVWH
SUWATAUAVAWH
SUWAUH
SUWAVAWH
SUWAVH
SVATAUAVAWUH
SVATAUH
SVATAVAWUH
SVATAVH
SVATAWUH
SVAUAVAWH
SVAUAVH
SVAUAWH
SVAVAWU
SVAVAWUH
SVAVH
SVAWH
SVWATAUAVAWH
SVWATAUAVAWU
SVWATAUAVAWUH
SVWATAUAVUH
SVWATAUAWH
SVWATAUAWUH
SVWATAUH
SVWATAVAW
SVWATAVAWH
SVWATAVAWU
SVWATAVAWUE
SVWATAVAWUH
SVWATAVH
SVWATAWH
SVWATH
SVWATUH
SVWAUAVAWH
SVWAUAVAWUH
SVWAUAVUH
SVWAUAWUH
SVWAVAWH
SVWAVAWUH
SVWAVH
SVWAWUH
SVWUATAUAVAWH
SVWUATAUAVH
SVWUATAUH
SV{TIJ
SV|;Th
SVۺcj
SWATAUAVAWUH
SWATAVAWUH
SWATAVUH
SWATAWUH
SWAUAVH
SX<ZoG
SX<eTk
SX=fmZ
SXH+SPH
S\a>1J
S\aN>pl
S\aba
S\b<xT\b3hU\b*t
S\n99\f6
S\n\e;V@3
S\t=Bo
S\vl<\b
S\v˻3X
S`H+SXH
S`Q;Udc
SandyBridge
Saturday
Sb<DPL
Sc\\9Y
ScatterKeysAndValues
Scene is empty
SeLockMemoryPrivilege
September
SetEndOfFile
SetEnvironmentVariableA
SetEvent
SetEvent failed
SetFileInformationByHandle
SetFilePointerEx
SetLastError
SetStdHandle
SetThreadAffinityMask
SetThreadAffinityMask failed
SetThreadGroupAffinity
SetThreadGroupAffinity failed
SetThreadIdealProcessor
SetThreadIdealProcessor failed
SetThreadIdealProcessorEx
SetThreadIdealProcessorEx failed
SetThreadpoolTimer
SetThreadpoolWait
SetUnhandledExceptionFilter
SimpleFreeFieldHRIR
Simulating reflections for %d sources, which is more than the max (%d). Some sources will be ignored
Sj-;16\r9
Sj<#1\e
Sk0;1Z
Sk;|2M
Skylake
SleepConditionVariableCS
SleepConditionVariableSRW
Sls<69
Sm<HF
Smc:[oT
Sn8:\bn
Sn;-\fO
Sn;\t
SourcePosition
Sp>g8d
SplitBvh\n
Sp커斻K
Ss=pM
Ss\b>(a
St;c|B
StJ:z7
StO9>T
Steam Audio
Steam Audio Core
StringFileInfo
SubdivPatch1
SubdivPatch1CachedMBlurBuilderSAH
SubdivPatch1EagerBuilderSAH
SubmitThreadpoolWork
Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday
Sunday
Sv\a>6
Svڻ%W
SwitchToThread
Sy*>TE
SzԺ`3
S{h;R
S~:\bz,9F
SŴ:p1i
Sƒ6jp
Sʅ;QV
SӀ:FfZ91
SӋ>x0
SӺWs\f
SԹk@Y
Sռk\r콆1
SܹS0-;\aX
S߹\rX6
S溝OƻlU
T  fB
T 6<.è7k
T :H]Z
T PġpYD pĢI
T `ġpY
T!;\fAI=HH
T!<qf
T" fC
T"9xh
T$ fA
T$ fE
T$ ff
T$ fff
T$ t H
T$ t"H
T$ t'H
T$ t)H
T$ t-H
T$ t0H
T$ t2H
T$ t;H
T$09t
T$0;MwH
T$0H+G@M
T$0Hc
T$0Hc\v
T$0Lce
T$0fA
T$0fff
T$0s+H
T$89T
T$<9T$D
T$@Hc
T$@HcB
T$@HcElH
T$@HcL
T$@IcG
T$@fA
T$@ff
T$H3\tD$8
T$H3ۉL$P
T$H9SD
T$H;T$L
T$HI;B
T$Hb!|H
T$PHcB
T$PHcL
T$PI;B\b
T$PIcG
T$PM9y\bt
T$Pb!|H
T$PfA
T$PfE
T$PŀW
T$PŀW%a
T$PŨYE
T$XH;WXr
T$XHǅ0
T$XHǅP
T$XI;B0
T$XLc
T$XtsA
T$\bI;T
T$\fuPH
T$`A9r\b
T$`Hc
T$`HcۉD$XHc
T$`KcT( A
T$`fA
T$`fD
T$hI9V8v?ff
T$hI;V8r
T$pH;z\b
T$pHcL
T$pHǅ0
T$pfA
T$pfD
T$pǅ8
T%'Wv
T%4(j
T%GLP
T%N~z
T%O;J
T%\fO
T%c-y
T%kFy
T( fB
T* fC
T*\abA|H
T+=\elA
T+\aba|H
T,7#1T:g
T,Z=T
T-7N3
T-KH3
T-VFk
T-k\tE
T-k\vE
T.;WLY
T/;ivJ
T1R:3
T1X;2\v
T1\\;kO
T2E:m
T2]:v
T2xġjYT2
T3:.a19
T3:\rc`:0
T4;r~c<v2
T5p43
T5p@3
T8*NR:5
T8-9D
T8^<r
T8e;!RT
T8Ǽ6뽣s
T9E)y; 9o
T9Q=C
T9i5Z:\tH
T:/Iu:0
T:7*h
T:9(j9
T:I:Z
T:ZXW;10
T:\aEe
T:\ts
T:r~s8
T;9?N
T;\nb
T;f%g;An ;6
T;hD\e
T;s@K
T;лIB
T<@zɽA\fC
T<gLk:F\fX
T<p;ol
T<q\tӼ\tI
T=C~y
T=G\n
T=Pms
T=fQμ\n
T=f]1
T=pN6
T>G'i>s;I
T?E;EAf
T?j?Y
T@Y- iE
T@Y-~gE
T@YU\bb
T@Ym\nb
TANCreateContext
TANCreateConvolution
TAz<)o
TBgvlC~0GB
TC:i5
TC>0L
TCg:G
TEP:$q
THY-0YD
THY-fhE
THYT\a\fb
THYɍT
TIL$@A
TIf:'XȻz
TJ;Z6
TKD2\bA
TKS;X
TKS< R
TL¼\vR
TMd;g
TN;?l
TNǻo\f
TQ\v;K
TS;0C
TT fC
TT.:77
TT5\rH3
TTo;\t
TU fC
TUUUUUU
TV;<\fd
TV;l>n9
TW=ON3
TX,"H
TX\f1L
TY,>5
TY=}p3
T[9d%D
T\a<Vn4<rD
T\a\bba|H
T\a\bbq|H
T\a\tbQ|H
T\a\v:8
T\a\vba|H
T\b<J
T\fU;Sm
T\n(vDB
T\n<a5
T\nM90A
T\n\bba|H
T\n{O<W
T\rChU
T\rWE
T\r\\uz
T\r\n8J
T\rb\nf
T\tƻZ
T\v!hn7
T\v8=\vO
T\v<a\a
T^9;qA
T_:4Y
Targets
Tasking
Tba:Wi
Tbߺ1h
Te;hQG
TerminateProcess
Teջ\rKD
Tf %f %f %f\n\n
Tf黌:7
Th'= s\r
The maximum number of elements for scan exceeded\n
This device does not support HLBVH construction\n
This is a netCDF dimension but not a netCDF variable
Threads
Thursday
Tj(<1Q
TjO;]eD;W
TjQ>g
Tl<W*G
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
Tn":xH\r
To;d|\v
Translation
Traverse child nodes otherwise. \n                    else \n                    { \n                        // This is an internal node, proceed to left child (it is at current + 1 index) \n                        addr = addr + 1; \n                    } \n                } \n                else \n                { \n                    // We missed the node, goto next one \n                    addr = NEXT(node); \n                } \n \n                // Here check if we ended up traversing bottom level BVH \n                // in this case idx = -1 and topidx has valid value \n                if (addr == INVALID_IDX && top_addr != INVALID_IDX) \n                { \n                    //  Proceed to next top level node \n                    addr = NEXT(nodes[top_addr]); \n                    // Set topidx \n                    top_addr = INVALID_IDX; \n                    // Restore ray here \n                    r = top_ray; \n                    // Restore invdir \n                    invdir = invdirtop; \n                } \n            } \n \n            hits[global_id] = MISS_MARKER; \n        } \n    } \n} \n
Tree height
TrueAudioNext.dll
TryAcquireSRWLockExclusive
TryEnterCriticalSection
Tts;1
TtƼ_T
Tu;S{A
Tuesday
Type Descriptor
T~780
T~=\rwZ
T~żpA
TúfW5
Tü\tFF
Tƻj\rŻZ
Tʃ;zN
TҨ>6y
TӨ\bt\v
Tָ/7^94LȻ5
Tٽlh\b
Tۥ<zo
Tݓ>Hmg
T㈼y2G
T溚0c;Uw
T󶹡xȺ30
U 5<'\aZ
U McT
U bA, X
U";<1dP
U%bRE
U(HcEHH
U(HcEXH
U(HcE\bH
U(I;B
U)x;TJ
U*=\vPe
U,9Sn
U.2<TNM
U09\f
U0;9iS:\\K
U0I;B0
U0ŘXM
U0ŨXup
U27<S
U2弇:l
U5<\aB
U6+;b
U6<F4̻K
U6w<N
U7+щM
U7>\nt\e
U7y;O
U8D83A
U8LOR9Y
U:$I=9ZLo
U:)MK
U:,D6
U:,VO9
U:6<r
U:93w
U:\eje;F7
U:\rCV
U:\vgR
U:oF,;i
U;'97
U;)f7
U;6<QY
U;A\vu
U;Bu=;7o\a
U;ES-9b
U;L]@9XbE
U;\egr
U;\tpZ
U;mRj
U<&e0
U<Os:TP
U<g<4.n
U=.m0
U=9xk
U=dh!?K
U>s82
U?q:dq
U@5YW
U@5zX
UA>N0Wl
UAH:dxe
UATAUAVAW
UATAUAVAWH
UATAUAVAWI
UATAUAWH
UATAUH
UATAUI
UATAVH
UATAWH
UAUAVH
UAUAWH
UAVAWH
UAVVWSH
UAWAVAUATVWS
UAWAVAUATVWSH
UAԻV1
UAݽ{FO
UBdn~C
UDm;hʤ<o'Z
UDݺ\f\b
UEͻv{\v
UF,:fAG
UF>yd
UGݼ|Gӻc
UHG;8X
UHM<g
UJ%:R\v
UJ\rt%7
UNKNOWN
UO <\n
UOW9\b
UP;;c
UQq;"O
URn<t
US;z\tP
USATAVAWH
USATH
USAUH
USAWH
USVATAUAWI
USVATAWH
USVAUI
USVAVAWH
USVAVH
USVWATAUAVAW
USVWATAUAVAWH
USVWATAUAVH
USVWATAUAWH
USVWATAUH
USVWATAUI
USVWATAVAW
USVWATAVAWH
USVWATAVH
USVWAUAVAWH
USVWAUAVH
USVWAUAWH
USVWAV
USVWAVAW
USVWAVAWH
USVWAVAWI
USVWAVH
USVWAVI
USVWAWH
USVWH
USWATAUAVH
USWATAUH
UT:N%\n
UTF-16LEUNICODE
UTc;֛b:su
UTu;HX\n;L
UU;"V
UUUUA
UUUUUU
UUUUUUU
UV;ab
UVATAUAVH
UVATAUH
UVATAVAWH
UVATAVH
UVATAWH
UVAVH
UVAWH
UVWATAUAVAW
UVWATAUAVAWH
UVWATAUAVAWI
UVWATAUH
UVWATAUI
UVWATAVH
UVWATAWH
UVWATH
UVWAUH
UVWAVAW
UVWAVAWH
UVWAVH
UV\e=o
UWATAVAW
UWATAVAWH
UWATAVH
UWATH
UWAUAVAWH
UWAUH
UWAVAWH
UWAVAWI
UWAVH
UX9A\bs
UZ%;w
UZ;\f{D
UZ?5t,?G
U\\:s&c9e
U\aI>^v
U\abA|H
U\af;b
U\b4>L
U\b<x/2
U\bbA|H
U\bt;X
U\nbQ|H
U\r;Z
U\t<Gd
U\t>u
U\tbA|H
U\vbA|H
U_;F6
U_L;V\b
U_M;Q\b
U_d:Fd!;q
U`9A\bs
U`H9~PtV
Ua;pr
Ua=Wf
UaK<N36
Uba|XZ
UcY:(3\b;3B
UdǺ8I
Ufj:0
Uft;]a
Ug)<pD
Ug;B"a
Uh9A\bs
UhE3҈M
UhH+U`uFI
Ujn;Lr\b
Ul;uN\\8
Um<bn
Unable to create OpenCL kernel %s. [%d
Unable to load SOFA data. [%d
Unable to load SOFA file: %s. [%d
Unable to open file %s for OBJ dump
UnhandledExceptionFilter
Unknown CPU
Unknown exception
Unknown matrix type
Unĺ\r
Uo:DR
Up;LG\t
Urp;kv6
UserProfile
Using %d CUs for convolution, %d CUs for IR update
Using OpenCL device: %s %s (%s
Using OpenCL platform: %s %s (%s
Uu;)L
UuL;Cb
UvW;aRr
Ux;=k
UxġlYL3
Uzz:C\b
U{pNo
U|j;c
UĻ@LS
UƹS9B9
Uɹjbs
Uк0\a
U؈D$ H
Uټo 3
U܄;r\nD
Uܹ8Q˺ז8
Uܺp(D
Uݺ;y71
U㽼T_D
V!;i5
V&ͽRU
V'Z<_2P
V(HcEpH
V)< R
V-s=Qj
V.;Yw麑\rG
V/f9% 1
V/ҺKc\v
V0H.D2V4H2
V0z\vx
V0};ur
V38sHR
V5=os
V7:ZC
V8<W&B
V8Z*V\\R*P5
V9#EM:z
V:<kv:i
V:Lj\v:9
V:bsr;\b
V:dX;:o
V:dz8
V:nfP:{&z
V:s.q
V:w1f
V;-IM:Z
V;0Lq
V;3{59
V;=dY
V;Bx\r;w
V;Gw\t
V;LwR<0
V;WU3;N
V;gs\f
V;h=vCN
V;j5X
V;wR\a
V;͞j;mm19h2u;z
V<<f06
V<D~j<s\v
V<GZs
V<`gg
V<l;Bk
V=/6R
V=2KN
V=ʸ\rAf;d
V>\aV
V>h:w
V>o6A
V?&pW?SHX?j
V?:wF
VA';e
VA7<5
VATAUAVH
VATAVAWH
VATAWH
VATAWUH
VAUAVAWH
VAUAVH
VAUAWH
VAVAWH
VAVAWUH
VAVAWUI
VCϺNp
VEa9Sk
VFổfa;'W
VKV:E
VL;B?3
VOȽGd :v
VQ[;Ba
VQߺ2z
VR0;X
VS<kS
VS_VERSION_INFO
VUUUA
VV}:j
VWATAUAVAWH
VWATAUAVAWUH
VWATAUAVH
VWATAUAWH
VWATAUH
VWATAVAW
VWATAVAWH
VWATAVAWUH
VWATAVAWUL
VWATAVH
VWATUH
VWAUAVAWH
VWAUAWUH
VWAVH
VWAWH
VWUSATAUAVAWH
VXH+VP
VXH+VPH
VXH+VPH;Q w
VXH9r\bt
VXS;\n\t
V\\:SUn
V\\t;aFe
V\a=F@Y<N
V\b6\n6\f
V\b9xW\b0hX\b'4
V\bA9W\bA
V\bXy\bb
V\b\\a\vb
V\b\\i\bb
V\fлZj
V\r9>Q
V\rO8M\n
V\tT;5
V\ta<Y
V\v6I]Dc
V\v;N
V]8iMĺÇI
V]ügHS
V_:X1
Valve Corporation
Vam;9lE
Vc=N-\t
Vc>L\bH
Vd;kT
VeO<Qm
VeU:Z
Vg}9OE
Vh>6Q&?f
VirtualAlloc
VirtualFree
VirtualProtect
VirtualQuery
Visual C++ Compiler
Vlۼd\e
Vr<NfݼA9k
Vs:=2
Vs^<WV
Vu;ӿl
VuK<y
Vv;JQf
Vv;LL4
Vw:;u\f
VzO:ӪO
V{N;jyr
V|3<K\f9
V|;6fb
V}0<NTq:Q
Vƺ60N
Vƻ_ZV
VǽHc7
Vȼ5D<p
Vμ4R»Z
VϺBh6
VщL$PH
VщT$Pf
Vӻ8%t;y
VԹBQZ
V؉L$Pf
W I;W(t&H
W \aae
W%.;JtS
W%3<Wx
W%\t=DX
W%\vH3
W%guI
W%t<l#s
W%ҼMN
W&b<O3
W(A+W0A
W)9\a
W+A>zgD
W,;Yb
W,<fr
W,=gzq
W-G;3
W.s;j
W1a>C
W2:L3
W2ʺ`m
W2ؼFl
W35;|p
W53nG
W59'H
W5L:q6
W5OZB
W5YGM
W5dNH
W5pw8
W5xNy
W5~5y
W6;s6
W6\tf
W8<UW
W8I;W@t*H
W8WAD
W8m;A
W9>58l
W9BHA9Y
W9j^!;U
W9u#3
W9}0Y
W9ЪG:D
W:'Bl;A
W:7CW
W:7eO95
W:KwӺd
W:L~V9
W:R㸹s
W:j)b;N
W:uls
W:xs`9
W;&wS
W;'8J
W;*I6
W;JJD
W;\bj\a
W;\fVA;av
W;d A
W;j\vl;A
W;ԼJ9
W<96裻\e
W<>Sa
W<XrR
W=$H3
W=*zd=z
W=4{6
W=UՒ>Sb
W>EWC
W>P$D
W@ӻhK
WARNING: "Flush to Zero" or "Denormals are Zero" mode not enabled
WARNING: AdjustTokenPrivileges failed to enable SeLockMemoryPrivilege: Add SeLockMemoryPrivilege for current user and run process in elevated mode (Run as administrator
WARNING: AdjustTokenPrivileges failed while trying to enable SeLockMemoryPrivilege
WARNING: LookupPrivilegeValue failed while trying to enable SeLockMemoryPrivilege
WARNING: OpenProcessToken failed while trying to enable SeLockMemoryPrivilege
WATAUAVAW
WATAUAVAWH
WATAUAVAWL
WATAUAVAWUH
WATAUAVH
WATAUAVUH
WATAUH
WATAUUH
WATAVAWUH
WATAVH
WATAWH
WAUAVAWH
WAVAWH
WAVAWUI
WAֹDl
WC<p\f
WCQ;ǡA
WCv;Щ29D
WD$PŠT
WD$PŨT
WD2:o
WD8l$@t\fH
WD;N \b9f
WD<Ig
WG$85d
WJ=Q$a
WK?;7zx:i4
WLcT$PLc\\$HHc\\$@Hc|$8Hct$0L
WN;Z2
WNd;S
WPB:YQ
WPI;WXt*H
WPI;WXw
WQ-<P
WR-:L
WR2;D
WR;RmA
WS<_Z
WT=lY
WU(;O
WU3:\n
WU;t9d
WUUUUU
WXH+WP
WXH+WPH
WX½\bT6
WXмhcO
WYֽ]a
WZp:h9!<B
W[k;W
W\b:vC0:J
W\bL$0H
W\bL$0L
W\bM;P\b
W\bfD9g\n
W\bʼ9c
W\bʼN
W\ns;.X
W\r'tA
W\r3;I
W\r>0쏽W
W\r\tmG
W\rw[7
W\rz=pc
W\t=T\b\n
W\t˺l8
W_2;1\a
Wa:wvf
WaitForSingleObject
WaitForSingleObjectEx
WaitForSingleObjects failed
WaitForThreadpoolTimerCallbacks
WakeAllConditionVariable
WakeConditionVariable
Warning
Wc;!42
Wd>;5\b
We)=D
We9 =N
Wednesday
Wg;;n
Wg~;R
Wh9<.WC
WhƹcJ\n
WideCharToMultiByte
Windows (64bit
Wj;Z;x9
Wk%;t
Wk̼;l3
WkֻTdp
Wl*<0`w
Wl;eEH
Wm:\b`a9
WnȼPQ
Woy:\v\a
Wp>;vi
Wqݻ)D
Wr95B
WrM<dr
WriteConsoleW
WriteFile
Wrong number of vertices per face
Ws,<WrQ
Wv:u5B
WvQ;:Mj
WwN<&yx
Wx;GoI
Wz+9Sx
Wz{:u
W|F<u
W}U:8h
W}u;C\v7
Wí9QcW9q
WƼqѼV
WȮ9WH\r
WɄ:AaI
W̼\raq
Wκ[5J
WӚ>n2
W⊼ \t
X 843"8
X UAVAWH
X UVWATAUAVAWH
X UVWAVAWH
X UVWH
X VWAVH
X"<Ikd
X%te9
X&:9G
X)9/j
X,;dJ
X,;s 5;xA
X2ԺK\r6
X3g=Xx
X3ۉT$HD
X4:[447)9
X5w9}^O;}C
X69}%r
X6;H3\e
X7f:\e\r\r
X9=\f
X9\bY
X9iAy:g
X9}ٓ8e
X9ܰt:4
X:9.08
X:=Ic
X:AuI<WBV
X:\e8\a
X:\et0
X;%Cu
X;\v$p;C2
X;yb!<v
X< w\eH
X<\e1M
X<\evx
X<f<2
X<f\vw
X<o`5
X<t\eu
X=[g8>t
X=t\vu<E
X>7iad8
X>\ek
XA(źXy
XC\b;R_\b
XF:g.A
XG.:n8
XG;uٯ9p
XG\a<\\ 3
XH;;L
XHc|$`H
XHսi7
XI+@PH
XI+@PL
XI+JPI+@PH
XI;3H
XI@źXy
XI\tba
XIm< A
XKO<#B
XL#O\bt
XL$PŘX
XL$PŠX
XLc_lA
XMpŐX
XOK;gL
XOK;t
XP\e9
XQ\fŢXi
XR?9Dz
XS&=0
XSh;Yq
XT,9Иk:0
XT0 ŨY
XT0@ŬY
XT<ZO
XTR;|b
XV27U
XW;\a
XW<\tv
XY$ŢXi
XY<Dm
XYD1 Ģy
XYD; Ģy
XYD\e
XYD\e Ģy
XYH`ŠY
XYVpŠYE
XY\nba^\bXI\tb
X\\tH$5
X\a;yh
X\bUVWATAUAVAWH
X\bm;5
X\r;3
X]A_A
X]A_A^A
X]A_A^A]A
X`n:a
Xa:vE>;t
Xa\vbaN
XbS;~Y
Xbt<f
Xc;FKu
Xc=+Xc=+Xc=+Xc
Xe=kme
XeL;'2
Xfy9q
Xhl:(D
Xi Ś\\I
Xi\fbaF
Xj:Gnw
Xl$\bba
Xl:n")9
Xl;\a\a
Xl<-W
Xm ŘX}0ŐX
Xm.=o9R
Xm\b?#8
Xob:ͪ\v
Xp:IH
Xq3;f\e
Xq4Ś\\aT
XqLł\\iL
Xq\fba
Xs.<(1V
Xt$ w\t
Xu@ŐY
Xu\bA
XupŘX
XvTfff
Xvϻqz
Xw>YZ
Xwj:β;9
Xwǽ5c
Xx;YmƽϺ\t
X}PňY
X}pŐX
X~úY9
X~ʼcg
Xʒ:5d
Xʻ6M3
X̼Y漼yh
Xͻ\t2
XӺ+5q
XԻk%v
Xⷸ%PZ
Y F;R
Y a:j
Y ba|\b
Y ŢXY
Y!;yU
Y$:7l
Y%2;+5n9
Y%5XD
Y%:nFh
Y%_YD
Y%kgE
Y%~VQ
Y%~iQ
Y&:hj
Y&<b2B
Y'̺3T
Y*<5Y
Y+9)K
Y-)WD
Y-<eE
Y-D<G
Y-JhE
Y-XYD
Y-g-4
Y-w;W\rA
Y/o<Ww
Y/Ļoon
Y0<9m
Y4+bA|@Yt
Y4>M&\f
Y4ba~\b
Y58BQ
Y5<eE
Y5^SD
Y5ciE
Y76<(\v
Y83hѺF
Y8ba~\b
Y8~\t
Y9;H&E
Y9Q\b_9
Y9\rHN9
Y:ZhJ;*Xߺ4h
Y:aB3;Y
Y:dKb
Y:vg~9D
Y:~fw
Y;%ki
Y;/Bg
Y;9b\t;s
Y;<t2
Y;\f g
Y;\r3e
Y;\tw\f;M
Y;gk2>xQ
Y;p9f;Ԡf
Y;xbV
Y;z)k
Y<\v8X<Vh
Y<_B6
Y<ba~\b
Y=)pG
Y=L&Q
Y=L6Q
Y=\f\eI
Y=q;H
Y=u:2
Y=u<R
Y=v6L9
Y=}4A
Y>eu>>S
Y>kX>M\e
Y?;oB
Y@ ŀYH
Y@[9ϩs9L
YBT>x
YC0ŐY
YC0ŠY
YC@ŀYKP
YC@ŘYSP
YC@ŠYKP
YC@ŠYSP
YC@ŰYS0ŠYKP
YC`ŌY
YC`ŔY
YC`ŜY
YC`ŬY
YD `ġ8YT
YD pġ8YT
YD$ H;\r
YD$ H;\r6
YD$ H;\rV
YD$ fD
YD$0ŠX
YD$@fD
YD$@ŠYL
YD$`ŠYL$p
YD$pŰY
YD+ Ģy
YD9 Ģy
YD\b0ŐW5
YD\b@ŐW5
YDؼ4g
YE ŠX}P
YE ŤYM
YE(<e
YE0ňT
YE0ŠX
YE0ŠX}p
YE0ŠYM
YE@ŠX}p
YE@ŬYM
YEPŠX
YEPŠY
YE\vbQ
YE`ŴYM
YEpŠY
YF\n<Z
YH@ŘY
YHS;rM
YHa>K]I
YHb=0
YHpŐY@P
YJ1:u
YJ\rW\vj
YJ\raw
YKPŐYC
YKPŠYC
YKPŠYC@ŨYS0
YKPŰYS
YK`ŌYS
YK`ŔY
YK`ŜY
YK`ŠYD
YK`ŠYE
YK`ŤY
YL!<h5
YL$0ŠY
YL$0ŨY
YL$@ŸYEP
YL$Pt=fD
YL$Ptef
YL$PŀY
YL$PŘX
YL$PŠY
YL$PŠYE
YL$PŨY
YL$PŸY
YL$PŸYEP
YL$`ŠYE
YL$`ŨYE
YL$pŠYE
YL$pŨX
YL$pŸY
YL(Pġ8YD( ňW
YL;Sw
YL\b ŸYD\b
YL\b ŸYD\b0
YL\bPŸYD\b
YL\b`ňW
YL\b`ŸYD\b
YL\bpňW=V
YM ŐX
YM ŔY
YM ŠYE
YM ŬY
YM ŸY
YM żY
YM żYE
YM0ŠY
YM@ňY
YM@ňYEP
YM@ŌY
YM@ŔYE
YM@ŜYE
YM@ŠX
YM@ŠY
YM@ŠYE
YM@ŠYE0
YM@ŠYEP
YM@ŤY
YM@ŬYE
YM@żY
YMPŠY
YMPŠYE
YMPŠYEp
YM\a:'Y
YM\rbA|H
YM`ŀY
YM`ŌY
YM`ŤY
YM`żY
YMpŀY
YMpŠX
YMpŠY
YMpŠYEP
YN0ŐY
YN0ŠY
YNb=#uA
YO0ŠYE
YO0ŠYEP
YO0ŸY
YO0ŸYE
YO;ΝA
YO@:h
YOz;7\b
YO캨9P
YPŊ\\I0
YQ<We9
YQȼzN
YR<U깺!aS
YR@ŨYJ
YR@ŸYJ
YR`ńY
YR`ŤY
YRpŘYJ
YRpŘYM
YRpŠYJ
YS`ŜY
YS`ŤY
YSpŠYE
YSpŨYE
YT 0ňW
YT 0ňW=2\e
YT @ňW
YT$0ŘY
YT$PHc
YT$PI
YT$PŘY
YT$`I
YT$pŘY
YT;7]A
YT\b ŸYL\b0ŸYD\b
YU ŘXm
YU żT
YU żT%7\t
YU;5Z\a<7
YU@ŸT
YU@ŸT%p
YU@żT
YUPŘW
YUPŘXm
YUPŸYM0ŸYE
YU\tbAD@Y}\vbBmH
YU`ŘW
YU`ŘXmp
YU`żT
YU`żT%y
YUpŘXm0
YUpŸT%%d
YV;H]\b
YV;y]j;LkZ
YVpňYE
YVpŠYE
YW`ňYE0
YW`ŌY
YW`ŠYE
YW`ŤY
YWpŠYE
YWpŠYE0
YWw;j'w
YW˹l\b
Y[L;w
Y\a=l
Y\aba|\b
Y\b<VS
Y\b>H
Y\b>p
Y\bba~\b
Y\e<V l
Y\f+Z\fA
Y\f.9\nX
Y\f>b
Y\fba|H
Y\fba~\b
Y\nba~\b
Y\r,r9
Y\r1=.e
Y\r5%Q
Y\r55Q
Y\r;\n9
Y\rCTD
Y\rE-9
Y\rGN9
Y\r\f\n9
Y\r\rfE
Y\r\vPQ
Y\r\vcQ
Y\rbav\bX
Y\rcr9
Y\rl-9
Y\rmUD
Y\rr\n9
Y\t;4$n
Y\t;gdӻu
Y\t\b
Y\tba~\b
Y\vba~\b
Y\vl\rm p
Y`>0\nS
Y`O:@8j
Yb :3:W
Yb0ŨYJ
Ybo;`Ox
Yc;,6f
Yd$0ňY
Yd$0ŸY
Yd$@fD
Yd$PňY
Yd$PŸY
Yd$pŘX}p
Yd$pŸY
Yd\a\nb
Yd绝oۻ4
YePŀYMp
YePŘX}p
Ye\nbA|H
YepŀY
Yf@ŠX
Yg@ŠX
Yg@ŠX}P
Yh\a=V
Yi;PC
YiN<hA
Yk ŸYK
Yk'>X
YkƻҳJ
Yl\atĢY
Ym\bb!4HY
Ym\bb"EH
Ym\bbbM
Ym\rbA\\@Y
Ymں\tJ
Yn ŸYN
Yn;ư*9E
Yn\v<fD
YnպյL;K
Yo ŸYO
Yqz>~/k
Yr@;7
Ys\f;,F
Yt$`fA
Yt$pfA
Yu9l]A:5
Yu\fb
Yu\nbA|H
Yu\vbA|H
Yu`ŐY}p
Yvc;cT
Yw;\b0c
YwǼ)汼MTi
Ywۼ;Q
Yx:\n
YxԻwJo;{Q
Y}N:Mb
Y}\bbA4HYe
Y}\nbA<@Ym\fbA|@YE
Y~ügN\v
YÈD$FH
YĻyj
YƉD$hB
YȉL$DD
Y͉D$0A
Yͼiuм5
YЉL$pD
YӋM\bA
Yև>0g
Y؉L$tD
YًM\bA
YڋM\bA
YۻK[W
YbѼYZ̼r
Z ba~\b
Z!0;1
Z#;Go8
Z':cn
Z'M;c
Z(8;H\b
Z(\a<bt
Z)8E/W9
Z)bA|\b
Z* ,\t\a\vm8
Z+5<1
Z,ba~\b
Z0=M,N
Z0[<E
Z0bA|\b
Z2:Bm
Z2b:y Y9
Z30:Bq
Z3@<s
Z3m<B\t
Z3Խ3-d>R
Z4g<Vh
Z5-;iK
Z6=r^9
Z7s:9
Z8\e0
Z95~j
Z9F<rti;Q
Z:4\e
Z::Mt:t
Z:=QtS
Z:Glj8
Z:T4c:J
Z:d?p9
Z;"X4
Z;/aC;M
Z;K*c
Z;MUh
Z;\es
Z;b\v:b
Z;e3мU
Z<2b1
Z<N$O
Z<S;\rl
Z<cDݼ\b
Z<riw
Z=1ችDP
Z=\rIn=U
Z=qh\n>5
Z>6E\v
Z>M#O
Z?<Gsg
Z?ǻUa
Z@t<3y
ZC=\rg
ZCr;B
ZE:Ik1
ZE\t:l\f
ZEo^m
ZFa=b
ZFλgX\e
ZGϺqFx
ZH<\f1
ZI{;Ct
ZM:iR\a
ZN;\e
ZO:"k
ZR<)dl
ZRU=3e
ZS\b;EN\r
ZT;kJ
ZU<\v
ZVǖAO\b
ZWz;nc
ZX ;|i
ZX<xۣ;X
ZXǼDSC
Z\\Q4ŊXY0
Z\aba|\b
Z\b;\e4
Z\bba|\b
Z\e{&1q
Z\eŻle
Z\f:Md
Z\fbA
Z\rbA|\b
Z\rκ9;9
Z\t1<Ⱦ9
Z\tbA
Z\tba|\b
Z\vbA
Z\vo>8
Z]輴dY
Z^<C9
Za;\a
Zb(<N\vG
Zci:eF
Zd;،g;s
Ze+:g
ZgC;d
Zj9dtK
Zk;k袻K
Zk\r9
ZlͻZm\v
Zrk;D
Zu1;At
Zw:3>f
Zy9\b
Zy;R齺ݺE
ZzS;\t
Z{Etm;,M
Z{L:J
Z}F7Q;l
Z~@f#aCW
Z¼n4\b=v
ZȺ2AE
Z̻y\rR
ZЕ;Jcm
ZԻEs3
ZԻ[S2
ZոV\b6
Z㻩t:r2
a D=Q
a e=^v
a";gn
a"C<EV
a#Ib?AG
a$9\n
a$ba~\b
a%;vGj
a';N8
a*c:n
a-2<H8
a/1<MX
a/ݻi\ne
a09;z
a0;JJs
a0;u8
a1R;\t
a1\t9(f
a2;%\bn
a32:1
a3<U2
a3F:γ4
a4-;Z
a5::I
a5;hE
a5ӻ\n@Y
a8ܻA_軙14
a9,_W8
a9;E\e :2
a9<4Lṻ1
a9=2ں|Q
a9F$ 9
a9\bfr
a9k}\f
a9t;2
a9x|\a0h}\a'4
a9z9|v
a:&Ex
a:0)b8
a::\amٺUI
a:;Pi
a:?h\nx
a:IrQ:q
a:VHZ
a:ZlH:co
a:\eEF
a:\rnߺi
a:mᗼN
a:oF\n
a:r?a8
a:wݑ9
a:䋆:RGI
a;"jf
a;/kY
a;GI\b
a;HJ\n9
a;ScֺM
a;W9滻b
a;WHj
a;Wvp
a;\f\rh
a;\te7;a
a;\vUe
a;\vis:3
a;djE;AXO
a;hzx
a;ja».E
a;mG\r
a;o\n
a;o}K
a;qϠ6/do
a;rX\n
a;v&G
a<#o9
a<%hf
a<)pL
a<)q2
a<KN\n9
a<K嘻sk\b
a<SXԼ2
a<V"a9
a<XBF
a<\at"D
a<\au+H
a<\auiH
a<\auiI
a<\auvH
a<\auvI
a<\tWZ<omJ
a<a櫼\fy
a<x"\a3h#\a*tQ
a=#qn
a=,ücAv
a=FA8
a=X5i
a=b4D
a=bV\n
a=fiJ
a=lHe>z
a=lV\e
a=o=1
a=v_g
a>2MR
a><gAd
a>B}h
a>Q>TQ
a>Ud6>O7n
a>uZ>2
a?;RFe
a?a:s
a@;C3
a@b;zO
aAͽ:\f5
aAݻis
aB=i\n\r
aBuilderInstancing
aCo7"L
aD8D$(t
aE3\nS\tI
aE3\nW\tI
aE<zQ
aEh;VB
aF\r:0i
aH9D$8t
aH9D$8t0
aHcwHB
aHh:P
aIcp\bH
aJ:TRH
aJ\r$l3
aJ\r%'9
aJ\r(\rY
aJ\r(t9
aJ\r+0
aJ\r.SY
aJ\r/\tX
aJ\r2)Z
aJ\r3ha
aJ\r5\ac
aJ\r=#6
aJ\r>]Y
aJ\r>cW
aJ\rM\r
aJ\r\e
aJ\r\fQ8
aJ\r\t
aJ\r\vE
aJ\r`?a
aJ\r`O4
aJ\r}\b6
aJcT*`G
aJn?L
aKi;E훺b
aL;<V
aL<Z\f
aL=T\a8
aM+\vE+C\bL
aM5;k
aNX<C
aNcD: F
aO=W"L
aP3:GG
aP5<L1Q
aP<ut
aQ8=S
aQ;l&\n
aQ<6`d
aQ<=u
aQżqK3
aR=?3
aS;_a\b9
aSU:LD
aT0:b
aT4;#L
aT4>m
aTI=\f
aU_=d
aV\n;gt
aX:8m
aY>7%Z
aYw;e
aYỒ;C
a\a<\a0
a\aba|H
a\aba~\b
a\abq|H
a\b4%\aP
a\b<z
a\bL\ne\v
a\bbQ|H
a\bba~\b
a\bf=\a
a\e<\va
a\f$9
a\f0\vP
a\fba|\b
a\n8_F
a\n;V
a\n;x3
a\n<ps\b
a\n^=ci
a\nba~\b
a\r9l}M
a\rm;\fS#:xx
a\rx:T\f
a\rӺE
a\tD;A
a\tba~\b
a\v:6
a\v:x
a\vba~\b
a]:MyH
a_\r;wVD
a`h;ziV
a`ۼRZ
aa\b;t
ab!}Hp
ab5;a
ab<0\ba
abA|H
aba|H
abcdefghijklmnopqrstuvwxyz
abq}Hp\f
acc.type
accel
accel_mb
accels
acۺT?I
add@ThreadPool@TaskScheduler@embree@@QEAAXAEBV?$Ref@UTaskScheduler@embree@@@3@@Z
addScheduler@TaskScheduler@embree@@CAXAEBV?$Ref@UTaskScheduler@embree@@@2@@Z
address family not supported
address in use
address not available
advapi32
ae<~Q
aeD<]\f
aeG<L
ae\r=W
af7<\af
afD9 t
afD9 t\a
af\n=X
affinity
ag=<zM
agH;\tD
ah9{SR
aho9K>\t
ai9\aiI:bq
ai;"q
ai\n;qGV
aiܻbiE<j
aj;P\vB;L
ajq;U
ak:Pq
ak˺<lQ
al-memory histogram. A work-item with local\n\t\t// index i writes to local-memory histogram (i % NUM_LOCAL_HISTOGRAMS).\n\t\t// When calculating the bin index, bin index i is mapped to index  NUM_LOCAL_HISTOGRAMS * i in the\n\t\t// local-memory buffer. This is because the histograms are interleaved.\n        local int* shiftedLocalEnergy = localEnergy + localIndex % NUM_LOCAL_HISTOGRAMS;\n\n        global float* rayEnergy = (global float*) (&totalEnergy[offset + rayIndex]);\n\n        float time = totalEnergy[offset + rayIndex].w;\n        uint bin = convert_uint_sat(floor(time / BIN_DURATION)) * NUM_LOCAL_HISTOGRAMS;\n\n        if (bin < NUM_BINS)\n        {\n            float energyValue = scale * rayEnergy[band] * shCoefficients[channel * numRays + rayIndex];\n            int quantizedEnergyValue = convert_int_sat(floor(energyValue));\n            atomic_add(shiftedLocalEnergy + bin, quantizedEnergyValue);\n        }\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 2\n\t// Each work-item processes one bin. The corresponding bins for all local-memory histograms are added, and the\n\t// result is stored in a private variable. No atomic operations or barriers are required here, since each work-item\n\t// operates on independent data.\n    int accumulatedEnergy = 0;\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++) \n    {\n        accumulatedEnergy += workItemEnergy[i];\n    }\n\n\t// Stage 3\n\t// Each work-item processes one bin. The summed values from the local-memory histograms are added to the corresponding\n\t// bin in a global-memory histogram. Here, atomic_adds must be used, because multiple work-groups may be trying to\n\t// write to the same global-memory bin at the same time.\n    atomic_add(energy + channel * NUM_BANDS * NUM_BINS + band * NUM_BINS + localIndex, accumulatedEnergy);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Reconstruction Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\n#define ENERGY_THRESHOLD            1e-7f\n#define MIN_VARIANCE                1e-5f\n#define NUM_WORK_ITEM_SAMPLES       32\n#define WORK_GROUP_SIZE\t\t\t\t64\n\nkernel void applyIIRFilter(global IIR* filters, \n                           global float* impulseResponse, \n\t\t\t\t\t\t   uint numBins, \n\t\t\t\t\t\t   uint samplesPerBin,\n\t\t\t\t\t\t   uint numSamples)\n{\n    size_t band = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t numBands = get_global_size(0);\n    size_t numChannels = get_global_size(1);\n    size_t batch = get_global_id(2);\n\t\t\n\tlocal float localSamples[(NUM_WORK_ITEM_SAMPLES * WORK_GROUP_SIZE) + NUM_WORK_ITEM_SAMPLES]; \n\n\tconst int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\tlocal float* workItemSamples = &localSamples[localIndex * NUM_WORK_ITEM_SAMPLES];\n\n    global float* signal = &impulseResponse[(batch * numChannels * numBands * numSamples) + (channel * numBands * numSamples) + (band * numSamples)];\n\n\tfloat xm1 = 0.0f;\n\tfloat xm2 = 0.0f;\n\tfloat ym1 = 0.0f;\n\tfloat ym2 = 0.0f;\n\n    global IIR* filter = &filters[band];\n\n    float a1 = filter->a1;\n    float a2 = filter->a2;\n    float b0 = filter->b0;\n    float b1 = filter->b1;\n    float b2 = filter->b2;\n\n\tfor (uint i = 0; i < (numBins * samplesPerBin); i += NUM_WORK_ITEM_SAMPLES)\n    {\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\t\t\n\t\t\tworkItemSamples[j] = signal[i + j];\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tfloat x = workItemSamples[j];\n\t\t\tfloat y = (b0 * x) + (b1 * xm1) + (b2 * xm2) - (a1 * ym1) - (a2 * ym2);\n\n\t\t\txm2 = xm1;\n\t\t\txm1 = x;\n\t\t\tym2 = ym1;\n\t\t\tym1 = y;\n\n\t\t\tworkItemSamples[j] = y;\n\t\t}\n\t\t\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tsignal[i + j] = workItemSamples[j]; \t\t\n\t\t}\t\t\n    }\n}\n\n// todo: linear reconstruction?\nkernel void reconstructImpulseResponse(globa
al_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n \n__kernel void segmented_distribute_part_sum_int( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    //inout_array[globalId] += sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; in_flags[globalId + i] == 0 && i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                inout_array[globalId + i] += sum; \n            } \n        } \n    } \n} \n \n__kernel void segmented_distribute_part_sum_int_nocut( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    bool stop = false; \n    //inout_array[globalId] += sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                if (in_flags[globalId + i] == 0) \n                { \n                    inout_array[globalId + i] += sum; \n                } \n                else \n                { \n                    if (stop) \n                    { \n                        break; \n                    } \n                    else \n                    { \n                        inout_array[globalId + i] += sum; \n                        stop = true; \n                    } \n                } \n            } \n        } \n    } \n} \n \n// --------------------- ATOMIC OPERTIONS ------------------------ \n \n#define DEFINE_ATOMIC(operation)\\ \n    __attribute__((always_inline)) void atomic_##operation##_float(volatile __global float* addr, float value)\\ \n    {\\ \n        union\\ \n        {\\ \n        unsigned int u32;\\ \n        float        f32;\\ \n        } next, expected, current;\\ \n        current.f32 = *addr;\\ \n        do\\ \n        {\\ \n            expected.f32 = current.f32;\\ \n            next.f32 = operation(expected.f32, value);\\ \n            current.u32 = atomic_cmpxchg((volatile __global unsigned int *)addr,\\ \n                expected.u32, next.u32);\\ \n        } while (current.u32 != expected.u32);\\ \n    } \n \n#define DEFINE_ATOMIC_FLOAT3(operation)\\ \n    __attribute__((always_inline)) void atomic_##operation##_float3(volatile __global float3* addr, float3 value)\\ \n    {\\ \n        volatile __global float* p = (volatile __global float*)addr;\\ \n        atomic_##operation##_float(p, value.x);\\ \n        atomic_##operation##_float(p + 1, value.y);\\ \n        atomic_##operation##_float(p + 2, value.z);\\ \n    } \n \n__attribute__((always_inline)) void atomic_max_int(volatile __global int* addr, int value) \n{ \n    atomic_max(addr, value); \n} \n \n__attribute__((always_inline)) void atomic_min_int(volatile __global int* addr, int value) \n{ \n    atomic_min(addr, value); \n} \n \n// --------------------- REDUCTION ------------------------ \n \n#define DEFINE_REDUCTION(bin_op, type)\\ \n__kernel void reduction_##bin_op##_##type(const __global type* buffer,\\ \n                                          int count,\\ \n                                          __local type* shar
al_size(0); \n    int groupId = get_group_id(0); \n    int numGroups = get_global_size(0) / groupSize; \n \n    /// Load single int4 value \n    int4 val = safe_load_int4_intmax(in_array, globalId, numElems); \n \n    int4 localOffset; \n    short4 localHistogram; \n    group_split_radix_2bits(localId, groupSize, bitshift, val, shmem, &localOffset, \n        &localHistogram); \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    __local int* sharedData = (__local int*)shmem; \n    __local int4* sharedData4 = (__local int4*)shmem; \n \n    sharedData[localOffset.x] = val.x; \n    sharedData[localOffset.y] = val.y; \n    sharedData[localOffset.z] = val.z; \n    sharedData[localOffset.w] = val.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    // Now store to memory \n    if (((globalId + 1) << 2) <= numElems) \n    { \n        out_array[globalId] = sharedData4[localId]; \n        out_debug_offset[globalId] = localOffset; \n    } \n    else \n    { \n        if ((globalId << 2) < numElems) out_array[globalId].x = sharedData4[localId].x; \n        if ((globalId << 2) + 1 < numElems) out_array[globalId].y = sharedData4[localId].y; \n        if ((globalId << 2) + 2 < numElems) out_array[globalId].z = sharedData4[localId].z; \n    } \n \n    if (localId == 0) \n    { \n        out_histograms[groupId] = localHistogram.x; \n        out_histograms[groupId + numGroups] = localHistogram.y; \n        out_histograms[groupId + 2 * numGroups] = localHistogram.z; \n        out_histograms[groupId + 3 * numGroups] = localHistogram.w; \n \n        out_local_histograms[groupId] = 0; \n        out_local_histograms[groupId + numGroups] = localHistogram.x; \n        out_local_histograms[groupId + 2 * numGroups] = localHistogram.x + localHistogram.y; \n        out_local_histograms[groupId + 3 * numGroups] = localHistogram.x + localHistogram.y + localHistogram.z; \n    } \n} \n \n#define GROUP_SIZE 64 \n#define NUMBER_OF_BLOCKS_PER_GROUP 8 \n#define NUM_BINS 16 \n \n// The kernel computes 16 bins histogram of the 256 input elements. \n// The bin is determined by (in_array[tid] >> bitshift) & 0xF \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid BitHistogram( \n    // Number of bits to shift \n    int bitshift, \n    // Input array \n    __global int const* restrict in_array, \n    // Number of elements in input array \n    uint numelems, \n    // Output histograms in column layout \n    // [bin0_group0, bin0_group1, ... bin0_groupN, bin1_group0, bin1_group1, ... bin1_groupN, ...] \n    __global int* restrict out_histogram \n    ) \n{ \n    // Histogram storage \n    __local int histogram[NUM_BINS * GROUP_SIZE]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    /// Clear local histogram \n    for (int i = 0; i < NUM_BINS; ++i) \n    { \n        histogram[i*GROUP_SIZE + localid] = 0; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    const int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    const int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        /// Load single int4 value \n        int4 value = safe_load_int4_intmax(in_array, loadidx, numelems); \n \n        /// Handle value adding histogram bins \n        /// for all 4 elements \n        int4 bin = ((value >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.x*GROUP_SIZE + localid]); \n        //bin = ((value.y >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.y*GROUP_SIZE + localid]); \n        //bin = ((value
alignedNodes
alignedNodesMB
alignedNodesMB4D
alloc
allocThreadIndex@TaskScheduler@embree@@QEAA_JXZ
alloc_main_block_size
alloc_num_main_slots
alloc_single_thread_alloc
alloc_thread_block_size
allocation exceeds size of tessellation cache segment
allocation is too large
already connected
already initialized
am\r<R
america
american
american english
american-english
amfrt64.dll
an;̴Q
anonymous namespace
anx;[I
ao؆\afȇ\a
ao؉\afȊ\a
aoة\afȪ\a
aoش\afȵ\a
aoؼ\afȽ\a
apU;\v
api-ms
api-ms-win-appmodel-runtime-l1-1-1
api-ms-win-core-datetime-l1-1-1
api-ms-win-core-fibers-l1-1-1
api-ms-win-core-file-l2-1-1
api-ms-win-core-localization-l1-2-1
api-ms-win-core-localization-obsolete-l1-2-0
api-ms-win-core-processthreads-l1-1-2
api-ms-win-core-string-l1-1-0
api-ms-win-core-synch-l1-2-0
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-2-1
api-ms-win-core-winrt-l1-1-0
api-ms-win-core-xstate-l2-1-0
api-ms-win-rtcore-ntuser-window-l1-1-0
api-ms-win-security-systemfunctions-l1-1-0
applyIIRFilter
apy<S@n
aq6;~t
aq=)R
ar:X}E7
ar;\aR4
arFileInfo
argument list too long
argument out of bounds
argument out of domain
ar؆\aiȇ\a
ar؈\aiȉ\a
ar،\aiȍ\a
ar؎\aiȏ\a
arؒ\aiȓ\a
arؔ\aiȕ\a
arؖ\aiȗ\a
arؘ\aiș\a
arؚ\aiț\a
arآ\aiȣ\a
arئ\aiȧ\a
arت\aiȫ\a
arج\aiȭ\a
arذ\aiȱ\a
arز\aiȳ\a
as:7Ձ9
asQ=1wU
as|:p\a
at=L;\r
at\n:g<F
ata \n    GLOBAL Intersection *hits) \n{ \n    __local uint lds_stack[GROUP_SIZE * LDS_STACK_SIZE]; \n \n    uint index = get_global_id(0); \n    uint local_index = get_local_id(0); \n \n    // Handle only working subset \n    if (index < *num_rays) \n    { \n        const ray my_ray = rays[index]; \n \n        if (ray_is_active(&my_ray)) \n        { \n            // Precompute inverse direction and origin / dir for bbox testing \n            const float3 invDir32 = safe_invdir2(my_ray); \n            const half3 invDir = convert_half3(invDir32); \n            const half3 oxInvDir = convert_half3(-my_ray.o.xyz * invDir32); \n \n            // Intersection parametric distance \n            float closest_t = my_ray.o.w; \n \n            // Current node address \n            uint addr = 0; \n            // Current closest address \n            uint closest_addr = INVALID_ADDR; \n \n            uint stack_bottom = STACK_SIZE * index; \n            uint sptr = stack_bottom; \n            uint lds_stack_bottom = local_index * LDS_STACK_SIZE; \n            uint lds_sptr = lds_stack_bottom; \n \n            lds_stack[lds_sptr++] = INVALID_ADDR; \n \n            while (addr != INVALID_ADDR) \n            { \n                const bvh_node node = nodes[addr]; \n \n                if (INTERNAL_NODE(node)) \n                { \n                    half4 s01 = fast_intersect_bbox2( \n                        node.aabb01_min_or_v0_and_addr0.xyz, \n                        node.aabb01_max_or_v1_and_addr1_or_mesh_id.xyz, \n                        invDir, oxInvDir, closest_t); \n                    half4 s23 = fast_intersect_bbox2( \n                        node.aabb23_min_or_v2_and_addr2_or_prim_id.xyz, \n                        node.aabb23_max_and_addr3.xyz, \n                        invDir, oxInvDir, closest_t); \n \n                    bool traverse_c0 = (s01.x <= s01.z); \n                    bool traverse_c1 = (s01.y <= s01.w) && (node.aabb01_max_or_v1_and_addr1_or_mesh_id.w != INVALID_ADDR); \n                    bool traverse_c2 = (s23.x <= s23.z); \n                    bool traverse_c3 = (s23.y <= s23.w) && (node.aabb23_max_and_addr3.w != INVALID_ADDR); \n \n                    if (traverse_c0 || traverse_c1 || traverse_c2 || traverse_c3) \n                    { \n                        uint a = INVALID_ADDR; \n                        half d = 100000000.0f; \n \n                        if (traverse_c0) \n                        { \n                            a = node.aabb01_min_or_v0_and_addr0.w; \n                            d = s01.x; \n                        } \n \n                        if (traverse_c1) \n                        { \n                            if (a == INVALID_ADDR) \n                                a = node.aabb01_max_or_v1_and_addr1_or_mesh_id.w; \n                            else \n                            { \n                                uint topush = s01.y < d ? a : node.aabb01_max_or_v1_and_addr1_or_mesh_id.w; \n                                d = min(s01.y, d); \n                                a = topush == a ? node.aabb01_max_or_v1_and_addr1_or_mesh_id.w : a; \n                                stack_push(lds_stack, &lds_sptr, lds_stack_bottom, stack, &sptr, topush); \n                            } \n                        } \n \n                        if (traverse_c2) \n                        { \n                            if (a == INVALID_ADDR) \n                                a = node.aabb23_min_or_v2_and_addr2_or_prim_id.w; \n                            else \n                            { \n                                uint topush = s23.x < d ? a : node.aabb23_min_or_v2_and_addr2_or_prim_id.w; \n                                d = min(s23.x, d); \n                                a = topush == a ? node.aabb23_min_or_v2_and_addr2_or_prim_id.w : a; \n                                stack_push(lds_stack, &lds_sptr, lds_stack_bottom, stack, &sptr, topush); \n                            } \n                        } \n \n                        if (traverse_c3) \n
atp:T~P
attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL void intersect_main( \n    // BVH nodes \n    GLOBAL bvh_node const* restrict nodes, \n    // Vertices \n    GLOBAL float3 const* restrict vertices, \n    // Faces \n    GLOBAL Face const* restrict faces, \n    // Shapes \n    GLOBAL Shape const* restrict shapes, \n    // BVH root index \n    int root_idx,               \n    // Rays \n    GLOBAL ray const* restrict rays, \n    // Number of rays in ray buffer \n    GLOBAL int const* restrict num_rays, \n    // Hits  \n    GLOBAL Intersection* hits \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Handle only working subset \n    if (global_id < *num_rays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (ray_is_active(&r)) \n        { \n            // Precompute invdir for bbox testing \n            float3 invdir = safe_invdir(r); \n            float3 invdirtop = invdir; \n            float t_max = r.o.w; \n \n            // We need to keep original ray around for returns from bottom hierarchy \n            ray top_ray = r; \n            // Fetch top level BVH index \n            int addr = root_idx; \n \n            // Set top index \n            int top_addr = INVALID_IDX; \n            // Current shape ID \n            int shape_id = INVALID_IDX; \n            // Closest shape ID \n            int closest_shape_id = INVALID_IDX; \n            int closest_prim_id = INVALID_IDX; \n            float2 closest_barycentrics; \n            while (addr != INVALID_IDX) \n            { \n                // Fetch next node \n                bvh_node node = nodes[addr]; \n \n                // Intersect against bbox \n                float2 s = fast_intersect_bbox1(node, invdir, -r.o.xyz * invdir, t_max); \n \n                if (s.x <= s.y) \n                { \n                    if (LEAFNODE(node)) \n                    { \n                        // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                        // or containing another BVH (top level hierarhcy) \n                        if (top_addr != INVALID_IDX) \n                        { \n                            // Intersect leaf here \n                            // \n                            int const face_idx = STARTIDX(node); \n                            Face const face = faces[face_idx]; \n                            float3 const v1 = vertices[face.idx[0]]; \n                            float3 const v2 = vertices[face.idx[1]]; \n                            float3 const v3 = vertices[face.idx[2]]; \n \n                            // Intersect triangle \n                            float const f = fast_intersect_triangle(r, v1, v2, v3, t_max); \n                            // If hit update closest hit distance and index \n                            if (f < t_max) \n                            { \n                                t_max = f; \n                                closest_prim_id = face.prim_id; \n                                closest_shape_id = shape_id; \n \n                                float3 const p = r.o.xyz + r.d.xyz * t_max; \n                                // Calculte barycentric coordinates \n                                closest_barycentrics = triangle_calculate_barycentrics(p, v1, v2, v3); \n                            } \n \n                            // And goto next node \n                            addr = NEXT(node); \n                        } \n                        else \n                        { \n                            // This is top level hierarchy leaf \n                            // Save top node index for return \n                            top_addr = addr; \n                            // Get shape descrition struct index \n                            int shape_idx = SHAPEIDX(node); \n                            // Get shape mask \n                            unsigned int const shapeDisabled = shapes[shape_idx].shapeDisabled; \n                            int const shapeId = shapes[shape_idx].id; \n
au\b=0
au\tD9t$ uX
australian
aut;\eF
av/;J
av;\v
av\v=H7
avf;wOu
avx2::BVH4Bezier1iIntersector1
avx2::BVH4Bezier1iIntersector1_OBB
avx2::BVH4Bezier1iIntersector4Hybrid
avx2::BVH4Bezier1iIntersector4Hybrid_OBB
avx2::BVH4Bezier1iIntersector8Hybrid
avx2::BVH4Bezier1iIntersector8Hybrid_OBB
avx2::BVH4Bezier1vIntersector1
avx2::BVH4Bezier1vIntersector1_OBB
avx2::BVH4Bezier1vIntersector4Hybrid
avx2::BVH4Bezier1vIntersector4Hybrid_OBB
avx2::BVH4Bezier1vIntersector8Hybrid
avx2::BVH4Bezier1vIntersector8Hybrid_OBB
avx2::BVH4IntersectorStreamPacketFallback
avx2::BVH4Line4iIntersector1
avx2::BVH4Line4iIntersector4
avx2::BVH4Line4iIntersector8
avx2::BVH4Line4iMBIntersector1
avx2::BVH4Line4iMBIntersector4
avx2::BVH4Line4iMBIntersector8
avx2::BVH4OBBBezier1iMBIntersector1_OBB
avx2::BVH4OBBBezier1iMBIntersector4Hybrid_OBB
avx2::BVH4OBBBezier1iMBIntersector8Hybrid_OBB
avx2::BVH4Quad4iIntersector1Moeller
avx2::BVH4Quad4iIntersector1Pluecker
avx2::BVH4Quad4iIntersector4HybridMoeller
avx2::BVH4Quad4iIntersector4HybridPluecker
avx2::BVH4Quad4iIntersector8HybridMoeller
avx2::BVH4Quad4iIntersector8HybridPluecker
avx2::BVH4Quad4iIntersectorStreamMoeller
avx2::BVH4Quad4iIntersectorStreamPluecker
avx2::BVH4Quad4iMBIntersector1Moeller
avx2::BVH4Quad4iMBIntersector1Pluecker
avx2::BVH4Quad4iMBIntersector4HybridMoeller
avx2::BVH4Quad4iMBIntersector4HybridPluecker
avx2::BVH4Quad4iMBIntersector8HybridMoeller
avx2::BVH4Quad4iMBIntersector8HybridPluecker
avx2::BVH4Quad4vIntersector1Moeller
avx2::BVH4Quad4vIntersector1Pluecker
avx2::BVH4Quad4vIntersector4HybridMoeller
avx2::BVH4Quad4vIntersector4HybridMoellerNoFilter
avx2::BVH4Quad4vIntersector4HybridPluecker
avx2::BVH4Quad4vIntersector8HybridMoeller
avx2::BVH4Quad4vIntersector8HybridMoellerNoFilter
avx2::BVH4Quad4vIntersector8HybridPluecker
avx2::BVH4Quad4vIntersectorStreamMoeller
avx2::BVH4Quad4vIntersectorStreamMoellerNoFilter
avx2::BVH4Quad4vIntersectorStreamPluecker
avx2::BVH4SubdivPatch1CachedIntersector1
avx2::BVH4SubdivPatch1CachedIntersector4
avx2::BVH4SubdivPatch1CachedIntersector8
avx2::BVH4SubdivPatch1CachedMBIntersector1
avx2::BVH4SubdivPatch1CachedMBIntersector4
avx2::BVH4SubdivPatch1CachedMBIntersector8
avx2::BVH4SubdivPatch1EagerIntersector1
avx2::BVH4SubdivPatch1EagerIntersector4
avx2::BVH4SubdivPatch1EagerIntersector8
avx2::BVH4SubdivPatch1Intersector1
avx2::BVH4SubdivPatch1Intersector4
avx2::BVH4SubdivPatch1Intersector8
avx2::BVH4SubdivPatch1MBIntersector1
avx2::BVH4SubdivPatch1MBIntersector4
avx2::BVH4SubdivPatch1MBIntersector8
avx2::BVH4Triangle4Intersector1Moeller
avx2::BVH4Triangle4Intersector4HybridMoeller
avx2::BVH4Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH4Triangle4Intersector8HybridMoeller
avx2::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH4Triangle4IntersectorStreamMoeller
avx2::BVH4Triangle4IntersectorStreamMoellerNoFilter
avx2::BVH4Triangle4iIntersector1Moeller
avx2::BVH4Triangle4iIntersector1Pluecker
avx2::BVH4Triangle4iIntersector4HybridMoeller
avx2::BVH4Triangle4iIntersector4HybridPluecker
avx2::BVH4Triangle4iIntersector8HybridMoeller
avx2::BVH4Triangle4iIntersector8HybridPluecker
avx2::BVH4Triangle4iIntersectorStreamMoeller
avx2::BVH4Triangle4iIntersectorStreamPluecker
avx2::BVH4Triangle4iMBIntersector1Moeller
avx2::BVH4Triangle4iMBIntersector1Pluecker
avx2::BVH4Triangle4iMBIntersector4HybridMoeller
avx2::BVH4Triangle4iMBIntersector4HybridPluecker
avx2::BVH4Triangle4iMBIntersector8HybridMoeller
avx2::BVH4Triangle4iMBIntersector8HybridPluecker
avx2::BVH4Triangle4vIntersector1Pluecker
avx2::BVH4Triangle4vIntersector4HybridPluecker
avx2::BVH4Triangle4vIntersector8HybridPluecker
avx2::BVH4Triangle4vIntersectorStreamPluecker
avx2::BVH4Triangle4vMBIntersector1Moeller
avx2::BVH4Triangle4vMBIntersector1Pluecker
avx2::BVH4Triangle4vMBIntersector4HybridMoeller
avx2::BVH4Triangle4vMBIntersector4HybridPluecker
avx2::BVH4Triangle4vMBIntersector8HybridMoeller
avx2::BVH4Triangle4vMBIntersector8HybridPluecker
avx2::BVH4VirtualIntersector1
avx2::BVH4VirtualIntersector4Chunk
avx2::BVH4VirtualIntersector8Chunk
avx2::BVH4VirtualIntersectorStream
avx2::BVH4VirtualMBIntersector1
avx2::BVH4VirtualMBIntersector4Chunk
avx2::BVH4VirtualMBIntersector8Chunk
avx2::BVH4XfmTriangle4Intersector1Moeller
avx2::BVH8Bezier1iIntersector1_OBB
avx2::BVH8Bezier1iIntersector4Hybrid_OBB
avx2::BVH8Bezier1iIntersector8Hybrid_OBB
avx2::BVH8Bezier1vIntersector1_OBB
avx2::BVH8Bezier1vIntersector4Hybrid_OBB
avx2::BVH8Bezier1vIntersector8Hybrid_OBB
avx2::BVH8IntersectorStreamPacketFallback
avx2::BVH8Line4iIntersector1
avx2::BVH8Line4iIntersector4
avx2::BVH8Line4iIntersector8
avx2::BVH8Line4iMBIntersector1
avx2::BVH8Line4iMBIntersector4
avx2::BVH8Line4iMBIntersector8
avx2::BVH8OBBBezier1iMBIntersector1_OBB
avx2::BVH8OBBBezier1iMBIntersector4Hybrid_OBB
avx2::BVH8OBBBezier1iMBIntersector8Hybrid_OBB
avx2::BVH8Quad4iIntersector1Moeller
avx2::BVH8Quad4iIntersector1Pluecker
avx2::BVH8Quad4iIntersector4HybridMoeller
avx2::BVH8Quad4iIntersector4HybridPluecker
avx2::BVH8Quad4iIntersector8HybridMoeller
avx2::BVH8Quad4iIntersector8HybridPluecker
avx2::BVH8Quad4iIntersectorStreamMoeller
avx2::BVH8Quad4iIntersectorStreamPluecker
avx2::BVH8Quad4iMBIntersector1Moeller
avx2::BVH8Quad4iMBIntersector1Pluecker
avx2::BVH8Quad4iMBIntersector4HybridMoeller
avx2::BVH8Quad4iMBIntersector4HybridPluecker
avx2::BVH8Quad4iMBIntersector8HybridMoeller
avx2::BVH8Quad4iMBIntersector8HybridPluecker
avx2::BVH8Quad4vIntersector1Moeller
avx2::BVH8Quad4vIntersector1Pluecker
avx2::BVH8Quad4vIntersector4HybridMoeller
avx2::BVH8Quad4vIntersector4HybridMoellerNoFilter
avx2::BVH8Quad4vIntersector4HybridPluecker
avx2::BVH8Quad4vIntersector8HybridMoeller
avx2::BVH8Quad4vIntersector8HybridMoellerNoFilter
avx2::BVH8Quad4vIntersector8HybridPluecker
avx2::BVH8Quad4vIntersectorStreamMoeller
avx2::BVH8Quad4vIntersectorStreamMoellerNoFilter
avx2::BVH8Quad4vIntersectorStreamPluecker
avx2::BVH8Triangle4Intersector1Moeller
avx2::BVH8Triangle4Intersector4HybridMoeller
avx2::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH8Triangle4Intersector8HybridMoeller
avx2::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH8Triangle4IntersectorStreamMoeller
avx2::BVH8Triangle4IntersectorStreamMoellerNoFilter
avx2::BVH8Triangle4iIntersector1Moeller
avx2::BVH8Triangle4iIntersector1Pluecker
avx2::BVH8Triangle4iIntersector4HybridMoeller
avx2::BVH8Triangle4iIntersector4HybridPluecker
avx2::BVH8Triangle4iIntersector8HybridMoeller
avx2::BVH8Triangle4iIntersector8HybridPluecker
avx2::BVH8Triangle4iIntersectorStreamMoeller
avx2::BVH8Triangle4iIntersectorStreamPluecker
avx2::BVH8Triangle4iMBIntersector1Moeller
avx2::BVH8Triangle4iMBIntersector1Pluecker
avx2::BVH8Triangle4iMBIntersector4HybridMoeller
avx2::BVH8Triangle4iMBIntersector4HybridPluecker
avx2::BVH8Triangle4iMBIntersector8HybridMoeller
avx2::BVH8Triangle4iMBIntersector8HybridPluecker
avx2::BVH8Triangle4vIntersector1Pluecker
avx2::BVH8Triangle4vIntersector4HybridPluecker
avx2::BVH8Triangle4vIntersector8HybridPluecker
avx2::BVH8Triangle4vIntersectorStreamPluecker
avx2::BVH8Triangle4vMBIntersector1Moeller
avx2::BVH8Triangle4vMBIntersector1Pluecker
avx2::BVH8Triangle4vMBIntersector4HybridMoeller
avx2::BVH8Triangle4vMBIntersector4HybridPluecker
avx2::BVH8Triangle4vMBIntersector8HybridMoeller
avx2::BVH8Triangle4vMBIntersector8HybridPluecker
avx2::BVH8VirtualIntersector1
avx2::BVH8VirtualIntersector4Chunk
avx2::BVH8VirtualIntersector8Chunk
avx2::BVH8VirtualIntersectorStream
avx2::BVH8VirtualMBIntersector1
avx2::BVH8VirtualMBIntersector4Chunk
avx2::BVH8VirtualMBIntersector8Chunk
avx2::InstanceIntersectorN
avx2::QBVH4Quad4iIntersector1Pluecker
avx2::QBVH4Triangle4iIntersector1Pluecker
avx2::QBVH8Quad4iIntersector1Pluecker
avx2::QBVH8Triangle4Intersector1Moeller
avx2::QBVH8Triangle4iIntersector1Pluecker
avx512knl
avx512skx
avx::BVH
avx::BVH4Bezier1iIntersector1
avx::BVH4Bezier1iIntersector1_OBB
avx::BVH4Bezier1iIntersector4Hybrid
avx::BVH4Bezier1iIntersector4Hybrid_OBB
avx::BVH4Bezier1iIntersector8Hybrid
avx::BVH4Bezier1iIntersector8Hybrid_OBB
avx::BVH4Bezier1vIntersector1
avx::BVH4Bezier1vIntersector1_OBB
avx::BVH4Bezier1vIntersector4Hybrid
avx::BVH4Bezier1vIntersector4Hybrid_OBB
avx::BVH4Bezier1vIntersector8Hybrid
avx::BVH4Bezier1vIntersector8Hybrid_OBB
avx::BVH4IntersectorStreamPacketFallback
avx::BVH4Line4iIntersector1
avx::BVH4Line4iIntersector4
avx::BVH4Line4iIntersector8
avx::BVH4Line4iMBIntersector1
avx::BVH4Line4iMBIntersector4
avx::BVH4Line4iMBIntersector8
avx::BVH4OBBBezier1iMBIntersector1_OBB
avx::BVH4OBBBezier1iMBIntersector4Hybrid_OBB
avx::BVH4OBBBezier1iMBIntersector8Hybrid_OBB
avx::BVH4Quad4iIntersector1Moeller
avx::BVH4Quad4iIntersector1Pluecker
avx::BVH4Quad4iIntersector4HybridMoeller
avx::BVH4Quad4iIntersector4HybridPluecker
avx::BVH4Quad4iIntersector8HybridMoeller
avx::BVH4Quad4iIntersector8HybridPluecker
avx::BVH4Quad4iIntersectorStreamMoeller
avx::BVH4Quad4iIntersectorStreamPluecker
avx::BVH4Quad4iMBIntersector1Moeller
avx::BVH4Quad4iMBIntersector1Pluecker
avx::BVH4Quad4iMBIntersector4HybridMoeller
avx::BVH4Quad4iMBIntersector4HybridPluecker
avx::BVH4Quad4iMBIntersector8HybridMoeller
avx::BVH4Quad4iMBIntersector8HybridPluecker
avx::BVH4Quad4vIntersector1Moeller
avx::BVH4Quad4vIntersector1Pluecker
avx::BVH4Quad4vIntersector4HybridMoeller
avx::BVH4Quad4vIntersector4HybridMoellerNoFilter
avx::BVH4Quad4vIntersector4HybridPluecker
avx::BVH4Quad4vIntersector8HybridMoeller
avx::BVH4Quad4vIntersector8HybridMoellerNoFilter
avx::BVH4Quad4vIntersector8HybridPluecker
avx::BVH4Quad4vIntersectorStreamMoeller
avx::BVH4Quad4vIntersectorStreamMoellerNoFilter
avx::BVH4Quad4vIntersectorStreamPluecker
avx::BVH4SubdivPatch1CachedIntersector1
avx::BVH4SubdivPatch1CachedIntersector4
avx::BVH4SubdivPatch1CachedIntersector8
avx::BVH4SubdivPatch1CachedMBIntersector1
avx::BVH4SubdivPatch1CachedMBIntersector4
avx::BVH4SubdivPatch1CachedMBIntersector8
avx::BVH4SubdivPatch1EagerIntersector1
avx::BVH4SubdivPatch1EagerIntersector4
avx::BVH4SubdivPatch1EagerIntersector8
avx::BVH4SubdivPatch1Intersector1
avx::BVH4SubdivPatch1Intersector4
avx::BVH4SubdivPatch1Intersector8
avx::BVH4SubdivPatch1MBIntersector1
avx::BVH4SubdivPatch1MBIntersector4
avx::BVH4SubdivPatch1MBIntersector8
avx::BVH4Triangle4Intersector1Moeller
avx::BVH4Triangle4Intersector4HybridMoeller
avx::BVH4Triangle4Intersector4HybridMoellerNoFilter
avx::BVH4Triangle4Intersector8HybridMoeller
avx::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx::BVH4Triangle4IntersectorStreamMoeller
avx::BVH4Triangle4IntersectorStreamMoellerNoFilter
avx::BVH4Triangle4iIntersector1Moeller
avx::BVH4Triangle4iIntersector1Pluecker
avx::BVH4Triangle4iIntersector4HybridMoeller
avx::BVH4Triangle4iIntersector4HybridPluecker
avx::BVH4Triangle4iIntersector8HybridMoeller
avx::BVH4Triangle4iIntersector8HybridPluecker
avx::BVH4Triangle4iIntersectorStreamMoeller
avx::BVH4Triangle4iIntersectorStreamPluecker
avx::BVH4Triangle4iMBIntersector1Moeller
avx::BVH4Triangle4iMBIntersector1Pluecker
avx::BVH4Triangle4iMBIntersector4HybridMoeller
avx::BVH4Triangle4iMBIntersector4HybridPluecker
avx::BVH4Triangle4iMBIntersector8HybridMoeller
avx::BVH4Triangle4iMBIntersector8HybridPluecker
avx::BVH4Triangle4vIntersector1Pluecker
avx::BVH4Triangle4vIntersector4HybridPluecker
avx::BVH4Triangle4vIntersector8HybridPluecker
avx::BVH4Triangle4vIntersectorStreamPluecker
avx::BVH4Triangle4vMBIntersector1Moeller
avx::BVH4Triangle4vMBIntersector1Pluecker
avx::BVH4Triangle4vMBIntersector4HybridMoeller
avx::BVH4Triangle4vMBIntersector4HybridPluecker
avx::BVH4Triangle4vMBIntersector8HybridMoeller
avx::BVH4Triangle4vMBIntersector8HybridPluecker
avx::BVH4VirtualIntersector1
avx::BVH4VirtualIntersector4Chunk
avx::BVH4VirtualIntersector8Chunk
avx::BVH4VirtualIntersectorStream
avx::BVH4VirtualMBIntersector1
avx::BVH4VirtualMBIntersector4Chunk
avx::BVH4VirtualMBIntersector8Chunk
avx::BVH4XfmTriangle4Intersector1Moeller
avx::BVH8Bezier1iIntersector1_OBB
avx::BVH8Bezier1iIntersector4Hybrid_OBB
avx::BVH8Bezier1iIntersector8Hybrid_OBB
avx::BVH8Bezier1vIntersector1_OBB
avx::BVH8Bezier1vIntersector4Hybrid_OBB
avx::BVH8Bezier1vIntersector8Hybrid_OBB
avx::BVH8IntersectorStreamPacketFallback
avx::BVH8Line4iIntersector1
avx::BVH8Line4iIntersector4
avx::BVH8Line4iIntersector8
avx::BVH8Line4iMBIntersector1
avx::BVH8Line4iMBIntersector4
avx::BVH8Line4iMBIntersector8
avx::BVH8OBBBezier1iMBIntersector1_OBB
avx::BVH8OBBBezier1iMBIntersector4Hybrid_OBB
avx::BVH8OBBBezier1iMBIntersector8Hybrid_OBB
avx::BVH8Quad4iIntersector1Moeller
avx::BVH8Quad4iIntersector1Pluecker
avx::BVH8Quad4iIntersector4HybridMoeller
avx::BVH8Quad4iIntersector4HybridPluecker
avx::BVH8Quad4iIntersector8HybridMoeller
avx::BVH8Quad4iIntersector8HybridPluecker
avx::BVH8Quad4iIntersectorStreamMoeller
avx::BVH8Quad4iIntersectorStreamPluecker
avx::BVH8Quad4iMBIntersector1Moeller
avx::BVH8Quad4iMBIntersector1Pluecker
avx::BVH8Quad4iMBIntersector4HybridMoeller
avx::BVH8Quad4iMBIntersector4HybridPluecker
avx::BVH8Quad4iMBIntersector8HybridMoeller
avx::BVH8Quad4iMBIntersector8HybridPluecker
avx::BVH8Quad4vIntersector1Moeller
avx::BVH8Quad4vIntersector1Pluecker
avx::BVH8Quad4vIntersector4HybridMoeller
avx::BVH8Quad4vIntersector4HybridMoellerNoFilter
avx::BVH8Quad4vIntersector4HybridPluecker
avx::BVH8Quad4vIntersector8HybridMoeller
avx::BVH8Quad4vIntersector8HybridMoellerNoFilter
avx::BVH8Quad4vIntersector8HybridPluecker
avx::BVH8Quad4vIntersectorStreamMoeller
avx::BVH8Quad4vIntersectorStreamMoellerNoFilter
avx::BVH8Quad4vIntersectorStreamPluecker
avx::BVH8Triangle4Intersector1Moeller
avx::BVH8Triangle4Intersector4HybridMoeller
avx::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx::BVH8Triangle4Intersector8HybridMoeller
avx::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx::BVH8Triangle4IntersectorStreamMoeller
avx::BVH8Triangle4IntersectorStreamMoellerNoFilter
avx::BVH8Triangle4iIntersector1Moeller
avx::BVH8Triangle4iIntersector1Pluecker
avx::BVH8Triangle4iIntersector4HybridMoeller
avx::BVH8Triangle4iIntersector4HybridPluecker
avx::BVH8Triangle4iIntersector8HybridMoeller
avx::BVH8Triangle4iIntersector8HybridPluecker
avx::BVH8Triangle4iIntersectorStreamMoeller
avx::BVH8Triangle4iIntersectorStreamPluecker
avx::BVH8Triangle4iMBIntersector1Moeller
avx::BVH8Triangle4iMBIntersector1Pluecker
avx::BVH8Triangle4iMBIntersector4HybridMoeller
avx::BVH8Triangle4iMBIntersector4HybridPluecker
avx::BVH8Triangle4iMBIntersector8HybridMoeller
avx::BVH8Triangle4iMBIntersector8HybridPluecker
avx::BVH8Triangle4vIntersector1Pluecker
avx::BVH8Triangle4vIntersector4HybridPluecker
avx::BVH8Triangle4vIntersector8HybridPluecker
avx::BVH8Triangle4vIntersectorStreamPluecker
avx::BVH8Triangle4vMBIntersector1Moeller
avx::BVH8Triangle4vMBIntersector1Pluecker
avx::BVH8Triangle4vMBIntersector4HybridMoeller
avx::BVH8Triangle4vMBIntersector4HybridPluecker
avx::BVH8Triangle4vMBIntersector8HybridMoeller
avx::BVH8Triangle4vMBIntersector8HybridPluecker
avx::BVH8VirtualIntersector1
avx::BVH8VirtualIntersector4Chunk
avx::BVH8VirtualIntersector8Chunk
avx::BVH8VirtualIntersectorStream
avx::BVH8VirtualMBIntersector1
avx::BVH8VirtualMBIntersector4Chunk
avx::BVH8VirtualMBIntersector8Chunk
avx::InstanceIntersectorN
avx::QBVH
avx::QBVH4Quad4iIntersector1Pluecker
avx::QBVH4Triangle4iIntersector1Pluecker
avx::QBVH8Quad4iIntersector1Pluecker
avx::QBVH8Triangle4Intersector1Moeller
avx::QBVH8Triangle4iIntersector1Pluecker
aw:R)z8f0
aw];C
ax5;T
ax仡iٻ0
ay57u
az-AZ-Cyrl
az-AZ-Latn
az-az-cyrl
az-az-latn
az<hf
az=\t4d
azE:Ty
a{P;u
a}<7v
a~C<7P
aĻs=8
aͼE\nȼL
aμ?sX=IV
aѻ44{0
aѻR\f
aѼV4M
aҹOTO
aּ%7F
aڛ;9k
aܼw-A
aݓ9EЕ9w
aᚼD-D
a㱼ڪL>ti
a꼍Cռs
a빺d`;ZQ
a캅4B:)L
aQzɻ\a
a8\t
b %d %H : %M : %S %Y
b 4;=\tQ
b \b=Uvc
b bB%H6
b ba|\b
b!,HY
b!4HY
b!L@X
b!T@YD
b!THYT
b!THYd
b!V\bY
b!W<2
b!\\HYt
b!d(Y
b!d@Y
b!dHYT
b!lHYt
b!l\bY
b!t@Y
b!t@Yd
b!v\b
b!|HY
b!}Hp
b!}Hp$1b
b!}Hp$±bA
b!}Hp$ڱbA
b!}Hp,1b
b!}Hp,ȱb2MH
b!}Hp,ʱb1LHY
b!}Hp,αb2MH
b!}Hp1b
b!}Hp1batH
b!}Hp4
b!}Hp41
b!}Hp4ȱL
b!}Hp4ȱb
b!}Hp4бb
b!}Hp4ұL
b!}Hp4ұb1}Hp\f
b!}Hp4ڱb
b!}Hp4ڱba}Hp\f
b!}Hp<رba}Hp
b!}Hp\f
b!}Hp\f±b
b!}Hp\fȱb
b!}Hp\fɱb
b!}Hp\fʱb
b!}Hp\fرb
b!}Hp±b
b!}Hpñb
b!}HpǱb
b!}HpǱb1|H
b!}HpǱbA|H
b!}HpǱbq|H
b!}Hpɱb
b!}Hpʱb
b!}Hp˱b
b!}Hp̱ba|H
b!}Hpαb
b!}Hpϱb
b!}HpϱbA|H
b!}HpϱbA|L
b!}Hpбb
b!}Hpұba}Hp
b!}Hpӱb
b!}HpԱb
b!}Hpձb
b!}HpձbA,@YU
b!}HpֱbA,@YU
b!}Hpֱbb}H
b!}HpױbA,@YU
b!}HpٱbQ}Hp
b!}Hpܱb
b!}Hpݱb
b!}Hp߱b
b!}Hp߱bA}HpƱb
b!}Jpбb
b!}Jpұb
b"V<i
b#0<w
b#MBCƱb
b#UBCűb
b#a=TO
b#m\b!4
b#uCCqb
b#}BCбb
b#}BCرb
b%2<7
b&D<q
b&o<9
b';fN
b(V:W
b(l8X
b)A<2
b)A<6fg
b*<4S
b,;wEv
b-,48M
b-;jE
b-;oh
b-R>L1
b09;\v
b0bA|\b
b1,@Y
b1,@YT
b14@Y
b14@YT
b1:2U\t
b1;:wM
b1<;p
b1D@Y
b1LHT
b1dHY
b1dHYt
b1}Hp
b1}Hp$ɱba}Hp4
b1}Hp,1bQ,HY
b1}Hp,ƱbQ4@Y
b1}Hp,ڱb
b1}Hp4
b1}Hp4ȱb
b1}Hp4رbQ\\@Y
b1}Hp<1bA
b1}Hp<ڱb1}Hp\f
b1}Hp\f
b1}Hp\fȱbQ,HY
b1}Hp\fʱba}Hp$ڱbQ4HYU\fH
b1}Hp\fʱba}Hp$ڱbQ4HYU\fbq}Hp\f
b1}Hp±bA$@Y
b1}HpǱba}HpǱb
b1}Hp˱ba}Hp˱b
b1}HpӱbQ,HYU
b1}HpԱbQ,HYU\ab
b1}HpٱB
b1}Hp߱b
b2:ve2
b2=@6
b3D<B\t
b3i>N
b3}C#Јb3uC#وb
b4;hK
b4=YTl
b4źꗢ9P
b58<A
b5K;n
b6\t;s
b7;6\f
b7<i7a
b8:X*r
b8\a/U:he\v
b8\nR\f
b8w7F
b92|뻮0
b989d
b9A\bs
b9B\bs
b9G;9
b9I"\b
b9M7Ϲr
b9W8@:\\R
b9i0x
b9p3 :t
b9x_\b0h`\b'4
b9üCZ<3QC
b: Vw:M
b:!3D
b:6?1
b:Dř8'yr
b:E\tuZH
b:KBV9
b:U;7
b:V\to
b:WlH:l
b:\f4i:褃:t02
b:\vg
b:p\bP
b;'mj
b;'mt
b;0\nN
b;21\r
b;7c\e
b;@Fb;P
b;@Qx
b;@xS
b;CӺ9Y
b;V3Ժk
b;VR\t
b;W\n
b;\nt
b;h68
b;n"V
b;w$t
b;y]L
b;z9\a
b;ռej
b<&vq
b<Iᙼf
b<c3j
b<c\r
b<pgW
b<w$\r=hR
b<x \b3h!\b*tL
b<x&\b3h'\b*tX
b<x~\b3h
b<z3?9
b<פQ;NX
b=4%1
b=6鏽uJ
b=8Sc
b=?wOj>\e
b=M\tR>08N>Hb
b=\rDU
b=e;\fS
b=z%7
b=zd1
b>,j1
b>9<mI
b>[rC
b>y<K
b?<of
b?Z<c?s
b?\bt\r
b?^Cy\r
b?xCz
b@ :i
b@>ca
bA$@Y
bA$@Yu
bA$HY,\vb
bA,@YM
bA,@YT
bA,HY
bA,HYu\nbQ|H
bA4@YL
bA4@Yu
bA4@Yu\b
bA4@Yu\bb"MH
bA4HY
bA4HYM
bA9A\bs
bA9B\bs
bA9C\bs
bA;A\bs
bA;u8
bA<@YE
bA<@Ym\fL
bA<HYT
bA<HY\f
bA<HYm
bA>\b
bA@:r
bAD@Y
bAD@YE\fL
bAD@YE\fbA|H
bAD@YU
bAD@Ym\nb
bADHYL
bADHYm
bALHX
bAT@YU
bA\\(XM
bA\\@YE\fb"u
bA\\@YU
bA\\HY
bA\\HYe
bA\\HYe\bb
bA\\HYe\fb
bA\\HYe\nb
bA\\HYe\vb
bA\f@Y
bA\f@YU
bA\v?C
bAd@Y
bAl X
bAl@YM\nb
bAl@Ym\bL
bAl@Ym\bb
bAl@Yu
bAl@Yu\fb
bAt(YU
bAt@YM
bAtHYE
bA|@YE\bbA
bA|@Ym
bA|@Yt
bA}Hp
bA}Hp,ܱbA}Hp
bA}Hp1b
bA}HpT
bA}Hpl
bA}Hpqb
bA}Hp±b
bA}Hpñb
bA}Hpűb
bA}HpǱbB-H
bA}Hpɱb
bA}Hpʱb
bA}Hpϱb
bA}HpѱbA,@YU
bA}Hpұb
bA}HpӱbA,@YU
bA}HpԱb
bA}Hpձb
bA}Hpֱb
bA}Hpױb
bA}HpױbQ}Hp
bA}HpرbQ|H
bA}Hp۱b
bA}Hpݱb
bA}Hpޱb
bA}Hp߱b
bA~(o
bA~(ou
bA~\b
bAջ]ux
bB5@6
bBO:N
bBellevue1
bB~H5
bBƼj\vt
bC 9,o
bC:9Y;Nu
bCM\b
bCP=֙Q
bCZ;=O\n
bD =v
bD8T$1u
bD91t
bD;S\f
bD;\n|Q
bD;\n|U
bD;d$P
bD;l$P
bD;t$P
bDɹmt绨b
bE;e\b
bEu:VQ
bEӻ=lv
bF'<s
bF:hʼ9x*%:MAB
bFEMh\f
bFl:z
bG<\ty\v<v
bH"9JJ\n
bH+] H
bH+]0H
bH9_0v9
bH;F\b
bH;G\b
bH;P A
bH;P\b
bH;x\b
bHN&n
bHbQ|H
bHc|$0I
bIcD$\fH
bIcG\fH
bIcI8
bJ7>]b
bJ^<t
bJɻ1P
bK*:dj
bL';m
bL+t$PD
bL9u/t.H
bM9rPtaE
bM;x\rx
bMcH 3
bO>BfL
bP";T
bP:\ehG
bQ$@YM
bQ$@Ye
bQ4HY
bQ;mRA;T\n
bQ<@Yu
bQ<HY
bQ<HYu
bQLHY
bQLHYm
bQT@Ym\bb
bQ|\n
bQ}Hp
bQ}Hp1b
bQ}Hp1b"eH
bQ}Hp1bq}Hp
bQ}Hp4ƱI
bQ}Hp4ǱL
bQ}Hp\f
bQ}Hp\fıb
bQ}Hp\fԱbR\r
bQ}Hp\fرbQ
bQ}Hpqb
bQ}HpƱb
bQ}HpɱbA}Hp
bQ}HpɱbQ}Hp
bQ}HpɱbQ}Hp۱b
bQ}Hpʱbq}Hpױba|H
bQ}Hp˱b1|H
bQ}Hp˱bq|H
bQ}Hpͱb
bQ}HpϱbA$@Y
bQ}HpϱbA}HpޱbQTHY
bQ}HpбbQ$HY
bQ}HpбbQ,HYU
bQ}HpшbQ}Hp
bQ}HpѱbQ
bQ}HpѱbQ,HYU
bQ}Hpұb
bQ}HpұbbU
bQ}Hpұbr%H
bQ}HpԱb
bQ}HpֱbA}Hpرb
bQ}Hpڱbr}H
bQ}Hp۱b
bQ}Hp۱b2
bQ}Hp۱b25H
bQ}Hp۱b2M
bQ}Hp۱bq}Hp
bQ}Hp۱brM
bQ}HpޱbA}Hp
bQ}Hp߱b
bR%H6
bREH6
bRF=in
bS;oh
bS;µźxs
bSM>X
bSUH%̖b
bSUH%̖bre
bSܻKP\r
bT:(j6:2\a
bU<.O
bUVWATAUAVAW
bUVWATAUAVAWH
bUVWAUAVH
bUVWAVAWH
bUVWH
bUú+eH
bVWAVH
bW%/dx
bW%?kb
bW%VjG
bW%nEs
bWD;q
bWڻufa
bX*9>K4
bX6ba.\bX
bX<$bA
bXD$\tb
bXY@ŪXi
bXY\fŪY
bX`JP`dRf*h
bXa\ab
bXba|\b
bXf:R
bY1:to
bY\\\ad
bY\t;q
bZ <lP
bZ-;H
bZ<tq3
bZR;v
bZW<{c
b[ <A8\a
b\\<LXJ
b\\A\aba
b\\I\abqf
b\a;i
b\a<Q
b\b8FGhF
b\b8F}eF
b\b<VlE
b\bF\n5\v
b\b\b
b\b\b\b
b\b\e9u
b\e<L2A
b\fU;1
b\n8t\t\n
b\n:S4o
b\n;11
b\n;6
b\n\b
b\nba|\b
b\nba~\b
b\r?z]D
b\rb!d(Y
b\rbA
b\rp\f0\vP
b\t7<j
b\t?s
b\tq?\b\tq
b\v\a9
b\vbb-@6
b\vbb]H6
b]x;I
b`:nA
b`?<0HH
ba$ Y
ba$ Y%`iE
ba4 Y
ba4@X
ba;\vc1
ba<@Y\f;ba<@YD
baL X
baL@Yt
baLHYِH
baT(W
baT@X
baTHY<9b
baTHYd
baT\bY\r
baV\bY5\aSD
ba\\H
ba\f Y
ba\f Y=BWD
ba\fPY5
bad address
bad allocation
bad array new length
bad cast
bad conversion
bad exception
bad file descriptor
bad function call
bad locale name
bad message
bad(W=D
bad@Y
bad@Y%rgE
bad@Y%tXD
bad@Y\r
bad@Y\rqXD
bad@Y\rugE
bad_weak_ptr
bal(W-N0
bal@X
bal@Y,/b
balHYA
balHYy\aba|H
barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    v1.w = shmem0[localId]; \n \n    short t = v1.y; v1.y = v1.w; v1.w += t; \n    t = v1.x; v1.x = v1.y; v1.y += t; \n    t = v1.z; v1.z = v1.w; v1.w += t; \n    *offset0 = v1; \n \n    v2.w = shmem1[localId]; \n \n    t = v2.y; v2.y = v2.w; v2.w += t; \n    t = v2.x; v2.x = v2.y; v2.y += t; \n    t = v2.z; v2.z = v2.w; v2.w += t; \n    *offset1 = v2; \n \n    v3.w = shmem2[localId]; \n \n    t = v3.y; v3.y = v3.w; v3.w += t; \n    t = v3.x; v3.x = v3.y; v3.y += t; \n    t = v3.z; v3.z = v3.w; v3.w += t; \n    *offset2 = v3; \n \n    v4.w = shmem3[localId]; \n \n    t = v4.y; v4.y = v4.w; v4.w += t; \n    t = v4.x; v4.x = v4.y; v4.y += t; \n    t = v4.z; v4.z = v4.w; v4.w += t; \n    *offset3 = v4; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    *histogram = total; \n} \n \n// Calculate bool radix mask \nshort4 radix_mask(int offset, uchar digit, int4 val) \n{ \n    short4 res; \n    res.x = ((val.x >> offset) & 3) == digit ? 1 : 0; \n    res.y = ((val.y >> offset) & 3) == digit ? 1 : 0; \n    res.z = ((val.z >> offset) & 3) == digit ? 1 : 0; \n    res.w = ((val.w >> offset) & 3) == digit ? 1 : 0; \n    return res; \n} \n \n// Choose offset based on radix mask value  \nshort offset_4way(int val, int offset, short offset0, short offset1, short offset2, short offset3, short4 hist) \n{ \n    switch ((val >> offset) & 3) \n    { \n    case 0: \n        return offset0; \n    case 1: \n        return offset1 + hist.x; \n    case 2: \n        return offset2 + hist.x + hist.y; \n    case 3: \n        return offset3 + hist.x + hist.y + hist.z; \n    } \n \n    return 0; \n} \n \n \n \n// Perform group split using 2-bits pass \nvoid group_split_radix_2bits( \n    int localId, \n    int groupSize, \n    int offset, \n    int4 val, \n    __local short* shmem, \n    int4* localOffset, \n    short4* histogram) \n{ \n    /// Pointers to radix flag arrays \n    __local short* shmem0 = shmem; \n    __local short* shmem1 = shmem0 + groupSize; \n    __local short* shmem2 = shmem1 + groupSize; \n    __local short* shmem3 = shmem2 + groupSize; \n \n    /// Radix masks for each digit \n    short4 mask0 = radix_mask(offset, 0, val); \n    short4 mask1 = radix_mask(offset, 1, val); \n    short4 mask2 = radix_mask(offset, 2, val); \n    short4 mask3 = radix_mask(offset, 3, val); \n \n    /// Resulting offsets \n    short4 offset0; \n    short4 offset1; \n    short4 offset2; \n    short4 offset3; \n \n    group_scan_short_4way(localId, groupSize, \n        mask0, mask1, mask2, mask3, \n        shmem0, shmem1, shmem2, shmem3, \n        &offset0, &offset1, &offset2, &offset3, \n        histogram); \n \n    (*localOffset).x = offset_4way(val.x, offset, offset0.x, offset1.x, offset2.x, offset3.x, *histogram); \n    (*localOffset).y = offset_4way(val.y, offset, offset0.y, offset1.y, offset2.y, offset3.y, *histogram); \n    (*localOffset).z = offset_4way(val.z, offset, offset0.z, offset1.z, offset2.z, offset3.z, *histogram); \n    (*localOffset).w = offset_4way(val.w, offset, offset0.w, offset1.w, offset2.w, offset3.w, *histogram); \n} \n \nint4 safe_load_int4_intmax(__global int4* source, uint idx, uint sizeInInts) \n{ \n    int4 res = make_int4(INT_MAX, INT_MAX, INT_MAX, INT_MAX); \n    if (((idx + 1) << 2) <= sizeInInts) \n        res = source[idx]; \n    else \n    { \n        if ((idx << 2) < sizeInInts) res.x = source[idx].x; \n        if ((idx << 2) + 1 < sizeInInts) res.y = source[idx].y; \n        if ((idx << 2) + 2 < sizeInInts) res.z = source[idx].z; \n    } \n    return res; \n} \n \nvoid safe_store_int(int val, __global int* dest, uint idx, uint sizeInInts) \n{ \n    if (idx < sizeInInts) \n        dest[idx] = val; \n} \n \n// Split kernel launcher \n__kernel void split4way(int bitshift, __global int4* in_array, uint numElems, __global int* out_histograms, __global int4* out_array, \n    __global int* out_local_histograms, \n    __global int4* out_debug_offset, \n    __local short* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_loc
barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_SUM(type)\\ \n    void group_scan_exclusive_sum_##type(int localId, int groupSize, __local type* shmem, type* sum)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    *sum = shmem[groupSize - 1];\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    if (localId == 0){\\ \n    shmem[groupSize - 1] = 0;}\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_PART(type)\\ \n    type group_scan_exclusive_part_##type( int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    type sum = 0;\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (localId == 0)\\ \n    {\\ \n    sum = shmem[groupSize - 1];\\ \n    shmem[groupSize - 1] = 0;\\ \n    }\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    return sum;\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE(type)\\ \n    __kernel void scan_exclusive_##type(__global type const* in_array, __global type* out_array, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    int groupId   = get_group_id(0);\\ \n    shmem[localId] = in_array[2*globalId] + in_array[2*globalId + 1];\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    out_array[2 * globalId + 1] = shmem[localId] + in_array[2*globalId];\\ \n    out_array[2 * globalId] = shmem[localId];\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\\ \n    v2.w += v1.w;\\ \n    shmem[localId] = v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    v2
barrier_sys_regression_test
based
bat(W
bat(Y
bat@Y
bat@Y-\aXD
bav\bY-[cE
ba|@Y<7b
ba|@Yd
ba|HY
ba|HY=7dE
ba|\b
ba|\bW=u
ba}Hp
ba}Hp$±b
ba}Hp$ȱb
ba}Hp$رb
ba}Hp$رbb]H
ba}Hp,ȱb!}Hp
ba}Hp,ڱb
ba}Hp1b
ba}Hp4
ba}Hp4±b
ba}Hp4ȱb
ba}Hp4ʱbA\f@Ye
ba}Hp4бL
ba}Hp<ȱI
ba}Hp<ʱb
ba}Hp<ʱbA
ba}Hp<ٱb
ba}Hp<ٱb"uH
ba}HpY
ba}Hp\f
ba}Hp\fڱb
ba}Hp\fڱbq}Hp
ba}Hpqb
ba}HpqbA}Hp
ba}Hp±b
ba}Hpñb
ba}Hpıb
ba}Hpűb
ba}HpűbQ|H
ba}HpƱb"M
ba}HpǱb
ba}Hpȱb
ba}Hpɱb!|H
ba}Hpʱb
ba}HpʱbA}Hpݱbq|H
ba}Hp˱b
ba}Hp̱b
ba}Hpͱb
ba}Hpбb
ba}Hpѱb
ba}Hpұb
ba}HpұbA,@YU
ba}Hpӱb
ba}HpԱb
ba}HpԱbA,@YU
ba}Hpձb
ba}Hpֱb
ba}Hpױb
ba}HpرL
ba}Hpرb
ba}Hpٱba}Hp
ba}Hpڱb
ba}HpڱbQ
ba}HpڱbQt
ba}Hpݱb
ba}Hpޱbq|H
ba}Jpűb
ba}Jpͱb
ba}Jpбb
ba}Jpѱb
ba}Jpұb
ba}Jp۱b
ba}Mp
ba~(o
ba~Ho
ba~Ho%n
ba~Ho0bq~HoH
ba~Ho5
ba~Ho=N
ba~Ho=T
ba~Ho=|\r
ba~HoI
ba~Ho\r
ba~Hoa
ba~Hoi
ba~Hoq
ba~\bo5
bb!|H
bb!|IY
bb!}Hp
bb!}Hpٱb
bb1}Hp
bb1}HpױbQt@Y
bb23_max_and_addr3.w : a; \n                                stack_push(lds_stack, &lds_sptr, lds_stack_bottom, stack, &sptr, topush); \n                            } \n                        } \n \n                        addr = a; \n                        continue; \n                    } \n                } \n                else \n                { \n#ifdef RR_RAY_MASK \n                    if (ray_get_mask(&my_ray) != convert_int(GetMeshId(node))) \n                    { \n#endif // RR_RAY_MASK \n                        float t = fast_intersect_triangle( \n                            my_ray, \n                            as_float3(node.aabb01_min_or_v0_and_addr0.xyz), \n                            as_float3(node.aabb01_max_or_v1_and_addr1_or_mesh_id.xyz), \n                            as_float3(node.aabb23_min_or_v2_and_addr2_or_prim_id.xyz), \n                            closest_t); \n \n                        if (t < closest_t) \n                        { \n                            hits[index] = HIT_MARKER; \n                            return; \n                        } \n#ifdef RR_RAY_MASK \n                } \n#endif // RR_RAY_MASK \n                } \n \n                addr = lds_stack[--lds_sptr]; \n \n                if (addr == INVALID_ADDR && sptr > stack_bottom) \n                { \n                    sptr -= LDS_STACK_SIZE; \n                    for (int i = 1; i < LDS_STACK_SIZE; ++i) \n                    { \n                        lds_stack[lds_stack_bottom + i] = stack[sptr + i]; \n                    } \n \n                    lds_sptr = lds_stack_bottom + LDS_STACK_SIZE - 1; \n                    addr = lds_stack[lds_sptr]; \n                } \n            } \n \n            // Finished traversal, but no intersection found \n            hits[index] = MISS_MARKER; \n        } \n    } \n} \n
bb5Hw
bb5Hwh
bbA|H
bbQ|H
bbQ}Hp
bb\r@w
bb\v<D[c
bbaf\bX
bbal@Y
bba}Hpұb
bbq}HpɱbA$@Y
bbq}Hp۱bQ\fHY
bbuH6
bb}HX
bb}HX%,J3
bb}HX%MR3
bb}HX\rU\e6
bb}HZ
bb}HZ5
bb}HZ5\r
bbպ'\as
bcu@%ږbQd
bd3, 6d
bd3,0Ad
bd5,p
bd6,0Ld
bd6,0Sd
bd6,0Zd
bd6,0ad
bd7,0T
bd7,@H
bd7,P
bd7,`0
bd7,p
bd;vK3
be9Pl
belgian
benchmark
bezier1i
bf-;ytZ;\a
bf;E\a
bg*;s31
bh;nݰ8\a
bh<<WDD
bh<V@z
bhP:sQ
bhk;D
bj=UWi
bjn;\ez
bjӹaE
bjԽXG
bk;S8N
bk]<0
bl؉\bcȊ\bZ
bmd;Z
bmt<\e
bmȺLE
bn~<xk
bnؕ\beȖ\b
bnر\beȲ\b
bo:JZ
bo=}qL
bp*<SZ
bpY>GTr
bp\a;u
bq, Y\r
bq.OpŀW
bq<@Y
bq\\HY
bq\\HYt
bqd@Y
bqlHY
bq}Hp
bq}Hp$ʱH
bq}Hp$ʱbQ
bq}Hp$رbQ4@Y
bq}Hp,αbA
bq}Hp,رbA
bq}Hp1bA
bq}Hp4±b
bq}Hp<ڱb
bq}Hp\f
bq}Hp\fȱbQ$@Y
bq}Hp\fӱbrEH
bq}Hp±b
bq}Hpñbr}H
bq}Hpűb
bq}HpɱbA$@Y
bq}Hpαb
bq}HpαbQ}Hp
bq}Hpϱb
bq}HpбbQ4@Y
bq}Hpѱb
bq}HpѱbQ,HYU
bq}HpұbQ
bq}HpӱbQ,HYU
bq}HpӱbQD@Y
bq}HpձbQ
bq}HpձbQ,HYU
bq}HpֱbQT@Y
bq}HpױbQ,HYU
bq}HpױbQt@Y
bq}Hpޱb
bq}HpޱbA}Hp
bq}Hp߱bQ
bq}Hp߱bqTHX
bq~Ho
br<=q
brE@@\r
brR;$j
br\t:H
britain
broken pipe
br}HX
br}HX-8,6
br}HX5
br}HX5\ve3
br}HX5_m3
br}HX\r
br}HwX
br؈\biȉ\b
br؊\biȋ\b
br؎\biȏ\b
brؐ\biȑ\b
brؖ\biȗ\b
brج\biȭ\b
brذ\biȱ\b
bs-BA-Latn
bs-P%\r
bs-P%\r:n3
bs-ba-latn
bsN:7
bs]L#ԈbS
bs|;m\ar
bsܙ_>jj
bt:ۼF
bt\aA\v
bt\f;cfQ
bu6t<f
buSt[A
bu\nA
bu_tef
buffer error
buffer is already mapped
buffer is not mapped
build threads
builder
builder_mb
building BVH
buildslave\\phonon_deps_win64\\build\\mysofa\\src\\hrtf\\resample.c
buӻ=h\f
bv:C/A
bvh.builder
bvh.force2level
bvh.forceflat
bvh.sah.extra_node_budget
bvh.sah.max_split_depth
bvh.sah.min_overlap
bvh.sah.num_bins
bvh.sah.traversal_cost
bvh.sah.use_splits
bvh.type
bvh.usesplits
bvh4.bezier1i
bvh4.bezier1imb
bvh4.bezier1v
bvh4.grid.eager
bvh4.line4i
bvh4.line4imb
bvh4.object
bvh4.quad4i
bvh4.quad4imb
bvh4.quad4v
bvh4.subdivpatch1
bvh4.subdivpatch1cached
bvh4.subdivpatch1eager
bvh4.triangle4
bvh4.triangle4i
bvh4.triangle4imb
bvh4.triangle4v
bvh4.triangle4vmb
bvh4obb.bezier1i
bvh4obb.bezier1v
bvh8.bezier1imb
bvh8.line4i
bvh8.line4imb
bvh8.object
bvh8.quad4i
bvh8.quad4imb
bvh8.quad4v
bvh8.triangle4
bvh8.triangle4i
bvh8.triangle4imb
bvh8.triangle4v
bvh8.triangle4vmb
bvh8obb.bezier1i
bvh8obb.bezier1v
bvh_builder: branching factor too large
bvĻ\r
bw ;2
bw!;O
bw:/Q
bw;:6
bw<?ZB
bw}:Lb
bx;ąJ
by.<u
bytes
bytes/prim
bz\b:I\r
b|\vD8C
b}Z8 \t
b~3;lI
b»rZͻ\f
bġ*Yt2t
bō;U2
bŻxo%;c
bſ<Z1
bǺ6sZ
bȻT88
bɅ:ITP
bкLNM
bл9JY
bҰ=tH
bԐ9mu89
bںE8ۻM
bھ:\rJ6
bڿ;Rb
bެ;BC
b鍸h+ȸ2D
b뢋D$hI
b벺)ff;5A
c [1>H
c \v=H
c$;dq
c%;j51:l
c)\f=iw
c-;aB
c0S<I2
c1 = (s1.x <= s1.y); \n                    bool c1first = traverse_c1 && (s0.x > s1.x); \n \n                    if (traverse_c0 || traverse_c1) \n                    { \n                        uint deferred = INVALID_ADDR; \n \n                        if (c1first || !traverse_c0)  \n                        { \n                            addr = GetAddrRight(node); \n                            deferred = GetAddrLeft(node); \n                        } \n                        else \n                        { \n                            addr = GetAddrLeft(node); \n                            deferred = GetAddrRight(node); \n                        } \n \n                        if (traverse_c0 && traverse_c1) \n                        { \n                            if (lds_sptr - lds_stack_bottom >= LDS_STACK_SIZE) \n                            { \n                                for (int i = 1; i < LDS_STACK_SIZE; ++i) \n                                { \n                                    stack[sptr + i] = lds_stack[lds_stack_bottom + i]; \n                                } \n \n                                sptr += LDS_STACK_SIZE; \n                                lds_sptr = lds_stack_bottom + 1; \n                            } \n \n                            lds_stack[lds_sptr++] = deferred; \n                        } \n \n                        continue; \n                    } \n                } \n                else \n                { \n#ifdef RR_RAY_MASK \n                    if (ray_get_mask(&my_ray) != convert_int(GetMeshId(node))) \n                    { \n#endif // RR_RAY_MASK \n                        float t = fast_intersect_triangle( \n                            my_ray, \n                            node.aabb_left_min_or_v0_and_addr_left.xyz, \n                            node.aabb_left_max_or_v1_and_mesh_id.xyz, \n                            node.aabb_right_min_or_v2_and_addr_right.xyz, \n                            closest_t); \n \n                        if (t < closest_t) \n                        { \n                            closest_t = t; \n                            closest_addr = addr; \n                        } \n#ifdef RR_RAY_MASK \n                    } \n#endif // RR_RAY_MASK \n                } \n \n                addr = lds_stack[--lds_sptr]; \n \n                if (addr == INVALID_ADDR && sptr > stack_bottom) \n                { \n                    sptr -= LDS_STACK_SIZE; \n                    for (int i = 1; i < LDS_STACK_SIZE; ++i) \n                    { \n                        lds_stack[lds_stack_bottom + i] = stack[sptr + i]; \n                    } \n \n                    lds_sptr = lds_stack_bottom + LDS_STACK_SIZE - 1; \n                    addr = lds_stack[lds_sptr]; \n                } \n            } \n \n            // Check if we have found an intersection \n            if (closest_addr != INVALID_ADDR) \n            { \n                // Calculate hit position \n                const bvh_node node = nodes[closest_addr]; \n                const float3 p = my_ray.o.xyz + closest_t * my_ray.d.xyz; \n \n                // Calculate barycentric coordinates \n                const float2 uv = triangle_calculate_barycentrics( \n                    p, \n                    node.aabb_left_min_or_v0_and_addr_left.xyz, \n                    node.aabb_left_max_or_v1_and_mesh_id.xyz, \n                    node.aabb_right_min_or_v2_and_addr_right.xyz); \n \n                // Update hit information \n                hits[index].prim_id = GetPrimId(node); \n                hits[index].shape_id = GetMeshId(node); \n                hits[index].uvwt = (float4)(uv.x, uv.y, 0.0f, closest_t); \n            } \n            else \n            { \n                // Miss here \n                hits[index].prim_id = MISS_MARKER; \n                hits[index].shape_id = MISS_MARKER; \n            } \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL void occluded_main( \n    // Bvh nodes \n    GLOBAL const bvh_node *restrict nodes, \n
c39f욻Sr
c4:|Wz
c5ŽDH
c8YxT9hJA
c8]vo:1
c8z;)D
c9K#\r
c9f癹Y
c:;hz
c:LW99
c;7wR
c;9\ei
c;LL6;N
c;Stz
c;UUUUUU
c;Y[n;C
c;\br
c;b3s
c;nNl
c<CBX
c<\eX
c=Q53
c=iX<\r2
c=u)Q
c>T;4\t
c>uo¾L
c?FA@s
c@S;w\t
cA$;Y
cA$;d
cA;o|q:VC
cC<G读y
cC<j6W
cC}=Hu
cEP=>L
cF+;UH
cG95_E
cG<AE\f
cGy;\r
cIûL\e
cIͺ@09
cK;b=U
cK\a;C
cLk>M\r
cN\ewun
cP7;b"R
cR=flT
cRH;4FQ;\e\r1;d2
cRü'8
cSպD<P
cU>an~o
cUI:ݙy
cV\n;mg
cW+;Ah
cX<8yQ
cY59RQ
cY59eQ
cY=,HQ
c\\R<1b
c\bH:TSk
c\b\r;6
c\bba
c\e>Gn
c\eպL\b
c\r;j
c\rJ55K8
c\tr;\n
c\v<xd\v3he\v*t
c];T3
c^;0\vQ
c^ٻVg
ca!A8
ca>:C
cache_accesses
cache_flushes
cache_hits
cache_misses
cache_num_patches
cache_regression_test
cache_size
calculate_morton_code_main
canadian
cannot instantiate this geometry
cannot unget that many items
cartesian
cas:0
cb漰"6<w
cd4;]㖺IyF;2\t
cd>,DZ
cdecl
cdֻ+mw
ce$=B
ceS:b
ce\n;K
character
chinese
chinese-hongkong
chinese-simplified
chinese-singapore
chinese-traditional
ciM;D
ci\f;n'O:A
ck:Ug
cl-mad-enable -cl-fast-relaxed-math -cl-std=CL1.2 -I
clBuildProgram
clCompileProgram
clCreateBuffer
clCreateBuffer failed
clCreateCommandQueue
clCreateCommandQueue failed
clCreateContext
clCreateContext failed
clCreateKernel
clCreateKernelsInProgram
clCreateKernelsInProgram failed
clCreateKernelsInProgram return 0 kernels
clCreateProgramWithSource
clCreateProgramWithSource failed
clCreateSubBuffer
clEnqueueCopyBuffer
clEnqueueFillBuffer
clEnqueueMapBuffer
clEnqueueMapBuffer failed
clEnqueueNDRangeKernel
clEnqueueNDRangeKernel failed
clEnqueueReadBuffer
clEnqueueReadBuffer failed
clEnqueueUnmapMemObject
clEnqueueUnmapMemObject failed
clEnqueueWriteBuffer
clEnqueueWriteBuffer failed
clFinish
clFinish failed
clFlush
clFlush failed
clGetCommandQueueInfo
clGetDeviceIDs
clGetDeviceIDs failed
clGetDeviceInfo
clGetDeviceInfo failed
clGetEventInfo
clGetEventInfo failed
clGetKernelInfo
clGetKernelInfo failed
clGetMemObjectInfo
clGetMemObjectInfo failed
clGetPlatformIDs
clGetPlatformIDs failed
clGetPlatformInfo
clGetPlatformInfo failed
clGetProgramBuildInfo
clReleaseCommandQueue
clReleaseContext
clReleaseDevice
clReleaseEvent
clReleaseKernel
clReleaseMemObject
clReleaseProgram
clRetainCommandQueue
clRetainContext
clRetainDevice
clRetainEvent
clRetainKernel
clRetainMemObject
clRetainProgram
clSetKernelArg
clSetKernelArg failed
clWaitForEvents
clWaitForEvents failed
cl_amd_media_ops2
cl_khr_fp16
closure stack overflow
clrcall
cmѼ7-\a
co%;hxۻk
coherent
collapsing from
combineBandpassedImpulseResponse
compact
compile time enabled
connection aborted
connection already in progress
connection refused
connection reset
const n = mad(box.pmin.xyz, invdir, oxinvdir); \n    float3 const tmax = max(f, n); \n    float3 const tmin = min(f, n); \n    float const t1 = min(min3(tmax.x, tmax.y, tmax.z), t_max); \n    float const t0 = max(max3(tmin.x, tmin.y, tmin.z), 0.f); \n    return make_float2(t0, t1); \n} \n \n// Given a point in triangle plane, calculate its barycentrics \nINLINE \nfloat2 triangle_calculate_barycentrics(float3 p, float3 v1, float3 v2, float3 v3) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n    float3 const e = p - v1; \n    float const d00 = dot(e1, e1); \n    float const d01 = dot(e1, e2); \n    float const d11 = dot(e2, e2); \n    float const d20 = dot(e, e1); \n    float const d21 = dot(e, e2); \n \n    float denom = (d00 * d11 - d01 * d01); \n     \n    if (denom == 0.f) \n    { \n        return make_float2(0.f, 0.f); \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invdenom = 1.f / denom; \n#else \n    float const invdenom = native_recip(denom); \n#endif \n \n    float const b1 = (d11 * d20 - d01 * d21) * invdenom; \n    float const b2 = (d00 * d21 - d01 * d20) * invdenom; \n    return make_float2(b1, b2); \n} \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define LEAFIDX(i) ((num_prims-1) + i) \n#define NODEIDX(i) (i) \n// Shortcut for delta evaluation \n#define DELTA(i,j) delta(morton_codes,num_prims,i,j) \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \ntypedef struct \n{ \n    int parent; \n    int left; \n    int right; \n    int next; \n} HlbvhNode; \n \n/************************************************************************* \nFUNCTIONS \n**************************************************************************/ \n// The following two functions are from \n// http://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/ \n// Expands a 10-bit integer into 30 bits \n// by inserting 2 zeros after each bit. \nINLINE uint expand_bits(uint v) \n{ \n    v = (v * 0x00010001u) & 0xFF0000FFu; \n    v = (v * 0x00000101u) & 0x0F00F00Fu; \n    v = (v * 0x00000011u) & 0xC30C30C3u; \n    v = (v * 0x00000005u) & 0x49249249u; \n    return v; \n} \n \n// Calculates a 30-bit Morton code for the \n// given 3D point located within the unit cube [0,1]. \nINLINE uint calculate_morton_code(float3 p) \n{ \n    float x = min(max(p.x * 1024.0f, 0.0f), 1023.0f); \n    float y = min(max(p.y * 1024.0f, 0.0f), 1023.0f); \n    float z = min(max(p.z * 1024.0f, 0.0f), 1023.0f); \n    unsigned int xx = expand_bits((uint)x); \n    unsigned int yy = expand_bits((uint)y); \n    unsigned int zz = expand_bits((uint)z); \n    return xx * 4 + yy * 2 + zz; \n} \n \n// Make a union of two bboxes \nINLINE bbox bbox_union(bbox b1, bbox b2) \n{ \n    bbox res; \n    res.pmin = min(b1.pmin, b2.pmin); \n    res.pmax = max(b1.pmax, b2.pmax); \n    return res; \n} \n \n// Assign Morton codes to each of positions \nKERNEL void calculate_morton_code_main( \n    // Centers of primitive bounding boxes \n    GLOBAL bbox const* restrict primitive_bounds, \n    // Number of primitives \n    int num_primitive_bounds, \n    // Scene extents \n    GLOBAL bbox const* restrict scene_bound,  \n    // Morton codes \n    GLOBAL int* morton_codes \n    ) \n{ \n    int global_id = get_global_id(0); \n \n    if (global_id < num_primitive_bounds) \n    { \n        // Fetch primitive bound \n        bbox bound = primitive_bounds[global_id]; \n        // Calculate center and scene extents \n        float3 const center = (bound.pmax + bound.pmin).xyz * 0.5f; \n        float3 const scene_min = scene_bound->pmin.xyz; \n        float3 const scene_extents = scene_bound->pmax.xyz - scene_bound->pmin.xyz; \n        // Calculate morton code \n        morton_codes[global_id] = calculate_morton_code((center - scene_min) / scene_extents); \n    } \n} \n \n \n \n// Calculates longe
const traverse_c0 = (s0.x <= s0.y); \n                    bool const traverse_c1 = (s1.x <= s1.y); \n                    bool const c1first = traverse_c1 && (s0.x > s1.x); \n \n                    if (traverse_c0 || traverse_c1) \n                    { \n                        int deferred = -1; \n \n                        // Determine which one to traverse first \n                        if (c1first || !traverse_c0) \n                        { \n                            // Right one is closer or left one not travesed \n                            addr = node.child1; \n                            deferred = node.child0; \n                        } \n                        else \n                        { \n                            // Traverse left node otherwise \n                            addr = node.child0; \n                            deferred = node.child1; \n                        } \n \n                        // If we traverse both children we need to postpone the node \n                        if (traverse_c0 && traverse_c1) \n                        { \n                            // If short stack is full, we offload it into global memory \n                            if ( lm_stack - lm_stack_base >= SHORT_STACK_SIZE * WAVEFRONT_SIZE) \n                            { \n                                for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                                { \n                                    gm_stack[i] = lm_stack_base[i * WAVEFRONT_SIZE]; \n                                } \n \n                                gm_stack += SHORT_STACK_SIZE; \n                                lm_stack = lm_stack_base + WAVEFRONT_SIZE; \n                            } \n \n                            *lm_stack = deferred; \n                            lm_stack += WAVEFRONT_SIZE; \n                        } \n \n                        // Continue traversal \n                        continue; \n                    } \n                } \n \n                // Try popping from local stack \n                lm_stack -= WAVEFRONT_SIZE; \n                addr = *(lm_stack); \n \n                // If we popped INVALID_IDX then check global stack \n                if (addr == INVALID_IDX && gm_stack > gm_stack_base) \n                { \n                    // Adjust stack pointer \n                    gm_stack -= SHORT_STACK_SIZE; \n                    // Copy data from global memory to LDS \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        lm_stack_base[i * WAVEFRONT_SIZE] = gm_stack[i]; \n                    } \n                    // Point local stack pointer to the end \n                    lm_stack = lm_stack_base + (SHORT_STACK_SIZE - 1) * WAVEFRONT_SIZE; \n                    addr = lm_stack_base[WAVEFRONT_SIZE * (SHORT_STACK_SIZE - 1)]; \n                } \n            } \n \n            // Check if we have found an intersection \n            if (isect_idx != INVALID_IDX) \n            { \n                // Fetch the node & vertices \n                Face const face = faces[isect_idx]; \n                float3 const v1 = vertices[face.idx[0]]; \n                float3 const v2 = vertices[face.idx[1]]; \n                float3 const v3 = vertices[face.idx[2]]; \n                // Calculate hit position \n                float3 const p = r.o.xyz + r.d.xyz * t_max; \n                // Calculte barycentric coordinates \n                float2 const uv = triangle_calculate_barycentrics(p, v1, v2, v3); \n                // Update hit information \n                hits[global_id].shape_id = face.shape_id; \n                hits[global_id].prim_id = face.prim_id; \n                hits[global_id].uvwt = make_float4(uv.x, uv.y, 0.f, t_max); \n            } \n            else \n            { \n                // Miss here \n                hits[global_id].shape_id = MISS_MARKER; \n                hits[global_id].prim_id = MISS_MARKER; \n            } \n        } \n    } \n} \n \n \n \n
copy constructor closure
cr=>U
createContext
created scene intersector
cross device link
crt_strtox::floating_point_value::as_double
crt_strtox::floating_point_value::as_float
cu:'r\e=BL3
curves
cuռ]m\r
cvC=Z
cx!:A
cy:1V\b
c~<H5Z
c~ǻkY
cŘ"rY
cƽ\bS
cѕ:Ix
cՄ;1s
cպF2R
d / %m / %y
d"9d l
d#\a\b4*\apv
d$ UAVAWH
d$ bq|H
d$ fA
d$0A_A^A]A
d$0H;Ep
d$0Hc
d$0M;g\b
d$0]A^A]A
d$0fA
d$0tQ
d$0tQD
d$4D8l$1u
d$8A_A^A]A
d$8Ii
d$8L;g\br
d$8]A
d$;j7\b
d$@D9fD
d$@D;fD
d$@Hc
d$@Lc]l
d$@fD
d$@tL
d$@tQ
d$@tR
d$@tS
d$@u\vA
d$@uy
d$DH+H@I
d$PI9rPtWE
d$PLcSl
d$PfD
d$Pff
d$Pfff
d$PtG
d$PtJ
d$PtN
d$PtPD
d$PtQ
d$PtS
d$Pň]Gp
d$PŐ]Cp
d$XA8_\t
d$`3\bD$F
d$`L9~P
d$`L9~Pta
d$`M9bXtG
d$`ff
d$`tG
d$`tJ
d$`tK
d$`tN
d$`tR
d$`tS
d$dD;d$ltY
d$pH;E0
d$pL9vPtY
d$pL9~Pta
d$pM9bXtD
d$pfff
d$ptG
d$ptJ
d$ptPD
d$ptQ
d$ptQD
d$ptS
d$x]A
d';aV@9
d'ûdE
d+<0B
d+\a\b40\a
d,ܺLMb
d3;H*k
d3K;:[B
d4\a\b45\a
d5e<^L
d5ƺsD
d6:yi\a
d79Y\r-8
d84<5k
d8s;i
d9 fE
d93PM
d9<kQ
d9r<A
d:75S
d:Cva;z
d:Ei\b
d:b<K
d:b\a
d:hPG
d:o1g<W
d:pǭ;Sr
d; fE
d;)惼w3f
d;*Zi
d;@AQ
d;_}T9eq2;yX
d;b3ԺS
d;qs5
d;wsj
d<(1T
d<9W\a
d<\bO
d<a<v
d<w|h
d=*X6
d>U"D=z
d? fE
d?000000
d@Y]\bb
d@Y]\bbBe
d@Y]\fb
d@Y]\fb1DHY
d@Y]\nbBe
dC>@5X
dCºEp
dD:Ckl
dE;iyn
dFb:\n
dG\e:q
dGk<US
dHY4\ab
dHYU\ab
dIɻDv
dK;qSH
dL=ܭ7=L
dMڼʥ4
dN:{2N
dP;4e
dP?=MQ
dQH;fdo
dRD;X
dS;Jo3
dS;\v
dS\r<nT
dT fC
dT-'Y3
dTq<*A
dUK:6
dW%A:3
dW-<43
dW=N(6
dW=x43
dW=x@3
dX4"H
dX\f"H
dX\f<Uy
dY%)cK
dY&:k
dYv ŔY
d\aPġRYl\aTĢi
d\a\abQ|H
d\b fE
d\b$;ol
d\b;UḺ4
d\b\f;Oi
d\bʸY0
d\fn:r
d\n9<[yP
d\nO;SO
d\n\abA|H
d\n\fba|H
d\nջM
d\v3=D
d\v;W1*9
d\v\abA|H
d^\n<lQ
d_O;.Cz;Z
data error
data must be 4 bytes aligned
data$r
data$rs
db:;9P;H
dbf:CK\t
db};c$v
dc\a;\vn\f
dc_\bA
dd+;P
dddd, MMMM dd, yyyy
de5:e
de<2f
debug
default
default constructor closure
defaultBlockSize
delete
depth
depth limit reached
deque<T> too long
destination address required
device or resource busy
df;qye
dg27\f%8
dhr;w
di.<GZ
didat$2
didat$3
didat$4
didat$5
didat$6
didat$7
directory not empty
disabled
disabled\n
distribute_part_sum_int4
div-MV
div-mv
dj\a\b4p\a
dk:l]k
dk;qǇ9
dkU<U
dl\a\b4r\a
dm9\e
dm{>b\bw?q
dm|9xu
do;P-X
do\a\b4t\a
do\a\b4t\ap
dot(e1, e1); \n    float const d01 = dot(e1, e2); \n    float const d11 = dot(e2, e2); \n    float const d20 = dot(e, e1); \n    float const d21 = dot(e, e2); \n \n    float denom = (d00 * d11 - d01 * d01); \n     \n    if (denom == 0.f) \n    { \n        return make_float2(0.f, 0.f); \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invdenom = 1.f / denom; \n#else \n    float const invdenom = native_recip(denom); \n#endif \n \n    float const b1 = (d11 * d20 - d01 * d21) * invdenom; \n    float const b2 = (d00 * d21 - d01 * d20) * invdenom; \n    return make_float2(b1, b2); \n} \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n \n#define INVALID_ADDR 0xffffffffu \n#define INTERNAL_NODE(node) (GetAddrLeft(node) != INVALID_ADDR) \n \n#define GROUP_SIZE 64 \n#define STACK_SIZE 32 \n#define LDS_STACK_SIZE 16 \n \n// BVH node \ntypedef struct \n{ \n    float4 aabb_left_min_or_v0_and_addr_left; \n    float4 aabb_left_max_or_v1_and_mesh_id; \n    float4 aabb_right_min_or_v2_and_addr_right; \n    float4 aabb_right_max_and_prim_id; \n \n} bvh_node; \n \n#define GetAddrLeft(node)   as_uint((node).aabb_left_min_or_v0_and_addr_left.w) \n#define GetAddrRight(node)  as_uint((node).aabb_right_min_or_v2_and_addr_right.w) \n#define GetMeshId(node)     as_uint((node).aabb_left_max_or_v1_and_mesh_id.w) \n#define GetPrimId(node)     as_uint((node).aabb_right_max_and_prim_id.w) \n \nINLINE float2 fast_intersect_bbox2(float3 pmin, float3 pmax, float3 invdir, float3 oxinvdir, float t_max) \n{ \n    const float3 f = mad(pmax.xyz, invdir, oxinvdir); \n    const float3 n = mad(pmin.xyz, invdir, oxinvdir); \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n    const float t1 = min(min3(tmax.x, tmax.y, tmax.z), t_max); \n    const float t0 = max(max3(tmin.x, tmin.y, tmin.z), 0.f); \n    return (float2)(t0, t1); \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL void intersect_main( \n    // Bvh nodes \n    GLOBAL const bvh_node *restrict nodes, \n    // Rays \n    GLOBAL const ray *restrict rays, \n    // Number of rays in rays buffer \n    GLOBAL const int *restrict num_rays, \n    // Stack memory \n    GLOBAL uint *stack, \n    // Hit data \n    GLOBAL Intersection *hits) \n{ \n    __local uint lds_stack[GROUP_SIZE * LDS_STACK_SIZE]; \n \n    uint index = get_global_id(0); \n    uint local_index = get_local_id(0); \n \n    // Handle only working subset \n    if (index < *num_rays) \n    { \n        const ray my_ray = rays[index]; \n \n        if (ray_is_active(&my_ray)) \n        { \n            const float3 invDir = safe_invdir(my_ray); \n            const float3 oxInvDir = -my_ray.o.xyz * invDir; \n \n            // Intersection parametric distance \n            float closest_t = my_ray.o.w; \n \n            // Current node address \n            uint addr = 0; \n            // Current closest address \n            uint closest_addr = INVALID_ADDR; \n \n            uint stack_bottom = STACK_SIZE * index; \n            uint sptr = stack_bottom; \n            uint lds_stack_bottom = local_index * LDS_STACK_SIZE; \n            uint lds_sptr = lds_stack_bottom; \n \n            lds_stack[lds_sptr++] = INVALID_ADDR; \n \n            while (addr != INVALID_ADDR) \n            { \n                const bvh_node node = nodes[addr]; \n \n                if (INTERNAL_NODE(node)) \n                { \n                    float2 s0 = fast_intersect_bbox2( \n                        node.aabb_left_min_or_v0_and_addr_left.xyz, \n                        node.aabb_left_max_or_v1_and_mesh_id.xyz, \n                        invDir, oxInvDir, closest_t); \n                    float2 s1 = fast_intersect_bbox2( \n                        node.aabb_right_min_or_v2_and_addr_right.xyz, \n                        node.aabb_right_max_and_prim_id.xyz, \n                        invDir, oxInvDir, closest_t); \n \n                    bool traverse_c0 = (s0.x <= s0.y); \n                    bool traverse
dummy_rtcore_ispc___avx
dummy_rtcore_ispc___avx2
dummy_rtcore_ispc___sse2
dummy_rtcore_ispc___sse4
dut;tE
dutch-belgian
dv);P7
dv\n#4u\n
dynamic
dynamic atexit destructor for
dynamic initializer for
dŮ=AI
dż;4i
dƼCQۼ89
dǘ:44
dʯ;Dz
d̺\vOM
dλQf'<u
dս\nw1=jj\t
dغ\vL
dܺQ#f
d䨹j6D
d濻Euz
e =pKH
e =Ӳf
e ŘXD$p
e ŬT-KD3
e ŬT-k
e ๏4\f
e!<fp
e"2<Z
e"?Dg
e$; \tB;1
e%89z
e%I<\n3
e%c<S1
e&<Nf
e&=4o\t
e'9\t5G;Y
e';YKY
e';gu
e'<lH
e)X;r
e)e>u
e*;=uo9\n
e*<0b\r
e*k:n
e+:EQ
e+W:F
e,I=waK
e-ǻcZ
e.5;+oB
e/;\vca
e/g<b
e/¼fr
e/ʺHo
e0<dV
e0A_A
e0A_A^A]A
e0ban\bY1ŊXA
e1>:L
e1A26b
e1G;J{f
e1^;8K\t
e1y;6
e1Ӻoq
e3:gN
e3;Tu
e4,;Tf
e4;Lv
e4="Q
e5;cw3
e5<7 &;z
e5S;T>g:0
e69\r:l
e6:&x
e6;G~G
e7#<X
e7.? bz
e7;B\te
e7;CE
e7<!\v0
e7t;@n3
e8A_A^A]A
e8G;]5
e99<9I
e9;N^J
e9^ä9
e: 涻G
e:Rfx
e:Z/8
e:\n l
e:rM\a9
e:uW{9
e:vCw
e:ΊzWd
e;( O
e;(UI
e;0an
e;YM]9J
e;YY\e
e;\aI
e;`Q5
e;d&i
e;fzp
e;g%H
e;g+C:9
e;oAV
e;ykv
e;ԃV=1Z
e;ޖd;W9
e< t ;C
e<!96
e<[P09o
e<\bl
e<`nH
e<eT\n<HY
e<hq\r
e<k8k
e=-Ke
e=Q0F
e=Q蒽I
e=rAe>U:f
e>+8j
e>K7\a
e>q<0H
e>uik
e>uu=Rp
e? =\rUֽb
e?5t,?d
e@A_A^A
eA1:HYS
eB@=HRS>vR
eBZ>̣m
eBٺ>Aj
eC2<Z
eC<$o
eCNאBO:#Cl
eCŻDX
eD?}\eD
eDigiCert Assured ID Root CA0
eEr;db
eF=9Aټp\f9>s
eFڻXvU
eG<!0
eG\v<}R
eGʻ2l
eH;_@tIH
eHH:)Z
eH\t=ME
eI ;1
eI<UGW
eI};giW
eIٺb8z
eJ.85
eJ5;WN\b;y5C
eJ\r"qP
eJ\r%B1
eJ\r1
eJ\r1\e
eJ\r3&Q
eJ\r6RQ
eJ\r7
eJ\r:>E
eJ\r<.M
eJ\r<ZJ
eJ\r?b
eJ\rESO
eJ\rQh
eJ\rT
eJ\rVi
eJ\r[#R
eJ\r\a\b
eJ\r\eF
eJ\r\t\\P
eJ\r`2Q
eJ\raAQ
eJ\rc"I
eJ\re8y
eJ\rgJ
eJ\rk\\1
eJ\rlM
eJ\rwyz
eJ\rz0
eJ\r|p1
eL;6E
eL;swg
eL<<g8G
eN9=3W
eO9ۻ\r
eO;JP\a
eO<dH
eOP9f
eP%;0
eP8RG:\t
ePw:1
ePŘXE
eQ(>1
eQ*=O
eQD;Q"*;tnt
eQۼ\fT
eR7<g
eRS:T
eS;{HA
eU<Dh
eVW=z
eV˻j6
eW=88z
eX;!7I
eXd;fs
eXܻ"U
eY=&PQ
eY=&cQ
eY=ht1=M\f
eYO9m
eY̼Xh
eZn:0
e[;4OV
e\a>8Na
e\abA|H
e\aͻ\bt
e\b+;NG
e\bX=Tĭ>6
e\bb;x
e\e;脫98tt
e\ebA,(X
e\f:k~z
e\nb1d@T
e\r;eL
e\r>7
e\rbA|H
e\t;Q
e\tz:s
e\v5=%䥾VMx
e\vbA|H
e\vn?c
e^;iRe
e`:G\fb
e`ŘXEp
easy->fir
eaܺͥ6
eb!|H
eb1t Y
ebA}Hpɱb
eba|H
ec;Wa
ec<\r
ed:"e
ed;\fO
ed;\t
ed<9i2
ed_mem,\\ \n                                          __global type* out,\\ \n                                          int /* in elements */ out_offset)\\ \n{\\ \n    int global_id = get_global_id(0);\\ \n    int group_id = get_group_id(0);\\ \n    int local_id = get_local_id(0);\\ \n    int group_size = get_local_size(0);\\ \n    if (global_id < count)\\ \n        shared_mem[local_id] = buffer[global_id];\\ \n    else\\ \n        shared_mem[local_id] = neutral_##bin_op##_##type;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int i = group_size / 2; i > 0; i >>= 1)\\ \n    {\\ \n        if (local_id < i)\\ \n            shared_mem[local_id] = bin_op(shared_mem[local_id], shared_mem[local_id + i]);\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (local_id == 0)\\ \n        atomic_##bin_op##_##type(out + out_offset, shared_mem[0]);\\ \n} \n \n// --------------------- NORMALIZATION ------------------------ \n \n#define DEFINE_BUFFER_NORMALIZATION(type)\\ \n__kernel void buffer_normalization_##type(const __global type* input,\\ \n                                          __global type* output,\\ \n                                          int count,\\ \n                                          const __global type* storage)\\ \n{\\ \n    type norm_coef = storage[0] - storage[1];\\ \n    int global_id = get_global_id(0);\\ \n    if (global_id < count)\\ \n        output[global_id] = (input[global_id] - storage[1]) / norm_coef;\\ \n} \n \n// Do not change the order \nDEFINE_ATOMIC(min) \nDEFINE_ATOMIC(max) \nDEFINE_ATOMIC_FLOAT3(min) \nDEFINE_ATOMIC_FLOAT3(max) \n \nDEFINE_REDUCTION(min, int) \nDEFINE_REDUCTION(min, float) \nDEFINE_REDUCTION(min, float3) \nDEFINE_REDUCTION(max, int) \nDEFINE_REDUCTION(max, float) \nDEFINE_REDUCTION(max, float3) \n \nDEFINE_BUFFER_NORMALIZATION(int) \nDEFINE_BUFFER_NORMALIZATION(float) \nDEFINE_BUFFER_NORMALIZATION(float3) \n
edata
ee2:w
ee:lYF
ef$;TE
ef;|jY
efG;R
effffff
eg<@s
eh vector constructor iterator
eh vector copy constructor iterator
eh vector destructor iterator
eh vector vbase constructor iterator
eh vector vbase copy constructor iterator
eh:N]\a
eh\f::t
ehttp://www.digicert.com/CPS0
eiX9t
ej;!Lx
el\f;n
el{n0t:e
em,=l
embree2
emit_hierarchy_main
en097
enable_dc_correction_for_phase_interpolation
enable_paths_from_all_source_probes
enable_selockmemoryprivilege
enabled
enabled (forced)\n
enabled\n
england
english-american
english-aus
english-belize
english-can
english-caribbean
english-ire
english-jamaica
english-nz
english-south africa
english-trinidad y tobago
english-uk
english-us
english-usa
enn:u
eo/<c
eoI;ef
ep:i9B;4
ep;VX
ep;ak
epNcD
eph<'c
er*:r
er\a<s
erd:*7W
erp:0
er~;1
es1;<7
estimatedSize
es{9Zu
et:5J\t9
et<3lA=M
euCȭU
euJ:52
evC=Eu
evϼg%a
ew:ki6
ew;:x
ewM;3
ewh/?y
ex;<d
executable format error
execute_local@TaskQueue@TaskScheduler@embree@@QEAA_NAEAUThread@23@PEAUTask@23@@Z
ext-ms-win-kernel32-package-current-l1-1-0
ext-ms-win-ntuser-dialogbox-l1-1-0
ext-ms-win-ntuser-windowstation-l1-1-0
exȺ3 c
ey:HBp
ez<8w
e|ѽ\fEH
e}4=Z
e}<LN3
e~8;o
e»vhq
e¼\vOǼJk
e¼t麼O
eǑ<qg
eɼ8%Y\r
eʻ"A0
e̽NOj>x
eҔ;b7d
eҢ9nuo
eӖ:s80
eԻqvϺTj
eؼCO\r=|a
eٻ#ur;9
eߨ;KS
e쫼F_G
f %d %d %d\n
f :F'\n
f u:gw
f"<dZ
f#b"eH
f$\e>zI
f$bA~\b
f%d\e\f%4
f&ba}Hp<ѱK
f':6J
f';KjX
f(-8y
f(k:0dR
f(ȹvǮ9B
f)\n;tq
f)\r<Gi
f*d\e\f*4
f+:qdA
f+bQ|H
f,6:N
f/8o J;;b
f0-<K
f0:;l
f0U808
f0\vP
f0\vP!o
f0b!L@X
f0u'H
f1.=y\e
f1L<ͅǻM
f2:!I4
f2\bp\a
f2\bp\aP
f2\n9I
f2b1|H
f2bA|H
f3bBm
f4Ic\f
f65;܂G
f6b:s
f8>1x:N
f8?ls7
f8ba\\H
f8ݗV:\fl
f9(t\eL
f9(t\fH
f9)u H
f9)uTH
f9*u\tH
f9,P9
f9.9r
f9/t\tH
f94748
f9GGd9
f9\\$bu\nJ
f9\a=s:bcB
f9\bt\rH
f9\bt\tH
f9\bu3HcH<H
f9b!lH
f9b1|H
f9i@w
f9w=`p
f9wZ~9
f9£i8
f:"Yv:d
f:'SK
f::OS
f:Sw$9
f:WV*;Td
f:YXn9
f:\fe
f:fQ\f
f:iby
f:itd:\t
f:ki{9
f:p\t
f:q;Q
f;)ax;K
f;*Ns
f;.tS
f;0H1
f;2Y}>k
f;8\rH9W
f;<wL
f;>YE
f;H9n
f;O^0
f;S;y
f;X\rM
f;X`e
f;Yt˹3
f;\bd
f;\n@a<RI
f;\nDf;VH
f;\tq1<[4I
f;\vuS
f;bA|H
f;k\nF:j
f;r4U
f;t'4<u
f;v\a
f;x)6
f;{\vq; E
f;~gF
f;Ä\b9 \rA
f<IR\t
f<Ol4
f<[6I
f<\fr6
f<\vzμs
f<]V̹AHP
f<f'f<I
f<mT\nE
f<s42
f=B^l=;or
f=G(H
f=HQ\v
f=dS\v>\n
f=j63
f>0Wy
f>>FN
f>Jd\b
f>\bAV>\f
f>\ncL
f?0UE
f?@9ke
f?R(1
f?T;p
f?br}H
f@A:2
f@HcC(H
f@Ye\nH
f@Ye\nb14HY
f@br}H
fA9,Au
fA9,Qu
fA91t A
fA9<\\u
fA;(t(fA98t
fA;8unI
fA;\at\rI
fB9,$O
fB9,Nu
fB94Ou
fB9<@u
fB9<Bu
fB9<Hu
fB:)Tf
fC\a>8B
fC\r8\e
fD9 tMH
fD9 t\a
fD9 t\nH
fD9 t\vH
fD9 u\fH
fD9$Hu
fD9(u\fA
fD9+t
fD9,Au
fD9,Cu
fD9,Ku
fD9,Pu
fD91u\r
fD94Fu
fD9;u\a3
fD9<Au
fD9<Cu
fD9<Hu
fD9<Xu
fD9?t
fD9\bt\rH
fD9\fwu
fD9\nt\tH
fD9\tt(I
fD9t$b
fDigiCert Inc1
fE2;B
fE9,Du
fE9,tu
fE98t
fE9<Au
fE:k\f
fES:헏:D
fE\n;T Z
fE\v\bfA
fEo;N
fF"=\rX5
fF9<qu
fF<Muq
fFs;\e\em
fG9$Ou
fG9,wu
fG;PB
fH:!H
fHX\v5c
fHY4\ebA\fHY\\\e
fH}aB
fI;n1
fI;tJ\b
fJ;I@a
fJԻyrg
fM7<Io
fNֺl/b:\v
fO*>V
fO;Qm
fP:zV
fP;?C";UI
fPҺ/X
fQѻ;q
fR <4c\f
fRI+APH
fR\bp\a
fR\bp\aP
fRռhg
fRؽ$C\t
fS>p%C
fSԻvyc
fT=O&n=V
fT\r<Zf2
fU\t=c
fV2:i
fV:Rǭ9
fV<\nL
fV=۠Q
fVE`A\v
fVM@A\v
fW%9H3
fW;-I
fW=+H3
fW=Y:3
fW=r43
fW=r@3
fW=s:3
fW\r%H3
fWo:Js
fX!t5
fXڻOa
fY)9I
fY59pK
fY5AmK
fY5wmK
fY;7a
fYٻw\e
fZ;6=u
fZK;r
fZy=kJA
f[#9a'g
f[D;\nD
f\a96
f\a<Vhn
f\b!9D
f\b!<8M
f\b9xg\b0hh\b'4
f\b;"ep
f\bL:T\tn
f\b\\Q\nb
f\eba~Ho
f\f:|Zk
f\fv:m
f\n=@Z9
f\n>J0
f\nW;`wv
f\n\n;k
f\nba|H
f\nr8J
f\r:D
f\r<\eV
f\r=j}5
f\tn:l
f\v<\tL
f\vT<ӸG
f\vb!|H
f\vba|H
f]<o\af
f]P>uep
f]R=r/X
f]\t:In
f`3;JF
f`;N#O9aU
failed
fast_allocator_regression_test
fastcall
fatbvh
fb;<Cu
fbQ|H
fb\b0\aP
fba$@X
fba|H
fd;ۖ4
fdY:\f圻68
fdbBm
fe;+GF
feJ<F
feN>(s[>v
fffff
ffffff
ffffffJ
fffffff
fg>5Xu
fgƺAyy
fgϻ^9
fic9aaP
file error
file exists
file too large
filename too long
filled
filter functions not supported for this geometry
finished BVH
fiԼ<k\t
fj:mgA
fj;`L
fkU:^o
fkg;m
fl;9c
float expected
float radius)\n{\n    float3 origin = ray->o.xyz;\n    float3 direction = ray->d.xyz;\n\n    float3 v = origin - center;\n    float r = radius;\n\n    float B = 2.0f * dot(v, direction);\n    float C = dot(v, v) - (r * r);\n    float D = (B * B) - (4.0f * C);\n\n    if (D < 0.0f)\n        return FLT_MAX;\n\n    float t = -0.5f * (B + sqrt(D));\n    return t;\n}\n\nkernel void sphereOcclusion(uint numSources,\n                            global const CoordinateSpace* sources,\n                            uint numListeners,\n                            global const CoordinateSpace* listeners,\n                            global Ray* rays,\n                            global Hit* hits)\n{\n    uint numRays = get_global_size(0);\n    uint rayIndex = get_global_id(0);\n\n    for (int i = 0; i < numListeners; ++i)\n    {\n        uint index = i * numRays + rayIndex;\n\n        float listenerSphereHitDistance = raySphereIntersect(&rays[index], listeners[i].origin, LISTENER_RADIUS);\n        if (0.0f <= listenerSphereHitDistance && listenerSphereHitDistance < hits[index].uvwt.s3)\n        {\n            rays[index].extra.y = 0;\n            hits[index].primid = -1;\n            return;\n        }\n\n        for (int j = 0; j < numSources; ++j)\n        {\n            float sourceSphereHitDistance = raySphereIntersect(&rays[index], sources[j].origin, SOURCE_RADIUS);\n            if (0.0f <= sourceSphereHitDistance && sourceSphereHitDistance < hits[index].uvwt.s3)\n            {\n                rays[index].extra.y = 0;\n                hits[index].primid = -1;\n                return;\n            }\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Shading + Shadow/Bounced Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat3 calculateHitPoint(Ray ray, \n                         Hit hit)\n{\n    return ray.o.xyz + hit.uvwt.s3 * ray.d.xyz;\n}\n\nfloat3 calculateHitNormal(Ray ray, \n                          Hit hit, \n                          global float4* normals)\n{\n    float3 hitNormal = normals[hit.primid].xyz;\n    if (dot(hitNormal, ray.d.xyz) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    return hitNormal;\n}\n\nfloat pointSourceIrradiance(float distance,\n                            float minDistance)\n{\n    float attenuation = 1.0f / max(distance, minDistance);\n    float irradiance = (1.0f / (4.0f * PI)) * (attenuation * attenuation);\n    return irradiance;\n}\n\nfloat3 reflect(float3 incident, \n               float3 normal)\n{\n    return normalize(incident - (2.0f * dot(incident, normal) * normal));\n}\n\nkernel void shadeAndBounce(uint numSources,\n                           global const CoordinateSpace* sources,\n                           uint numListeners,\n                           global const CoordinateSpace* listeners,\n                           global const Directivity* directivities,\n                           uint numRays,\n                           uint numBounces,\n                           float irradianceMinDistance,\n                           global const Ray* rays,\n                           global const Hit* hits,\n                           global const float3* normals,\n                           global const int* materialIndices,\n                           global const Material* materials,\n                           uint numDiffuseSamples,\n                           global const float4* diffuseSamples,\n                           uint randomNumber,\n                           float scalar,\n                           global Ray* shadowRays,\n                           global Ray* reflectedRays,\n                           global float4* energyDelay,\n                           global float4* accumEnergyDelay)\n{\n    size_t numChunks = max(numListeners, numSources);\n    size_t numPrimaryRays = get_global_size(0) / numChunks;\n    size_t numShadowRays = get
float2 s = fast_intersect_bbox1(node, invdir, oxinvdir, t_max); \n \n                if (s.x <= s.y) \n                { \n                    // Check if the node is a leaf \n                    if (LEAFNODE(node)) \n                    { \n                        int const face_idx = STARTIDX(node); \n                        Face const face = faces[face_idx]; \n#ifdef RR_RAY_MASK \n                        if (ray_get_mask(&r) != face.shape_id) \n                        { \n#endif // RR_RAY_MASK \n                            float3 const v1 = vertices[face.idx[0]]; \n                            float3 const v2 = vertices[face.idx[1]]; \n                            float3 const v3 = vertices[face.idx[2]]; \n \n                            // Intersect triangle \n                            float const f = fast_intersect_triangle(r, v1, v2, v3, t_max); \n                            // If hit store the result and bail out \n                            if (f < t_max) \n                            { \n                                hits[global_id] = HIT_MARKER; \n                                return; \n                            } \n#ifdef RR_RAY_MASK \n                        } \n#endif // RR_RAY_MASK \n                    } \n                    else \n                    { \n                        // Move to next node otherwise. \n                        // Left child is always at addr + 1 \n                        ++addr; \n                        continue; \n                    } \n                } \n \n                addr = NEXT(node); \n            } \n \n            // Finished traversal, but no intersection found \n            hits[global_id] = MISS_MARKER; \n        } \n    } \n} \n
float3 const e = p - v1; \n    float const d00 = dot(e1, e1); \n    float const d01 = dot(e1, e2); \n    float const d11 = dot(e2, e2); \n    float const d20 = dot(e, e1); \n    float const d21 = dot(e, e2); \n \n    float denom = (d00 * d11 - d01 * d01); \n     \n    if (denom == 0.f) \n    { \n        return make_float2(0.f, 0.f); \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invdenom = 1.f / denom; \n#else \n    float const invdenom = native_recip(denom); \n#endif \n \n    float const b1 = (d11 * d20 - d01 * d21) * invdenom; \n    float const b2 = (d00 * d21 - d01 * d20) * invdenom; \n    return make_float2(b1, b2); \n} \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n \n#define INVALID_ADDR 0xffffffffu \n#define INTERNAL_NODE(node) ((node).aabb01_min_or_v0_and_addr0.w != INVALID_ADDR) \n \n#define GROUP_SIZE 64 \n#define STACK_SIZE 32 \n#define LDS_STACK_SIZE 16 \n \n// BVH node \ntypedef struct \n{ \n    uint4 aabb01_min_or_v0_and_addr0; \n    uint4 aabb01_max_or_v1_and_addr1_or_mesh_id; \n    uint4 aabb23_min_or_v2_and_addr2_or_prim_id; \n    uint4 aabb23_max_and_addr3; \n \n} bvh_node; \n \n#define mymin3(a, b, c) min(min((a), (b)), (c)) \n#define mymax3(a, b, c) max(max((a), (b)), (c)) \n \nINLINE half2 unpackFloat2x16(uint v) \n{ \n    return (half2) \n        (as_half(convert_ushort(v & 0xffffu)), \n         as_half(convert_ushort(v >> 16))); \n} \n \nINLINE half4 fast_intersect_bbox2(uint3 pmin, uint3 pmax, half3 invdir, half3 oxinvdir, float t_max) \n{ \n    half2 pmin_x = unpackFloat2x16(pmin.x); \n    half2 pmin_y = unpackFloat2x16(pmin.y); \n    half2 pmin_z = unpackFloat2x16(pmin.z); \n    half2 pmax_x = unpackFloat2x16(pmax.x); \n    half2 pmax_y = unpackFloat2x16(pmax.y); \n    half2 pmax_z = unpackFloat2x16(pmax.z); \n \n    half2 f_x = fma(pmax_x, invdir.xx, oxinvdir.xx); \n    half2 f_y = fma(pmax_y, invdir.yy, oxinvdir.yy); \n    half2 f_z = fma(pmax_z, invdir.zz, oxinvdir.zz); \n \n    half2 n_x = fma(pmin_x, invdir.xx, oxinvdir.xx); \n    half2 n_y = fma(pmin_y, invdir.yy, oxinvdir.yy); \n    half2 n_z = fma(pmin_z, invdir.zz, oxinvdir.zz); \n \n    half2 t_max_x = max(f_x, n_x); \n    half2 t_max_y = max(f_y, n_y); \n    half2 t_max_z = max(f_z, n_z); \n \n    half2 t_min_x = min(f_x, n_x); \n    half2 t_min_y = min(f_y, n_y); \n    half2 t_min_z = min(f_z, n_z); \n \n    half2 t_zero = (half2)(0.0f, 0.0f); \n    half2 t_max2 = (half2)(t_max, t_max); \n    half2 t1 = min(mymin3(t_max_x, t_max_y, t_max_z), t_max2); \n    half2 t0 = max(mymax3(t_min_x, t_min_y, t_min_z), t_zero); \n \n    return (half4)(t0, t1); \n} \n \nINLINE float3 safe_invdir2(ray r) \n{ \n    float const dirx = r.d.x; \n    float const diry = r.d.y; \n    float const dirz = r.d.z; \n    float const ooeps = 1e-5; \n    float3 invdir; \n    invdir.x = 1.0f / (fabs(dirx) > ooeps ? dirx : copysign(ooeps, dirx)); \n    invdir.y = 1.0f / (fabs(diry) > ooeps ? diry : copysign(ooeps, diry)); \n    invdir.z = 1.0f / (fabs(dirz) > ooeps ? dirz : copysign(ooeps, dirz)); \n    return invdir; \n} \n \nINLINE void stack_push( \n    __local uint *lds_stack, \n    __private uint *lds_sptr, \n    uint lds_stack_bottom, \n    __global uint *stack, \n    __private uint *sptr, \n    uint idx) \n{ \n    if (*lds_sptr - lds_stack_bottom >= LDS_STACK_SIZE) \n    { \n        for (int i = 1; i < LDS_STACK_SIZE; ++i) \n        { \n            stack[*sptr + i] = lds_stack[lds_stack_bottom + i]; \n        } \n \n        *sptr = *sptr + LDS_STACK_SIZE; \n        *lds_sptr = lds_stack_bottom + 1; \n    } \n \n    lds_stack[*lds_sptr] = idx; \n    *lds_sptr = *lds_sptr + 1; \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL void intersect_main( \n    // Bvh nodes \n    GLOBAL const bvh_node *restrict nodes, \n    // Rays \n    GLOBAL const ray *restrict rays, \n    // Number of rays in rays buffer \n    GLOBAL const int *restrict num_rays, \n    // Stack memory \n    GLOBAL uint *stack, \n    // Hit d
float_exceptions
fmR:\n
fm\v:/t
fn<zɹ;H
fo9@T
fo:GỺl
for BVH4<Bezier1i
for BVH4<Bezier1v
for BVH4<Line4i
for BVH4<Line4iMB
for BVH4<Object
for BVH4<Quad4i
for BVH4<Quad4iMB
for BVH4<Quad4v
for BVH4<Triangle4
for BVH4<Triangle4i
for BVH4<Triangle4iMB
for BVH4<Triangle4v
for BVH4<Triangle4vMB
for BVH4OBB<Bezier1i
for BVH4OBB<Bezier1iMB
for BVH4OBB<Bezier1v
for BVH8<Line4i
for BVH8<Object
for BVH8<Quad4i
for BVH8<Quad4v
for BVH8<Triangle4
for BVH8<Triangle4i
for BVH8<Triangle4iMB
for BVH8<Triangle4v
for BVH8<Triangle4vMB
for BVH8MBOBB<Bezier1iMB
for QBVH8<Quad4i
foȸ%M\v
fp09*$u:\tS
fp\v`\n0
fp\v`\nP
fp\v`\nP\t0
fpx<QFI
fq1<&JF
fq5<1
fq;6nǺg
fq<dm
fqp;E
fq༉匼Cb
fr\bp\a
fr\bp\aP
free blocks
free field
french-belgian
french-canadian
french-luxembourg
french-swiss
fs,:3e
ft==\nT
ft\v;7
fuQ:|vs
function BVH8Bezier1iBuilder_OBB_New not supported by your CPU
function BVH8Bezier1vBuilder_OBB_New not supported by your CPU
function BVH8BuilderTwoLevelQuadMeshSAH not supported by your CPU
function BVH8BuilderTwoLevelTriangleMeshSAH not supported by your CPU
function BVH8BuilderTwoLevelVirtualSAH not supported by your CPU
function BVH8Line4iMBSceneBuilderSAH not supported by your CPU
function BVH8Line4iSceneBuilderSAH not supported by your CPU
function BVH8OBBBezier1iMBBuilder_OBB not supported by your CPU
function BVH8Quad4iMBSceneBuilderSAH not supported by your CPU
function BVH8Quad4iSceneBuilderSAH not supported by your CPU
function BVH8Quad4vMeshBuilderMortonGeneral not supported by your CPU
function BVH8Quad4vMeshBuilderSAH not supported by your CPU
function BVH8Quad4vMeshRefitSAH not supported by your CPU
function BVH8Quad4vSceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Quad4vSceneBuilderSAH not supported by your CPU
function BVH8QuantizedQuad4iSceneBuilderSAH not supported by your CPU
function BVH8QuantizedTriangle4SceneBuilderSAH not supported by your CPU
function BVH8QuantizedTriangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4MeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4MeshBuilderSAH not supported by your CPU
function BVH8Triangle4MeshRefitSAH not supported by your CPU
function BVH8Triangle4SceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4SceneBuilderSAH not supported by your CPU
function BVH8Triangle4iMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4iMeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4iMeshBuilderSAH not supported by your CPU
function BVH8Triangle4iMeshRefitSAH not supported by your CPU
function BVH8Triangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vMeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4vMeshBuilderSAH not supported by your CPU
function BVH8Triangle4vMeshRefitSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderSAH not supported by your CPU
function BVH8VirtualMBSceneBuilderSAH not supported by your CPU
function BVH8VirtualMeshBuilderMortonGeneral not supported by your CPU
function BVH8VirtualMeshBuilderSAH not supported by your CPU
function BVH8VirtualMeshRefitSAH not supported by your CPU
function BVH8VirtualSceneBuilderSAH not supported by your CPU
function not supported
fv8Dd
fvϽjE
fx:_P2
fxº\fm
fxǾ;X2
fy=p:5
f}ͻB碻lC
f~ֺ\f9M
fÈbQ4
fÜ9- w
fżeqD
fǻ4sJ
fȼf\fj
fɐbq|H
fϹk,e:EG1
fӔ;tpw
fջ\tIz
fռ7`s
fغKd̺oU
fܵ;BA
g!3;Rn8
g!T9"d
g#d<'YC
g%H9V
g'L;kd
g(v;\fA
g*?VO
g*U;t
g*k;8
g+m;sOν[3
g+ѻ2PK
g,;wa 9c
g,<\bp3
g->Ra
g0;TQj
g0ܼe_c
g2=ya=A
g2{:Rn
g3>:2w
g3}>Bi
g4o>e
g4v:E
g5=b\nj
g5RҌ<țu
g6H=Co
g6N:B
g8;;\nk
g8B~0GBf
g8ɊúD
g8мFT
g8߰99g
g9@x!8
g9P0\e
g9P[T<Q
g9ھg9
g: kP;O
g:7`U
g:A\n
g:Hǩ;vHO
g:PZP
g:V6s
g:_lu
g:isr9U
g:qmU
g;2zI
g;>\n49
g;G7p
g;G;kyW
g;hD&;E
g;kuG
g;m{5
g<df\t
g<vm2
g<v«9n
g<z(L
g=+8S
g=K\r
g>>wd\r
g@2:9
gB:cc0
gC\bru&o
gC`;C
gDﻪY1
gGV=pD
gLV;I3
gM3<Xs
gO;uIg
gQ;'x
gR9>W8
gRC:h
gS;chc;rx
gS<m\vl
gT\\;QYI
gU(:;47
gUD;ZU
gX<FK
gY(<d
gY^8\a
g\\z>RD
g\b:CkK
g\e<fB
g\eL>r
g\fD:\n
g\n<K!G<G
g\t;!LM
g\tC;[P
g\v;KZa:6
g^z:h
g_j<H_w
gaP=\rH
ga\b;d
gatherEnergyField
gatherImage
gb6=Md
gbѼzQP
general
generateCameraRays
generateListenerRays
generic
geometries inside group have to be of same type
geometry groups cannot contain other geometry groups
geometry instances only support a single timestep
german-austrian
german-lichtenstein
german-luxembourg
german-swiss
getinfoaH
gfffffff
gfffffffH
gfffffffI
gfffffffL
gffffffff
gg:C\r4<t
gj\f>t
global_size(0);\n\n    uint rayIndex = (numListeners > 1) ? get_global_id(0) : (get_global_id(0) % numPrimaryRays);\n    uint chunkIndex = get_global_id(0) / numPrimaryRays;\n    uint listenerIndex = (numListeners > 1) ? chunkIndex : 0;\n    uint sourceIndex = (numSources > 1) ? chunkIndex : 0;\n    uint shadowRayIndex = get_global_id(0);\n\n    // If this ray is disabled, don't do anything.\n    if (rays[rayIndex].extra.y == 0 || hits[rayIndex].primid < 0)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        reflectedRays[rayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n        return;\n    }\n\n    // Random number generation for work group.\n    local RNG rng;\n    local float randomFloat;\n    local uint randomUint;\n    if (get_local_id(0) == 0)\n    {\n        initRNG(randomNumber + rayIndex, &rng);\n        randomFloat = randFloat(&rng);\n        randomUint = randUint(&rng);\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    // Calculate hit point.\n    float3 rayDirection = rays[rayIndex].d.xyz;\n    int triangleIndex = hits[rayIndex].primid;\n    float hitDistance = hits[rayIndex].uvwt.s3;\n    float3 hitPoint = rays[rayIndex].o.xyz + hitDistance * rayDirection;\n\n    // Calculate hit normal.\n    float3 hitNormal = normals[triangleIndex].xyz;\n    if (dot(hitNormal, rayDirection) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    // Calculate hit material.\n    Material hitMaterial = materials[materialIndices[triangleIndex]];\n    float3 hitMaterialAbsorption = (float3) (hitMaterial.absorptionLow, hitMaterial.absorptionMid, hitMaterial.absorptionHigh);\n\n    // Calculate shadow ray direction.\n    float3 source = sources[sourceIndex].origin;\n    float hitToSourceDistance = distance(hitPoint, source);\n    float4 hitToSource = (float4) (normalize(source - hitPoint), 0.0f);\n\n    // Skip the ray if:\n    //  a) the hit point is inside the listener, or\n    //  b) the hit point is too close to the source, or\n    //  c) the ray hit a backfacing triangle.\n    if (hitDistance <= LISTENER_RADIUS ||\n        hitToSourceDistance <= irradianceMinDistance ||\n        dot(hitToSource.xyz, hitNormal) < 0.0f)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n    }\n    else\n    {\n        // Generate the shadow ray.\n        shadowRays[shadowRayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * hitToSource.xyz, hitToSourceDistance);\n        shadowRays[shadowRayIndex].d = hitToSource;\n        shadowRays[shadowRayIndex].extra = (int2) (0xffffffff, 1);\n\n        // Calculate shading values.\n        float3 energy = (1.0f / PI) * hitMaterial.scattering * max(0.0f, dot(hitNormal, hitToSource.xyz));\n        energy += ((SPECULAR_EXPONENT + 2.0f) / (8.0f * PI)) * (1.0f - hitMaterial.scattering) * pow(fabs(dot(normalize(hitToSource.xyz - rayDirection), hitNormal)), SPECULAR_EXPONENT);\n        energy *= scalar;\n        energy *= evaluateDirectivity(hitPoint, sources[sourceIndex], directivities[sourceIndex]);\n        energy *= pointSourceIrradiance(hitToSourceDistance, irradianceMinDistance);\n        energy *= accumEnergyDelay[rayIndex].xyz * ((float3) 1.0f - hitMaterialAbsorption);\n\n        float delay = (hitDistance + hitToSourceDistance) / SPEED_OF_SOUND;\n        delay += accumEnergyDelay[rayIndex].w - (distance(source, listeners[listenerIndex].origin) / SPEED_OF_SOUND);\n\n        energyDelay[shadowRayIndex] = (float4) (energy, delay);\n    }\n\n    barrier(CLK_GLOBAL_MEM_FENCE);\n\n    // Generate the bounced ray.\n    if (numListeners > 1 || sourceIndex == 0)\n    {\n        accumEnergyDelay[rayIndex].xyz *= ((float3) 1.0f - hitMaterialAbsorption);\n        accumEnergyDelay[rayIndex].w += hitDistance / SPEED_OF_SOUND;\n\n        float4 reflectedDirection = (float4) 0.0f;\n        if (randomFloat < hitMaterial.scattering)\n        {\n            uint sampleIndex = randomUint % numDiffuseSamples;\n            float3 transformedDiffuseSample = transformHemisphereSample(diffuseSamples[sampleIndex].xyz, hitNo
go7H=_;K
gp;:nJ
gr9DH7S
gr:-\rY
great britain
gu;wI
gvd;>L
gyU:b
g»t\e
gŏ=KG
gŦ:DA
gʼ0;g<o
gͺˇy:2v\n
gκhv付E
gМ;zg
gһuv0
gԺUKL
gۼYVn
h WATAUAVAWH
h#:yo
h&2;2r
h-Ѽws
h16;|x
h4:IgZ
h5]:i
h5e>v
h60;kG
h6D;2t;<6
h6ٺڿB8
h7꼫a1
h8o\vo
h9 20
h9*yx:UQ
h9<qah
h9>0˺_N
h9^c89
h:)J\t:AY
h:/1E
h:2hH;z
h:Z磺\vO
h:g+f
h:or^9
h:p.Y
h;Adi;rr
h;NDn
h;XtۼK
h;\fZV;7e
h;fKn;06r
h;yjo;K
h;̤d;\tUl
h<A<w\a7
h<I\b6
h=:"OV9
h=;kSp
h=E.2
h=I?F>I
h=\n;pD
h>2ip
h>^ht>0
h?=vxX
h?tFپLJk
hA;μw
hA_A]A
hA_A^A]A
hB)9Ǯq
hB.<C6F
hB:QN49
hB^T{C
hDº\eTr
hEb>0
hHL+h
hHM+h
hHM+h@A
hJ8;zl
hKλyp
hL#=x3
hL#O\bt
hL\a;uP
hMK</u
hMK<sJs
hNh4hhh
hN亦Hy
hP:qk
hQƽ2d
hR>\fpm
hU'>k\b
hU<Ǯo
hU\\;CJ{a
hVC;Lo
hW:_z
hX:3jG;F
hX=^y\e
hXD\b
hYL\a
hYL\t
hYL\t H
h\e;x
h\eH99x\n;1
h\f\f
h\rm<hz
h\v\a
h];sT
h_:~xr9b
h`hhh\b\b\axwpwpp\b\b
ha;gRa:r
hair_accel
hair_accel_mb
hair_builder
hair_builder_mb
hair_traverser
hair_traverser_mb
half edge generation
hc;!UR;8
hdK:3
header crc mismatch
hfffffff
high_quality
histogram
hk<;n
hl(<2xz
hlbvh accelerator max batch size exceeded
hls:PW4
holland
hong-kong
host unreachable
hpT;U
hr\b\f8
hrd<O
hs89r
hs:XO
htr<jtb<lt6<tt&<wt
http://ocsp.digicert.com0
http://ocsp.digicert.com0A
http://ocsp.digicert.com0C
http://ocsp.digicert.com0X
https://github.com/ValveSoftware/steam-audio/blob/master/LICENSE.md
hu=?lq
hugepages
hvļTAS
hwc;kY
hypot
hypotf
hyz8^7B
hz!>I
hz;Xz
h|S:\fE
h»A,0;J
hÊD$g
hü rj
hŻ\aO
hʼa䯼\bT
h̼wyP
hӻC\fC;}p
hܽe\a
hޯ<WP
hᗻ\vPD
h⡽7-h
i 3\bA(L
i ;\e
i B=w5
i H9i0u
i!S( H
i"p<F
i# <Q
i#:xYJ
i#F;y
i$baV\bY
i&=tQ\v
i';Ne
i';ecu
i)U;h
i+i<Uj
i,ba~\b
i.;Ws
i.>N5
i0:oȦ9
i1\n;fV8
i3<HO
i4V;\v
i4ۻ?k
i6:\b
i6=uA
i8P/\f
i8U,';n
i8g\b2
i8m8@A
i9<S~\r
i9>:\tM
i9B܈9Iw
i9iǋ<Z
i9lzM9
i9v>T\e
i:J+k
i:M)7:^DZ
i:Yoa:\t
i:\bv
i:ik\e
i;LbB
i;Mzu
i;P<5
i;Vv3
i;Zo5
i;\n\fk
i;c+J
i;ku4;iN9
i;l1C
i;oi|:SnO
i;ouJ
i<]Cb
i<tyZ
i=6\nk
i=w?6?T
i>&xO
i>=q8
i>>yo
i>Bsa
i?0@I
i?<Bu-8
iA<p5
iAU;v
iBo<;T
iD2;v\e
iH<QsO
iHȻDee;5
iI=M\t\v
iI=}9
iIĺ8 Q
iJ\r#QX
iJ\r)\ac
iJ\r0\rY
iJ\r0\tX
iJ\r7:7
iJ\r@%7
iJ\rMmV
iJ\rUt7
iJ\rWK7
iJ\re
iJ\rf
iJ\rh?a
iJ\rlh
iJ\rm*V
iK;n~];qe
iM:_R9\r
iM;$LQ
iOA9\t
iS;U,H
iTa;S1\t
iU;GA
iVr9*bn8
iXh<z
i\a:KIz
i\aļVvB?p
i\bH+)H
i\bba~\b
i\eĻ\b2
i\fźXI
i\n;O
i\nW<6
i\r;2
i\r<e3R
i\v7<\r
i\v<xj\v3hk\v*t
ib/:u
idata$2
idata$3
idata$4
idata$5
idata$6
identifier expected
identifier removed
ie <GG
if;#A
ifh;#\n
ignore_config_files
igy;p
iiFi#ii
ii\e?j
iix;Tڈ:w
ikR8qN&9\f
il0<Yl
ilj;S
illegal byte sequence
imb;D
imŻ\ny
in the MXCSR control and status register. This can have a severe
in(:5
inappropriate io control operation
include "pmmintrin.h
include "xmmintrin.h
incoherent
incompatible version
incorrect data check
incorrect header check
incorrect length check
inflate 1.2.11 Copyright 1995-2017 Mark Adler
ing is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals.x = keys[localid << 2]; \n            localvals.y = keys[(localid << 2) + 1]; \n            localvals.z = keys[(localid << 2) + 2]; \n            localvals.w = keys[(localid << 2) + 3]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n        int4 bin = (localvals >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        if (localid < NUM_BINS) \n        { \n            scanned_histogram[localid] += sum; \n        } \n    } \n} \n \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid ScatterKeysAndValues(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Input values \n    __global int4 const* restrict in_values, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys, \n    // Output values \n    __global int* restrict  out_values \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localkeys = safe_load_int4_intmax(in_keys, loadidx, numelems); \n        int4 localvals = safe_load_int4_intmax(in_values, loadidx
inlen == hrtf->N
instance
instance@TaskScheduler@embree@@CAPEAU12@XZ
instancing_block_size
instancing_open_factor
instancing_open_max
instancing_open_max_depth
instancing_open_min
insufficient memory
integer expected
internal error in ISA selection for BVH4Bezier1iIntersector1
internal error in ISA selection for BVH4Bezier1iIntersector16Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector16Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersector1_OBB
internal error in ISA selection for BVH4Bezier1iIntersector4Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector4Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersector8Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersectorStream
internal error in ISA selection for BVH4Bezier1vIntersector1
internal error in ISA selection for BVH4Bezier1vIntersector16Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector16Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersector1_OBB
internal error in ISA selection for BVH4Bezier1vIntersector4Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector4Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersector8Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersectorStream
internal error in ISA selection for BVH4IntersectorStreamPacketFallback
internal error in ISA selection for BVH4Line4iIntersector1
internal error in ISA selection for BVH4Line4iIntersector16
internal error in ISA selection for BVH4Line4iIntersector4
internal error in ISA selection for BVH4Line4iIntersector8
internal error in ISA selection for BVH4Line4iIntersectorStream
internal error in ISA selection for BVH4Line4iMBIntersector1
internal error in ISA selection for BVH4Line4iMBIntersector16
internal error in ISA selection for BVH4Line4iMBIntersector4
internal error in ISA selection for BVH4Line4iMBIntersector8
internal error in ISA selection for BVH4OBBBezier1iMBIntersector16Hybrid_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector1_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector4Hybrid_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector1Moeller
internal error in ISA selection for BVH4Quad4iIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersectorStreamMoeller
internal error in ISA selection for BVH4Quad4iIntersectorStreamPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH4Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector1Moeller
internal error in ISA selection for BVH4Quad4vIntersector1Pluecker
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersectorStreamMoeller
internal error in ISA selection for BVH4Quad4vIntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersectorStreamPluecker
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector1
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector16
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector4
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector8
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector1
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector16
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector4
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector8
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector1
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector16
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector4
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector8
internal error in ISA selection for BVH4SubdivPatch1Intersector1
internal error in ISA selection for BVH4SubdivPatch1Intersector16
internal error in ISA selection for BVH4SubdivPatch1Intersector4
internal error in ISA selection for BVH4SubdivPatch1Intersector8
internal error in ISA selection for BVH4SubdivPatch1MBIntersector1
internal error in ISA selection for BVH4SubdivPatch1MBIntersector16
internal error in ISA selection for BVH4SubdivPatch1MBIntersector4
internal error in ISA selection for BVH4SubdivPatch1MBIntersector8
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector1Moeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4IntersectorStreamMoeller
internal error in ISA selection for BVH4Triangle4IntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH4Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersectorStreamMoeller
internal error in ISA selection for BVH4Triangle4iIntersectorStreamPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersectorStreamPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH4VirtualIntersector1
internal error in ISA selection for BVH4VirtualIntersector16Chunk
internal error in ISA selection for BVH4VirtualIntersector4Chunk
internal error in ISA selection for BVH4VirtualIntersector8Chunk
internal error in ISA selection for BVH4VirtualIntersectorStream
internal error in ISA selection for BVH4VirtualMBIntersector1
internal error in ISA selection for BVH4VirtualMBIntersector16Chunk
internal error in ISA selection for BVH4VirtualMBIntersector4Chunk
internal error in ISA selection for BVH4VirtualMBIntersector8Chunk
internal error in ISA selection for BVH4XfmTriangle4Intersector1Moeller
internal error in ISA selection for BVH8Bezier1iIntersector16Hybrid_OBB
internal error in ISA selection for BVH8Bezier1iIntersector1_OBB
internal error in ISA selection for BVH8Bezier1iIntersector4Hybrid_OBB
internal error in ISA selection for BVH8Bezier1iIntersector8Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector16Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector1_OBB
internal error in ISA selection for BVH8Bezier1vIntersector4Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector8Hybrid_OBB
internal error in ISA selection for BVH8IntersectorStreamPacketFallback
internal error in ISA selection for BVH8Line4iIntersector1
internal error in ISA selection for BVH8Line4iIntersector16
internal error in ISA selection for BVH8Line4iIntersector4
internal error in ISA selection for BVH8Line4iIntersector8
internal error in ISA selection for BVH8Line4iMBIntersector1
internal error in ISA selection for BVH8Line4iMBIntersector16
internal error in ISA selection for BVH8Line4iMBIntersector4
internal error in ISA selection for BVH8Line4iMBIntersector8
internal error in ISA selection for BVH8OBBBezier1iMBIntersector16Hybrid_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector1_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector4Hybrid_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector8Hybrid_OBB
internal error in ISA selection for BVH8Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector1Moeller
internal error in ISA selection for BVH8Quad4iIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersectorStreamMoeller
internal error in ISA selection for BVH8Quad4iIntersectorStreamPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH8Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector1Moeller
internal error in ISA selection for BVH8Quad4vIntersector1Pluecker
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersectorStreamMoeller
internal error in ISA selection for BVH8Quad4vIntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector1Moeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4IntersectorStreamMoeller
internal error in ISA selection for BVH8Triangle4IntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH8Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersectorStreamMoeller
internal error in ISA selection for BVH8Triangle4iIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH8VirtualIntersector1
internal error in ISA selection for BVH8VirtualIntersector16Chunk
internal error in ISA selection for BVH8VirtualIntersector4Chunk
internal error in ISA selection for BVH8VirtualIntersector8Chunk
internal error in ISA selection for BVH8VirtualIntersectorStream
internal error in ISA selection for BVH8VirtualMBIntersector1
internal error in ISA selection for BVH8VirtualMBIntersector16Chunk
internal error in ISA selection for BVH8VirtualMBIntersector4Chunk
internal error in ISA selection for BVH8VirtualMBIntersector8Chunk
internal error in ISA selection for InstanceBoundsFunc
internal error in ISA selection for InstanceIntersectorN
internal error in ISA selection for QBVH4Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for QBVH8Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH8Triangle4Intersector1Moeller
internal error in ISA selection for QBVH8Triangle4iIntersector1Pluecker
internal error in ISA selection for rayStreamFilterFuncs
internal error: AccelN too small
internal_tasking_system
internal_time_splits
interrupted
intersect_main
intersection_filter
intersector1
intersector16
intersector4
intersector8
intersectorN
invalid argument
invalid bit length repeat
invalid block type
invalid buffer specified
invalid code -- missing end-of-block
invalid code lengths set
invalid destination pointer
invalid distance code
invalid distance too far back
invalid distances set
invalid geometry
invalid geometry ID
invalid geometry flag
invalid index buffer specified
invalid literal/length code
invalid literal/lengths set
invalid map<K, T> key
invalid number of threads specified
invalid seek
invalid stored block lengths
invalid string position
invalid thread ID
invalid timestep
invalid topology ID
invalid vector<T> subscript
invalid vertex buffer specified
invalid window size
io error
ion and origin / dir for bbox testing \n            const float3 invDir32 = safe_invdir2(my_ray); \n            const half3 invDir = convert_half3(invDir32); \n            const half3 oxInvDir = convert_half3(-my_ray.o.xyz * invDir32); \n \n            // Intersection parametric distance \n            float closest_t = my_ray.o.w; \n \n            // Current node address \n            uint addr = 0; \n            // Current closest address \n            uint closest_addr = INVALID_ADDR; \n \n            uint stack_bottom = STACK_SIZE * index; \n            uint sptr = stack_bottom; \n            uint lds_stack_bottom = local_index * LDS_STACK_SIZE; \n            uint lds_sptr = lds_stack_bottom; \n \n            lds_stack[lds_sptr++] = INVALID_ADDR; \n \n            while (addr != INVALID_ADDR) \n            { \n                const bvh_node node = nodes[addr]; \n \n                if (INTERNAL_NODE(node)) \n                { \n                    half4 s01 = fast_intersect_bbox2( \n                        node.aabb01_min_or_v0_and_addr0.xyz, \n                        node.aabb01_max_or_v1_and_addr1_or_mesh_id.xyz, \n                        invDir, oxInvDir, closest_t); \n                    half4 s23 = fast_intersect_bbox2( \n                        node.aabb23_min_or_v2_and_addr2_or_prim_id.xyz, \n                        node.aabb23_max_and_addr3.xyz, \n                        invDir, oxInvDir, closest_t); \n \n                    bool traverse_c0 = (s01.x <= s01.z); \n                    bool traverse_c1 = (s01.y <= s01.w) && (node.aabb01_max_or_v1_and_addr1_or_mesh_id.w != INVALID_ADDR); \n                    bool traverse_c2 = (s23.x <= s23.z); \n                    bool traverse_c3 = (s23.y <= s23.w) && (node.aabb23_max_and_addr3.w != INVALID_ADDR); \n \n                    if (traverse_c0 || traverse_c1 || traverse_c2 || traverse_c3) \n                    { \n                        uint a = INVALID_ADDR; \n                        half d = 100000000.0f; \n \n                        if (traverse_c0) \n                        { \n                            a = node.aabb01_min_or_v0_and_addr0.w; \n                            d = s01.x; \n                        } \n \n                        if (traverse_c1) \n                        { \n                            if (a == INVALID_ADDR) \n                                a = node.aabb01_max_or_v1_and_addr1_or_mesh_id.w; \n                            else \n                            { \n                                uint topush = s01.y < d ? a : node.aabb01_max_or_v1_and_addr1_or_mesh_id.w; \n                                d = min(s01.y, d); \n                                a = topush == a ? node.aabb01_max_or_v1_and_addr1_or_mesh_id.w : a; \n                                stack_push(lds_stack, &lds_sptr, lds_stack_bottom, stack, &sptr, topush); \n                            } \n                        } \n \n                        if (traverse_c2) \n                        { \n                            if (a == INVALID_ADDR) \n                                a = node.aabb23_min_or_v2_and_addr2_or_prim_id.w; \n                            else \n                            { \n                                uint topush = s23.x < d ? a : node.aabb23_min_or_v2_and_addr2_or_prim_id.w; \n                                d = min(s23.x, d); \n                                a = topush == a ? node.aabb23_min_or_v2_and_addr2_or_prim_id.w : a; \n                                stack_push(lds_stack, &lds_sptr, lds_stack_bottom, stack, &sptr, topush); \n                            } \n                        } \n \n                        if (traverse_c3) \n                        { \n                            if (a == INVALID_ADDR) \n                                a = node.aabb23_max_and_addr3.w; \n                            else \n                            { \n                                uint topush = s23.y < d ? a : node.aabb23_max_and_addr3.w; \n                                d = min(s23.y, d); \n                                a = topush == a ? node.aa
ios_base::badbit set
ios_base::eofbit set
ios_base::failbit set
iostream
iostream stream error
ipl::HRTFMap::loadAmbisonicsHRIRs
ipl::HRTFMap::verifyDataHeader
iplAirAbsorptionCalculate
iplAmbisonicsBinauralEffectApply
iplAmbisonicsBinauralEffectCreate
iplAmbisonicsBinauralEffectRelease
iplAmbisonicsBinauralEffectReset
iplAmbisonicsBinauralEffectRetain
iplAmbisonicsDecodeEffectApply
iplAmbisonicsDecodeEffectCreate
iplAmbisonicsDecodeEffectRelease
iplAmbisonicsDecodeEffectReset
iplAmbisonicsDecodeEffectRetain
iplAmbisonicsEncodeEffectApply
iplAmbisonicsEncodeEffectCreate
iplAmbisonicsEncodeEffectRelease
iplAmbisonicsEncodeEffectReset
iplAmbisonicsEncodeEffectRetain
iplAmbisonicsPanningEffectApply
iplAmbisonicsPanningEffectCreate
iplAmbisonicsPanningEffectRelease
iplAmbisonicsPanningEffectReset
iplAmbisonicsPanningEffectRetain
iplAmbisonicsRotationEffectApply
iplAmbisonicsRotationEffectCreate
iplAmbisonicsRotationEffectRelease
iplAmbisonicsRotationEffectReset
iplAmbisonicsRotationEffectRetain
iplAudioBufferAllocate
iplAudioBufferConvertAmbisonics
iplAudioBufferDeinterleave
iplAudioBufferDownmix
iplAudioBufferFree
iplAudioBufferInterleave
iplAudioBufferMix
iplBinauralEffectApply
iplBinauralEffectCreate
iplBinauralEffectRelease
iplBinauralEffectReset
iplBinauralEffectRetain
iplCalculateRelativeDirection
iplContextCreate
iplContextRelease
iplContextRetain
iplContextSetProfilerContext
iplContextSetVariableBool
iplContextSetVariableFloat32
iplContextSetVariableInt32
iplContextSetVariableString
iplConvolutionPartitionerCreate
iplConvolutionPartitionerPartition
iplConvolutionPartitionerRelease
iplConvolutionPartitionerRetain
iplDirectEffectApply
iplDirectEffectCreate
iplDirectEffectRelease
iplDirectEffectReset
iplDirectEffectRetain
iplDirectSimulatorCreate
iplDirectSimulatorRelease
iplDirectSimulatorRetain
iplDirectSimulatorSimulate
iplDirectivityCalculate
iplDistanceAttenuationCalculate
iplDistanceAttenuationGetCorrectionCurve
iplEmbreeDeviceCreate
iplEmbreeDeviceRelease
iplEmbreeDeviceRetain
iplEnergyFieldCopyDeviceToHost
iplEnergyFieldCopyHostToDevice
iplEnergyFieldCreate
iplEnergyFieldGetData
iplEnergyFieldGetNumBins
iplEnergyFieldGetNumChannels
iplEnergyFieldGetSize
iplEnergyFieldRelease
iplEnergyFieldRetain
iplEnergyFieldSetData
iplHRTFCreate
iplHRTFRelease
iplHRTFRetain
iplHybridReverbEstimatorCreate
iplHybridReverbEstimatorEstimate
iplHybridReverbEstimatorRelease
iplHybridReverbEstimatorRetain
iplImpulseResponseCopyDeviceToHost
iplImpulseResponseCopyHostToDevice
iplImpulseResponseCreate
iplImpulseResponseGetData
iplImpulseResponseGetNumChannels
iplImpulseResponseGetNumSamples
iplImpulseResponseGetSize
iplImpulseResponseRelease
iplImpulseResponseRetain
iplImpulseResponseSetData
iplIndirectEffectIRCreate
iplIndirectEffectIRRelease
iplIndirectEffectIRRetain
iplInstancedMeshAdd
iplInstancedMeshCreate
iplInstancedMeshRelease
iplInstancedMeshRemove
iplInstancedMeshRetain
iplInstancedMeshUpdateTransform
iplOpenCLDeviceCreate
iplOpenCLDeviceCreateFromExisting
iplOpenCLDeviceListCreate
iplOpenCLDeviceListGetDeviceDesc
iplOpenCLDeviceListGetNumDevices
iplOpenCLDeviceListRelease
iplOpenCLDeviceListRetain
iplOpenCLDeviceRelease
iplOpenCLDeviceRetain
iplPanningEffectApply
iplPanningEffectCreate
iplPanningEffectRelease
iplPanningEffectReset
iplPanningEffectRetain
iplPathBakerBake
iplPathBakerCancelBake
iplPathEffectApply
iplPathEffectCreate
iplPathEffectRelease
iplPathEffectReset
iplPathEffectRetain
iplPathSimulatorCreate
iplPathSimulatorRelease
iplPathSimulatorRetain
iplPathSimulatorSimulate
iplProbeArrayCreate
iplProbeArrayGenerateProbes
iplProbeArrayGetNumProbes
iplProbeArrayGetProbe
iplProbeArrayRelease
iplProbeArrayRetain
iplProbeBatchAddProbe
iplProbeBatchAddProbeArray
iplProbeBatchCommit
iplProbeBatchCreate
iplProbeBatchGetDataSize
iplProbeBatchGetInfluencingProbes
iplProbeBatchGetNumProbes
iplProbeBatchGetProbeArray
iplProbeBatchLoad
iplProbeBatchRelease
iplProbeBatchRemoveData
iplProbeBatchRemoveProbe
iplProbeBatchRetain
iplProbeBatchSave
iplProbeBatchUpdateEndpoint
iplProbeBatchUpdateProbePosition
iplProbeBatchUpdateProbeRadius
iplProbeNeighborhoodCalculateWeights
iplProbeNeighborhoodCheckOcclusion
iplProbeNeighborhoodCreate
iplProbeNeighborhoodFindNearest
iplProbeNeighborhoodGetNumProbes
iplProbeNeighborhoodGetNumValidProbes
iplProbeNeighborhoodRelease
iplProbeNeighborhoodReset
iplProbeNeighborhoodResize
iplProbeNeighborhoodRetain
iplRadeonRaysDeviceCreate
iplRadeonRaysDeviceRelease
iplRadeonRaysDeviceRetain
iplReconstructorCreate
iplReconstructorReconstruct
iplReconstructorRelease
iplReconstructorRetain
iplReflectionEffectApply
iplReflectionEffectCreate
iplReflectionEffectRelease
iplReflectionEffectReset
iplReflectionEffectRetain
iplReflectionMixerApply
iplReflectionMixerCreate
iplReflectionMixerRelease
iplReflectionMixerReset
iplReflectionMixerRetain
iplReflectionSimulatorCreate
iplReflectionSimulatorRelease
iplReflectionSimulatorRetain
iplReflectionSimulatorSimulate
iplReflectionsBakerBake
iplReflectionsBakerCancelBake
iplReverbEstimatorEstimate
iplSceneCommit
iplSceneCreate
iplSceneLoad
iplSceneRelease
iplSceneRetain
iplSceneSave
iplSceneSaveOBJ
iplSerializedObjectCreate
iplSerializedObjectGetData
iplSerializedObjectGetSize
iplSerializedObjectRelease
iplSerializedObjectRetain
iplSimulatorAddProbeBatch
iplSimulatorCommit
iplSimulatorCreate
iplSimulatorRelease
iplSimulatorRemoveProbeBatch
iplSimulatorRetain
iplSimulatorRunDirect
iplSimulatorRunPathing
iplSimulatorRunPathingPerSource
iplSimulatorRunPathingPerSourceForNeighborhood
iplSimulatorRunReflections
iplSimulatorSetScene
iplSimulatorSetSharedInputs
iplSourceAdd
iplSourceCreate
iplSourceGetOutputs
iplSourceGetOutputsAux
iplSourceRelease
iplSourceRemove
iplSourceRetain
iplSourceSetInputs
iplStaticMeshAdd
iplStaticMeshCreate
iplStaticMeshLoad
iplStaticMeshRelease
iplStaticMeshRemove
iplStaticMeshRetain
iplStaticMeshSave
iplTrueAudioNextDeviceAcquireSlot
iplTrueAudioNextDeviceCreate
iplTrueAudioNextDeviceRelease
iplTrueAudioNextDeviceRetain
iplTrueAudioNextReleaseSlot
iplTrueAudioNextSetImpulseResponse
iplTrueAudioNextUpdateIRs
iplVirtualSurroundEffectApply
iplVirtualSurroundEffectCreate
iplVirtualSurroundEffectRelease
iplVirtualSurroundEffectReset
iplVirtualSurroundEffectRetain
ir":r
ir4;D
irish-english
is a directory
isZ;f
is_double
italian-swiss
ivK;H
ix;h58
ixn<JtA<v
iy0=*{u
iy;\fb
izL;x
i|ŢXY
iȽutv=\tV
iʄ;Et
iͻo\t
i⺵gI;F
i繇ٱ:WF;dF
i軲j̻CF
j ;=M
j ?;k9
j ba|\b
j"=Np\n
j&9|6
j(L=N
j(ŒYq\b
j(ŒYw\b
j/ʼn4
j1;m\a
j3K:\e
j7w:Y
j7֏L8
j8L;x
j8b3M
j8ba|\b
j9!I4
j9:jId
j9\b|89
j9n.칣J
j9~ry
j: \n\t
j:( K
j:K+9
j:P7\a
j:nsr
j:p\rE:\a0Y:6
j;-v6
j;2<a
j;>N3=B
j;J5\t
j;V^b
j;YSc
j;d<H
j;nYB<D
j<W;a
j<\nQ
j<gOǼh\n
j<hln
j<s@X
j=GǬ9W
j?Q>c
j?\fKk?X
j@p;2
j@w;U
jAE;\n
jB:kZx
jB<\eR
jB\t=!U
jCZ<U\f
jCӻ\f\en
jD5;Hp
jD<3eW
jE3<4
jF;@N
jFb=\fl
jH:<QT
jH<r6v;K
jJ0>o4㽞X
jK<8kc
jL-; H
jO;GA
jPj;Ȥ4
jQ7:5(u
jQ:X&9;\bP
jQ;%8
jS.9eI(:8I
jTK;5ۡ<S
jU)9`9
jU;kD
jW2;5]Q
jX\a<p
jXa ŲXA
jY>=|ZY
jY\e;~7
jYd\aTĢQ
j[;kM
j\a\f
j\aba|H
j\aba|\b
j\aba~\b
j\ah<5p
j\ah<m3
j\b A
j\b9xk\b0hl\b'4
j\b\a:Z 6
j\bbA
j\bbA|\b
j\e=lV
j\e\n<h
j\f\n<lN
j\fbA
j\nͼs[c
j\t<B\fy
j\vba|\b
j\vͼgA
j`4<EV
jc<\r
jd\e<օx
jdɼ!j
jf93A5
jg<=w
jgE;TY
jgr:g
jh\v<5
jj@0HK4
jm%<nv
joC:H7
joL<ha
jrG;&sV
jt":2
jtm}S
jtۺ\e7\t
juD;BK5
jv: t
jxD<,霼U`E
jy:VK
jy=Hܖ=P
j{E>hI
j˂8>GO:}X
jϼ2Qy<C
jѷ<b3s
jֻOM3
jٚ;n3
jݼfB绪j
jސ;Du
jꅽE-I
jﺜܙ80
k [:Y
k w:f
k!U<k
k"5:*ub
k"<\f4F
k$l9\\8
k+g:Y6
k,=LAZ
k-z>P\a
k.2:x_O
k.;9p
k0;b8\e
k0L9kXv
k1;qP6
k1ӽVk
k2=)i
k46:!S
k4ݺiTx
k53<HC
k6A;\\x
k7˼\bQɼK
k80qA
k89;~W
k8=ԈĽ5l
k92JX
k:;3P0
k:=4w
k:Dq\t
k:N=h:3
k:мCz
k;FLO;C
k;K#H
k;Lnm;\\a
k;\n\aۻ8Y
k;\tu7
k;bLŻa
k;tޏ:I0
k;}lU
k;~XO
k<*b2
k<9cXN
k<Z9k
k<\b8\e=C
k=t\b
k>p"Q
k>pzf>M
k@L9khv
k@b1|H
kB<qeλ\tt
kE{;Kx
kH\v;A39;BUn:8
kJ\f>V
kL:mw\b9y
kL<9mK
kL\f?g
kP<HI <4jv
kPfff
kPffff
kPfffff
kPffffff
kPfffffff
kPջ8u\t
kQQ:I
kQi<\b
kQƼU}S
kQɻ C
kR9;N
kRi;\n
kS;l\a
kT!;>DZ
kT>Lu
kV[8Y
kW\n<|H廀A
kY=@XQ
kY=@kQ
kZ;Z}H
kZ<2"N
kZa<jq
k[F<yT
k\a<xl\a3hm\a*t
k\e;wT
k\fb!|HX
k\n;w
k\v<xl\v3hm\v*t
k]\t;9N
kaw;Ff
kb:cD
kc3:\e
ke@<uM
kernel32
kernel32.dll
kf<8B
kfH;B]z
kf\e<g
kg;_A
kg=<Zɼy|J
kh;yua;d
kj;\a );K
kl\t<TpC
km\f<O
kok-IN
kok-in
kp漽\f
kq;j\n
krU9\vUy
kt;:\rs
ku;é3:Q
ky\r9E
kyq;]8
k|^Xm
k}<aq
k~*6Q
k~y:K
kļu\r7
kľ<Eg\e
kȻjꦻqkܻFY
kɻ-eQ
kҼf[R
kջWH2<[Q0
kܥ:zfa
l `ŠW5
l `ŠW59SD
l int* energy, \n\t\t\t\t\t\t\t\t\t   uint samplingRate, \n                                       uint samplesPerBin,\n\t\t\t\t\t\t\t\t\t   uint numSamples, \n\t\t\t\t\t\t\t\t\t   global float* airAbsorption, \n\t\t\t\t\t\t\t\t\t   global IIR* filters, \n                                       global float* whiteNoise,\n                                       global float* impulseResponse, \n                                       uint offset,\n\t\t\t\t\t\t\t\t\t   float scale)\n{\n    size_t bin = get_global_id(0);\n    size_t band = get_global_id(1);\n    size_t channel = get_global_id(2);\n\tsize_t numBins = get_global_size(0);\n    size_t numBands = get_global_size(1);\n    size_t numChannels = get_global_size(2);\n\n    global float* impulseResponseBin = &impulseResponse[offset + (channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n    global float* whiteNoiseBin = &whiteNoise[(channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n\n    float e0 = (float)energy[0*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n    float e = (float)energy[channel*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n\n    if (fabs(e) < ENERGY_THRESHOLD || fabs(e0) < ENERGY_THRESHOLD)\n    {\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = 0.0f;\n        }\n    }\n    else\n    {\n        float tMean = ((bin + 0.5f) * samplesPerBin) / samplingRate;\n        float tVariance = MIN_VARIANCE;\n\n        int sample = bin * samplesPerBin;\n        float binEnergy = 0.0f;\n\n        float t = sample / (float) samplingRate;\n        float dt = 1.0f / (float) samplingRate;\n\n        float g = exp(-((t - tMean) * (t - tMean)) / (2.0f * tVariance));\n        float dg = exp(-(dt * ((2.0f * (t - tMean)) + dt)) / (2.0f * tVariance));\n        float ddg = exp(-(dt * dt) / tVariance);\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = g * whiteNoiseBin[i];\n            binEnergy += impulseResponseBin[i] * impulseResponseBin[i];\n            g *= dg;\n            dg *= ddg;\n        }\n\n        float normalization = e / sqrt(e0 * sqrt(4.0f * PI));\n\n        normalization *= exp(-0.5f * airAbsorption[band] * SPEED_OF_SOUND * ((bin + 0.5f) * samplesPerBin * (1.0f / samplingRate)));\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] *= normalization;\n        }\n    }\n}\n\nkernel void combineBandpassedImpulseResponse(uint numSamples, \n                                             global float* bandImpulseResponses, \n\t\t\t\t\t\t\t\t\t\t\t global float* impulseResponse)\n{\n    size_t sample = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t batch = get_global_id(2);\n\tsize_t numChannels = get_global_size(1);\n\n\tfloat value = 0.0f;\n\n    for (int i = 0; i < NUM_BANDS; ++i)\n    {\n        value += bandImpulseResponses[(batch * numChannels * NUM_BANDS * numSamples) + (channel * NUM_BANDS * numSamples) + (i * numSamples) + sample];\n    }\n\n\timpulseResponse[(batch * numChannels * numSamples) + (channel * numSamples) + sample] = value;\n}\n
l pŠW5
l!;b\tF
l!s;9p
l$ VATAVH
l$ VAVH
l$ VWATAVAWH
l$ VWAUH
l$ VWAVH
l$ VWAWH
l$ WATAWH
l$ WAVAWH
l$ ba|\b
l$ ba~\b
l$(LcE
l$(ba
l$0L9n
l$0LcX
l$0Lcy\f
l$0fC
l$0t1E3
l$8D;l$4
l$8H9~(v"H
l$@D8W\buIH
l$@HcB
l$@LcP
l$@LcSl
l$@fff
l$@tS
l$HA_A^A]A
l$HL9k
l$N=1
l$PD;f
l$PHc
l$PLcP
l$PtR
l$Pu\afE
l$Pu\vE
l$TH+H@I
l$XE3\tT$`A
l$`IcC
l$`ba|H
l$hH;l
l$pHǅp
l$pIcE
l$pfA
l$pfE
l$pfff
l$pň]Gp
l%ݼN8m
l&:GF
l-;eM
l/:09
l0+:z
l0=h{D
l0\aba|H
l15;RJ
l1ú\ad
l2|X/gGe
l598_r
l6w<H
l7<dV
l8%9\tc
l9<RW
l9\t;!\nW
l9u;.L
l:Xj纨E
l:\b\n\t;gr󹙌A;bYi;DQ
l:g\r\t
l:j\aB;r
l:nZ>:JzH
l:~ou
l; fE
l; le
l;B8a
l;\tyٺtM\f;F
l<w5Ž\nL\b
l<ǜu=57
l>a|m
l? fE
l@3=jX
l@Y\r0gE
lBL:pj
lB黻n9
lD;LH\e
lD<dq4<K
lE8o]Q
lGo<`m
lH;QS{9
lHYu\rb
lHY|\a\bb
lHY}\abB
lK=$39
lNs:E7
lO5;"S
lP9[В9
lR);ce
lT%q\bD
lT-O*D
lT0fB
lU ńX
lV;#f
lW%H;3
lW%a;3
lW2:8
lW?XҶ<M
lWۻ4\fM9
lX%bN3
lXD\b
lXD\n
lXL\n
lX\f"H
lY2;\f
lYL\a
lYL\f
lYL\n
lZ1<x
lZ=Ru\r
lZ=vI
l\\59(6
l\a<a8):A
l\aPġBYT\a\\L
l\e;Ko\e:b
l\f5;d'P
l\f<< T
l\f<j
l\fI9
l\fx8Ŕe
l\n\v<2
l\t\abA|H
l\vP:7
l\vS9S7
l\v\abA|H
l]U:j
l_Y<K
l_뻗jK
l`I<\eL
lbS;9bU
leaves
lf8<E>6
lfW;I
lg;;T
lg\v<DZO
li$<}C0=t
li;4ZD
li=YU˼jn
liF;5F
line segments
line4i
line_accel
line_accel_mb
line_builder
line_builder_mb
line_traverser
line_traverser_mb
list too long
list<T> too long
listTanDevicesAndCaps
ljH;p
lk9(mP
lk;6᤹a\n
llHl$ll
llɻhOx
lm?;DjW
lm_stack_base[i * WAVEFRONT_SIZE] = gm_stack[i]; \n                    } \n                    // Point local stack pointer to the end \n                    lm_stack = lm_stack_base + (SHORT_STACK_SIZE - 1) * WAVEFRONT_SIZE; \n                    addr = lm_stack_base[WAVEFRONT_SIZE * (SHORT_STACK_SIZE - 1)]; \n                } \n            } \n \n            // Finished traversal, but no intersection found \n            hits[global_id] = MISS_MARKER; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL void intersect_main( \n    // Bvh nodes \n    GLOBAL bvh_node const* restrict nodes, \n    // Bounding boxes \n    GLOBAL bbox const* restrict bounds, \n    // Triangles vertices \n    GLOBAL float3 const* restrict vertices, \n    // Faces \n    GLOBAL Face const* restrict faces, \n    // Rays \n    GLOBAL ray const* restrict rays, \n    // Number of rays in rays buffer \n    GLOBAL int const* restrict num_rays, \n    // Stack memory \n    GLOBAL int* stack, \n    // Hit data \n    GLOBAL Intersection* hits) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Handle only working subset \n    if (global_id < *num_rays) \n    { \n        ray const r = rays[global_id]; \n \n        if (ray_is_active(&r)) \n        { \n            // Allocate stack in global memory  \n            __global int* gm_stack_base = stack + (group_id * WAVEFRONT_SIZE + local_id) * GLOBAL_STACK_SIZE; \n            __global int* gm_stack = gm_stack_base; \n            // Allocate stack in LDS \n            __local int lds[SHORT_STACK_SIZE * WAVEFRONT_SIZE]; \n            __local int* lm_stack_base = lds + local_id; \n            __local int* lm_stack = lm_stack_base; \n \n            // Precompute inverse direction and origin / dir for bbox testing \n            float3 const invdir = safe_invdir(r); \n            float3 const oxinvdir = -r.o.xyz * invdir; \n            // Intersection parametric distance \n            float t_max = r.o.w; \n \n            // Current node address \n            int addr = 0; \n            // Current closest intersection leaf index \n            int isect_idx = INVALID_IDX; \n \n            //  Initalize local stack \n            *lm_stack = INVALID_IDX; \n            lm_stack += WAVEFRONT_SIZE; \n \n            // Start from 0 node (root) \n            while (addr != INVALID_IDX) \n            { \n                // Fetch next node \n                bvh_node const node = nodes[addr]; \n \n                // Check if it is a leaf \n                if (LEAFNODE(node)) \n                { \n                    Face face = faces[STARTIDX(node)]; \n#ifdef RR_RAY_MASK \n                    if (ray_get_mask(&r) != face.shape_id) \n                    { \n#endif // RR_RAY_MASK \n                        // Leafs directly store vertex indices \n                        // so we load vertices directly \n                        float3 const v1 = vertices[face.idx[0]]; \n                        float3 const v2 = vertices[face.idx[1]]; \n                        float3 const v3 = vertices[face.idx[2]]; \n                        // Intersect triangle \n                        float const f = fast_intersect_triangle(r, v1, v2, v3, t_max); \n                        // If hit update closest hit distance and index \n                        if (f < t_max) \n                        { \n                            t_max = f; \n                            isect_idx = STARTIDX(node); \n                        } \n#ifdef RR_RAY_MASK \n                    } \n#endif // RR_RAY_MASK \n                } \n                else \n                { \n                    // It is internal node, so intersect vs both children bounds \n                    float2 const s0 = fast_intersect_bbox1(bounds[node.child0], invdir, oxinvdir, t_max); \n                    float2 const s1 = fast_intersect_bbox1(bounds[node.child1], invdir, oxinvdir, t_max); \n \n                    // Determine which one to traverse \n                    bool
ln;7M\r
local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \nvoid group_segmented_scan_exclusive_int_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n
local static guard
local static thread guard
local vftable
local vftable constructor closure
log10f
lp:9#\f
lpֹ1yK
lv;u\rR
lvӼUf
lxໝi];w
ly\r;^pB
l~;n25
lúL #8
lŽVĖ<mE
lϻg{G
lعIEz
lܼ)8u
lޡ=eo\t
l嫼G+6
l蠼3\v_< ot
m / %d / %y
m LcT$8I
m b!|\bX
m b1t\b
m!=\n3A
m"2;lxO
m"K;u
m'=YYY
m(8?TT
m(;tU
m(t;eL
m);6\nr
m*k<o
m/:RG
m0L#ɉu
m0t;eL
m1q;\a
m2<\a'p
m3$;a
m3:@3\n
m5=R.O
m69jlQ9B
m6;]g
m6=FwK
m7;ka
m8(^S80
m8L9c\bt
m8RDu;~d
m8aK:a
m8ԻWw
m9 k;5
m9b25
m9f/\t
m:Dբ9fI
m:cG?;X#W
m:o黹R\n
m;4Ij;qi\a
m;;X4
m;;zmx
m;F|39
m;o1J
m;y\t\a
m<8楼ky
m<>s2
m<[jg
m<\fi
m='\bڽlM8
m=\a9
m>)VF
m?x:o
mAF=:D
mB;G\tH
mD><D
mEA;\a1
mF#ʈb3UF
mI;g\\U
mJ#;5
mJ\r.C
mJ\r5T
mJ\r7/J
mJ\r7O
mJ\r:qP
mJ\rF:y
mJ\rJ21
mJ\rL&Q
mJ\rL^y
mJ\rORQ
mJ\rS>E
mJ\rU.M
mJ\rUZJ
mJ\rZyy
mJ\r\bwJ
mJ\r\eJ
mJ\r\f\bO
mJ\r\vA
mJ\r]SO
mJ\raz1
mJ\rd 2
mJ\rdO1
mJ\rj
mJ\rx2Q
mJ\rzAQ
mJ\r|"I
mJ\r}H
mK=lr
mLK:a6t
mLY<F
mOD;7
mPD=I
mPo9"g
mQ<FYr
mQ<^D
mSV;Ux
mU=#si
mWA9o
mWC:1
mX=9\t)C
mXbaT
mXġxYT6
mY90W
mY9p>o
m[;1NJ
m\abA|H
m\b;w\f
m\b<xn\b3ho\b*t
m\bL#ɉu K
m\bba}HpձbA,@YU\tb
m\e<r
m\fbA$ X
m\fbQ|H
m\fbr}H
m\nE<v
m\nb1}HpֱbQ,HYU\vb
m\rbA|H
m\tQ9
m\t\v
m\tbQ|H
m\vbA|H
m\vbB
m\vbQ|H
m_4:\bN
ma;Ⱦ1
malloc
managed vector constructor iterator
managed vector copy constructor iterator
managed vector destructor iterator
map/set too long
map/set<T> too long
maxGrowSize
max_builder_isa
max_hrtf_normalization_volume_gain_db
max_isa
max_leaf_size
max_spatial_split_replications
maximally 256 floating point values can be interpolated per vertex
mb<\e
mc;|c
mc^:H
md:jgt
me;9*7
memory monitor forced termination
message size
mg<;z\b
mge:p
mi<78f
min_leaf_size
minimally possible
minkernel\\crts\\ucrt\\inc\\corecrt_internal_strtox.h
mj9Z[9G
mkX>\r+G
mkʻnI\v
ml">Z
mn;$R
mn];A
morton
motion blur hair
motion blur line segments
motion blur quads
motion blur triangles
mp~9GGW
mq:1kA
mq\e:3N
mr;4i
mr=/\b5
mr>\rw
ms:W6x
msM;W
mscoree.dll
mt^<E
mtllib %s.mtl\n
mv':\eh
mwH9?l\f:@Z`8eTE
mx::dh89mG
myzAn4
m~ҺBT
mÜ8\a
mȣ:ScսEd
mɺDDo;8
m˕9ntH
m˻7\eG;BF
m˻Eg7
mλ8FF
mѸC\e
n                            if (a == INVALID_ADDR) \n                                a = node.aabb23_max_and_addr3.w; \n                            else \n                            { \n                                uint topush = s23.y < d ? a : node.aabb23_max_and_addr3.w; \n                                d = min(s23.y, d); \n                                a = topush == a ? node.aabb23_max_and_addr3.w : a; \n                                stack_push(lds_stack, &lds_sptr, lds_stack_bottom, stack, &sptr, topush); \n                            } \n                        } \n \n                        addr = a; \n                        continue; \n                    } \n                } \n                else \n                { \n#ifdef RR_RAY_MASK \n                    if (ray_get_mask(&my_ray) != convert_int(GetMeshId(node))) \n                    { \n#endif // RR_RAY_MASK \n                        float t = fast_intersect_triangle( \n                            my_ray, \n                            as_float3(node.aabb01_min_or_v0_and_addr0.xyz), \n                            as_float3(node.aabb01_max_or_v1_and_addr1_or_mesh_id.xyz), \n                            as_float3(node.aabb23_min_or_v2_and_addr2_or_prim_id.xyz), \n                            closest_t); \n \n                        if (t < closest_t) \n                        { \n                            closest_t = t; \n                            closest_addr = addr; \n                        } \n#ifdef RR_RAY_MASK \n                    } \n#endif // RR_RAY_MASK \n                } \n \n                addr = lds_stack[--lds_sptr]; \n \n                if (addr == INVALID_ADDR && sptr > stack_bottom) \n                { \n                    sptr -= LDS_STACK_SIZE; \n                    for (int i = 1; i < LDS_STACK_SIZE; ++i) \n                    { \n                        lds_stack[lds_stack_bottom + i] = stack[sptr + i]; \n                    } \n \n                    lds_sptr = lds_stack_bottom + LDS_STACK_SIZE - 1; \n                    addr = lds_stack[lds_sptr]; \n                } \n            } \n \n            // Check if we have found an intersection \n            if (closest_addr != INVALID_ADDR) \n            { \n                // Calculate hit position \n                const bvh_node node = nodes[closest_addr]; \n                const float3 p = my_ray.o.xyz + closest_t * my_ray.d.xyz; \n \n                // Calculate barycentric coordinates \n                const float2 uv = triangle_calculate_barycentrics( \n                    p, \n                    as_float3(node.aabb01_min_or_v0_and_addr0.xyz), \n                    as_float3(node.aabb01_max_or_v1_and_addr1_or_mesh_id.xyz), \n                    as_float3(node.aabb23_min_or_v2_and_addr2_or_prim_id.xyz)); \n \n                // Update hit information \n                hits[index].prim_id = node.aabb23_min_or_v2_and_addr2_or_prim_id.w; \n                hits[index].shape_id = node.aabb01_max_or_v1_and_addr1_or_mesh_id.w; \n                hits[index].uvwt = (float4)(uv.x, uv.y, 0.0f, closest_t); \n            } \n            else \n            { \n                // Miss here \n                hits[index].prim_id = MISS_MARKER; \n                hits[index].shape_id = MISS_MARKER; \n            } \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL void occluded_main( \n    // Bvh nodes \n    GLOBAL const bvh_node *restrict nodes, \n    // Rays \n    GLOBAL const ray *restrict rays, \n    // Number of rays in rays buffer \n    GLOBAL const int *restrict num_rays, \n    // Stack memory \n    GLOBAL uint *stack, \n    // Hit results: 1 for hit and -1 for miss \n    GLOBAL int *hits) \n{ \n    __local uint lds_stack[GROUP_SIZE * LDS_STACK_SIZE]; \n \n    uint index = get_global_id(0); \n    uint local_index = get_local_id(0); \n \n    // Handle only working subset \n    if (index < *num_rays) \n    { \n        const ray my_ray = rays[index]; \n \n        if (ray_is_active(&my_ray)) \n        { \n            // Precompute inverse direct
n                // Fetch next node \n                bvh_node node = nodes[addr]; \n                // Intersect against bbox \n                float2 s = fast_intersect_bbox1(node, invdir, oxinvdir, t_max); \n \n                if (s.x <= s.y) \n                { \n                    // Check if the node is a leaf \n                    if (LEAFNODE(node)) \n                    { \n                        int const face_idx = STARTIDX(node); \n                        Face const face = faces[face_idx]; \n#ifdef RR_RAY_MASK \n                        if (ray_get_mask(&r) != face.shape_id) \n                        { \n#endif // RR_RAY_MASK \n                            float3 const v1 = vertices[face.idx[0]]; \n                            float3 const v2 = vertices[face.idx[1]]; \n                            float3 const v3 = vertices[face.idx[2]]; \n \n                            // Intersect triangle \n                            float const f = fast_intersect_triangle(r, v1, v2, v3, t_max); \n                            // If hit update closest hit distance and index \n                            if (f < t_max) \n                            { \n                                t_max = f; \n                                isect_idx = face_idx; \n                            } \n#ifdef RR_RAY_MASK \n                        } \n#endif // RR_RAY_MASK \n                    } \n                    else \n                    { \n                        // Move to next node otherwise. \n                        // Left child is always at addr + 1 \n                        ++addr; \n                        continue; \n                    } \n                } \n \n                addr = NEXT(node); \n            } \n \n            // Check if we have found an intersection \n            if (isect_idx != INVALID_IDX) \n            { \n                // Fetch the node & vertices \n                Face const face = faces[isect_idx]; \n                float3 const v1 = vertices[face.idx[0]]; \n                float3 const v2 = vertices[face.idx[1]]; \n                float3 const v3 = vertices[face.idx[2]]; \n                // Calculate hit position \n                float3 const p = r.o.xyz + r.d.xyz * t_max; \n                // Calculte barycentric coordinates \n                float2 const uv = triangle_calculate_barycentrics(p, v1, v2, v3); \n                // Update hit information \n                hits[global_id].shape_id = face.shape_id; \n                hits[global_id].prim_id = face.prim_id; \n                hits[global_id].uvwt = make_float4(uv.x, uv.y, 0.f, t_max); \n            } \n            else \n            { \n                // Miss here \n                hits[global_id].shape_id = MISS_MARKER; \n                hits[global_id].prim_id = MISS_MARKER; \n            } \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL  \nvoid occluded_main( \n    // BVH nodes \n    GLOBAL bvh_node const* restrict nodes, \n    // Triangle vertices \n    GLOBAL float3 const* restrict vertices, \n    // Triangle indices \n    GLOBAL Face const* restrict faces, \n    // Rays  \n    GLOBAL ray const* restrict rays, \n    // Number of rays \n    GLOBAL int const* restrict num_rays, \n    // Hit data \n    GLOBAL int* hits \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Handle only working subset \n    if (global_id < *num_rays) \n    { \n        // Fetch ray \n        ray const r = rays[global_id]; \n \n        if (ray_is_active(&r)) \n        { \n            // Precompute inverse direction and origin / dir for bbox testing \n            float3 const invdir = safe_invdir(r); \n            float3 const oxinvdir = -r.o.xyz * invdir; \n            // Intersection parametric distance \n            float t_max = r.o.w; \n \n            // Current node address \n            int addr = 0; \n \n            while (addr != INVALID_IDX) \n            { \n                // Fetch next node \n                bvh_node node = nodes[addr]; \n                // Intersect against bbox \n
n ;b\e
n <gE
n M;B"y
n T:C
n \n                // Check if it is a leaf \n                if (LEAFNODE(node)) \n                { \n                    Face face = faces[STARTIDX(node)]; \n#ifdef RR_RAY_MASK \n                    if (ray_get_mask(&r) != face.shape_id) \n                    { \n#endif // RR_RAY_MASK \n                        // Leafs directly store vertex indices \n                        // so we load vertices directly \n                        float3 const v1 = vertices[face.idx[0]]; \n                        float3 const v2 = vertices[face.idx[1]]; \n                        float3 const v3 = vertices[face.idx[2]]; \n                        // Intersect triangle \n                        float const f = fast_intersect_triangle(r, v1, v2, v3, t_max); \n                        // If hit update closest hit distance and index \n                        if (f < t_max) \n                        { \n                            hits[global_id] = HIT_MARKER; \n                            return; \n                        } \n#ifdef RR_RAY_MASK \n                    } \n#endif // RR_RAY_MASK \n                } \n                else \n                { \n                    // It is internal node, so intersect vs both children bounds \n                    float2 const s0 = fast_intersect_bbox1(bounds[node.child0], invdir, oxinvdir, t_max); \n                    float2 const s1 = fast_intersect_bbox1(bounds[node.child1], invdir, oxinvdir, t_max); \n \n                    // Determine which one to traverse \n                    bool const traverse_c0 = (s0.x <= s0.y); \n                    bool const traverse_c1 = (s1.x <= s1.y); \n                    bool const c1first = traverse_c1 && (s0.x > s1.x); \n \n                    if (traverse_c0 || traverse_c1) \n                    { \n                        int deferred = -1; \n \n                        // Determine which one to traverse first \n                        if (c1first || !traverse_c0) \n                        { \n                            // Right one is closer or left one not travesed \n                            addr = node.child1; \n                            deferred = node.child0; \n                        } \n                        else \n                        { \n                            // Traverse left node otherwise \n                            addr = node.child0; \n                            deferred = node.child1; \n                        } \n \n                        // If we traverse both children we need to postpone the node \n                        if (traverse_c0 && traverse_c1) \n                        { \n                            // If short stack is full, we offload it into global memory \n                            if (lm_stack - lm_stack_base >= SHORT_STACK_SIZE * WAVEFRONT_SIZE) \n                            { \n                                for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                                { \n                                    gm_stack[i] = lm_stack_base[i * WAVEFRONT_SIZE]; \n                                } \n \n                                gm_stack += SHORT_STACK_SIZE; \n                                lm_stack = lm_stack_base + WAVEFRONT_SIZE; \n                            } \n \n                            *lm_stack = deferred; \n                            lm_stack += WAVEFRONT_SIZE; \n                        } \n \n                        // Continue traversal \n                        continue; \n                    } \n                } \n \n                // Try popping from local stack \n                lm_stack -= WAVEFRONT_SIZE; \n                addr = *(lm_stack); \n \n                // If we popped INVALID_IDX then check global stack \n                if (addr == INVALID_IDX && gm_stack > gm_stack_base) \n                { \n                    // Adjust stack pointer \n                    gm_stack -= SHORT_STACK_SIZE; \n                    // Copy data from global memory to LDS \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n
n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \n__kernel void segmented_scan_exclusive_int_nocut(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_nocut_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_loc
n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n#define KERNEL __kernel \n#define GLOBAL __global \n#define INLINE __attribute__((always_inline)) \n#define HIT_MARKER 1 \n#define MISS_MARKER -1 \n#define INVALID_IDX -1 \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n/************************************************************************* \nTYPES \n**************************************************************************/ \n \n// Axis aligned bounding box \ntypedef struct \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \n// Ray definition \ntypedef struct \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int doBackfaceCulling; \n    int padding; \n} ray; \n \n// Intersection definition \ntypedef struct \n{ \n    int shape_id; \n    int prim_id; \n    int2 padding; \n \n    float4 uvwt; \n} Intersection; \n \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \nINLINE \nint ray_get_mask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nINLINE \nint ray_is_active(ray const* r) \n{ \n    return r->extra.y; \n} \n \nINLINE \nfloat ray_get_maxt(ray const* r) \n{ \n    return r->o.w; \n} \n \nINLINE \nfloat ray_get_time(ray const* r) \n{ \n    return r->d.w; \n} \n \nINLINE \nint ray_get_doBackfaceCull(ray const* r) \n{ \n    return r->doBackfaceCulling; \n} \n \n/************************************************************************* \nFUNCTIONS \n**************************************************************************/ \n#ifndef APPLE \nINLINE \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \nINLINE \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \nINLINE \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n#endif \n \nINLINE float min3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_min3(a, b, c); \n#else \n    return min(min(a,b), c); \n#endif \n} \n \nINLINE float max3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_max3(a, b, c); \n#else \n    return max(max(a,b), c); \n#endif \n} \n \n \n// Intersect ray against a triangle and return intersection interval value if it is in \n// (0, t_max], return t_max otherwise. \nINLINE \nfloat fast_intersect_triangle(ray r, float3 v1, float3 v2, float3 v3, float t_max) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n \n#ifdef RR_BACKFACE_CULL \n    if (ray_get_doBackfaceCull(&r) && dot(cross(e1, e2), r.d.xyz) > 0.f) \n    { \n        return t_max; \n    } \n#endif // RR_BACKFACE_CULL \n \n    float3 const s1 = cross(r.d.xyz, e2); \n \n    float denom = dot(s1, e1); \n    if (denom == 0.f) \n    { \n        return t_max; \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invd = 1.f / denom; \n#else \n    float const invd = native_recip(denom); \n#endif \n \n    float3 const d = r.o.xyz - v1; \n    float const b1 = dot(d, s1) * invd; \n    float3 const s2 = cross(d, e1); \n    float const b2 = dot(r.d.xyz, s2) * invd; \n    float const temp = dot(e2, s2) * invd; \n \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f
n \n// Axis aligned bounding box \ntypedef struct \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \n// Ray definition \ntypedef struct \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int doBackfaceCulling; \n    int padding; \n} ray; \n \n// Intersection definition \ntypedef struct \n{ \n    int shape_id; \n    int prim_id; \n    int2 padding; \n \n    float4 uvwt; \n} Intersection; \n \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \nINLINE \nint ray_get_mask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nINLINE \nint ray_is_active(ray const* r) \n{ \n    return r->extra.y; \n} \n \nINLINE \nfloat ray_get_maxt(ray const* r) \n{ \n    return r->o.w; \n} \n \nINLINE \nfloat ray_get_time(ray const* r) \n{ \n    return r->d.w; \n} \n \nINLINE \nint ray_get_doBackfaceCull(ray const* r) \n{ \n    return r->doBackfaceCulling; \n} \n \n/************************************************************************* \nFUNCTIONS \n**************************************************************************/ \n#ifndef APPLE \nINLINE \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \nINLINE \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \nINLINE \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n#endif \n \nINLINE float min3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_min3(a, b, c); \n#else \n    return min(min(a,b), c); \n#endif \n} \n \nINLINE float max3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_max3(a, b, c); \n#else \n    return max(max(a,b), c); \n#endif \n} \n \n \n// Intersect ray against a triangle and return intersection interval value if it is in \n// (0, t_max], return t_max otherwise. \nINLINE \nfloat fast_intersect_triangle(ray r, float3 v1, float3 v2, float3 v3, float t_max) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n \n#ifdef RR_BACKFACE_CULL \n    if (ray_get_doBackfaceCull(&r) && dot(cross(e1, e2), r.d.xyz) > 0.f) \n    { \n        return t_max; \n    } \n#endif // RR_BACKFACE_CULL \n \n    float3 const s1 = cross(r.d.xyz, e2); \n \n    float denom = dot(s1, e1); \n    if (denom == 0.f) \n    { \n        return t_max; \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invd = 1.f / denom; \n#else \n    float const invd = native_recip(denom); \n#endif \n \n    float3 const d = r.o.xyz - v1; \n    float const b1 = dot(d, s1) * invd; \n    float3 const s2 = cross(d, e1); \n    float const b2 = dot(r.d.xyz, s2) * invd; \n    float const temp = dot(e2, s2) * invd; \n \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f || temp < 0.f || temp > t_max) \n    { \n        return t_max; \n    } \n    else \n    { \n        return temp; \n    } \n} \n \nINLINE \nfloat3 safe_invdir(ray r) \n{ \n    float const dirx = r.d.x; \n    float const diry = r.d.y; \n    float const dirz = r.d.z; \n    float const ooeps = 1e-8; \n    float3 invdir; \n    invdir.x = 1.0f / (fabs(dirx) > ooeps ? dirx : copysign(ooeps, dirx)); \n    invdir.y = 1.0f / (fabs(diry) > ooeps ? diry : copysign(ooeps, diry)); \n    invdir.z = 1.0f / (fabs(dirz) > ooeps ? dirz : copysign(ooeps, dirz)); \n    return invdir; \n} \n \n// Intersect rays vs bbox and return intersection span.  \n// Intersection criteria is ret.x <= ret.y \nINLINE \nfloat2 fast_intersect_bbox1(bbox box, float3 invdir, float3 oxinvdir, float t_max) \n{ \n    float3 const f = mad(box.pmax.xyz, invdir, oxin
n!r<J{R
n"I\vc
n"a;x
n#define PI 3.14159265358979323846f \n#define KERNEL __kernel \n#define GLOBAL __global \n#define INLINE __attribute__((always_inline)) \n#define HIT_MARKER 1 \n#define MISS_MARKER -1 \n#define INVALID_IDX -1 \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n/************************************************************************* \nTYPES \n**************************************************************************/ \n \n// Axis aligned bounding box \ntypedef struct \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \n// Ray definition \ntypedef struct \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int doBackfaceCulling; \n    int padding; \n} ray; \n \n// Intersection definition \ntypedef struct \n{ \n    int shape_id; \n    int prim_id; \n    int2 padding; \n \n    float4 uvwt; \n} Intersection; \n \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \nINLINE \nint ray_get_mask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nINLINE \nint ray_is_active(ray const* r) \n{ \n    return r->extra.y; \n} \n \nINLINE \nfloat ray_get_maxt(ray const* r) \n{ \n    return r->o.w; \n} \n \nINLINE \nfloat ray_get_time(ray const* r) \n{ \n    return r->d.w; \n} \n \nINLINE \nint ray_get_doBackfaceCull(ray const* r) \n{ \n    return r->doBackfaceCulling; \n} \n \n/************************************************************************* \nFUNCTIONS \n**************************************************************************/ \n#ifndef APPLE \nINLINE \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \nINLINE \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \nINLINE \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n#endif \n \nINLINE float min3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_min3(a, b, c); \n#else \n    return min(min(a,b), c); \n#endif \n} \n \nINLINE float max3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_max3(a, b, c); \n#else \n    return max(max(a,b), c); \n#endif \n} \n \n \n// Intersect ray against a triangle and return intersection interval value if it is in \n// (0, t_max], return t_max otherwise. \nINLINE \nfloat fast_intersect_triangle(ray r, float3 v1, float3 v2, float3 v3, float t_max) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n \n#ifdef RR_BACKFACE_CULL \n    if (ray_get_doBackfaceCull(&r) && dot(cross(e1, e2), r.d.xyz) > 0.f) \n    { \n        return t_max; \n    } \n#endif // RR_BACKFACE_CULL \n \n    float3 const s1 = cross(r.d.xyz, e2); \n \n    float denom = dot(s1, e1); \n    if (denom == 0.f) \n    { \n        return t_max; \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invd = 1.f / denom; \n#else \n    float const invd = native_recip(denom); \n#endif \n \n    float3 const d = r.o.xyz - v1; \n    float const b1 = dot(d, s1) * invd; \n    float3 const s2 = cross(d, e1); \n    float const b2 = dot(r.d.xyz, s2) * invd; \n    float const temp = dot(e2, s2) * invd; \n \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f || temp < 0.f || temp > t_max) \n    { \n        return t_max; \n    } \n    else \n    { \n        return temp; \n    } \n} \n \nINLINE \nfloat3 safe_invdir(ray
n$v;b
n&ɻwh\b
n'>RR
n)g;v
n+C;\fK
n,:Ff
n-:LT̹K
n.<Uv
n/ ;l
n// Axis aligned bounding box \ntypedef struct \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \n// Ray definition \ntypedef struct \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int doBackfaceCulling; \n    int padding; \n} ray; \n \n// Intersection definition \ntypedef struct \n{ \n    int shape_id; \n    int prim_id; \n    int2 padding; \n \n    float4 uvwt; \n} Intersection; \n \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \nINLINE \nint ray_get_mask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nINLINE \nint ray_is_active(ray const* r) \n{ \n    return r->extra.y; \n} \n \nINLINE \nfloat ray_get_maxt(ray const* r) \n{ \n    return r->o.w; \n} \n \nINLINE \nfloat ray_get_time(ray const* r) \n{ \n    return r->d.w; \n} \n \nINLINE \nint ray_get_doBackfaceCull(ray const* r) \n{ \n    return r->doBackfaceCulling; \n} \n \n/************************************************************************* \nFUNCTIONS \n**************************************************************************/ \n#ifndef APPLE \nINLINE \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \nINLINE \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \nINLINE \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n#endif \n \nINLINE float min3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_min3(a, b, c); \n#else \n    return min(min(a,b), c); \n#endif \n} \n \nINLINE float max3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_max3(a, b, c); \n#else \n    return max(max(a,b), c); \n#endif \n} \n \n \n// Intersect ray against a triangle and return intersection interval value if it is in \n// (0, t_max], return t_max otherwise. \nINLINE \nfloat fast_intersect_triangle(ray r, float3 v1, float3 v2, float3 v3, float t_max) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n \n#ifdef RR_BACKFACE_CULL \n    if (ray_get_doBackfaceCull(&r) && dot(cross(e1, e2), r.d.xyz) > 0.f) \n    { \n        return t_max; \n    } \n#endif // RR_BACKFACE_CULL \n \n    float3 const s1 = cross(r.d.xyz, e2); \n \n    float denom = dot(s1, e1); \n    if (denom == 0.f) \n    { \n        return t_max; \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invd = 1.f / denom; \n#else \n    float const invd = native_recip(denom); \n#endif \n \n    float3 const d = r.o.xyz - v1; \n    float const b1 = dot(d, s1) * invd; \n    float3 const s2 = cross(d, e1); \n    float const b2 = dot(r.d.xyz, s2) * invd; \n    float const temp = dot(e2, s2) * invd; \n \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f || temp < 0.f || temp > t_max) \n    { \n        return t_max; \n    } \n    else \n    { \n        return temp; \n    } \n} \n \nINLINE \nfloat3 safe_invdir(ray r) \n{ \n    float const dirx = r.d.x; \n    float const diry = r.d.y; \n    float const dirz = r.d.z; \n    float const ooeps = 1e-8; \n    float3 invdir; \n    invdir.x = 1.0f / (fabs(dirx) > ooeps ? dirx : copysign(ooeps, dirx)); \n    invdir.y = 1.0f / (fabs(diry) > ooeps ? diry : copysign(ooeps, diry)); \n    invdir.z = 1.0f / (fabs(dirz) > ooeps ? dirz : copysign(ooeps, dirz)); \n    return invdir; \n} \n \n// Intersect rays vs bbox and return intersection span.  \n// Intersection criteria is ret.x <= ret.y \nINLINE \nfloat2 fast_intersect_bbox1(bbox box, float3 invdir, float3 oxinvdir, float t_max) \n{ \n    float3 const f = mad(box.pmax.xyz, invdir, oxinvdir); \n    float3
n// Copyright 2017 Valve Corporation. All rights reserved. Subject to the following license:\n// https://valvesoftware.github.io/steam-audio/license.html\n//\n\n#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable \n#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n\n// --------------------------------------------------------------------------------------------------------------------\n// Constants\n// --------------------------------------------------------------------------------------------------------------------\n\n#define PI                          3.14159f\n#define SOURCE_RADIUS               0.1f\n#define LISTENER_RADIUS             0.1f\n#define SPEED_OF_SOUND              340.0f\n#define RAY_SURFACE_OFFSET          1e-2f\n#define SPECULAR_EXPONENT           1e+2f\n#define NUM_BANDS                   3\n#define NUM_BINS                    256\n#define BIN_DURATION                0.01f\n#define NUM_LOCAL_HISTOGRAMS        2                     // Number of copies for scrambling (tunable)\n\n// --------------------------------------------------------------------------------------------------------------------\n// CoordinateSpace\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) CoordinateSpace_t\n{\n    float3 right;\n    float3 up;\n    float3 ahead;\n    float3 origin;\n} CoordinateSpace;\n\nCoordinateSpace createCoordinateSpace(float3 normal)\n{\n    CoordinateSpace space;\n    space.ahead = normal;\n\n    if (fabs(normal.x) > fabs(normal.z))\n    {\n        float3 right = (float3) (-normal.y, normal.x, 0.0f);\n        space.right = normalize(right);\n    }\n    else\n    {\n        float3 right = (float3) (0.0f, -normal.z, normal.y);\n        space.right = normalize(right);\n    }\n\n    space.up = cross(space.right, space.ahead);\n\n    return space;\n}\n\nfloat3 transformLocalToWorld(CoordinateSpace space, \n                             float3 direction)\n{\n    return direction.x * space.right + direction.y * space.up - direction.z * space.ahead;\n}\n\nfloat3 transformWorldToLocal(CoordinateSpace space, \n                             float3 direction)\n{\n    float3 transformedDirection;\n    transformedDirection.x = dot(direction, space.right);\n    transformedDirection.y = dot(direction, space.up);\n    transformedDirection.z = -dot(direction, space.ahead);\n    return transformedDirection;\n}\n\nfloat3 transformHemisphereSample(float3 direction, \n                                 float3 normal)\n{\n    CoordinateSpace tangentSpace = createCoordinateSpace(normal);\n    return normalize(transformLocalToWorld(tangentSpace, direction));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Random Sampling\n// --------------------------------------------------------------------------------------------------------------------\n\n// The following code is from the Radeon Rays / Baikal GitHub repository. It can be found at:\n//      https://github.com/GPUOpen-LibrariesAndSDKs/RadeonProRender-Baikal/blob/master/Baikal/Kernels/CL/sampling.cl\n\ntypedef struct RNG_t\n{\n    uint    value;\n} RNG;\n\nuint wangHash(uint seed)\n{\n    seed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nuint randUint(local RNG* rng)\n{\n    rng->value = wangHash(1664525U * rng->value + 1013904223U);\n    return rng->value;\n}\n\nfloat randFloat(local RNG* rng)\n{\n    return ((float)randUint(rng)) / 0xffffffffU;\n}\n\nvoid initRNG(uint seed, local RNG* rng)\n{\n    rng->value = wangHash(seed);\n}\n\nfloat2 uniformRandom2d(local RNG* rng)\n{\n    return (float2) (randFloat(rng), randFloat(rng));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Directivity\n
n/97vO
n/C;7
n0,;P0
n03>Pu
n0<)w
n0A:c
n0ƻAsm
n1#<OP8
n1=L88
n1i>u
n2:Nu
n4,;E
n5:\n
n6:!H
n7!;i
n76OL;\nq
n7;XPF
n7T7H
n8=]H
n9%HL
n99%ŻSbǻK
n9FѬ:r
n9\f˜9
n9ofi96
n:/9h
n:/QY
n:3;T
n:3sA
n:VT%;Z
n:\b$o8c
n:\b=5a
n:\bRs
n:\eoe9
n:l)s
n:m~a
n;5Yٺ3w
n;@ d:I
n;A^L
n;C4d<n
n;Ja[;Y
n;Q+f
n;V\fw;\f
n;\r5
n;\v0t;W
n;ai;X
n;b92
n;i|y
n;ku\b;0\nz
n;lvT8\fgM
n;r\b9
n;r\eW9
n;y[f
n<*ki
n</N9
n<4\ro
n<F\rh
n<O}w<p
n<\e4
n<\vzV
n<f8\r
n<s]7
n<uyN
n<vǨ8
n<z4ٻi
n=25b=v
n=4~y
n=9rD
n=TEԼYt
n=e}Q>p
n=fZȼ4u
n=jn\f
n=xnd
n>&CS
n>&S4
n>6<8
n><oF>d
n>Hsk=Q
n>J9H
n>L<Zse
n>Y\n\n>0
n>\e4E
n>log2
n>w%n
n>ֻ6zW
n?0ho?s
n?6\e
n?:Da\t
n?P;H
n?arh
nA>;b4L
nA>Spz
nB/:m
nBϺُt
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n#pragma OPENCL EXTENSION cl_khr_fp16 : enable \n \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n#define KERNEL __kernel \n#define GLOBAL __global \n#define INLINE __attribute__((always_inline)) \n#define HIT_MARKER 1 \n#define MISS_MARKER -1 \n#define INVALID_IDX -1 \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n/************************************************************************* \nTYPES \n**************************************************************************/ \n \n// Axis aligned bounding box \ntypedef struct \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \n// Ray definition \ntypedef struct \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int doBackfaceCulling; \n    int padding; \n} ray; \n \n// Intersection definition \ntypedef struct \n{ \n    int shape_id; \n    int prim_id; \n    int2 padding; \n \n    float4 uvwt; \n} Intersection; \n \n \n/************************************************************************* \nHELPER FUNCTIONS \n
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable \n#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable \n \n// --------------------- CONSTANTS ------------------------ \n// add neutral elements \n__constant int neutral_add_int = 0; \n__constant float neutral_add_float = 0; \n__constant float3 neutral_add_float3 = (float3)(0.0, 0.0, 0.0); \n// max neutral elements \n__constant int neutral_max_int = INT_MIN; \n__constant float neutral_max_float = FLT_MIN; \n__constant float3 neutral_max_float3 = (float3)(FLT_MIN, FLT_MIN, FLT_MIN); \n// min neutral elements \n__constant int neutral_min_int = INT_MAX; \n__constant float neutral_min_float = FLT_MAX; \n__constant float3 neutral_min_float3 = (float3)(FLT_MAX, FLT_MAX, FLT_MAX); \n \n__constant float epsilon = .00001f; \n \n// --------------------- HELPERS ------------------------ \n//#define INT_MAX 0x7FFFFFFF \n \n// -------------------- MACRO -------------------------- \n// Apple OCL compiler has this by default,  \n// so embrace with #ifdef in the future \n#define DEFINE_MAKE_4(type)\\ \n    type##4 make_##type##4(type x, type y, type z, type w)\\ \n{\\ \n    type##4 res;\\ \n    res.x = x;\\ \n    res.y = y;\\ \n    res.z = z;\\ \n    res.w = w;\\ \n    return res;\\ \n} \n \n// Multitype macros to handle parallel primitives \n#define DEFINE_SAFE_LOAD_4(type)\\ \n    type##4 safe_load_##type##4(__global type##4* source, uint idx, uint sizeInTypeUnits)\\ \n{\\ \n    type##4 res = make_##type##4(0, 0, 0, 0);\\ \n    if (((idx + 1) << 2)  <= sizeInTypeUnits)\\ \n    res = source[idx];\\ \n    else\\ \n    {\\ \n    if ((idx << 2) < sizeInTypeUnits) res.x = source[idx].x;\\ \n    if ((idx << 2) + 1 < sizeInTypeUnits) res.y = source[idx].y;\\ \n    if ((idx << 2) + 2 < sizeInTypeUnits) res.z = source[idx].z;\\ \n    }\\ \n    return res;\\ \n} \n \n#define DEFINE_SAFE_STORE_4(type)\\ \n    void safe_store_##type##4(type##4 val, __global type##4* dest, uint idx, uint sizeInTypeUnits)\\ \n{\\ \n    if ((idx + 1) * 4  <= sizeInTypeUnits)\\ \n    dest[idx] = val;\\ \n    else\\ \n    {\\ \n    if (idx*4 < sizeInTypeUnits) dest[idx].x = val.x;\\ \n    if (idx*4 + 1 < sizeInTypeUnits) dest[idx].y = val.y;\\ \n    if (idx*4 + 2 < sizeInTypeUnits) dest[idx].z = val.z;\\ \n    }\\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE(type)\\ \n    void group_scan_exclusive_##type(int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (localId == 0)\\ \n    shmem[groupSize - 1] = 0;\\ \n
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n#define KERNEL __kernel \n#define GLOBAL __global \n#define INLINE __attribute__((always_inline)) \n#define HIT_MARKER 1 \n#define MISS_MARKER -1 \n#define INVALID_IDX -1 \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n/************************************************************************* \nTYPES \n**************************************************************************/ \n \n// Axis aligned bounding box \ntypedef struct \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \n// Ray definition \ntypedef struct \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int doBackfaceCulling; \n    int padding; \n} ray; \n \n// Intersection definition \ntypedef struct \n{ \n    int shape_id; \n    int prim_id; \n    int2 padding; \n \n    float4 uvwt; \n} Intersection; \n \n \n/************************************************************************* \nHELPER FUNCTIONS \n
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n/** \n    \\file build_bvh.cl \n    \\author Dmitry Kozlov \n    \\version 1.0 \n    \\brief HLBVH build implementation \n \n    IntersectorHlbvh implementation is based on the following paper: \n    "HLBVH: Hierarchical LBVH Construction for Real-Time Ray Tracing" \n    Jacopo Pantaleoni (NVIDIA), David Luebke (NVIDIA), in High Performance Graphics 2010, June 2010 \n    https://research.nvidia.com/sites/default/files/publications/HLBVH-final.pdf \n \n    Pros: \n        -Very fast to build and update. \n    Cons: \n        -Poor BVH quality, slow traversal. \n */ \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n#define KERNEL __kernel \n#define GLOBAL __global \n#define INLINE __attribute__((always_inline)) \n#define HIT_MARKER 1 \n#define MISS_MARKER -1 \n#define INVALID_IDX -1 \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n/************************************************************************* \nTYPES \n**************************************************************************/ \n
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n/** \n    \\file intersect_2level_skiplinkscl \n    \\author Dmitry Kozlov \n    \\version 1.0 \n    \\brief Intersector implementation based on 2-level BVH with skip links. \n \n    IntersectorSkipLinks implementation is based on the modification of the following paper: \n    "Efficiency Issues for Ray Tracing" Brian Smits \n    http://www.cse.chalmers.se/edu/year/2016/course/course/TDA361/EfficiencyIssuesForRayTracing.pdf \n \n    Intersector is using binary BVH with a single bounding box per node. BVH layout guarantees \n    that left child of an internal node lies right next to it in memory. Each BVH node has a  \n    skip link to the node traversed next. Intersector builds its own BVH for each scene object  \n    and then top level BVH across all bottom level BVHs. Top level leafs keep object transforms and \n    might reference other leafs making instancing possible. \n \n \n    Pros: \n        -Simple and efficient kernel with low VGPR pressure. \n        -Can traverse trees of arbitrary depth. \n        -Supports motion blur. \n        -Supports instancing. \n        -Fast to refit. \n    Cons: \n        -Travesal order is fixed, so poor algorithmic characteristics. \n        -Does not benefit from BVH quality optimizations. \n */ \n \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n/** \n    \\file intersect_bvh2_skiplinks.cl \n    \\author Dmitry Kozlov \n    \\version 1.0 \n    \\brief Intersector implementation based on BVH with skip links. \n \n    IntersectorSkipLinks implementation is based on the following paper: \n    "Efficiency Issues for Ray Tracing" Brian Smits \n    http://www.cse.chalmers.se/edu/year/2016/course/course/TDA361/EfficiencyIssuesForRayTracing.pdf \n \n    Intersector is using binary BVH with a single bounding box per node. BVH layout guarantees \n    that left child of an internal node lies right next to it in memory. Each BVH node has a  \n    skip link to the node traversed next. The traversal pseude code is \n \n        while(addr is valid) \n        { \n            node <- fetch next node at addr \n            if (rays intersects with node bbox) \n            { \n                if (node is leaf) \n                    intersect leaf \n                else \n                { \n                    addr <- addr + 1 (follow left child) \n                    continue \n                } \n            } \n \n            addr <- skiplink at node (follow next) \n        } \n \n    Pros: \n        -Simple and efficient kernel with low VGPR pressure. \n        -Can traverse trees of arbitrary depth. \n    Cons: \n        -Travesal order is fixed, so poor algorithmic characteristics. \n        -Does not benefit from BVH quality optimizations. \n */ \n \n/************************************************************************* \n INCLUDES \n **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n/** \n    \\file intersect_hlbvh_stack.cl \n    \\author Dmitry Kozlov \n    \\version 1.0 \n    \\brief HLBVH build implementation \n \n    IntersectorHlbvh implementation is based on the following paper: \n    "HLBVH: Hierarchical LBVH Construction for Real-Time Ray Tracing" \n    Jacopo Pantaleoni (NVIDIA), David Luebke (NVIDIA), in High Performance Graphics 2010, June 2010 \n    https://research.nvidia.com/sites/default/files/publications/HLBVH-final.pdf \n \n    Pros: \n        -Very fast to build and update. \n    Cons: \n        -Poor BVH quality, slow traversal. \n */ \n \n /************************************************************************* \n  INCLUDES \n  **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n#define KERNEL __kernel \n#define GLOBAL __global \n#define INLINE __attribute__((always_inline)) \n#define HIT_MARKER 1 \n#define MISS_MARKER -1 \n#define INVALID_IDX -1 \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n/************************************************************************* \nTYPES \n
nD8)\bP
nD9Q$t
nEl:c3
nEȾ1l8
nGM;$i
nG۽-F0
nH;A\bu
nH;H s\bH
nH;Q\bu
nH;Q\bu\rL
nHȻ=59
nI7;7W
nINLINE \nint ray_get_mask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nINLINE \nint ray_is_active(ray const* r) \n{ \n    return r->extra.y; \n} \n \nINLINE \nfloat ray_get_maxt(ray const* r) \n{ \n    return r->o.w; \n} \n \nINLINE \nfloat ray_get_time(ray const* r) \n{ \n    return r->d.w; \n} \n \nINLINE \nint ray_get_doBackfaceCull(ray const* r) \n{ \n    return r->doBackfaceCulling; \n} \n \n/************************************************************************* \nFUNCTIONS \n**************************************************************************/ \n#ifndef APPLE \nINLINE \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \nINLINE \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \nINLINE \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n#endif \n \nINLINE float min3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_min3(a, b, c); \n#else \n    return min(min(a,b), c); \n#endif \n} \n \nINLINE float max3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_max3(a, b, c); \n#else \n    return max(max(a,b), c); \n#endif \n} \n \n \n// Intersect ray against a triangle and return intersection interval value if it is in \n// (0, t_max], return t_max otherwise. \nINLINE \nfloat fast_intersect_triangle(ray r, float3 v1, float3 v2, float3 v3, float t_max) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n \n#ifdef RR_BACKFACE_CULL \n    if (ray_get_doBackfaceCull(&r) && dot(cross(e1, e2), r.d.xyz) > 0.f) \n    { \n        return t_max; \n    } \n#endif // RR_BACKFACE_CULL \n \n    float3 const s1 = cross(r.d.xyz, e2); \n \n    float denom = dot(s1, e1); \n    if (denom == 0.f) \n    { \n        return t_max; \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invd = 1.f / denom; \n#else \n    float const invd = native_recip(denom); \n#endif \n \n    float3 const d = r.o.xyz - v1; \n    float const b1 = dot(d, s1) * invd; \n    float3 const s2 = cross(d, e1); \n    float const b2 = dot(r.d.xyz, s2) * invd; \n    float const temp = dot(e2, s2) * invd; \n \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f || temp < 0.f || temp > t_max) \n    { \n        return t_max; \n    } \n    else \n    { \n        return temp; \n    } \n} \n \nINLINE \nfloat3 safe_invdir(ray r) \n{ \n    float const dirx = r.d.x; \n    float const diry = r.d.y; \n    float const dirz = r.d.z; \n    float const ooeps = 1e-8; \n    float3 invdir; \n    invdir.x = 1.0f / (fabs(dirx) > ooeps ? dirx : copysign(ooeps, dirx)); \n    invdir.y = 1.0f / (fabs(diry) > ooeps ? diry : copysign(ooeps, diry)); \n    invdir.z = 1.0f / (fabs(dirz) > ooeps ? dirz : copysign(ooeps, dirz)); \n    return invdir; \n} \n \n// Intersect rays vs bbox and return intersection span.  \n// Intersection criteria is ret.x <= ret.y \nINLINE \nfloat2 fast_intersect_bbox1(bbox box, float3 invdir, float3 oxinvdir, float t_max) \n{ \n    float3 const f = mad(box.pmax.xyz, invdir, oxinvdir); \n    float3 const n = mad(box.pmin.xyz, invdir, oxinvdir); \n    float3 const tmax = max(f, n); \n    float3 const tmin = min(f, n); \n    float const t1 = min(min3(tmax.x, tmax.y, tmax.z), t_max); \n    float const t0 = max(max3(tmin.x, tmin.y, tmin.z), 0.f); \n    return make_float2(t0, t1); \n} \n \n// Given a point in triangle plane, calculate its barycentrics \nINLINE \nfloat2 triangle_calculate_barycentrics(float3 p, float3 v1, float3 v2, float3 v3) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n
nINLINE \nint ray_get_mask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nINLINE \nint ray_is_active(ray const* r) \n{ \n    return r->extra.y; \n} \n \nINLINE \nfloat ray_get_maxt(ray const* r) \n{ \n    return r->o.w; \n} \n \nINLINE \nfloat ray_get_time(ray const* r) \n{ \n    return r->d.w; \n} \n \nINLINE \nint ray_get_doBackfaceCull(ray const* r) \n{ \n    return r->doBackfaceCulling; \n} \n \n/************************************************************************* \nFUNCTIONS \n**************************************************************************/ \n#ifndef APPLE \nINLINE \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \nINLINE \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \nINLINE \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \nINLINE \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n#endif \n \nINLINE float min3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_min3(a, b, c); \n#else \n    return min(min(a,b), c); \n#endif \n} \n \nINLINE float max3(float a, float b, float c) \n{ \n#ifdef AMD_MEDIA_OPS \n    return amd_max3(a, b, c); \n#else \n    return max(max(a,b), c); \n#endif \n} \n \n \n// Intersect ray against a triangle and return intersection interval value if it is in \n// (0, t_max], return t_max otherwise. \nINLINE \nfloat fast_intersect_triangle(ray r, float3 v1, float3 v2, float3 v3, float t_max) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n \n#ifdef RR_BACKFACE_CULL \n    if (ray_get_doBackfaceCull(&r) && dot(cross(e1, e2), r.d.xyz) > 0.f) \n    { \n        return t_max; \n    } \n#endif // RR_BACKFACE_CULL \n \n    float3 const s1 = cross(r.d.xyz, e2); \n \n    float denom = dot(s1, e1); \n    if (denom == 0.f) \n    { \n        return t_max; \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invd = 1.f / denom; \n#else \n    float const invd = native_recip(denom); \n#endif \n \n    float3 const d = r.o.xyz - v1; \n    float const b1 = dot(d, s1) * invd; \n    float3 const s2 = cross(d, e1); \n    float const b2 = dot(r.d.xyz, s2) * invd; \n    float const temp = dot(e2, s2) * invd; \n \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f || temp < 0.f || temp > t_max) \n    { \n        return t_max; \n    } \n    else \n    { \n        return temp; \n    } \n} \n \nINLINE \nfloat3 safe_invdir(ray r) \n{ \n    float const dirx = r.d.x; \n    float const diry = r.d.y; \n    float const dirz = r.d.z; \n    float const ooeps = 1e-8; \n    float3 invdir; \n    invdir.x = 1.0f / (fabs(dirx) > ooeps ? dirx : copysign(ooeps, dirx)); \n    invdir.y = 1.0f / (fabs(diry) > ooeps ? diry : copysign(ooeps, diry)); \n    invdir.z = 1.0f / (fabs(dirz) > ooeps ? dirz : copysign(ooeps, dirz)); \n    return invdir; \n} \n \n// Intersect rays vs bbox and return intersection span.  \n// Intersection criteria is ret.x <= ret.y \nINLINE \nfloat2 fast_intersect_bbox1(bbox box, float3 invdir, float3 oxinvdir, float t_max) \n{ \n    float3 const f = mad(box.pmax.xyz, invdir, oxinvdir); \n    float3 const n = mad(box.pmin.xyz, invdir, oxinvdir); \n    float3 const tmax = max(f, n); \n    float3 const tmin = min(f, n); \n    float const t1 = min(min3(tmax.x, tmax.y, tmax.z), t_max); \n    float const t0 = max(max3(tmin.x, tmin.y, tmin.z), 0.f); \n    return make_float2(t0, t1); \n} \n \n// Given a point in triangle plane, calculate its barycentrics \nINLINE \nfloat2 triangle_calculate_barycentrics(float3 p, float3 v1, float3 v2, float3 v3) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n    float3 const e = p - v1; \n    float const d00
nIr;15\e<[g
nJ:A+5
nJ|;6v5
nK7:v8
nL\vPLc
nMcL$lM
nNANאB
nNq:RuY
nO;HbK
nO<u\a\e
nO}R7V
nOƼ!b\r
nP-<9
nP_=bw
nQ :oV
nR#;4
nR;SdH
nS:](1;m2
nS;GP
nSa=d
nS|;1
nT9Aq̼H
nUp<J
nV5> 8
nV;\e\e
nVl<TJG
nVǺciºD
nW:n$Z;K5J
nW\a;O
nWashington1
nX;O냻R
nXY8Ŋ\\a8łXY
nY<*y1
nYD\alġ*Y
nZ<vSk
nZ`<3g
nZeSd
n[:O9d
n\\8z
n\\q łX
n\a9SB;:9
n\a\a;A\e
n\abA|H
n\ay<{c
n\b:A枻y
n\b=jv8
n\bI+.H
n\bJ<I
n\bf\fn\n
n\e>BJb
n\e\n=U|O
n\es=]T
n\fּI
n\n// NOTE: Custom directivity callbacks are not supported at this time.\ntypedef struct __attribute__((packed)) Directivity_t\n{\n    float dipoleWeight;\n    float dipolePower;\n} Directivity;\n\nfloat evaluateDirectivity(float3 point, \n                          CoordinateSpace coordinates, \n                          Directivity directivity)\n{\n    float3 worldSpaceDirection = normalize(point - coordinates.origin);\n    float3 localSpaceDirection = transformWorldToLocal(coordinates, worldSpaceDirection);\n\n    float cosine = -localSpaceDirection.z;\n    return pow(fabs((1.0f - directivity.dipoleWeight) + directivity.dipoleWeight * cosine), directivity.dipolePower);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Material\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) Material_t\n{\n    float  absorptionLow;\n    float  absorptionMid;\n    float  absorptionHigh;\n    float  scattering;\n    float  transmissionLow;\n    float  transmissionMid;\n    float  transmissionHigh;\n} Material;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Radeon Rays Helpers\n// --------------------------------------------------------------------------------------------------------------------\n\n// This must exactly match the ray data structure (struct ray) used by Radeon Rays.\ntypedef struct Ray_t\n{\n    float4  o;\n    float4  d;\n    int2    extra;\n    int2    padding;\n} Ray;\n\n// This must exactly match the hit data structure (struct Intersection) used by Radeon Rays.\ntypedef struct Hit_t\n{\n    int       shapeid;\n    int       primid;\n    int       padding0;\n    int       padding1;\n    float4    uvwt;\n} Hit;\n\n// --------------------------------------------------------------------------------------------------------------------\n// IIR Filtering\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct IIR_t\n{\n    float a1, a2;\n    float b0, b1, b2;\n} IIR;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void generateCameraRays(global CoordinateSpace* camera, \n                               global Ray* rays)\n{\n    uint width = get_global_size(0);\n    uint height = get_global_size(1);\n    uint u = get_global_id(0);\n    uint v = get_global_id(1);\n    uint index = v * width + u;\n\n    float du = ((u / (float) width) - 0.5f) * 2.0f;\n    float dv = ((v / (float) height) - 0.5f) * 2.0f;\n\n    rays[index].o = (float4) (camera->origin, FLT_MAX);\n    rays[index].d = (float4) (normalize(du * camera->right + dv * camera->up - camera->ahead), 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\nkernel void generateListenerRays(global CoordinateSpace* listeners, \n                                 global float4* sphereSamples, \n                                 global Ray* rays)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t listenerIndex = get_global_id(1);\n    size_t index = listenerIndex * get_global_size(0) + rayIndex;\n\n    rays[index].o = (float4) (listeners[listenerIndex].origin, FLT_MAX);\n    rays[index].d = (float4) (sphereSamples[rayIndex].xyz, 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Sphere Occlusion Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat raySphereIntersect(global const Ray* ray,\n                         float3 center,\n
n\n<L6
n\n\f
n\nbq|H
n\nҼR
n\rba|H
n\t$;AW
n\t;ud
n\tbQ|H
n\v>c
n\vR<q
n\vb<c\e
n]8-Qz
n]\r\bd\f
n]s9P
n]ͺX0
n^r;R4
n`q<D9Q
na\e>i
nan(ind
nan(snan
naۼyt
nb!\fHY
nb!|H
nb\a<\n
nbaL X
nba~\b
nbb}XB
nbu;T
nc:\ba
nc<\e"7
ncd>0
ncڼY\a
nd'<T\f
nd1;,A
nd8<D1
ndC;D
ndN9^5
nda:h\b
ne::v
ne;=wgU
need dictionary
network down
network reset
network unreachable
new-zealand
newmtl material_%d\n
nextafter
nfA>MI\f
nfD9\nt\tH
nfe;h
nfffff
ng:2p5
ngN;1
ngf>ZL
ngo<E
nh0;7F
nh;R\b
nh;xl
nh<Spz
nhԼwc
ni#<v\a
ni&<5
ni/=4M
niø>2i
niۺ\e
nj;\rIe9
nk;\b$d
nkB;z
nm9C1
nmȻ/n
nn=<AI
nnu;Sl
no buffer space
no child process
no link
no lock available
no message
no message available
no protocol option
no space on device
no stream resources
no such device
no such device or address
no such file or directory
no such process
no9yaa
no:%\nO<dA
no;\t
no;o3\e
noJ;1
nodes
norwegian
norwegian-bokmal
norwegian-nynorsk
not a directory
not a socket
not a stream
not all buffers are unmapped
not connected
not enough memory
not supported
not supported node type in bvh_statistics
not:݊n
npA<0
npJ:4
np\t`\b0
np\t`\bP
np\t`\bP!X
np\t`\bP!Z
np\t`\bP!g
npɺL+\e
nq:\bx0
nqS<r
nr7;T
nr;r$\a
nr<UV
nre;X,K
ns<\r
nt91b\f:뜈94
nt=Ac
nu>mo
numBilinearFaces
numComplexFaces
numFaces
numIrregularQuadFaces
numRegularQuadFaces
numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localkeys >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LDS \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localkeys.x; \n            keys[newoffset.y] = localkeys.y; \n            keys[newoffset.z] = localkeys.z; \n            keys[newoffset.w] = localkeys.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localkeys.x = keys[localid << 2]; \n            localkeys.y = keys[(localid << 2) + 1]; \n            localkeys.z = keys[(localid << 2) + 2]; \n            localkeys.w = keys[(localid << 2) + 3]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals.x = keys[localid << 2]; \n            localvals.y = keys[(localid << 2) + 1]; \n            localvals.z = keys[(localid << 2) + 2]; \n            localvals.w = keys[(localid << 2) + 3]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n        int4 bin = (localkeys >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.x; \n            out_values[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin
nv?:Fx
nvdirtop = invdir; \n            float const t_max = r.o.w; \n \n            // We need to keep original ray around for returns from bottom hierarchy \n            ray top_ray = r; \n \n            // Fetch top level BVH index \n            int addr = root_idx; \n            // Set top index \n            int top_addr = INVALID_IDX; \n \n            while (addr != INVALID_IDX) \n            { \n                // Fetch next node \n                bvh_node node = nodes[addr]; \n                // Intersect against bbox \n                float2 s = fast_intersect_bbox1(node, invdir, -r.o.xyz * invdir, t_max); \n \n                if (s.x <= s.y) \n                { \n                    if (LEAFNODE(node)) \n                    { \n                        // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                        // or containing another BVH (top level hierarhcy) \n                        if (top_addr != INVALID_IDX) \n                        { \n                            // Intersect leaf here \n                            // \n                            int const face_idx = STARTIDX(node); \n                            Face const face = faces[face_idx]; \n                            float3 const v1 = vertices[face.idx[0]]; \n                            float3 const v2 = vertices[face.idx[1]]; \n                            float3 const v3 = vertices[face.idx[2]]; \n \n                            // Intersect triangle \n                            float const f = fast_intersect_triangle(r, v1, v2, v3, t_max); \n                            // If hit update closest hit distance and index \n                            if (f < t_max) \n                            { \n                                hits[global_id] = HIT_MARKER; \n                                return; \n                            } \n \n                            // And goto next node \n                            addr = NEXT(node); \n                        } \n                        else \n                        { \n                            // This is top level hierarchy leaf \n                            // Save top node index for return \n                            top_addr = addr; \n                            // Get shape descrition struct index \n                            int shape_idx = SHAPEIDX(node); \n                            // Get shape mask \n                            const unsigned int shapeDisabled = shapes[shape_idx].shapeDisabled; \n#ifdef RR_RAY_MASK \n                            const int shapeId = shapes[shape_idx].id; \n#endif // RR_RAY_MASK \n                            // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                            // otherwise skip the subtree \n                            if (!shapeDisabled  \n#ifdef RR_RAY_MASK \n                                && ray_get_mask(&r) != shapeId \n#endif // RR_RAY_MASK \n                                ) \n                            { \n                                // Fetch bottom level BVH index \n                                addr = shapes[shape_idx].bvh_idx; \n \n                                // Fetch BVH transform \n                                float4 wmi0 = shapes[shape_idx].m0; \n                                float4 wmi1 = shapes[shape_idx].m1; \n                                float4 wmi2 = shapes[shape_idx].m2; \n                                float4 wmi3 = shapes[shape_idx].m3; \n \n                                r = transform_ray(r, wmi0, wmi1, wmi2, wmi3); \n                                // Recalc invdir \n                                invdir = safe_invdir(r); \n                                // And continue traversal of the bottom level BVH \n                                continue; \n                            } \n                            else \n                            { \n                                addr = INVALID_IDX; \n                            } \n                        } \n                    } \n
nv}:gn
nv¼\f6
nx:V"3
nxm;n
nzW;soi
nzԉY9
n{;DX
n~\fX\n
n½<FM
nĻljs9
nƉ;8XB
nȉD$DH
nɍ\f8fD
nʈL$Wba
n˺Zu3
n̼myƼN
nϬ;DD
nӽoZ\r
nֺ]Gc;oq
nۺc{k
nܺ#9Z8\rx
nߋ:qZk
nDkt
o ;^Y
o!:5V
o"I=q
o"j=9
o#r;5C
o%8uH
o%iuz
o%l:3
o%{IiO
o&;Ts\n9
o):8tR\e
o-6yQ
o-C5O
o-LK3
o-[J3
o-\v4O
o-\vOP
o-q=3j
o0;\acL;&1
o1H:\r
o2;ht7
o2R<e
o4;"Q\r
o5!56
o5"tj
o5/\eR
o59`6
o5=gD
o5>w1
o5?@R
o5G=Q
o5K"R
o5T!N
o5\rv1
o5\rxw
o5^36
o5o>R
o5v/J
o7:n>L:F
o8%;n
o9?PI
o9JBD
o9YL軧w
o9\nAܹᆆ9
o9vI!9
o:!ＺU5p
o:=ds
o:CD0
o:Md\n:0
o:cPO
o:ˊV9T
o;0>r
o;7 X9
o;A;k
o;So4
o;a\a_:Hrb
o;n2;F2r;P
o;u ѺR
o;xXq
o<D<c
o<g~1
o<m7¼S
o<}ug
o=*uP
o=2X1
o=6z0
o=7nN
o=?LN
o=Ai1
o=C%P
o=\e 2=QO
o=n,K
o=v\e
o>3j\r?\f
o>p-I
o@e:z4
oAJ;o
oB);B
oB)>z
oB<P\b
oC;@cB
oD$0fA
oD$@fA
oD$PfA
oD$`fE
oD2 fA
oD>Kg
oEb;CK
oI\\$Hf
oJ;I\am;8
oK.;\vN
oL$ fD
oL$0fA
oL$0fD
oL$@fA
oL$PfA
oL$`fD
oL$pfD
oM̹r0
oO\vbQ
oO{Jw
oQ <]\b
oQ;Bs
oR<X\b
oRۼƿc
oSüoV
oT$ fD
oT$PfD
oT$`fD
oT<cQ˼Ի\t
oV<o6o
oW\v<kD
oZs=s_d
o\\$PfA
o\\$PfD
o\\$pfD
o\e;L
o\f;H
o\f;Wtv8
o\r >w
o\r TQ
o\r q0
o\r)kv
o\r+u0
o\r.R1
o\r/A1
o\r3H3
o\r3x
o\r4c0
o\r;hU
o\r>fQ
o\rHsf
o\rKLJ
o\rLr0
o\rPP
o\rQ&v
o\rQcT
o\rV`0
o\rZ\nf
o\r[7
o\r\bl8
o\r\esP
o\r\nO1
o\ra Q
o\rar
o\ri/A
o\rk\fx
o\rk]E
o\rkw
o\rpGR
o\rur
o\rvoR
o\t>j
o\t\r
o\te:xD
o\tĺ\fZ
o\v<xp\v3hq\v*t
o]X:C
o`U<R
ob!?K
object
object_accel
object_accel_max_leaf_size
object_accel_mb
object_accel_mb_max_leaf_size
object_accel_mb_min_leaf_size
object_accel_min_leaf_size
object_builder
object_builder_mb
occluded_main
oc̻P[b
od ;S
od$0fD
od$@fD
od$PfD
od$\bfD
od$`fD
oe);h
oe;\a{H
ofܺ\n
og 9P
oiκHT
oj<WD
oj>OP
oj?;78
ol$ fD
ol$0fD
ol$PfD
ol$`fA
ol$pfD
ole32.dll
omni callsig
ook:e
ooq:w
operation canceled
operation in progress
operation not permitted
operation not supported
operation not supported for this geometry
operation would block
operator
operator co_await
or>P>M
os<`M
ot$ fD
ot$@fA
ot$@fD
ot:Kh
ou;d%w
out of memory
outlen == newN
ov<v\e1
ovһwB
ow\nbQ
owner dead
owq:Bsb
owʹ12
oxp;O
oy[:Q
oz:Ŷ%;nUr
o|$0fD
o|$pfD
o|:zJC
o~7:95\b
oÍ9ChM
oƺ<t\tv
o˼rә=wqb
o؉D$4f
o݉D$Tf
o݉D$TfA
o݉D$`fA
oމD$Df
oމD$Lf
oމD$tf
oߏ;2Wf
p UATAUAVAWH
p UWATAUAWH
p UWATAVAWH
p WATAUAVAWH
p WAVAWH
p }8GQ
p!u;w;K
p"<C1
p&7]u
p&Ϻz\vƺ5u
p,m;\eQF
p/C<Dn
p1X>{C
p2j2d<R2P2DRrxtXrFPFv
p3L:B
p3ֹVBR
p4+<4
p7M}f
p7N<Bw
p7ǹzRa
p8H:d
p8W+B
p8^|S
p8墀9}\eT8
p9OBc
p9ݘX:2
p:4ߗ8z
p:KF\v
p:\vH\a
p:r\t
p:Ͳ7;9O
p:зٺ]Wr9L
p;5\b6
p;5qm
p;=AH
p;FpR
p;LFS
p;_8C
p;e8i
p<Q=7
p<W:sbI
p<\ba
p<gX\a
p=BAr
p=L\b
p=eaj
p=yO1
p>8MdF
p?<Ap
p?\b\tq?W
p@ݼoI
pA:sE
pA_A^A
pA_A^A]A
pC:\e
pD;#O
pDf;~I
pF<h:d
pG9;Dw
pGA:CH
pH+J0L
pH;z\b
pHL+p@3
pHM+p
pIc\f$I
pK\e;E
pKcT( A
pMٹ2qh
pOE=e
pOߺthM
pS;뮀66
pT$PNf
pT|\a
pU\v;j
pVֺ\t'F
pW\v=Z
pXT& ġHY
pXT( ġ@Y
pXT/ ġHY
pXT0 ā@Y
pXT0 ġ@Y
pXT0 ġHY
pXT\a
pXT\a ā@Y
pXT\a ġ@Y
pXT\b ġ@Y
pXT\f
pYD pġpY
pYD pĢI
pYL$PH
pYNPŸY
pYT pġ@YL @ġ8YD
pYT$@H
pYT\a
pYT\e
pYT\f
pYT\n
pYT\t
p[:I54
p\aIB
p\abA
p\aj;{s
p\b<I\v
p\b@8
p\f<TyQ
p\n|屮uO
p\r0\fP!C
p\r0\fP!L
p\r6;,E
p\r`\f0\vP
p\r`\f0\vP!n
p\r`\fP
p\r`\fP!d
p\r`\fP!h
p\r`\fP\v0
p\rk<\t
p\t:lϏ9
p\t<lt)<8
p\tL<dd\a
p\v";LG
p]:ql
p]A_A
p]A_A^A
p^<DGn
pa; V
pa;CT
pa;\f\e5
pascal
paλ-h
pb{>m
pc=i9
pd^=R
pdata
pej;0
performance impact. Please enable these modes for each application
permission denied
pf:6K
pf<^n
pgL:vt
pg\n?pg\n
pgݻDv
ph:t4-;c
phonon.dll
phonon_itest.exe
phonon_perf.exe
phonon_test.exe
piٻCb\t
pk9e\\V
pk;{ZR
pl':U!y:JW
placement delete closure
placement delete[] closure
pmg;xz?9}\a
pn9II0:SfR9Z
pn<dó<H
pn>6ނB
poh=qO
portuguese-brazilian
pp9* \n
pp;0E
pple OCL runtime \n#ifndef APPLE \nDEFINE_MAKE_4(int) \nDEFINE_MAKE_4(float) \n#endif \n \nDEFINE_SAFE_LOAD_4(int) \nDEFINE_SAFE_LOAD_4(float) \n \nDEFINE_SAFE_STORE_4(int) \nDEFINE_SAFE_STORE_4(float) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE(uint) \nDEFINE_GROUP_SCAN_EXCLUSIVE(float) \nDEFINE_GROUP_SCAN_EXCLUSIVE(short) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_SUM(uint) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(float) \n \nDEFINE_SCAN_EXCLUSIVE(int) \nDEFINE_SCAN_EXCLUSIVE(float) \n \nDEFINE_SCAN_EXCLUSIVE_4(int) \nDEFINE_SCAN_EXCLUSIVE_4(float) \n \nDEFINE_SCAN_EXCLUSIVE_PART_4(int) \nDEFINE_SCAN_EXCLUSIVE_PART_4(float) \n \nDEFINE_DISTRIBUTE_PART_SUM_4(int) \nDEFINE_DISTRIBUTE_PART_SUM_4(float) \n \n/// Specific function for radix-sort needs \n/// Group exclusive add multiscan on 4 arrays of shorts in parallel \n/// with 4x reduction in registers \nvoid group_scan_short_4way(int localId, int groupSize, \n    short4 mask0, \n    short4 mask1, \n    short4 mask2, \n    short4 mask3, \n    __local short* shmem0, \n    __local short* shmem1, \n    __local short* shmem2, \n    __local short* shmem3, \n    short4* offset0, \n    short4* offset1, \n    short4* offset2, \n    short4* offset3, \n    short4* histogram) \n{ \n    short4 v1 = mask0; \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y; \n    shmem0[localId] = v1.w; \n \n    short4 v2 = mask1; \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y; \n    shmem1[localId] = v2.w; \n \n    short4 v3 = mask2; \n    v3.y += v3.x; v3.w += v3.z; v3.w += v3.y; \n    shmem2[localId] = v3.w; \n \n    short4 v4 = mask3; \n    v4.y += v4.x; v4.w += v4.z; v4.w += v4.y; \n    shmem3[localId] = v4.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + shmem0[(2 * localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + shmem1[(2 * localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + shmem2[(2 * localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + shmem3[(2 * localId + 1)*stride - 1]; \n        } \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    short4 total; \n    total.s0 = shmem0[groupSize - 1]; \n    total.s1 = shmem1[groupSize - 1]; \n    total.s2 = shmem2[groupSize - 1]; \n    total.s3 = shmem3[groupSize - 1]; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    if (localId == 0) \n    { \n        shmem0[groupSize - 1] = 0; \n        shmem1[groupSize - 1] = 0; \n        shmem2[groupSize - 1] = 0; \n        shmem3[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem0[(2 * localId + 1)*stride - 1]; \n            shmem0[(2 * localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1]; \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem1[(2 * localId + 1)*stride - 1]; \n            shmem1[(2 * localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem2[(2 * localId + 1)*stride - 1]; \n            shmem2[(2 * localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem3[(2 * localId + 1)*stride - 1]; \n            shmem3[(2 * localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + temp; \n        } \n \n
pr china
pr-china
primitives
program name unknown
progress monitor forced termination
protocol error
protocol not supported
provided geometry ID already assigned to a geometry
ptr64
puerto-rico
pv<gX
pw8;;\v
pw<dqs
pz9<\nT
pz<\ta
p{h2Һi
p}Dbezier1v
pƻ8XN
pǄ:5j
p˔;yS
pͼ#BмKg\b
pΥ<03
pф;e6M
pӅ=T\nM
pԡ9j3
pؼWl9
q bR%H6
q!:F A:3
q!; s7
q!c;BF
q"L0P
q"L2P
q#>;Wqc
q'h96
q)9wa
q*;0X
q+:3MyX+z8
q+۽Rzt
q.spŀW
q0@80u\n
q0Ȼi(j
q1<k\r
q2';m26:D2J
q35;bK
q3h;r
q5-;fW
q8,PF
q8\aX
q8ŒXa
q9:w8;;Q
q9<l'\r
q9d>W9
q:5Cߺ\ewt
q:9I\t;8V
q:Rj\r;Gt5
q:Y\f
q:d/κQsW
q;0Tz
q;39\a
q;R>b
q;Tl\f
q;WkE
q;h1v
q;i\eP
q<TJ"=k4
q=.Ca
q=Ҳ9>BF
q?V<b
qB9/^o
qB>kjg
qBǻtOA
qCm=>\av
qGL="l~=M\f3
qGS9w?z
qH=}c
qJ;\e
qJ<W%A
qJ\r*Oh
qJ\r|Mg
qMX:Jj
qP:eAлz
qQQ:*5ʺa
qRG;Q
qS>g?h3
qTŊ\\I4
qTŢ\\I4
qU~;e
qW$;\eJg
qX=˱j
qX\a;Zu
qZ:aߺ9m
qZ;"9M;l
q[ݹWvɺa
q\a9xr\a0hs\a'4
q\a;Le
q\b7;(wV
q\b;6RֺF
q\b;j
q\b<xr\b3hs\b*t
q\bL+1H
q\bba~\b
q\e\e
q\nba|H
q\rչt
q\t;e7r
q\t\a=Ezz
q\tba~\b
q\vba~\b
q`k:c
qb!}Hp$ٱbA
qbvh4.quad4i
qbvh4.triangle4i
qbvh8.quad4i
qbvh8.triangle4
qbvh8.triangle4i
qbڻŤl9
qe-<L}g
qeB<FAE
qg<s%w
qgY=EG
qgw=(\a\t
qiT;B
qiX:S
qj/9;E
qj:axY9l
qjļDw
qot:׀X
qp2:R
qt5<-r
quad4i
quad4v
quad_accel
quad_accel_mb
quad_builder
quad_builder_mb
quad_traverser
quad_traverser_mb
quads
quantizedNodes
quz-BO
quz-EC
quz-PE
quz-bo
quz-ec
quz-pe
qv=#I
qw+=k5R
qxs?qxs
qxs?qxs?qxs?qxs?qxs?qxs
qyb:O2
q{3摻T
qƷ;coM
qǺu!w
qȽJ30
qںOKm:t
r %:Aj
r";Xb
r#=lRr
r$>9L
r%:y6
r'<Ms
r'=dB
r'X9|b
r'j=Zf
r(H=ja
r(T;Fh
r) \n{ \n    float const dirx = r.d.x; \n    float const diry = r.d.y; \n    float const dirz = r.d.z; \n    float const ooeps = 1e-8; \n    float3 invdir; \n    invdir.x = 1.0f / (fabs(dirx) > ooeps ? dirx : copysign(ooeps, dirx)); \n    invdir.y = 1.0f / (fabs(diry) > ooeps ? diry : copysign(ooeps, diry)); \n    invdir.z = 1.0f / (fabs(dirz) > ooeps ? dirz : copysign(ooeps, dirz)); \n    return invdir; \n} \n \n// Intersect rays vs bbox and return intersection span.  \n// Intersection criteria is ret.x <= ret.y \nINLINE \nfloat2 fast_intersect_bbox1(bbox box, float3 invdir, float3 oxinvdir, float t_max) \n{ \n    float3 const f = mad(box.pmax.xyz, invdir, oxinvdir); \n    float3 const n = mad(box.pmin.xyz, invdir, oxinvdir); \n    float3 const tmax = max(f, n); \n    float3 const tmin = min(f, n); \n    float const t1 = min(min3(tmax.x, tmax.y, tmax.z), t_max); \n    float const t0 = max(max3(tmin.x, tmin.y, tmin.z), 0.f); \n    return make_float2(t0, t1); \n} \n \n// Given a point in triangle plane, calculate its barycentrics \nINLINE \nfloat2 triangle_calculate_barycentrics(float3 p, float3 v1, float3 v2, float3 v3) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n    float3 const e = p - v1; \n    float const d00 = dot(e1, e1); \n    float const d01 = dot(e1, e2); \n    float const d11 = dot(e2, e2); \n    float const d20 = dot(e, e1); \n    float const d21 = dot(e, e2); \n \n    float denom = (d00 * d11 - d01 * d01); \n     \n    if (denom == 0.f) \n    { \n        return make_float2(0.f, 0.f); \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invdenom = 1.f / denom; \n#else \n    float const invdenom = native_recip(denom); \n#endif \n \n    float const b1 = (d11 * d20 - d01 * d21) * invdenom; \n    float const b2 = (d00 * d21 - d01 * d20) * invdenom; \n    return make_float2(b1, b2); \n} \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n#define STARTIDX(x)     (((int)(x.pmin.w)) >> 4) \n#define SHAPEIDX(x)     (((int)(x.pmin.w)) >> 4) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n#define NEXT(x)     ((int)((x).pmax.w)) \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n \ntypedef bbox bvh_node; \n \ntypedef struct \n{ \n    // Shape ID \n    int id; \n    // Shape BVH index (bottom level) \n    int bvh_idx; \n    // Is the shape disabled? \n    unsigned int shapeDisabled; \n    int padding1; \n    // Transform \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    // Motion blur params \n    float4 velocity_linear; \n    float4 velocity_angular; \n} Shape; \n \ntypedef struct \n{ \n    // Vertex indices \n    int idx[3]; \n    // Shape ID \n    int shape_id; \n    // Primitive ID \n    int prim_id; \n} Face; \n \n \nINLINE float3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nINLINE float3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nINLINE ray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \n \n
r)7<'H9
r);DBX
r*:v5
r*d\e\r*4
r+گ\n\eL6
r,2:n
r.'>Xft
r.9pR\n
r/d=rH
r0;sƐ9
r0\fP
r0\fP!\v
r130801120000Z
r1;D t
r1<%h
r1ֺB :9
r210429000000Z
r211007000000Z
r220323000000Z
r220801000000Z
r230714000000Z
r231220013430Z0
r241009235959Z0a1\v0\t
r2:bO
r2<u4һq
r2=Iz
r311109235959Z0b1\v0\t
r341013235959Z0H1\v0\t
r360428235959Z0i1\v0\t
r370322235959Z0c1\v0\t
r380115120000Z0b1\v0\t
r3>l`ݽK
r3Ӽ_t
r42:n2F
r5:D/z
r5:zp58z\ff
r6ƻ\t\nĻD
r6ǼHY
r7;&v
r7<}ZԼ}8j
r8,;5
r8\\=rd
r8\v:WO
r8q:Q
r9=)K\v
r9=gD2
r9>Hߺ5
r9IT\v
r9N8y9
r9Rǳ:y
r9mpe;Dk":\b
r9obֺޟm
r9z6;\tQg
r:%h4
r:'X̻yn
r:,Ul
r:Q\a89
r:S(ڻlq
r:Yoa
r:\f;L94
r:eSĺ A
r:gom:fp
r;0 h
r;0=MIA
r;81\t=\t
r;9>\t:R6
r;9D2
r;9Tr
r;:CQ
r;;bIE
r;;쇻05r
r;A\vx;w2
r;C"7
r;E%4
r;FG{8
r;GHM
r;I,w:GoQ:W
r;K%n9
r;N2<v
r;Q\e@9
r;XE]:N
r;\n9V
r;`kD
r;`sD
r;d$c
r;d|d
r;pBL
r;q=t:0s
r;q>Q
r;usb;_i
r;wH@<m
r<25A
r<2wg
r<FO.<X
r<T9a
r<Z^6
r<dKļGB
r<v;f
r="rD=bx
r='DN
r=2uz
r=;3Kh
r=O>m
r=\tSD>\t
r=kB\e
r=on5=D
r=u8\b
r>3;caN
r><7ag
r>KQA>x
r>P\n
r>Rq=>2
r>\fB
r>e4F
r>e\n
r?fQ3
r?ѻTS
r@0:WI
rB;ިL
rB\tp\b`\aP
rB\v;v
rC<RE
rCCޱb#UCC
rE\b=6yM
rF 9d
rFV:J
rH :P
rH6;3
rH;~r
rHR=w
rH\e;!A
rJ;\e\n
rK<ldC
rLI+\nN
rLc]lI
rLg<qr
rM?\t7\a
rMI+\nN
rMe;u
rM»\f"W
rN*;D
rOI+\nN
rO|:wv
rP%=-L3
rP%=\fD3
rP%=nU3
rP\f0
rPܺr嬻y
rR\\;eV
rSಸCd9
rT%>2
rT1<3e
rUC:ºf;a
rW;(F
rX"<6
rX6:;z
rX;pf
rX<)E
rX[;X
rXy`łY
rXypŚXyt
rXϻ(\nF
rY;\tbC
rY<}S
rY>P/1
rYI<\bK
rYL<\fXC
rZ2;nvܺt
rZ8>\v
rZ98r
rZ>"n
rZ\a<Yeûk
rZk;\fj
r[k8B
r\\y4łY
r\a(:Kb
r\abbmH
r\b<5
r\b<gAt
r\bD+z\bA
r\bSA|X=G
r\b\a>4hl
r\bb"e@6
r\bbA
r\bba|\b
r\bba~\b
r\br><A
r\e\f
r\ebA|\b
r\f;[w6
r\f<(DF
r\fbA
r\fl<\tFU
r\fp\v`\n0
r\n$;T4t8
r\n0\tP\bp\a
r\n;r@5
r\n<\eqǻm0
r\r:NB
r\rbA
r\t9,g0
r\tVr.>T
r\ta<1G
r\ta<؆e
r\tbA
r\tba
r\tba|\b
r\vba|H
r\vw<?hG
r`\fP!W
r`j9ϹI
rae:m2R;B
rb!4@Yt
rb!\f@Yt
rb,9J
rbA|H
rbQ|H
rba$@X
rcalculating laplacian: %.2f
rdata
rdata$T
rdata$r
rdata$voltmd
rdata$zzzdbg
re;0w8
reU>\v
read only file system
reconstructImpulseResponse
refit_bounds_main
reloc
remove@ThreadPool@TaskScheduler@embree@@QEAAXAEBV?$Ref@UTaskScheduler@embree@@@3@@Z
removeScheduler@TaskScheduler@embree@@CAXAEBV?$Ref@UTaskScheduler@embree@@@2@@Z
resource deadlock would occur
resource unavailable try again
restrict
result out of range
reverberant
rf;2Py
rfJBGo
rfffff
rg<<e
rh.;s
rh\t;<Q
ri/=q
ri4<wb
riP<d3
rj$:o\b
rj9=Q
rjQ9u3
rk9Bi
rk<<p
rkV<M
rk_;bt
rl7=V
rlԻDJ
rm;8m^9
rmal);\n            reflectedDirection = (float4) (transformedDiffuseSample, 0.0f);\n        }\n        else\n        {\n            reflectedDirection = (float4) (reflect(rayDirection, hitNormal), 0.0f);\n        }\n\n        reflectedRays[rayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * reflectedDirection.xyz, FLT_MAX);\n        reflectedRays[rayIndex].d = reflectedDirection;\n        reflectedRays[rayIndex].extra = (int2) (0xffffffff, 1);\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Image Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherImage(uint numSources, \n                        global const int* occluded, \n                        global const float4* totalEnergy,\n                        global float4* image)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t numRays = get_global_size(0);\n\n    for (uint i = 0; i < numSources; ++i) \n    {\n        if (occluded[i * numRays + rayIndex] < 0) \n        {\n            image[rayIndex] += totalEnergy[i * numRays + rayIndex];\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Energy Field Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherEnergyField(float scale, \n                              global const float4* totalEnergy,\n                              uint offset,\n                              global const int* occluded,\n                              global const float* shCoefficients,\n                              global int* energy)\n{\n\t// The number of global work-items for this kernel is #rays * #bands * #channels.\n\t// The number of local work-items for this kernel is #bins * 1 * 1. Here, #bins is a compile-time constant.\n\t// This kernel runs in three stages:\n\t//\t1.\tEach work-group operates on a subset of rays, and accumulates their energy into one of multiple\n\t//\t\tlocal-memory histograms.\n\t//\t2.\tEach work-group adds all of its local-memory histograms together.\n\t//\t3.\tThe work-groups cooperate and combine their local-memory histograms into a global-memory histogram.\n\n    uint rayIndex = get_global_id(0);\n    uint band = get_global_id(1);\n    uint channel = get_global_id(2);\n\n    size_t numRays = get_global_size(0);\n\n    bool isOccluded = (occluded[offset + rayIndex] >= 0);\n\n\t// FIXME: shouldn't this be just get_local_id(0)?\n    const int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\n\t// Each work-group stores NUM_LOCAL_HISTOGRAMS histograms in local memory. These are interleaved, i.e.,\n\t// bin i of histogram j is at index (NUM_LOCAL_HISTOGRAMS * i + j) in the buffer. We use multiple local-memory\n\t// histograms to reduce the chance that an atomic_add leads to contention (see below for details).\n    local int localEnergy[NUM_BINS * NUM_LOCAL_HISTOGRAMS];\n\n\t// These base pointers are used in stage 2 of the kernel. See below for details.\n    local int* workItemEnergy = localEnergy + mul24(localIndex, NUM_LOCAL_HISTOGRAMS);\n\n\t// Initialize all local-memory histograms to zero.\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++) \n    {\n        workItemEnergy[i] = 0.0f;\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 1\n\t// Each work-item processes one ray. If it is not occluded (i.e., it carries non-zero energy), the energy is added\n\t// to one of the local-memory histograms for the work-group. These adds need to be atomic, since multiple rays\n\t// being processed in the same work-group may write to the same bin of the same histogram. The contention\n\t// due to atomic_adds can be reduced by increasing NUM_LOCAL_HISTOGRAMS, at the cost of increased local memory\n\t// usage.\n    if (!isOccluded)\n    {\n\t\t// Adjacent work-items in a work-group do not use the same loc
rmarking potentially diffracting voxels: %.2f
rmj>zjZ
ro:?f
ro:xPG
roU;i
robust
rp;Kv
rp;bB
rp\f0\vP
rp\fP!C
rp\fP\v0
rp\f`\v0
rp\f`\v0\nP
rp\f`\vP
rp\f`\vP\n0
rpb<2
rq<NuW
rqp:J
rr:K\r\v
rrA<l
rs\b:B^B;c
rsrc$01
rsrc$02
rt8lS
rt<1k
rtc$IAA
rtc$IZZ
rtc$TAA
rtc$TZZ
rtcCommit
rtcCommitJoin
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcCommitThread
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcDebug
rtcDebug___avx
rtcDebug___avx2
rtcDebug___sse2
rtcDebug___sse4
rtcDeleteDevice
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_avx
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_avx2
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_sse2
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_sse4
rtcDeleteGeometry
rtcDeleteGeometry cannot get called in static scenes
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcDeleteScene
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcDeviceGetError
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_avx
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_avx2
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_sse2
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_sse4
rtcDeviceGetParameter1i
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_avx
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_avx2
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_sse2
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_sse4
rtcDeviceNewScene
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx2
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse2
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse4
rtcDeviceSetErrorFunction
rtcDeviceSetErrorFunction2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_avx
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_avx2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_sse2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_sse4
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx2
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse2
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse4
rtcDeviceSetMemoryMonitorFunction
rtcDeviceSetMemoryMonitorFunction2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_avx
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_avx2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_sse2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_sse4
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_avx
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_avx2
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_sse2
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_sse4
rtcDeviceSetParameter1i
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unuavx
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unuavx2
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unusse2
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unusse4
rtcDisable
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcEnable
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcExit
rtcExit___avx
rtcExit___avx2
rtcExit___sse2
rtcExit___sse4
rtcGetBounds
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_avx
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_avx2
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_sse2
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_sse4
rtcGetError
rtcGetError___avx
rtcGetError___avx2
rtcGetError___sse2
rtcGetError___sse4
rtcGetLinearBounds
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcGetParameter1i
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_avx
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_avx2
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_sse2
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_sse4
rtcGetUserData
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcInit
rtcInit has to get called before rtcExit
rtcInit___un_3C_Cunt_3E_avx
rtcInit___un_3C_Cunt_3E_avx2
rtcInit___un_3C_Cunt_3E_sse2
rtcInit___un_3C_Cunt_3E_sse4
rtcInterpolate
rtcInterpolate2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse4
rtcInterpolateN
rtcInterpolateN2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse4
rtcIntersect
rtcIntersect and rtcOccluded not enabled
rtcIntersect16
rtcIntersect16 and rtcOccluded16 not enabled
rtcIntersect16 not supported
rtcIntersect16Ex
rtcIntersect16Ex not supported
rtcIntersect1Ex
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcIntersect1M
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse4
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse4
rtcIntersect1Mp
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcIntersect4
rtcIntersect4 and rtcOccluded4 not enabled
rtcIntersect4Ex
rtcIntersect8
rtcIntersect8 and rtcOccluded8 not enabled
rtcIntersect8Ex
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcIntersectN and rtcOccludedN not enabled
rtcIntersectNM
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx2
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse2
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse4
rtcIntersectNp
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx2
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse2
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse4
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx2
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse2
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse4
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcMapBuffer
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcNewBSplineCurveGeometry
rtcNewBSplineCurveGeometry2
rtcNewBSplineHairGeometry
rtcNewBSplineHairGeometry2
rtcNewBezierCurveGeometry
rtcNewBezierCurveGeometry2
rtcNewBezierHairGeometry
rtcNewBezierHairGeometry2
rtcNewCurveGeometry
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewDevice
rtcNewDevice___un_3C_Cunt_3E_avx
rtcNewDevice___un_3C_Cunt_3E_avx2
rtcNewDevice___un_3C_Cunt_3E_sse2
rtcNewDevice___un_3C_Cunt_3E_sse4
rtcNewGeometryGroup
rtcNewGeometryInstance
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcNewHairGeometry
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewInstance
rtcNewInstance2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcNewInstance3
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcNewLineSegments
rtcNewLineSegments2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewQuadMesh
rtcNewQuadMesh2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewScene
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx2
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse2
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse4
rtcNewSubdivisionMesh
rtcNewSubdivisionMesh2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuavx
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuavx2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunusse2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunusse4
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunuavx
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunuavx2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunusse2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunusse4
rtcNewTriangleMesh
rtcNewTriangleMesh2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewUserGeometry
rtcNewUserGeometry2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcNewUserGeometry3
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuavx
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuavx2
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunusse2
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunusse4
rtcNewUserGeometry4
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcOccluded
rtcOccluded16
rtcOccluded16 not supported
rtcOccluded16Ex
rtcOccluded16Ex not supported
rtcOccluded1Ex
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcOccluded1M
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx2
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse2
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse4
rtcOccluded1Mp
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx2
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse2
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse4
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcOccluded4
rtcOccluded4Ex
rtcOccluded8
rtcOccluded8Ex
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcOccludedNM
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx2
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse2
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse4
rtcOccludedNp
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx2
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse2
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse4
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx2
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse2
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse4
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcSetBoundaryMode
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_avx
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_avx2
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_sse2
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_sse4
rtcSetBoundsFunction
rtcSetBoundsFunction2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_avx
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_avx2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_sse2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_sse4
rtcSetBoundsFunction3
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_avx
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_avx2
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_sse2
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_sse4
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_avx
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_avx2
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_sse2
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_sse4
rtcSetBuffer
rtcSetBuffer2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunuavx
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunuavx2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunusse2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunusse4
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuavx
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuavx2
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunusse2
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunusse4
rtcSetDisplacementFunction
rtcSetDisplacementFunction2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcSetErrorFunction
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx2
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse2
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse4
rtcSetIndexBuffer
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_avx
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_avx2
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_sse2
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_sse4
rtcSetIntersectFunction
rtcSetIntersectFunction16
rtcSetIntersectFunction1Mp
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx2
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse2
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse4
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx2
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse2
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse4
rtcSetIntersectFunction4
rtcSetIntersectFunction8
rtcSetIntersectFunctionN
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx2
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse2
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse4
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx2
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse2
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse4
rtcSetIntersectionFilterFunction
rtcSetIntersectionFilterFunction16
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx2
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse2
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse4
rtcSetIntersectionFilterFunction4
rtcSetIntersectionFilterFunction8
rtcSetIntersectionFilterFunctionN
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx2
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse2
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse4
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx2
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse2
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse4
rtcSetMask
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuuniavx
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuuniavx2
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuunisse2
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuunisse4
rtcSetMemoryMonitorFunction
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_avx
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_avx2
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_sse2
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_sse4
rtcSetOccludedFunction
rtcSetOccludedFunction16
rtcSetOccludedFunction1Mp
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx2
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse2
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse4
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx2
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse2
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse4
rtcSetOccludedFunction4
rtcSetOccludedFunction8
rtcSetOccludedFunctionN
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx2
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse2
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse4
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx2
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse2
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse4
rtcSetOcclusionFilterFunction
rtcSetOcclusionFilterFunction16
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx2
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse2
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse4
rtcSetOcclusionFilterFunction4
rtcSetOcclusionFilterFunction8
rtcSetOcclusionFilterFunctionN
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx2
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse2
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse4
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx2
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse2
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse4
rtcSetParameter1i
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unuavx
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unuavx2
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unusse2
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unusse4
rtcSetProgressMonitorFunction
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_avx
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_avx2
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_sse2
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_sse4
rtcSetSubdivisionMode
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_avx
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_avx2
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_sse2
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_sse4
rtcSetTessellationRate
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfavx
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfavx2
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfsse2
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfsse4
rtcSetTransform
rtcSetTransform2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unuavx
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unuavx2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unusse2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unusse4
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_avx
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_avx2
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_sse2
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_sse4
rtcSetUserData
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_avx
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_avx2
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_sse2
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_sse4
rtcUnmapBuffer
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcUpdate
rtcUpdateBuffer
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
ru6:2
run@Task@TaskScheduler@embree@@QEAAXAEAUThread@23@@Z
rv;Ovg
rw*<y\a
rw5<Rh
rx<]Im
rxt:3
ry \rG
ry6rcI
ry=4Ы=\b7
r}R9N,N
rǼExd
rȺd#4
rȻhf\r
rɋL$PH
rː;Nu
r̍Avf
r̻de8;L9\n;U
r̻hiK
rЯ:G8s
rҺEe0
rԼYvI=\f
rػfK\f
rںmY`:ry
rڻX1ĹQ
rݻXt9
rݼ+QӼHh
rߺF)0
rᇺJ2};S
r辽ICA
r깺\bn
r엺o\b5<\e 8
rY4t
s ;Pr/;G
s WATAUAVAWH
s WAVAWH
s!< N
s$W<M\b
s%9"Ue
s%O:bLE
s'b;sy
s(D+s0
s)3:l
s0;;O
s0C;yd
s1;ʭ0
s3:?L
s4+sP
s59=p}Խm
s5ͼ\vpi
s6}:g
s6߹PtG
s82٫9v
s: HRTF data contains Ambisonic HRIRs of unsupported order: %d
s: Unsupported HRTF data format version: %d
s: invalid %s: %s = %s
s:0xS
s:DYa9
s:Ja)<K
s:qn\r
s:s梺t7
s;3!G
s;7dE
s;8|p
s;^o6
s;rYO<4
s;t\v
s;whk
s<MBs
s<\tk
s<pD[<l
s<yln
s<zde
s>P=6z
s>\bE
s@=aa0
sBȻQ8
sEӺHMM
sFȺi0
sFҺ\a
sFں2f
sI"9_R\n
sI:59
sI\e;t1
sJ:v6
sJt<9\n
sK:&r
sL:rq
sL;20~<d
sLݺmvH
sM:\e\t
sN:\e
sP=Ywżi+J
sRA; J
sT`>y1
sUN;y
sV< Mp
sV\t<Ax㻞j
sX-1{Q
sXX:*q
sY%'XQ
sY%'kQ
sZֻVt
s\a;1i
s\a<Xy
s\aA\v
s\b9xt\b0hu\b'4
s\eֺn
s\n;E
s\nF;R5
s\t>9
s\v8>\t4
s\v<xt\v3hu\v*t
s\v@9
s\vD88w
s\vHcҋD
s\v\r=L
s_<d2
s`3;Y
sa_<z
sah_fast_spatial
sah_presplit
sc\r;rά;a
scalar deleting destructor
scan_exclusive_int4
scan_exclusive_part_int4
scene got not committed
scenes do not belong to the same device
segments
selected scene intersector
set_affinity
settings
settings->freeCallback
settings->simdLevel
sf\n>Y0
sg@;m
sh9w3I
shadeAndBounce
shared
shoebox
si)<ZO
siںGC
sl;܀F
slotMask
slovak
sma-NO
sma-SE
sma-no
sma-se
smj-NO
smj-SE
smj-no
smj-se
smn-FI
smn-fi
sms-FI
sms-fi
sn$:p
south africa
south korea
south-africa
south-korea
spW;w
spanish-argentina
spanish-bolivia
spanish-chile
spanish-colombia
spanish-costa rica
spanish-dominican republic
spanish-ecuador
spanish-el salvador
spanish-guatemala
spanish-honduras
spanish-mexican
spanish-modern
spanish-nicaragua
spanish-panama
spanish-paraguay
spanish-peru
spanish-puerto rico
spanish-uruguay
spanish-venezuela
sphereOcclusion
spherical
sqM+\nH
sr-BA-Cyrl
sr-BA-Latn
sr-SP-Cyrl
sr-SP-Latn
sr-ba-cyrl
sr-ba-latn
sr-sp-cyrl
sr-sp-latn
ssM+\nH
sse2::BVH
sse2::BVH4Bezier1iIntersector1
sse2::BVH4Bezier1iIntersector1_OBB
sse2::BVH4Bezier1iIntersector4Hybrid
sse2::BVH4Bezier1iIntersector4Hybrid_OBB
sse2::BVH4Bezier1vIntersector1
sse2::BVH4Bezier1vIntersector1_OBB
sse2::BVH4Bezier1vIntersector4Hybrid
sse2::BVH4Bezier1vIntersector4Hybrid_OBB
sse2::BVH4IntersectorStreamPacketFallback
sse2::BVH4Line4iIntersector1
sse2::BVH4Line4iIntersector4
sse2::BVH4Line4iMBIntersector1
sse2::BVH4Line4iMBIntersector4
sse2::BVH4OBBBezier1iMBIntersector1_OBB
sse2::BVH4OBBBezier1iMBIntersector4Hybrid_OBB
sse2::BVH4Quad4iIntersector1Moeller
sse2::BVH4Quad4iIntersector1Pluecker
sse2::BVH4Quad4iIntersector4HybridMoeller
sse2::BVH4Quad4iIntersector4HybridPluecker
sse2::BVH4Quad4iIntersectorStreamMoeller
sse2::BVH4Quad4iIntersectorStreamPluecker
sse2::BVH4Quad4iMBIntersector1Moeller
sse2::BVH4Quad4iMBIntersector1Pluecker
sse2::BVH4Quad4iMBIntersector4HybridMoeller
sse2::BVH4Quad4iMBIntersector4HybridPluecker
sse2::BVH4Quad4vIntersector1Moeller
sse2::BVH4Quad4vIntersector1Pluecker
sse2::BVH4Quad4vIntersector4HybridMoeller
sse2::BVH4Quad4vIntersector4HybridMoellerNoFilter
sse2::BVH4Quad4vIntersector4HybridPluecker
sse2::BVH4Quad4vIntersectorStreamMoeller
sse2::BVH4Quad4vIntersectorStreamMoellerNoFilter
sse2::BVH4Quad4vIntersectorStreamPluecker
sse2::BVH4SubdivPatch1CachedIntersector1
sse2::BVH4SubdivPatch1CachedIntersector4
sse2::BVH4SubdivPatch1CachedMBIntersector1
sse2::BVH4SubdivPatch1CachedMBIntersector4
sse2::BVH4SubdivPatch1EagerIntersector1
sse2::BVH4SubdivPatch1EagerIntersector4
sse2::BVH4SubdivPatch1Intersector1
sse2::BVH4SubdivPatch1Intersector4
sse2::BVH4SubdivPatch1MBIntersector1
sse2::BVH4SubdivPatch1MBIntersector4
sse2::BVH4Triangle4Intersector1Moeller
sse2::BVH4Triangle4Intersector4HybridMoeller
sse2::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse2::BVH4Triangle4IntersectorStreamMoeller
sse2::BVH4Triangle4IntersectorStreamMoellerNoFilter
sse2::BVH4Triangle4iIntersector1Moeller
sse2::BVH4Triangle4iIntersector1Pluecker
sse2::BVH4Triangle4iIntersector4HybridMoeller
sse2::BVH4Triangle4iIntersector4HybridPluecker
sse2::BVH4Triangle4iIntersectorStreamMoeller
sse2::BVH4Triangle4iIntersectorStreamPluecker
sse2::BVH4Triangle4iMBIntersector1Moeller
sse2::BVH4Triangle4iMBIntersector1Pluecker
sse2::BVH4Triangle4iMBIntersector4HybridMoeller
sse2::BVH4Triangle4iMBIntersector4HybridPluecker
sse2::BVH4Triangle4vIntersector1Pluecker
sse2::BVH4Triangle4vIntersector4HybridPluecker
sse2::BVH4Triangle4vIntersectorStreamPluecker
sse2::BVH4Triangle4vMBIntersector1Moeller
sse2::BVH4Triangle4vMBIntersector1Pluecker
sse2::BVH4Triangle4vMBIntersector4HybridMoeller
sse2::BVH4Triangle4vMBIntersector4HybridPluecker
sse2::BVH4VirtualIntersector1
sse2::BVH4VirtualIntersector4Chunk
sse2::BVH4VirtualMBIntersector1
sse2::BVH4VirtualMBIntersector4Chunk
sse2::BVH4XfmTriangle4Intersector1Moeller
sse2::InstanceIntersectorN
sse2::QBVH
sse2::QBVH4Quad4iIntersector1Pluecker
sse2::QBVH4Triangle4iIntersector1Pluecker
sse4.1
sse4.2
sse42::BVH4Bezier1iIntersector1
sse42::BVH4Bezier1iIntersector1_OBB
sse42::BVH4Bezier1iIntersector4Hybrid
sse42::BVH4Bezier1iIntersector4Hybrid_OBB
sse42::BVH4Bezier1vIntersector1
sse42::BVH4Bezier1vIntersector1_OBB
sse42::BVH4Bezier1vIntersector4Hybrid
sse42::BVH4Bezier1vIntersector4Hybrid_OBB
sse42::BVH4IntersectorStreamPacketFallback
sse42::BVH4Line4iIntersector1
sse42::BVH4Line4iIntersector4
sse42::BVH4Line4iMBIntersector1
sse42::BVH4Line4iMBIntersector4
sse42::BVH4OBBBezier1iMBIntersector1_OBB
sse42::BVH4OBBBezier1iMBIntersector4Hybrid_OBB
sse42::BVH4Quad4iIntersector1Moeller
sse42::BVH4Quad4iIntersector1Pluecker
sse42::BVH4Quad4iIntersector4HybridMoeller
sse42::BVH4Quad4iIntersector4HybridPluecker
sse42::BVH4Quad4iIntersectorStreamMoeller
sse42::BVH4Quad4iIntersectorStreamPluecker
sse42::BVH4Quad4iMBIntersector1Moeller
sse42::BVH4Quad4iMBIntersector1Pluecker
sse42::BVH4Quad4iMBIntersector4HybridMoeller
sse42::BVH4Quad4iMBIntersector4HybridPluecker
sse42::BVH4Quad4vIntersector1Moeller
sse42::BVH4Quad4vIntersector1Pluecker
sse42::BVH4Quad4vIntersector4HybridMoeller
sse42::BVH4Quad4vIntersector4HybridMoellerNoFilter
sse42::BVH4Quad4vIntersector4HybridPluecker
sse42::BVH4Quad4vIntersectorStreamMoeller
sse42::BVH4Quad4vIntersectorStreamMoellerNoFilter
sse42::BVH4Quad4vIntersectorStreamPluecker
sse42::BVH4SubdivPatch1CachedIntersector1
sse42::BVH4SubdivPatch1CachedIntersector4
sse42::BVH4SubdivPatch1CachedMBIntersector1
sse42::BVH4SubdivPatch1CachedMBIntersector4
sse42::BVH4SubdivPatch1EagerIntersector1
sse42::BVH4SubdivPatch1EagerIntersector4
sse42::BVH4SubdivPatch1Intersector1
sse42::BVH4SubdivPatch1Intersector4
sse42::BVH4SubdivPatch1MBIntersector1
sse42::BVH4SubdivPatch1MBIntersector4
sse42::BVH4Triangle4Intersector1Moeller
sse42::BVH4Triangle4Intersector4HybridMoeller
sse42::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse42::BVH4Triangle4IntersectorStreamMoeller
sse42::BVH4Triangle4IntersectorStreamMoellerNoFilter
sse42::BVH4Triangle4iIntersector1Moeller
sse42::BVH4Triangle4iIntersector1Pluecker
sse42::BVH4Triangle4iIntersector4HybridMoeller
sse42::BVH4Triangle4iIntersector4HybridPluecker
sse42::BVH4Triangle4iIntersectorStreamMoeller
sse42::BVH4Triangle4iIntersectorStreamPluecker
sse42::BVH4Triangle4iMBIntersector1Moeller
sse42::BVH4Triangle4iMBIntersector1Pluecker
sse42::BVH4Triangle4iMBIntersector4HybridMoeller
sse42::BVH4Triangle4iMBIntersector4HybridPluecker
sse42::BVH4Triangle4vIntersector1Pluecker
sse42::BVH4Triangle4vIntersector4HybridPluecker
sse42::BVH4Triangle4vIntersectorStreamPluecker
sse42::BVH4Triangle4vMBIntersector1Moeller
sse42::BVH4Triangle4vMBIntersector1Pluecker
sse42::BVH4Triangle4vMBIntersector4HybridMoeller
sse42::BVH4Triangle4vMBIntersector4HybridPluecker
sse42::BVH4VirtualIntersector1
sse42::BVH4VirtualIntersector4Chunk
sse42::BVH4VirtualIntersectorStream
sse42::BVH4VirtualMBIntersector1
sse42::BVH4VirtualMBIntersector4Chunk
sse42::BVH4XfmTriangle4Intersector1Moeller
sse42::QBVH4Quad4iIntersector1Pluecker
sse42::QBVH4Triangle4iIntersector1Pluecker
sso;2b
st common prefix length of bit representations \n// if  representations are equal we consider sucessive indices \nINLINE int delta(GLOBAL int const* morton_codes, int num_prims, int i1, int i2) \n{ \n    // Select left end \n    int left = min(i1, i2); \n    // Select right end \n    int right = max(i1, i2); \n    // This is to ensure the node breaks if the index is out of bounds \n    if (left < 0 || right >= num_prims)  \n    { \n        return -1; \n    } \n    // Fetch Morton codes for both ends \n    int left_code = morton_codes[left]; \n    int right_code = morton_codes[right]; \n \n    // Special handling of duplicated codes: use their indices as a fallback \n    return left_code != right_code ? clz(left_code ^ right_code) : (32 + clz(left ^ right)); \n} \n \n// Find span occupied by internal node with index idx \nINLINE int2 find_span(GLOBAL int const* restrict morton_codes, int num_prims, int idx) \n{ \n    // Find the direction of the range \n    int d = sign((float)(DELTA(idx, idx+1) - DELTA(idx, idx-1))); \n \n    // Find minimum number of bits for the break on the other side \n    int delta_min = DELTA(idx, idx-d); \n \n    // Search conservative far end \n    int lmax = 2; \n    while (DELTA(idx,idx + lmax * d) > delta_min) \n        lmax *= 2; \n \n    // Search back to find exact bound \n    // with binary search \n    int l = 0; \n    int t = lmax; \n    do \n    { \n        t /= 2; \n        if(DELTA(idx, idx + (l + t)*d) > delta_min) \n        { \n            l = l + t; \n        } \n    } \n    while (t > 1); \n \n    // Pack span  \n    int2 span; \n    span.x = min(idx, idx + l*d); \n    span.y = max(idx, idx + l*d); \n    return span; \n} \n \n// Find split idx within the span \nINLINE int find_split(GLOBAL int const* restrict morton_codes, int num_prims, int2 span) \n{ \n    // Fetch codes for both ends \n    int left = span.x; \n    int right = span.y; \n \n    // Calculate the number of identical bits from higher end \n    int num_identical = DELTA(left, right); \n \n    do \n    { \n        // Proposed split \n        int new_split = (right + left) / 2; \n \n        // If it has more equal leading bits than left and right accept it \n        if (DELTA(left, new_split) > num_identical) \n        { \n            left = new_split; \n        } \n        else \n        { \n            right = new_split; \n        } \n    } \n    while (right > left + 1); \n \n    return left; \n} \n \n// Set parent-child relationship \nKERNEL void emit_hierarchy_main( \n    // Sorted Morton codes of the primitives \n    GLOBAL int const* restrict morton_codes, \n    // Bounds \n    GLOBAL bbox const* restrict bounds, \n    // Primitive indices \n    GLOBAL int const* restrict indices, \n    // Number of primitives \n    int num_prims, \n    // Nodes \n    GLOBAL HlbvhNode* nodes, \n    // Leaf bounds \n    GLOBAL bbox* bounds_sorted \n    ) \n{ \n    int global_id = get_global_id(0); \n \n    // Set child \n    if (global_id < num_prims) \n    { \n        nodes[LEAFIDX(global_id)].left = nodes[LEAFIDX(global_id)].right = indices[global_id]; \n        bounds_sorted[LEAFIDX(global_id)] = bounds[indices[global_id]]; \n    } \n     \n    // Set internal nodes \n    if (global_id < num_prims - 1) \n    { \n        // Find span occupied by the current node \n        int2 range = find_span(morton_codes, num_prims, global_id); \n \n        // Find split position inside the range \n        int  split = find_split(morton_codes, num_prims, range); \n \n        // Create child nodes if needed \n        int c1idx = (split == range.x) ? LEAFIDX(split) : NODEIDX(split); \n        int c2idx = (split + 1 == range.y) ? LEAFIDX(split + 1) : NODEIDX(split + 1); \n \n        nodes[NODEIDX(global_id)].left = c1idx; \n        nodes[NODEIDX(global_id)].right = c2idx; \n        //nodes[NODEIDX(global_id)].next = (range.y + 1 < num_prims) ? range.y + 1 : -1; \n        nodes[c1idx].parent = NODEIDX(global_id); \n        //nodes[c1idx].next = c2idx; \n        nodes[c2idx].parent = NODEIDX(global_id); \n        //nodes[c2idx].next = nodes[NODEI
st:PM
startThreads@TaskScheduler@embree@@CAXXZ
startThreads@ThreadPool@TaskScheduler@embree@@QEAAXXZ
start_threads
state not recoverable
static
static geometries cannot get modified
static scenes can only contain static geometries
static scenes cannot get modified
stdcall
stream buffer empty
stream end
stream error
stream timeout
stride of vertex buffers have to be identical for each time step
string
string too long
stλ$oZ
suM+\nH
subdiv_accel
subdiv_accel_mb
subdivision surfaces
subdivpatch1
subdivpatch1cached
subdivs
supported
sw@;E
swapThread@TaskScheduler@embree@@CAPEAUThread@12@PEAU312@@Z
swedish-finland
swift_1
swift_2
sy\v:6
syr-SY
syr-sy
s|@9l
sºJlֺM
s»;6P
sǙ=di
s͛=Ei
sϺu`M9
sݹsQM
s移\erH
s躭\te
t $;c
t \f*d
t ]9p
t!+V\bH
t!1;zP
t!:6C
t!Hc\vH
t!s99\v3
t" fC
t#B;o
t#k:M
t$ ATAUAVAWE3
t$ AVH
t$ AWH
t$ UATAUAVAWH
t$ UAWH
t$ UWATAVAW
t$ UWATAVAWH
t$ UWAVH
t$ UWAWH
t$ WATAUAVAWH
t$ WATAVH
t$ WATAWH
t$ WAUAVH
t$ WAVAWH
t$ WAVM
t$ ba|H
t$ ff
t$ fff
t$(A2
t$(ba|H
t$0H;E
t$0fff
t$0ŐX
t$48_\bu?H
t$@H;EX
t$@IcF
t$@Lc
t$HA_A^A]A
t$HH9q`t
t$O7:\a
t$P@87u
t$PHc
t$PfE
t$PfH
t$Pu!A
t$Pv\vH
t$PŘXM
t$XIcmlC
t$`L#N\bt
t$`fB
t$`fD
t$hH97
t$hL#N\bt
t$ht\fH
t$pD;nD
t$pHc
t$pL#N\bt
t$pfA
t$pfD
t$x3\tD$HH
t$xE3
t$xHcOH
t%TvZ
t%fE9\bt
t&b;Ab
t'HcG
t'HcАH
t'j=2\fB
t'ѹm3
t(9Z\ae
t(:dIf
t(HcJ\fH
t(c<@_j9aE
t)D8l$@t\fH
t)HcJ\fH
t)IcV\bH
t* fC
t*HcJ\fH
t+;RU
t+\a\b40\a
t+z:X
t,HcJ\fH
t-Z;anJ
t-\a\b42\a
t-\a\bd2\a
t-s;D
t.;bzZ
t.C<p
t.k:H9
t.ۺubL
t/̺Ttz
t099\t
t0<Yi
t0\bP!V
t0\bP!X
t0\e:R
t0h \t'4J
t1?"t1?"t1?"t1
t1p;ˣ\b
t2V<Ϛ0
t3 b1
t3<S-a
t3ܻA\a
t4;ExF
t4N;V
t4\e;9V
t4\v*d3\v*42\v
t4z;@;k
t5ƺO/M
t6$:N
t6B<g
t6P=H\f
t6p7MOf
t7t9]9m
t7ݹIMj
t8<Q.I
t8=j&꼪o
t8=tD
t8B: \b
t8M<TTs
t8Tڿ:baK
t8\r*d7\r*46\r
t8d<xvt
t8r<G
t95:B
t9Cʈ8
t9Oa0
t9\v*d7\v*46\v
t9q x
t9x#\t0h$\t'4R
t9x+\t0h,\t'4b
t9x/\t0h0\t'4j
t:!xC
t:1iV
t:3]T
t:B0\r
t:DkL
t:\at
t:\n3d9\n+48\n
t:\t7d9\t/48\t\e
t:_Li
t:c\a\e
t:dS\a9
t:lyY
t:o[4
t:uEZ
t;.9t9
t;8F|:G
t;:ZM
t;GR4;KKY
t;J479
t;O\av
t;TXQ9
t;\aJt
t;\e5f
t;\vw\n:sT\r
t;eAK
t;hR\f
t;ig4
t;pcl:V
t;qs\r
t;y8z
t;ܣɻGcA
t< >M
t<$6C
t<%fH
t<*dK<7
t<:r8
t<;FP
t<@cO
t<Fer
t<J"˻3O
t<R8u
t<\e3
t<\rN\e9
t<\tFU
t<b8o9Hu
t<jeܻ6
t<u<Y
t<u=4<I
t<wTj
t<zTa9b
t=8dE
t=UWټi
t=\aMf>,u
t=\fO
t=cl;=L
t=gW켼\fg
t>&EF
t>QW2
t>Yj >h~5
t>\bU
t>n;r
t>u}9
t>͛g<4F
t?@b1
t?L;YᴻL
t?X5I
t?\a\bdD\a
t@)fLL
t@HcS\bH
t@REF%08lX
tA<DF
tAO:q
tA\v9
tB9\a4
tB:,NR
tB<#b
tCI9I
tCU:Y
tC\a*dA\a*4@\a
tD$|M
tD8X0t
tD='sC
tD\f*dC\f*4B\f
tD\r*dC\r*4B\r
tDĻ&cS
tE=@8
tF*<ZIj
tF;^d
tF=A䴼th
tF@8x0t
tF\a%dE\a%4D\a
tF\n7dE\n/4D\n\e
tG<zmZ
tGѻ.N
tH#:P
tH696d
tHY-oVD
tHY-qhE
tHcȉL$0
tHкKY
tI@8{:t
tI\a\bdN\a
tI\n*dH\n*4F\n
tJ:4zs
tJ>\a
tJR>8o
tJY%`hE
tJ\a%dI\a%4H\a
tJ\a*dI\a*4H\a
tK9_\bt
tK@8{:t
tKI=dXW
tK\a\bdP\a
tL$@fD
tL:\t0
tL;!lD
tL\f*dK\f*4J\f
tL\t%dK\t%4J\t
tL\v*dK\v*4J\v
tLg:C
tLջJ0
tM99WC
tM:>V|;mB
tMF<TV
tM\e;>m
tM\f*dK\f*4J\f
tM\r*dK\r*4J\r
tN:;\fP
tN\a\bdR\aP
tO,>f
tO;7Q
tO\b\bdP\b
tP@;r
tP\a\bdT\a
tP\f*dO\f*4N\f
tPϹƃg
tQ:|nG
tQD8c:u0M
tQX<sF
tQfD9 tK
tQg;l
tR$;9p
tRHǅ(\t
tRHǅ\b\t
tRV=\v
tR\a\bdX\a
tR躽1ݹY
tSHǅ(\n
tSHǅH\n
tSHǅH\t
tSHǅ\b\n
tSHǅh\n
tSHǅh\t
tSf91tNH
tT5#7B
tT:V05
tT\f*dS\f*4R\f
tTŸY\rM
tTػRa
tU8X0tP
tU8Z0tP
tUHǅ(\v
tUHǅH\v
tUHǅ\b\v
tV9;\v\e
tV;#4
tVf91tQH
tVݻr\r
tW=1¬=n
tW@8x0tQ
tW@8z0tQ
tWt:ttt
tX+>a
tX-< Gd
tXF:OPͺo
tXT"@āLY
tXT0@āDY
tXT0@ġDY
tXT1@āLY
tXT:@āLY
tXT\a
tXT\a@āDY
tXT\b
tXT\b@ġLY
tXT\n
tXT\n@āLY
tXT\n@ġLY
tXT\t
tXT\v
tX\a\bd^\a
tX\f*dW\f*4V\f
tX\v*dW\v*4V\v
tY5m5H
tY@8h0tS
tYT\a
tY\n*dW\n*4V\n
tY܈E\bH
tZ<eGv<\b4
tZ\b\bd^\b
tZ\n3dY\n+4X\n
t\\̉E4A
t\\̉EHA
t\a-<jv
t\a:Z
t\a?GY\r
t\aA\v
t\aH9D$PuCH
t\b<x\n\b3h\v\b*t
t\e\a\b4 \a
t\f;e
t\fH;Q@s
t\fO;l¯:Y
t\n<0u
t\n<0uC
t\nF?s
t\nH9Ahs
t\nH9P A
t\n\t\bd\v\tp
t\nbatH
t\r98t\fH
t\r; iҼn
t\r;vW
t\r@88t\vH
t\rL#\r\e
t\rfD9\nu\a
t\rp\f0\vP
t\t\n:9
t\v>\fw
t\vK9D'\b
t`:MK
t`\bP!d
t`\bP!f
t`\bP!q
ta8X0t
ta97zX
ta;e,F
ta<pN
taL9Chu
task cancelled
task stack overflow
tb!T@Yt\t
tb!|H
tbA\\HYe\ab
tbA|H
tbH;P(H
tbI<XO
tbQ|H
tb\v%da\v%4`\v
tbad(W
tba|H
tba|\b
tba}Hp
tbq}HpɱbA
tbq}HpбbA
tc7=P
tc;7!C
tc@8x0t
tc蹇k9
tdm;O1h
te=\tGR
teA8h\bu\fH9h
temp < 0.f || temp > t_max) \n    { \n        return t_max; \n    } \n    else \n    { \n        return temp; \n    } \n} \n \nINLINE \nfloat3 safe_invdir(ray r) \n{ \n    float const dirx = r.d.x; \n    float const diry = r.d.y; \n    float const dirz = r.d.z; \n    float const ooeps = 1e-8; \n    float3 invdir; \n    invdir.x = 1.0f / (fabs(dirx) > ooeps ? dirx : copysign(ooeps, dirx)); \n    invdir.y = 1.0f / (fabs(diry) > ooeps ? diry : copysign(ooeps, diry)); \n    invdir.z = 1.0f / (fabs(dirz) > ooeps ? dirz : copysign(ooeps, dirz)); \n    return invdir; \n} \n \n// Intersect rays vs bbox and return intersection span.  \n// Intersection criteria is ret.x <= ret.y \nINLINE \nfloat2 fast_intersect_bbox1(bbox box, float3 invdir, float3 oxinvdir, float t_max) \n{ \n    float3 const f = mad(box.pmax.xyz, invdir, oxinvdir); \n    float3 const n = mad(box.pmin.xyz, invdir, oxinvdir); \n    float3 const tmax = max(f, n); \n    float3 const tmin = min(f, n); \n    float const t1 = min(min3(tmax.x, tmax.y, tmax.z), t_max); \n    float const t0 = max(max3(tmin.x, tmin.y, tmin.z), 0.f); \n    return make_float2(t0, t1); \n} \n \n// Given a point in triangle plane, calculate its barycentrics \nINLINE \nfloat2 triangle_calculate_barycentrics(float3 p, float3 v1, float3 v2, float3 v3) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n    float3 const e = p - v1; \n    float const d00 = dot(e1, e1); \n    float const d01 = dot(e1, e2); \n    float const d11 = dot(e2, e2); \n    float const d20 = dot(e, e1); \n    float const d21 = dot(e, e2); \n \n    float denom = (d00 * d11 - d01 * d01); \n     \n    if (denom == 0.f) \n    { \n        return make_float2(0.f, 0.f); \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invdenom = 1.f / denom; \n#else \n    float const invdenom = native_recip(denom); \n#endif \n \n    float const b1 = (d11 * d20 - d01 * d21) * invdenom; \n    float const b2 = (d00 * d21 - d01 * d20) * invdenom; \n    return make_float2(b1, b2); \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n#define STARTIDX(x)     (((int)(x.pmin.w)) >> 4) \n#define NUMPRIMS(x)     (((int)(x.pmin.w)) & 0xF) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n#define NEXT(x)     ((int)((x).pmax.w)) \n \n \n \n/************************************************************************* \n TYPE DEFINITIONS \n **************************************************************************/ \ntypedef bbox bvh_node; \n \ntypedef struct \n{ \n    // Vertex indices \n    int idx[3]; \n    // Shape ID \n    int shape_id; \n    // Primitive ID \n    int prim_id; \n} Face; \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL  \nvoid intersect_main( \n    // BVH nodes \n    GLOBAL bvh_node const* restrict nodes, \n    // Triangle vertices \n    GLOBAL float3 const* restrict vertices, \n    // Triangle indices \n    GLOBAL Face const* restrict faces, \n    // Rays  \n    GLOBAL ray const* restrict rays, \n    // Number of rays \n    GLOBAL int const* restrict num_rays, \n    // Hit data \n    GLOBAL Intersection* hits \n) \n{ \n    int global_id = get_global_id(0); \n \n    if (global_id < *num_rays) \n    { \n        // Fetch ray \n        ray const r = rays[global_id]; \n \n        if (ray_is_active(&r)) \n        { \n            // Precompute inverse direction and origin / dir for bbox testing \n            float3 const invdir = safe_invdir(r); \n            float3 const oxinvdir = -r.o.xyz * invdir; \n            // Intersection parametric distance \n            float t_max = r.o.w; \n \n            // Current node address \n            int addr = 0; \n            // Current closest face index \n            int isect_idx = INVALID_IDX; \n \n            while (addr != INVALID_IDX) \n
tessellation_cache_size
text file busy
text$di
text$mn
text$mn$00
text$x
text$yd
tf/<LP
tf<KN
tf\a*de\a*4d\a
tf\v%de\v%4d\v
tfffffff
tg;iY
tg\n7de\n/4d\n\e
th*;073
th/;On
th9@p
th<V3̻I
th\r*dg\r*4f\r
thiscall
thread the following way
thread@TaskScheduler@embree@@CAPEAUThread@12@XZ
threadCount@TaskScheduler@embree@@SA_KXZ
threadID@TaskScheduler@embree@@SA_KXZ
threadIndex@TaskScheduler@embree@@SA_KXZ
threads
thy<F
ti;?z$9
ti;ڣ0;M
tiY:SV
ti\e>I
ti\n*dg\n*4f\n
ti\t*dh\t*4f\t
timed out
tj;+Z
tj;5R
tj\t3di\t+4h\t
tk<\vD
tkE>fvw
tkH;P(H
tk\a=W
tl;\bGE
tlN\f
tlT9t
tl\a%dk\a%4j\a
tl\n%dk\n%4j\n
tl\r*dk\r*4j\r
tls$ZZZ
tlŸY\rya
tm\f;q
tm\n*dk\n*4j\n
tn$;Wc
tn)=0O
tn,<w7
tnM;:Lf
tn\a*dm\a*4l\a
tn\f*dm\f*4l\f
tn\n7dm\n/4l\n\e
tny<l\nB
to:\taع4
to;6O
to\a*dm\a*4l\a
too many files open
too many files open in system
too many length or distance symbols
too many links
too many symbolic link levels
total
total            : sah
tp;GJl
tp;bJ̺j
tp<\nZ3
tpH91uk
tp[9\aO
tp\a\bdv\aP
tp\bP!\f
tp\bP!o
tp\b`\a0
tp\b`\aP
tp\f*do\f*4n\f
tp\r*do\r*4n\r
tpɼy\tw
tq\r*do\r*4n\r
tr%<.Om
tr:b51
tr\f*dq\f*4p\f
tr\t7dq\t/4p\t\e
tr\v>l(C
transformNodes
traverser
traverser_mb
tri_accel
tri_accel_mb
tri_builder
tri_builder_mb
tri_traverser
tri_traverser_mb
triangle4
triangle4i
triangle4v
triangle4vmb
triangles
trinidad & tobago
ts,<aM
ts;Hj
tsH91un
tsg:B
ts̸pv
tt$xD
tt\f*ds\f*4r\f
tt\r*ds\r*4r\r
tv;<D~G
tv>`I6=yW
tvL<U
tvûY`ԻA
tw\a\bdx\aP
twx\\w
tx<w]Y
tx\a\bd~\a
tx\f*dw\f*4v\f
tx\r*dw\r*4v\r
txмkn
ty\a\bdz\a
tyfD9 tsH
typeof
tz/9u1
tzH9\nuu
tz\a>yI5
tz\f*dy\f*4x\f
t{757
t{<j4
t|$DD
t|$TD
t|$dA
t}9;p
t}һO\r0
t~; Q
t~E;C
t»Wv̻Hu
t¼!8W
tƻCrb8"q
tʊD$8
tл\tm
tѣ<EW
tӎ;3u
tӺP\e\r
t۹>WJ
tۺ$4f
t⻲x\n
t焹G!y
t蝼^Pf
t뾖2j<C
u HcA<H
u L#N\bt
u M;w\b
u ba|H
u }<w88
u!bA|H
u"A8x,u
u#H9p s
u#H9x s
u(9A\bs
u(;3EV
u(L9\au\fH
u(k:9
u+L=B
u. ;BS0
u.>:wSG
u1!D$0H
u1D9{\bu+M
u3@8{,u-L
u4L;] t.L
u4\f<$v
u6ɸNGq
u7;otR;U
u7n;w7
u7t=fD
u8;-h
u8M9\av3I
u8U\e
u9<%F
u::wG
u:B\tP
u:R$h
u:h[0:U
u;2*m
u;5tg
u;;UsK
u;H"n
u;Lx9P쉺c
u;UȪ9
u;seؼr
u<>xg
u<K\nQ<f
u<\rDk
u<ջiR
u=K,J
u>2jh
u@9A\bs
u@:SG
u@L#N\bt
uA8D$`t\bH
uA;=Ne`=aE
uB<_Kt
uBa|)CG
uC<Y3V
uD=W2
uDx;!\e
uE:4Z
uF<xXߺR
uHL#N\bt
uJA:4a
uJ\r^$8
uK8o-\a
uK;xXL
uMcσ~\b
uN:w\n*9T
uN漘\e
uOɼ3\r
uP96K\v9
uPI;x\b
uQ8G\buAH
uQr;s
uTH9_0v
uV;U\n
uWh<Z
uXL#N\bt
uX뼔y\t<\b
uY<opx<c
uY\v:A
uZ;u{\v
uZEeu\b
uZH9_0v
u\abA
u\b9A\bs
u\b< t;<\tt7
u\b<oel
u\b<xv\b3hw\b*t
u\bbA|H
u\bbA|I
u\bbQ|H
u\bh;I
u\ee<XT
u\f9\r
u\fbQ|H
u\nA8
u\nA84
u\nA8_P
u\nD8AP
u\nL;y r
u\rb>g
u\rba,HY
u\rba|H
u\rfD9d$0
u\rw=Uf
u\t<BFb
u\tb"-H
u\tbA
u\tbA4HYM
u\v>W
u]D8O\buIH
u^8G\buGH
u^n=Zn
u_H:dB
u`9A\bs
u`L#N\bt
u`ġzoLG@ģu
ua;'W
uaA8_\buEI
ub'vb'v
ucF:\\T
ucO;oO09
udt returning
uf!T$(H!T
uf\v:5n
uh4;E9u
uh{:8
ui="jf
uiA8_\buEI
um;o(k
umٺ\bC
un;DW
unaligned
unalignedNodes
unalignedNodesMB
united-kingdom
united-states
unknown
unknown buffer type
unknown builder
unknown compression method
unknown error
unknown exception caught
unknown hair acceleration structure
unknown header flags set
unknown line segment acceleration structure
unknown motion blur hair acceleration structure
unknown motion blur line segment acceleration structure
unknown motion blur triangle acceleration structure
unknown quad acceleration structure
unknown quad motion blur acceleration structure
unknown readable parameter
unknown subdiv accel
unknown subdiv mblur accel
unknown traverser
unknown triangle acceleration structure
unknown user geometry accel
unknown user geometry mblur accel
unknown writable parameter
uoA8]\buMI
up;Ijf
upŸX}p
upƺ%W
uq`:)SK
us=;aI
usE8E\buQI
use_single_mode
used blocks
usemtl material_%d\n
user32
usergeom
using
uuNu'uu
uv+:t
uv\r;DF
uwo;Pw
uz-UZ-Cyrl
uz-UZ-Latn
uz-uz-cyrl
uz-uz-latn
uɊ9Rbj9
uɺ=z8
uδ;cf
uϋD$$LcL$(Hcl
uԋ<8Q
uݼ,Jn
v %f %f %f\n
v ><W
v D+v0D
v Lc\\$8I
v ɺM119
v";jd
v#9Lo_9
v#S;Pe
v$G<@A4
v%m=k
v&t*b&a
v)0;Px
v)9%4o
v)\a=Q2
v-;bG6
v-Y:\ev
v-jEJ
v-o;~z7
v-~eF
v.<zBA
v0,<\nTF
v0<a_\n
v1ͻ&e
v2!L.2
v2;[8e
v2Z;s\f
v4#:0
v4:6ݸ;f
v5?:7IN;\e
v5HcT
v5~:P
v6:Gq\n
v8F9\n
v9&;D
v9+M=9
v9A^5
v9d[z
v9o{W
v:+YC
v:5Il;˅N
v:;C5\n
v:<mF2;T,\b<uNV
v:JzK
v:M:3
v:X$T
v:ZQS
v:\br\t:H
v:kaH:l
v:lP :TFt82
v:պH\aa8
v;)mM9
v;0^8
v;509;4
v;:Pl
v;D\v
v;S\r
v;Us3;G
v;Zy\e
v;\tLr;{tb
v;\tnʺSF
v;`n5
v;dW><K
v;oOc:L
v;reO
v;s}p
v;w0N
v;x;K
v<Aj\n
v<F㴻JV
v<eiƼ1
v<er󻗇\t
v<n$b;L\r
v<x@\v3hA\v*t
v<~0p
v=#hD
v=Qeh
v=Y]Bv
v=YiZ
v=_cT
v>'5C
v>P9#>nV
v>x掾2
v>yE\v
v>{Ed=o
v>Ĩ\f>JfJ>MM
v?,\tm2
v?PDt?a
v@DIMENSION_SCALE
v@L:qY
vA03>A
vA;b\n
vBF:\r
vC<RDJ<s
vCք\tes\vC
vDN<V
vF;6S8
vF<a5L
vG|HO
vH9y\bu
vH;A\bu
vH;Q\bu
vH;Q\bu\rL
vHcG\bH
vHȻd(5
vK;A\fL
vL77㉼Q
vL9u O
vL<2N
vL{j\t\f
vLûbSv:̦I
vM8¶R
vM>TYӾI
vMW;q#6=2
vM~;Av
vN;\fLu
vNcD\b
vNr:oU
vO,;Y2
vO<lCF
vPE;E
vQ;7&N
vQ츟Xc
vR!;0
vSc<bAӽy
vT$9f
vT;nur;W
vT;|j
vTv<F
vU˻=nT
vValve Corp.0
vValve Corp.1
vWf;Ob\e
vX%|UQ
vX%|hQ
vX:s,\e
vX廑|Q;K
v[;\r6s
v[GbO\b
v\\8E5
v\a4:n
v\bD;3
v\f(<BI
v\f>GvS
v\f̺e\t
v\n\f;C4
v\nbatH
v\t;~y0
v\t<8Rj
v\t>k
v\tL;Y
v\tbQ|H
v\tcvo
v\tݺEx\v
v\v_;VYf:UPH
v\vɻz
v^>\nhh
v`3\bD$PL
v`Hc\aH
value too large
vaw</i
vaݺ\nkt
vb"5H
vb-;R
vb:<I
vb:o\t
vb<PK
vbA|H
vbA|\b
vbB5H
vbQ|H
vban\bX
vbase destructor
vba|H
vbqLHX
vbtable
vc<PM?;l
vcall
vde=s
vdir); \n    float3 const n = mad(box.pmin.xyz, invdir, oxinvdir); \n    float3 const tmax = max(f, n); \n    float3 const tmin = min(f, n); \n    float const t1 = min(min3(tmax.x, tmax.y, tmax.z), t_max); \n    float const t0 = max(max3(tmin.x, tmin.y, tmin.z), 0.f); \n    return make_float2(t0, t1); \n} \n \n// Given a point in triangle plane, calculate its barycentrics \nINLINE \nfloat2 triangle_calculate_barycentrics(float3 p, float3 v1, float3 v2, float3 v3) \n{ \n    float3 const e1 = v2 - v1; \n    float3 const e2 = v3 - v1; \n    float3 const e = p - v1; \n    float const d00 = dot(e1, e1); \n    float const d01 = dot(e1, e2); \n    float const d11 = dot(e2, e2); \n    float const d20 = dot(e, e1); \n    float const d21 = dot(e, e2); \n \n    float denom = (d00 * d11 - d01 * d01); \n     \n    if (denom == 0.f) \n    { \n        return make_float2(0.f, 0.f); \n    } \n     \n#ifdef USE_SAFE_MATH \n    float const invdenom = 1.f / denom; \n#else \n    float const invdenom = native_recip(denom); \n#endif \n \n    float const b1 = (d11 * d20 - d01 * d21) * invdenom; \n    float const b2 = (d00 * d21 - d01 * d20) * invdenom; \n    return make_float2(b1, b2); \n} \n \n /************************************************************************* \n   EXTENSIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n#define STARTIDX(x)     (((int)((x).child0))) \n#define LEAFNODE(x)     (((x).child0) == ((x).child1)) \n#define GLOBAL_STACK_SIZE 32 \n#define SHORT_STACK_SIZE 16 \n#define WAVEFRONT_SIZE 64 \n \ntypedef struct \n{ \n    int parent; \n    int child0; \n    int child1; \n    int next; \n} bvh_node; \n \ntypedef struct \n{ \n    // Vertex indices \n    int idx[3]; \n    // Shape ID \n    int shape_id; \n    // Primitive ID \n    int prim_id; \n} Face; \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \nKERNEL void \noccluded_main( \n    // Bvh nodes \n    GLOBAL bvh_node const * restrict nodes, \n    // Bounding boxes \n    GLOBAL bbox const* restrict bounds, \n    // Triangles vertices \n    GLOBAL float3 const * restrict vertices, \n    // Triangle indices \n    GLOBAL Face const* faces, \n    // Rays \n    GLOBAL ray const * restrict rays, \n    // Number of rays in rays buffer \n    GLOBAL int const * restrict num_rays, \n    // Stack memory \n    GLOBAL int* stack, \n    // Hit results: 1 for hit and -1 for miss \n    GLOBAL int* hits \n    ) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Handle only working set \n    if (global_id < *num_rays) \n    { \n        ray const r = rays[global_id]; \n \n        if (ray_is_active(&r)) \n        { \n            // Allocate stack in global memory  \n            __global int* gm_stack_base = stack + (group_id * WAVEFRONT_SIZE + local_id) * GLOBAL_STACK_SIZE; \n            __global int* gm_stack = gm_stack_base; \n            // Allocate stack in LDS \n            __local int lds[SHORT_STACK_SIZE * WAVEFRONT_SIZE]; \n            __local int* lm_stack_base = lds + local_id; \n            __local int* lm_stack = lm_stack_base; \n \n            // Precompute inverse direction and origin / dir for bbox testing \n            float3 const invdir = safe_invdir(r); \n            float3 const oxinvdir = -r.o.xyz * invdir; \n            // Intersection parametric distance \n            float const t_max = r.o.w; \n \n            // Current node address \n            int addr = 0; \n            // Current closest intersection leaf index \n            int isect_idx = INVALID_IDX; \n \n            //  Initalize local stack \n            *lm_stack = INVALID_IDX; \n            lm_stack += WAVEFRONT_SIZE; \n \n            // Start from 0 node (root) \n            while (addr != INVALID_IDX) \n            { \n                // Fetch next node \n                bvh_node const node = nodes[addr
vd˺;U
ve;;w
vector constructor iterator
vector copy constructor iterator
vector deleting destructor
vector destructor iterator
vector too long
vector vbase constructor iterator
vector vbase copy constructor iterator
vector<T> too long
vectorcall
verbose
verbosity
vertex buffer can be at most 16GB large
vertices
veɹt쵺5
vf;2yt
vf=;,UG;e
vf?;A@F
vftable
vg\v;.JB;N
vh:L=9
vh;Am
vhT;m$k
virtual displacement map
vj&<SS
vj8jB49
vla;"Y
vm:ay
vm:ay̺K\n
vm;9)t
vm<R\b
vn;\b
vo$;E
vp$;V/A
vp\nP!\r
vp\n`\t0\bP
vp\n`\tP\b0
vq9xk
vq;?7\t
vq;p\n
vq<<3
vqJ=C
vrؖ\viȗ\v
vrؘ\viș\v
vs:'cl
vsd=\fJ
vt;\vqi
vt\r<x
vt}<x
vu:XXR
vvܻOs
vwFHcN
vw˼R識4
vx=-o
vx\r=YG
vy;."w9\b
vy}:\nD
vz̻UWC
vzټw2D
v{;9I&9
v|G9RT
v}8<\bo
v}ŹWl#9!L
v~9;UF
v~:oe
v~o<gS
vä;OH
vĎ:Hf
vȉD$0
v̺B8c
vӽ9NB\n:3
vԥ;aY
vܻh+G;0I
vߔ<Av
v↻vhW
w = shmem[localId];\\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4_V1(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_##type##4##_v1(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    shmem[localId] = v1.x + v1.y + v1.z + v1.w + v2.x + v2.y + v2.z + v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    type offset = shmem[localId];\\ \n    type t = v1.x; v1.x = offset; offset += t;\\ \n    t = v1.y; v1.y = offset; offset += t;\\ \n    t = v1.z; v1.z = offset; offset += t;\\ \n    t = v1.w; v1.w = offset; offset += t;\\ \n    t = v2.x; v2.x = offset; offset += t;\\ \n    t = v2.y; v2.y = offset; offset += t;\\ \n    t = v2.z; v2.z = offset; offset += t;\\ \n    v2.w = offset;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_PART_4(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_part_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __global type* out_sums, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupId   = get_group_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\\ \n    v2.w += v1.w;\\ \n    shmem[localId] = v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    type sum = group_scan_exclusive_part_##type(localId, groupSize, shmem);\\ \n    if (localId == 0) out_sums[groupId] = sum;\\ \n    v2.w = shmem[localId];\\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_GROUP_REDUCE(type)\\ \n    void group_reduce_##type(int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n#define DEFINE_DISTRIBUTE_PART_SUM_4(type)\\ \n    __kernel void distribute_part_sum_##type##4( __global type* in_sums, __global type##4* inout_array, uint numElems)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int groupId   = get_group_id(0);\\ \n    type##4 v1 = safe_load_##type##4(inout_array, globalId, numElems);\\ \n    type    sum = in_sums[groupId >> 1];\\ \n    v1.xyzw += sum;\\ \n    safe_store_##type##4(v1, inout_array, globalId, numElems);\\ \n} \n \n \n// These are already defined in A
w"ʻvbV
w$HcL
w$j:3\n
w%7;9Q
w':UlO
w(A+w0A
w(E+w0E
w+=P8
w+OQvr
w+\r<s\no
w,a;Yk
w.:IQ
w/:3\aw
w0<s4
w0<y6\n
w0\t<3u
w0Ӻo)9
w11:c
w2&:sx
w29iN\t
w4;\tp
w4G;\r\f
w4_;W
w5<;V
w9T\rM
w9\r쭺>zr
w:RΙ;P9
w;"Nd
w;7aٻ7r
w;G9\a
w;W:2
w;\nJ
w;\t㊽xY
w;oC?<4
w;rWz;5
w;sG\n
w;tGB
w;w"L
w;y?J
w<0|H
w<v0c
w<wB\f
w=^eI
w=wSN
w>B7c
wA]A\\]_^[ÐSVWUATAUH
wA^A]A
wA_A^A]A
wB;9ٳ;S
wB<1\a
wD:ę\t7
wEA;M0w
wF7=1D
wF;wk绢J
wF\\:Pjb
wF\e;Vf
wG0:\a
wGB:Jρ:F
wH:|7
wH;S\b
wH;\r7 o
wH;\rW#o
wIz<=Ug
wJ\r9
wJ\v<$p
wLC<ɬ\e
wM;GI
wNM:>Vk9M
wOb:mj
wQ<:\nT
wQ?;g
wSԼD\n
wT:;dsp
wT:Fv\e
wT\t=\a
wX3\bD$PL
wY:%E\n
wZ:Wv
wZw=www w
w\\K:pz
w\a<I
w\a\t
w\b:E\auj
w\b<xx\b3hy\b*t
w\bUUUU
w\bf;E\auuA
w\eu;\e
w\f;˪k9
w\fS:hC
w\t9\v/};xrb
w]A_A
w]A_A^A
w^;5aD
w_*<GaQ
w_F;P
wait@TaskScheduler@embree@@SA_NXZ
wasted
wb9X-s
we9XHt
we;\nS8
weV=Fq
wgQ=]h
wgj;p49
wh?9nMW
wi_<a
wiںSys
wl989d
wlY>s
wlԼ\r
wn>Jj
wn_;Ysڻs
wp\b>\tX
wqu:B
wrong protocol type
wrɼCk
ws1:Mt
ws;PXR
wsA99tnA
wt4:M
wv;\r\f\r
www.digicert.com1!0
www.digicert.com1$0
wxԺ\r/7
wy:-hs9
wyh;\b
wz@7\n
wzT<\f
wz\n=#qn
w{9YM
w|y<Q
w};b7\f
w¹Sg̺n
wÐUAWAVAUATVWS
wĢ<EC
w˼QPü`V
w̺MK}<6
wξ\fZD>L
wϼ{Tl
wԹ3\aB9
wպOY2
wڗ:GY
w۹qVO
w㔻97\b
w挽\b8
x :\e)K
x ATAVAWH
x AVHcA
x UATAUAVAWH
x UAVAWH
x(D$ H
x(D$pH
x(D$pL
x(L$0H
x(T$ L
x)T$ I
x)T$PL
x)l$0L
x)t$ f
x)t$`Mc
x)t$pL
x+9- G8
x+:xb
x+<efI
x-;CT0
x.>5bF
x.S9L
x.\a6h/\a-4j
x2\a6h3\a-4r
x4:sS
x4D>qI
x8:Sb(8h
x8}0\t9
x9:\nV
x9;Fu
x:;dH\e
x:P5Q:Zx
x:U8ǻi
x:\fd2
x:\rhN
x:f#9
x:ۚ\e9Fl
x;)Li
x;<a 9p
x;CaR
x;Er\v
x;MҠ9
x;R7̻1
x;\eI\a
x;hKR
x;q_x9
x;uLO
x;|8O
x<$OV
x<1f켹c
x<EHv
x<J\r
x<qio
x=&UǽWN4
x>0\n
x>Q<\aQ
x>V6'?C
x?;1BN
x?S;3
x@bB%H6
xA_A^A]A
xB-zC\f
xC<@x
xEV<V
xFG;vMV
xG :*魹h
xG)=p
xH<jc
xHL+x
xHL+x@3
xHM+x
xHY9#yn
xI;3H
xI;\e
xJ>Hf
xJF;E6
xM;\\YU
xN.<S
xN\v<>,l6
xP:Ed\r
xQ*;A
xQ4:\fF
xR;[SA:L
xRZ;U
xRealTimeComputeUnits2
xS69:yX
xT%U,D
xU";c
xU9:O
xU:b~\a
xU;qGK
xW5?vG
xWD$P
xWD$p
xWI96tRI
xWؽX"K
xX'>ubW<]1
xX8:ՄJ
xXT\f
xX\r<Xx
xXs<S
xYL\t H
xYT$@H
xYT\a
xY\\ p
xYd pġxY
xZ\n:2
x[9[xE
x[Q:xJx
x\\g:cH
x\aH;m
x\bH+8H
x\f=9Z\a
x\nIcL$l
x\v;f#C
x\vD$0H
x\vL;0
x]A_A^A]A
x_x;5
x`D<7J
xa9;EJ
xbػ(Ri
xdata
xdata$x
xdp>n
xe;&j
xeq<H
xf;}ws
xh"9A
xjͻKQs
xk]:45R
xl;!\r5
xn5;|:A
xo78$E
xoM=6
xoؾvK
xpxxxx\b\a\b\a
xr<Ir
xs;6y
xuĻv\fx
xw;^n
xwg=.,f
xwֻ\an
xxJ;*\f
xxJ<&X
xy<Aq9
xǊ:2C
xϻ8go
xؙ9eUl
xݻhṻI
y ba~\b
y º KI
y!A( L
y!C(0M
y!D\bH
y!D\bX
y!D\bX0
y!X8 H
y!`8 I
y!p8 H
y!x8 H
y!x8 I
y"D1P
y"D2P
y&:kw
y(J9h1
y+Y<w
y+{YB
y-N:Pv
y.<Hm
y.K91\aZ:-E
y/8Qv
y0G=XM
y1d<0
y2@\e
y2o9,p\b
y2úڪZ
y3H:wO
y4<G3
y5zo1
y63˼}l
y67;\eq
y9.9W
y9<wh
y9\r`y
y9`;S
y9k>":0
y9x0C;\n
y:)Jp
y:< 6K
y:@FO
y:Bm(:t
y:\rz
y:oSj
y;-y5
y;;vV
y;aAڻeD
y;cev:V
y;ƗJ:Vt
y;ƼPDx
y<;TDf
y<W%7
y<l:lEV
y=F:LO
y=e;q\t
y=uYX
y=u\n3
y=ľS=jz
y>(0r
y?Nny
yA9TYi
yA<\fM
yEٺn3
yI!<o;P
yJ=0xN>7
yKc:\n
yM:'S`9
yM<pIл[!j
yM>ȞI
yN<qyC
yNӻ!n{bk
yO>;g
yPHcz
yQ&<C7
yTw:Nr
yU;J\vǻty
yY;rY8
yZy;ᴀ:t
y\\PD
y\a<xz\a3h{\a*t
y\a\b
y\a\f0\vP
y\b< Dn9
y\bL+9I
y\bW;,l
y\bba~\b
y\eq;d
y\fúbM
y\r<o
y\r=5
y\rk;b\b
y\tV<&h
y\v;\vNX
y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.y; \n            out_values[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.z; \n            out_values[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.w; \n            out_values[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        scanned_histogram[localid] += sum; \n    } \n} \n \n \n__kernel void compact_int(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_group_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n} \n \n__kernel void compact_int_1(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output, \n    __global int* out_size) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_group_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n \n    if (global_id == 0) \n    { \n        *out_size = in_address[in_size - 1] + in_predicate[in_size - 1]; \n    } \n} \n \n__kernel void copy(__global int4* in_input, \n    uint  in_size, \n    __global int4* out_output) \n{ \n    int global_id = get_global_id(0); \n    int4 value = safe_load_int4(in_input, global_id, in_size); \n    safe_store_int4(value, out_output, global_id, in_size); \n} \n \n \n#define FLAG(x) (flags[(x)] & 0x1) \n#define FLAG_COMBINED(x) (flags[(x)]) \n#define FLAG_ORIG(x) ((flags[(x)] >> 1) & 0x1) \n \nvoid group_segmented_scan_exclusive_int( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n
y^O;T
y_U;O\t
ya=OYY
yb;\rA
ycI<p
ycO:"K
yd=Oi
ygV:J(6
yj';f
yl苼$P\r
yn->l7
ynD3Păy"D1P
ynL7Pģq"L3P
yni;t
you can use rtcSetIntersectFunctionN only in stream mode
you can use rtcSetIntersectionFilterFunctionN only in stream mode
you can use rtcSetOccludedFunctionN only in stream mode
you can use rtcSetOcclusionFilterFunctionN only in stream mode
you have to use rtcSetIntersectFunctionN (and optionally rtcSetIntersectFunction1Mp) in stream mode
you have to use rtcSetIntersectionFilterFunctionN in stream mode
you have to use rtcSetOccludedFunctionN (and optionally rtcSetOccludedFunction1Mp) in stream mode
you have to use rtcSetOcclusionFilterFunctionN in stream mode
you have to wait for spawned subtasks
yp; \eA
ypg<9M
ypm;pR
yrL9JT
ytV;D
yuϻ%NX
yv;\v
yvL$\bŸW
yvM\bŸW
yzC<Z
y~;8J
yȺ\nY
yɻP.K
y̺4\e6
yͺ:rN-7
yϻ/Z0
y耺SC\a
z <tHm
z >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.z*GROUP_SIZE + localid]); \n        //bin = ((value.w >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.w*GROUP_SIZE + localid]); \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int sum = 0; \n    if (localid < NUM_BINS) \n    { \n        for (int i = 0; i < GROUP_SIZE; ++i) \n        { \n            sum += histogram[localid * GROUP_SIZE + i]; \n        } \n \n        out_histogram[numgroups*localid + groupid] = sum; \n    } \n} \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid ScatterKeys(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localvals = safe_load_int4_intmax(in_keys, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localvals >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LDS \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everyth
z v"z$\t
z!U:I
z";WF
z&:RC
z(HcB0A
z*Y9Pw
z+R<4T
z,;EAI
z096?\a
z0=|Q
z0U;6x
z0\f>L
z1=<D
z2v;Ns
z4:(lk
z4:NA
z4\f<Elf
z4v?\f\b
z7:hv¹p_v
z7<Gi
z7H<ur
z8J:X
z8W;r=A;ATB
z8\axغB
z8v>\r
z8ڻad
z9>z\rf
z9MdU;\nV
z9ں;u
z: SR
z:2\v
z:3:D8a0
z:3{g:xp
z:> R9f
z:bIm
z:c夺Q
z:jPj
z:o4.;E
z:vhT
z;7WH
z;GRt
z;\tOg<K
z;bhD
z;g<p
z;qbC
z;ѲI;7I
z<62P
z<;<fvu
z<rc+;\al9<gn
z<t\f
z=;NSH
z=T/P=tA
z=l4ݽw
z>W\f
z>h4Ժ/so
z?<5T
z?ƽA\t3
zA*=c
zA7<EU
zF;u+\f
zGf:XV
zH\t=p
zJ6;[O
zJ;߸89
zL<&Cs;2
zL\r;N
zQv<>8
zR>_OB
zRB:5
zRc;>E
zUżL^Q
zWM;L
zX\a;N
zXq ŊY
zY0v;C
zY6;j
zY;>u:m\t
zYD$4ŊY
zYt\a
z\aGl
z\aba|\b
z\bH+:H
z\e3<,S
z\fba~\b
z\r=t
z\rba|\b
z\t:|FO
z\tb"u\b
z\tbA
z\tba|\b
z\tba~\b
z\tƼ\a켭 w
z\v2;\a
z\vba~\b
z\vܺ78
z^\r;hU
zb2:E
ze<58\e
zg;9_ûc
zh-CHS
zh-CHT
zh-chs
zh-cht
zh:8n
zh\f:\n
zhb>f
zi3==\aR
zi9uMe
zi<g)C
ziS<D
zjS:6>Q:aph
zk3:\t(5
zkD;=N
zm?9CD
zmϼ`8r
zn==bR
znӺWT
zo%5+B
zo%Tw
zo%\fX5
zo%^\eY
zo%d}y
zo%qP
zo-;WF
zo-H\bm
zo-J.c
zo-KWm
zo-\e\am
zo-lXF
zo544p
zo5euo
zo='fn
zo=)u
zo=1$l
zo=7!X
zo=B|f
zo=F=H
zo=\aWd
zo=\rgG
zo=_KC
zo=a@f
zo=u"C
zoD$PH
zoD$PL
zoD$PŸW
zoD$PŸWE
zoL$@H
zoL$@I
zoL$@ŰW
zoL$PL
zoL$`H
zoLC@ģu
zoLG@ģu
zoLK@ģu
zoLO@ģu
zoLS@ģu
zoLW@ģu
zoS\b
zoT$\b
zoT$pL
zoV\b
zoW\b
zo\\$PI
zo\f$Ic
zo\r)Dn
zo\r0;A
zo\r0i9
zo\r:'d
zo\r:Ia
zo\r:UH
zo\rFNd
zo\rU(n
zo\rVWa
zo\r\bYb
zo\r\n{a
zo\r^ga
zo\resG
zo\rkDG
zo\rk\eA
zo\rp$E
zo\rq2
zo\rsjC
zo\rwvb
zq<gCn
zqz:r
zr`:o
zsX<\r
zt;\ar
ztߺv\a4
zut<[H
zwc΅]E
zx ;ɾn
zx%ܻK
zz1;j1
zzp;lQ
z~4\bġz
z~=gC
z˺jwx:c
z̓;9WG
zͻyp˻\aL
zѻ>\tCp
zּNDf
z߳;Rk
z㹭6/:oĤ6q
