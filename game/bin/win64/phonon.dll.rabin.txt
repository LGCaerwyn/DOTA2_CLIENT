0 ACr
0!\v4f8t4b
0%:I7
0%u\eA
0&>\vxe
0(J>a
0(¼2K
0*=tP
0+<5oϻU
0-based array is turned ON
0/8;&jt
00000000@@@@@@@@PPPPPPPP
0000@@@@PPPP
00=Ps
00cfg
0123456789
0123456789-+Ee
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789ABCDEFabcdef-+Xx
0123456789ABCDEFabcdef-+XxPp
0123456789abcdefghijklmnopqrstuvwxyz
02<N`N
040904b0
045>,D
06*>L
07T:R
08@HPX`hpx
08Y;zQ\n
08ܻM\nB;i
09G|\t;i
09kP\n
09})C
0: =p
0:'E9
0:8\r#8
0:<q6r
0:=Mg
0:HQo
0:Yk\a
0:qg 8
0:zh#;L
0:ďI9
0:ѳn86
0;!AI
0;7zA
0;?aq
0;B1ͺR
0;C8j8
0;Ts#:d
0;Z$D
0;hLw
0;iZ-:X
0;nU\r;f
0;vn2
0;xCg
0< l\f
0<4xS7
0<4~O
0<>2!<kRZ
0<QIx
0<\azJ
0<\boX;z
0<\tw\b
0=!cl
0=>yJ
0=s!N
0=􀒽\ttK
0><[cZUg
0>H8B
0>\bQ
0>\nW4
0>\rg
0?K;1F
0@>1j4
0A^A]A
0A_A]A
0A_A^A
0A_A^A]A
0B:;n
0E|;Ox
0FV:6
0G=·l=G
0H+=i
0Hq;qj\v
0II;6
0JV;\f
0K:y\a
0L9{0
0L;sxr
0L;x\b
0N;shY
0Pr<o\f
0R:;xW
0S,;iJM
0S;BF
0S;\tw2
0S_;f
0T\r.K
0T\rVV
0To:@75
0X8b?~\e
0Xh:u95
0Y\rInt
0Y\r\a
0Y\r\vT
0Y\rh`a
0Y\rzor
0Yr709
0\aba|H
0\eY8(iA
0\fѸS
0\rD;0
0\rP\fp\v`\n
0\tJ= H
0]A^A
0]A^A]A
0]A_A
0]A_A]A
0]A_A^A
0]A_A^A]A
0^;MzP:Q
0_:7r5
0_L$pH
0b!|H
0b!}Hp4
0b1F\bY
0b1\v0\t
0bA|H
0bC%\b
0bC\r\b
0ba|H
0ba~Ho
0ba~\b
0bc=\b
0bc=\b!d
0bcE\b
0df=Ŗ\n
0e1\v0\t
0e=;a
0e\\9f
0eɺB\v
0ffffff
0fffffff
0gû[x
0h<nBp
0hU<a
0i1\v0\t
0l:<z
0m;YG
0pU;ͲA
0r\a=FF
0r\r<,4
0s; $5
0sh;K
0t\e;U
0u;6B
0u;ȺJ;C
0x%I64x
0y<2\r6
0zD;wD
0zj;V
0}0i1\v0\t
0}<LB
0ġz~4
0ŀT=E
0ŻQ!v
0ż\tk
0ȹq!O:B
0Ϭ8Uh
0҇8,q
0ڼvYмr
0ފ;Rj
0籼d#3
1!;5jf
1#QNAN
1#SNAN
1*̽ Z
1+;\tk<Tt
1, 1))) \nvoid ScatterKeys(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localvals = safe_load_int4_intmax(in_keys, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localvals >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LDS \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals.x = keys[localid << 2]; \n            localvals.y = keys[(localid << 2) + 1]; \n            localvals.z = keys[(localid << 2) + 2]; \n            localvals.w = keys[(localid << 2) + 3]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n
1-8=M8I
1-based array indexing is turned ON
1.2.11
1/;Be
1/;hR
100.00
100.0f * cache_hits / cache_accesses
10=`M
119[V
13,<j
14;&Q
15:g7E
18?FMT[bi
18H\núy
19>]4
19eď9 Y
1:3\ae
1:\rh
1:a^l
1:f\tV
1;5`b
1;^u8
1;pOe:f
1<Egd;"m
1<\bL
1<\r2
1<]HB
1<tŨ;wvp
1<樫=H2E
1=hǽW
1=wgֻaQ<O
1=Ϻp\b2
1>:Do
1><pM
1>c\v8>gp
1>vER=\a
1@8|$Hu\v
1B=!e
1BLQXC?l
1C;pW\n
1C<ID\r
1D8G\buIH
1D8G\buQH
1D8t$Hu\v
1D<)T
1DZ<jF\n
1F;F碻-i
1FW:C
1G3;yWY
1H;>u?I
1HcD$(L
1I27K
1IL$LD
1Iw<C3
1J9rt纀T
1L9O7n8
1M;*S
1N;dC
1NI;K
1O);k
1Q:ay
1T'::1q
1T;=}88
1V";Bw
1Wz<cl
1\\>14C
1\\z9
1\fC=%I
1\n9t
1\t:QG3
1\t>\faS
1b!|H
1b!}Hp,ұb
1b1, X
1b1}Hp,бb
1bO;d
1ba4@X\tba|H
1ba\\ X
1ba\f
1bq}HpԱbQ$@Y
1b{9eV
1e;y\aW
1e\a:^M
1ffffff
1gt;O
1h$:\eZy
1hq<Jp\v
1hq<Y
1i]9{K
1j=\n
1jx;5\bλQE
1kG:y5
1l;(8G
1m><uE
1rE;k
1rd>y
1t\t9
1tں&s
1u0;t`b9
1vG ŰW
1wP=%Id
1wX:<n
1yD{z
1{S;c
1{q;kq
1|U;eG
1ºH=58
1ûZ\a\f
1āzXD
1ģi!l
1żah6
1˻UEV
1ֻ\bC6
1ֻuQ\b
1צ;zoR
1ٗ<V7\f
2 ;k/p
2!:Xs
2"A:j
2*N<(MAX_RING_EDGE_VALENCE
2*face_valence == edge_valence
2+=-tG=br
2,S;TS
2.8OVd
2.=jiD
2/x;Oq
20240722
20:WϽ;3
20H@.B<D>F>H
20l;g
21];ZD
21a;?H8:6
22:RNz
2333333
23=Dͳ=\tJ
26K;$N
27:ȵO
27<AFK
27O;P
29&b\f9
29[yi
2:6W\v:3ľ8
2:F_b
2:L`o9L
2:YFk:k
2:b=m<f
2:gDx
2;*l8
2;0"e
2;7i̻C
2;TiJ83CR
2;Ue绳w
2;\bT
2;\bZ8
2;` w
2;arX
2;s=2
2;sNL
2;vM\v
2;}w5
2<2\tźO
2<6r⼐kz
2<D@L
2<KB\r
2<j)i
2<u\bt
2<vdR
2<۽CK
2=i>3
2>~m6
2>ʚo>J2
2>۽vx
2A;sZ\v
2C\t9U
2DE=au
2DigiCert SHA256 RSA4096 Timestamp Responder 2025 10
2E=82R<d
2Ee<pI8
2Ej;?l3
2F=\f
2FҺ^J
2G8ƶy90
2GG>!B
2I;"bA
2I;\f
2J\f=Ԉ2
2Js;~n
2Jw;r􈺅Tb
2Ky;Un
2M¼\a\e
2Q;rf\r
2R=\fӽ<au
2T*<6
2TK;>nE
2T~:CS\b9
2Tлl8
2U1<J
2V1;(%v
2V:ϥC:M
2Vv=F
2W">`92
2YL\a|Ģa
2Y|2d
2\a<K
2\b:OZ\b
2\bD$`H
2\e>vc\a
2\e\v
2\f0\vP\np\t`\b
2\f:p4q
2\f<1W
2\n[:S0e
2\nЈEPH
2\rp\f`\v0
2\rp\f`\vP
2\v0\np\t`\b
2\v<X\v9
2\v=\n X
2\vL$PL
2]fQ\t?5
2^˼78
2`ġJYt2d
2a\v:)YD
2b!<HY
2b!|H
2b!}Hp
2b'>Q8
2bF;y
2b\b<Z
2ba}Hp\f
2bq}Hp
2dh=(X
2f<w\r7
2fGHz
2fffff
2g/:G
2h9sp
2http://crl3.digicert.com/DigiCertTrustedRootG4.crl0
2izj|4
2jG:z
2jP;3hN
2p;V+n
2p</MT
2r*9U
2wx:rd
2xNEON
2xk:F
2yY9u&U
2z<#k
2{A\vDcC
2|8Et
2ǼzSO<n
2Ɉ9dcz
2μcRƼc
2҈UHE3ɍA
2ֺ8WG
2ٻZᙻmg
2ݺv>F
2捻rF2<f\v
2蚻ǰV9NJ
3 :\v
3 ;4T
3 H=t
3!y:G
3$m<3
3%0=9
3%I;wDb
3%P;Ul
3)ƼkWy
3*V<gL
3+r:ߨ2;Qq
3- =cO
3-:MPN
3/C>R
30;th
31<(M
32-bit integer overflow problem
32767.0f <= ceil (bounds.bounds0.upper.x) && ceil (bounds.bounds0.upper.x) <= 32767.0f
32767.0f <= ceil (bounds.bounds0.upper.y) && ceil (bounds.bounds0.upper.y) <= 32767.0f
32767.0f <= ceil (bounds.bounds0.upper.z) && ceil (bounds.bounds0.upper.z) <= 32767.0f
32767.0f <= ceil (bounds.bounds1.upper.x) && ceil (bounds.bounds1.upper.x) <= 32767.0f
32767.0f <= ceil (bounds.bounds1.upper.y) && ceil (bounds.bounds1.upper.y) <= 32767.0f
32767.0f <= ceil (bounds.bounds1.upper.z) && ceil (bounds.bounds1.upper.z) <= 32767.0f
32767.0f <= ceil (bounds.upper.x) && ceil (bounds.upper.x) <= 32767.0f
32767.0f <= ceil (bounds.upper.y) && ceil (bounds.upper.y) <= 32767.0f
32767.0f <= ceil (bounds.upper.z) && ceil (bounds.upper.z) <= 32767.0f
32767.0f <= floor(bounds.bounds0.lower.x) && floor(bounds.bounds0.lower.x) <= 32767.0f
32767.0f <= floor(bounds.bounds0.lower.y) && floor(bounds.bounds0.lower.y) <= 32767.0f
32767.0f <= floor(bounds.bounds0.lower.z) && floor(bounds.bounds0.lower.z) <= 32767.0f
32767.0f <= floor(bounds.bounds1.lower.x) && floor(bounds.bounds1.lower.x) <= 32767.0f
32767.0f <= floor(bounds.bounds1.lower.y) && floor(bounds.bounds1.lower.y) <= 32767.0f
32767.0f <= floor(bounds.bounds1.lower.z) && floor(bounds.bounds1.lower.z) <= 32767.0f
32767.0f <= floor(bounds.lower.x) && floor(bounds.lower.x) <= 32767.0f
32767.0f <= floor(bounds.lower.y) && floor(bounds.lower.y) <= 32767.0f
32767.0f <= floor(bounds.lower.z) && floor(bounds.lower.z) <= 32767.0f
32źs౻a
333333
35i<sC
36;3\vR:Y
36A;rn5
36`=s\b
37ܻ4h
38$Dk9
38(3q;τr
38:\vk
38;qwZ
38غ%F
39.6v
396js
39\aq@;4
3:8me
3:JpV;l\v
3:}3w
3;&vh
3;7\bS
3;:HF\a
3;CScs
3;TWɻs
3;\n N
3;\tTʺK
3;atH
3<!lN
3<Cܮ<WP
3<dF\b
3<dU\r
3<y8B
3=:w2
3=N\f
3=h\a\t
3>4A\a
3>N;kU
3A-;w
3A;XI6
3A</a
3A\a;^ᇻ8d1
3BڼlxǼG
3D{7ýt
3E9>l
3E<tF
3F:Nڂ:4m
3G*=1
3GV;VL
3Gܻ\r7
3H=X\e
3Hc\f\bH
3I9)ZZ
3I:OP8
3Jg;d
3L:<h
3L;2V
3LA<n,\e
3O<qoW
3OIX:0w*:\f
3P=\v1`<ci1
3P>=U
3Q;\e/t
3Q\r<n
3Sk>r
3TF<F
3W<HF
3YY:4F
3\aC 3\aC$H
3\f<L
3\fW;T
3\n=Fw\n
3\n\t;Q
3\r<p6L
3\tD$ H
3\tD$0E3
3\tD$0H
3\tD$dM
3_<2l\r
3a\n<ZB
3b,;V2
3b1|\b
3b:NSm
3bA|H
3bad@X
3batHX
3c*:"u09\n
3c,:KFӺv
3eG<rb
3fffff
3ffffff
3hZ;\aX
3hi:٢b
3iD:P
3jȺ!eX<ܻV
3k;'N4
3k>Sgq
3kg;iX
3mo=EX
3oƻrn
3q;dŦ;E
3r=:WB
3t::T
3tD;\a
3t\b<kg
3v9\\sZ
3vQ:6˿;O
3xźOH4
3y->W
3zϺqh
3z꠩7Z\b
3}b;\nCR;eL
3~:yS
3ģi!T5
3ɉD$8H
3ɉL$HE
3ɋt$P
3ѻNgQ
3ѻadl:e
3҉T$ A
3҉T$ L
3҉T$0A
3ҋD$(Mc
3ۉT$HD
3۸VUUUD
3ۻD\vb<N
3J\n
4 <(Xx
4!<VE
4"T:PD
4%V<2u
4,bR}I
4/bA~\b
4/bbUH
40<k5
40{;N
41<zgE
42:|\fv
42;YAg
42B>F
42ģI!41
43b!|\b
44?:S
45X9.H0
469;}X
46ăI!40
47;0^68r
47\b=x
47bA|J
47bA~\b
47c#\e
49G%\a;bi
49HoKC
49u O
4:HmݼH
4:bFܺ7F
4;,Ip
4;K\v\b
4;Y/l;\n6
4;\nCs
4;bA|H
4;bBu
4;ba$@X
4;mA\n;Q
4;qH+:h
4;t }956
4;ʼuc\f
4</fb
4<4;ZvջA
4<>\v0A
4<G,ӼQkj
4<X8A
4<YP6
4<cZ44<\t
4<k:F
4=7#=5Z
4=D}Q
4=HH3
4=\tJ
4=rUľ}p
4>%4m
4>3RO
4>5IF>_X
4>PQ\a
4>b!L
4>v<r
4@=m0\r
4@bb}H
4A;!q
4B;$y
4Bo;n
4D8l$2u
4G3<%E
4GE:m
4Gbr}H
4Iڻ/A\f
4JB:킩8
4L廉zN
4M*<e
4M8Y?6
4M<D\nL
4N8=C
4N;Y*\r
4NŻ|6\a;s
4Q<\a8Y
4QY=M
4R):wvҺJ
4R9\v]5
4R<K3
4R=i7
4TԄWak>E
4Uʻa*w
4VR=ޗp
4Vc70d
4Xϻ7cu
4Y,96r
4Y-(kG
4Y-)EF
4Y-*0G
4Y-+fF
4Y-5~A
4Y-C\fG
4Y-IiF
4Y-XFG
4Y-vnA
4Ym ŬX
4Y̺Dis
4Z\n;1
4[<WH
4\\i7n
4\abq|H
4\b6\n@\f
4\eģI!t
4\f<z<K
4\f^;mS
4\nbA|H
4\nbA~\b
4\r<0Li
4\r>v
4\t<QU4
4\tbrm
4\tbr}H
4\vb;_Y
4_Q;2
4`q9P\r
4a<S\aF
4b;<l
4bA|H
4bL<dM
4bQ4HX
4df<W_9
4e;[h
4ffffff
4g<k\a5
4h:oW\v
4hG<"0
4hT<\r
4http://crl3.digicert.com/DigiCertAssuredIDRootCA.crl0
4i9CdS
4i;w9
4j;6\t
4j\v:\t{k
4k!:C8
4l;G{f
4l<\nt
4p:jCH;y
4p[7w
4q<+3U
4q<+l
4r<ܽ˽Sx
4s\b>Z4ԽO
4t;3u\n
4u9Ig
4ve;x
4x*9S
4xt;ђ9
4z<4/Q
4|λ8YŻ8
4ӺVڅ;p啻pW
4Թ:Qi
4ػOz\n<rg
4ݯ>28
5 ;=dU
5!D=6
5#:r\eO
5#\b<Yt
5%9ZKK
5&b?B1s
5';Z4\f
5(96N\r
5)m:F^k
5+;ruL
5,O<w
5-;e1
5-C:r
509;k
51+<Y
51:`k\a
51:sk
54;Djp
55M>vG
56*;n0
58\ej
58ٻ\tx
58ᓍ:紻92
59Z;\et
59ZEz
5: ]O
5:'4o
5:/F1
5:PAY
5:\vqY
5;+,v9C\f
5;6\r4:u
5;B\\c9
5;D\e
5;X(o
5;e5X=L
5;f\b
5;kc1<4H
5;n4b:\n
5;om컠\v
5;r\vb8hr
5;}SZ
5<FE.:TP
5<[ E
5<\f>лuxk
5<^ZA
5<e+L=H
5<eB0
5<m(3
5>'MX
5>cQW
5?5=A
5?l 6?#:7
5@D;OJ
5B:\b
5C3=f3
5C;\nN
5D0<dr\f
5Dۺvg
5E>haR
5F=4u
5FB;[Jz
5FM<5tE
5Fj;q i
5GJ:ʍg
5J;҇u
5JO<s
5Lv;E
5M;j2\f
5M\t;O
5N9t.y9
5NC<Dz
5Pһ\eM
5RC9!Ŵ9
5TK;c>d
5U!;Y
5UC7֚A
5Ul<"V
5V9;4
5V;'di
5VӼL\fl
5\a9x6\a0h7\a'4x
5\aS<c
5\b:yώ9
5\bY:hǱ9P
5\e=lOf
5\f4:T
5\nJ:U
5\nk=e
5\v7x6\v.h7\v%tx
5\v8x6\v/h7\v
5\v;hag
5\vʻ_2h
5b691n6
5bt;\n
5cI<S
5e"=k!z=Y
5e:)N6
5e:\t
5fffff
5h5<d
5http://cacerts.digicert.com/DigiCertTrustedRootG4.crt0C
5i,%5i}:  On entry to
5k>\rW\f=v
5l˽F{P
5lԽLX
5m8>8=t
5n:"f8
5n<<99Q
5o< I
5pME:i
5q1;R
5qB=g
5r:Q}4
5rv;S
5s0;B
5t:\\K6:U
5tĻrD
5w<6A
5wB\e
5xA9E
5xF;+gE
5xm?\a
5x¼@E
5{˻kN
5ºs0\t
5Ǻ033
5ʎ:Y5
5ʻG]9;a
5̸n[λNuM:9B
5պ91n;h
5ڹ\nG
5ڽp3Q
5ۺ:Q2
5蝽,4z=Fks
6!x<0R
6!»Br
6$)2Az
6';pIY
6*p;d
6,\f>brg
60u\rA
60ÜZ{i
61f;\tMK
61̼M\n
62F;u
64ι_e\v
666<jHv
68^dh<f\\A<2
68tGS
6:%Q6
6:;Uu
6:C8*;acy
6:CI1
6:\v\ae
6:enZ
6:iSB:V
6:scM9
6;!Iz;p
6;O\f\e
6;\t M
6;hVH
6<'(4;nAK
6<,|n=XQ1=3Y
6</in
6<2wN
6<Pr3
6<\to\e
6<cNx
6<k\rP
6=3D\a
6=4iＨxp
6=K웼S
6=X t
6>D\rF
6>v쓼L
6?<Vj
6@1<8
6@8|$8u\f
6A$:r
6C9>L
6D:\a_O
6E:Eo
6F#>\ff
6F;Dd\t
6FQ=47
6F½{o
6Gg;E.C
6Go;\v
6H<=Y
6I;uBV
6Ix=5
6Lc;R
6N<? q
6NK>\e\r
6Rɼ<X
6UļVJǼ1Hۼ42
6W绱}d
6X[;dIR;S
6Z_;4
6\\\e<Va7
6\a ;c
6\b>s
6\e;+C9
6\f9<'L
6\fA=\e
6\fXO>\ntA
6\fw9
6\nR<u
6\nܼt
6\v;r45
6_8<u
6`h;C
6`tl:hO
6a<\erb=6
6aR;5
6aͼ`8F
6b!F\bX
6bB;n
6d;zܩ9j
6d<HMr
6e;vu
6e}:}Ru:t
6f&;Y
6f?;\vu
6ffffff
6g=$Y
6gU9f
6i %-6i %-3i     %-8.4f %-8.4f
6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e
6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e   FAIL
6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e   pass
6iZ<vb
6iӻ`wh
6jG<,Q
6ko;T%;j
6l8\eQ
6m:\e
6mZ<DgJ
6nB;r\v
6nd<f
6oh;\f
6p7MOf
6q;fUR
6qO<F
6r9 5
6rǻ Y
6t:$2t
6t;FY
6tX<\v21
6wo=e
6x<Q\nX
6ys\b$;o
6yк%S
6zz<c
6}3= 5
6Ó;pC
6ăa!\f0
6Ƿ;L\v9
6͉dTUP,\n
6ͻqy"<3
6κj侺*Es9
6Ҽ46Żvt
6յ;vH
6㔻>SS;9
6璻UAۼU\t
7 :IƝ;du
7#bI;nR
7$\eD:g
7%;+xe9
7&n>h\fn
7'\a7=A
7+G;C
7+u:PH
7,;UX
7-:Zu\n
70:Y@4:I
70?Hz\e
72-<f\e
729:g
72L=L
72r=AY
73<q\f
75AJ9\n
75{V:\n
77;tc
78`_:V\bx9
79$畺3B$;E
7909b
79?G8
79bp\r:(L
7: 6J;@75
7:!8J
7:!X1
7:<7L
7:LRιr4
7:Z-f
7:\nn89
7:qZ9
7:vbA
7:vrt:0
7;%La
7;0\t
7;B|Q;R
7;l\n\t
7;rnպu
7<Q)5
7<RLK
7<dDW=v
7=7gS
7=<\ey7
7=\bK\a
7=dUt
7=wRj>K
7=}Jp
7>HֺBz
7?Լ\a3t
7AP:!o4
7BƼ|o
7BھXSB
7Cu<d
7E>9Lo=d
7F!;E
7H9x\fY
7H;^\br
7I3:\b
7Ld:I
7PR;D)k
7Q;E#i
7Q<F[l
7QC;\v5n
7R[<` p
7S>;s
7U:;X
7Uʻ/c
7V;g3
7Vmq:w
7Vӹ'Zt
7Xd<ηz
7YJ;~V
7Z1|9e
7\aǻ0Y
7\aɼ=KC
7\bu;C
7\e:Y
7\e{U;n
7\eջ1
7ae:%z
7b!|H
7bA~\b
7bJ;C7
7ba|H
7e:\f
7fffff
7ffffff
7fi9\aYG
7h[;\e7
7h\e1;V
7http://cacerts.digicert.com/DigiCertAssuredIDRootCA.crt0E
7hz\a
7i:lp
7iݽg\v
7j,<KDa
7jnj;D
7mh:h
7n?ǺM
7ni&9N
7nuH8
7p;f 3;q
7p<<xq
7q:42i;a
7q;8\\y9
7s1<R1\a
7s\t0
7sƜ:\b߉9m
7u<NT\a
7ur;yI
7vf;AJ
7x<\n
7{KV\nU
7~:\nTW
7ŲYMLHc
7źYMlHc
7ƍ;hND
7ơ<AY
7˺8`89\v
7˼*Es<V
7ͷ9kD
7φ:U9ֹa
7л<wH<v
7ӏ<H8Ȼ2z
7Ս<vZ
7ݻJ\e
7ޗ<b\eE=Ys
7릻yFF<m
7뻆\bڻ1V
8 V<bz
8"&08l
8#J\f
8#Po:M
8$ $9D
8$v2;E
8%h&;gn
8&#89K
8&GS9
8(Wһj\e
8(\tC;B
8(e=E0
8)B\a>8B
8)u&I
8,3M:QN
8,\rk;S
8-Z\v:H
8/;in
8/NG8
8/Uĺ2
80d\t
80pR<pIQ
81!;cr
81;*^C9~6B
81Eɻ~\vc
81¼R9？h
82AI9
82˦9R\r\n
83:aN
83;9M
84<HAJ
84XŹ7
85<ιL
85G<r\a\f
86:u6
86;rJ2
86>V9\f0
88/\ve
897}:I3G
89T$@fE
89Z6{[u<;w
89\\$Pf
89\\$pf
89\n0w
89t$0fA
89t$@fA
89whS<\v
89|$4
89~n0;h
8:1%Z;c
8:6,:5!m96
8:;dd
8:OBc
8:\bc\t;n
8:b\eg
8:dIj
8:q\t\n
8;'qw
8;)xV
8;3)D
8;5G\t
8;Bt::gW
8;PBA
8;W:p
8;XM8
8;e\b:U
8;fy3;r\e
8;jMa:aX
8;mH793
8;o.v
8;q`9:\vT
8;w{s
8;xNw;m
8;yHc
8;zsM
8;zʭ;of
8< .f
8<A?5
8<TYf
8<\f6t;͚T
8<]p3
8<aik
8<f<f9
8=#xѼa4
8=Qsg
8=RY\t
8=x$5>Y
8>9:k
8>G2\e=mf
8>\ew\t
8>c\eքBC?>6t9^\tc
8>~08
8?oЈ>Vc
8@Hd;L
8A;\b;f0
8A^A]A
8A_A^A
8A_A^A]A
8B"\e<l
8B+59&pt9
8BNK:Z
8BYV;Nٰ8
8B\r=[L
8Bh\e;\eH
8Bko9f
8C\buAH
8C\buGH
8Cj;<s
8Csinf
8Cؼ}98
8D$@t\fH
8D$Xt\fH
8D<<2
8D=V;C
8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA1
8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA10
8DigiCert Trusted G4 TimeStamping RSA4096 SHA256 2025 CA1
8DigiCert Trusted G4 TimeStamping RSA4096 SHA256 2025 CA10
8G\a\e=\r
8G\buAH
8G\buBH
8G\buGH
8GdH;z
8H9D\f8t1H
8H;E!Q
8H;_\br
8H;k\br
8H;t$P
8H;uXr!A
8H;{\br
8H;{xr
8H=E;y
8HS2:A
8I*\v
8I?=&UN
8Ia\n;u
8IջO/0
8J\f<qJ
8KyD9
8L$ܹz
8L:{r\f
8L;{xr
8M,;Iw
8M;D$0u
8M\v;X1
8Ms;\fTf
8N>u\e[>e
8NG1:'}\b
8NS`:iVR
8N\vɻV
8R"L;x
8Sf<\ap
8T\rYDl
8U)zj
8U;\ncN
8UL<ޭ\v
8UUUUU
8V;ŹR
8Vk;J
8W;2o
8Ww;z
8Xüy\f
8Xޠ;VY\e
8Y3<:fc
8Z0Ļu
8Z6\t:m
8Z;y\v
8Z=M1o>C*0
8ZüK|G
8[yǺTq
8\\$PtD
8\\$PtF
8\a;s
8\aj躥$u
8\b\a
8\bg88ew
8\eIN:7
8\eQq7
8\eǻZOp
8\n<[Hm
8\n<_Dp
8\nӺyqg
8\t'0:_sd9
8\t:^9U
8\tpw9q\ee
8\tr]H
8\v$=KO
8\v?m9y
8\vؼ"72
8\vߺ"S6
8]:\vo9
8];f\nB
8]A_A
8]A_A^A
8]A_A^A]A
8]ｾxD
8_9"3a
8_\bu?H
8_\bu@H
8_\buAH
8_\buEH
8`gԸBt
8avu\rA
8avx2u
8avxiu
8b!|H
8b!}Hp
8b!}Hp4
8b:c{p
8ba~\b
8bf=`a8
8bunz8
8bwE:O
8d;k活^as:L
8d=?9Y
8d>:v㐻Q
8e:u:c
8eY<L
8e\b<kw
8ffff
8fޗ:Gؠ9
8g=ʹi
8gnu;!~N
8h;;R
8hВ82Pa8
8iV=ˣP
8i\a=6x
8kqp;H
8kz[91
8lA99c
8m+:it
8m5йвd
8m:StY
8m=OSb
8n<PnZ
8nݹ>0r9
8o;EIJ
8o_9^Q
8p4[;=0
8p6y:\n
8pb0;S
8q2u}H
8sse3u
8sse4u
8sse4u\aA
8ssseu\rA
8ssu\rA
8t;e13
8tR/;R
8tZJ;P\tV;E
8t\tH
8u\e:tf
8u\nfD9
8u{b;\b
8v?Q:X
8vH<\vPZ
8vL96W
8vL;\bX
8v\tۺZw:J
8w(;s
8w:]C2
8w\bu?H
8w\buAH
8wpv0H
8wع]x
8x;\e
8x?I:z
8y tmH
8zq(;X
8{\bt
8|$8u\n
8|$Ht\fH
8|$Hu\n
8|$Pu
8~!tKH
8»MHa<L
8ÐATAUAVAWH
8ŻqGx
8ɺUr5
8˺8hC
8˻ë99
8̮e9\tL
8̶9)o
8ʹv72
8֖S:VX
8ֽwSt<R
8ؼI7\r
8ܧ9lM
8ދ\b9
8ျ\vJr8p
8ṉ;4op
9 ;Ԣi;O
9 OҺ]ej
9!6N:q
9!AF:\t
9!r9:U
9"2ԺEH0
9"]Q;tY
9"o&8+Pj:4T
9"ҼrB
9"٘;rBI
9#WùWiC
9$x[<Ac
9%/C9
9%?9j
9%B<2$c
9'I:0F
9(D>O
9(e;aP
9)eA:ڧ2
9)v<z
9*K:r
9*QY:\a
9*|G<uG
9+l\a
9,$ H
9,, H
9,4(H
9,c :\a
9-W\n:Vk69
9.}c:Mi
9/5i:\a
9/Q 9y
9/x9l
9/}M9u
90-\v8B
90;Hc
90f#<0hm
90|ƺU
90Ì;yK
90ܳ:0?j:Id
91#v:4
91C-:a
92$n9c
929ںOD
92;d\tr
92<T;v
92B;F_k;gl
92B\r;F
92_J8
92i;9d
92ճ:fp
932;A
93;fK
93R;\a
93Y\e;'t
949^;2
94UzPW
94ݻ31
951\t:J
96;MC\e
96<Ns
96K"<i
96VR;v
96qe8
96ލ:ͤa9
9738;L
97\r; AS
97d]:=w
97ڻZB
98/ºza5:B
98VŻ^I
98Wdu
98m:$J
99-9X
991%ڹ\b\n
99\bS;.G
99\fu:U
99fɹmL
99q\a:a
9:R\r?9
9:[i59
9:ck\n
9:rM9vG
9:rл#\tV9
9:x\tK
9;&QH
9;)NN;k
9;3V;\fV\f
9;7Nz
9;\n;jk
9;\va:4K5:`iX
9;_\aS9iY0;0
9;a?9
9;jm7<Cp
9;m_J
9;qtE
9;|P;eW
9;|\nHcC\bH
9<'md
9<)M72
9<1*:F4
9<1;B
9<90o
9<H8d
9=8H;J
9=\tuȼp
9>=N9
9>LXN
9>uQ[;Y
9?]X9\v
9?m8:7
9@@Y9ZS
9@We:>5
9@\nY9
9@мYF
9A';o
9A\b~6Hc
9Ar-:{f;9
9B J:s
9B<\bI5
9B\ef9
9C\b~)D
9C\b~4HcR\bD
9Cu,fD9y
9C빔Zƻm
9D$Pu\tA
9D%W9
9D*\v
9DBu9
9DE\f;aUF
9D\t/9a
9D_\v:G
9DgX;STU
9E,E:G
9E;3r8
9EE.9Y
9ES9\n5c
9E\b=B\t
9F) 90
9F:cJA
9FF>\\d
9FHtJH
9F\bt\fI
9G:P᭺\e
9G:hO
9G\bt\vI
9G\ft!I
9G\vS:$f)9
9Gg:m\e
9H7&;1
9H;CPv
9HPu9*ms
9Hn%:U
9H}\n:5N
9HŻyTw:D
9Idɺu
9Ig:Y
9Iڢ;LN
9J8v\nH
9J8v\nI
9J;N3W
9J>t9
9JHi:w
9JL$P
9Jk<jw
9JÊ:j\v
9K :#R
9K%{<0lj
9K-R;ys
9KG?;GD
9K\eg;C
9K\nM
9K\r:a
9K];7
9L>bN2
9L\bF
9Lj\f
9Lڂ;U\ag9
9MI+;{C
9Msd87
9N%|6
9N7w9}G
9NIz:G
9N\rC9
9NeغVb
9O';S
9O5S;q
9ODp;l
9PSc;Y
9Pa]9(,H9
9Pwָ\b
9Pʫ;A
9Q$vIJ
9Q.ȺPE
9Q4:)I6
9Rp:k#\n
9Rͻ:P
9S1ֹAC
9S7]d
9S>K<C
9SP<Q
9Sk\n
9Sz\e9q9
9T$PtJH
9T1[:}LQ
9T9]:x
9TF;loQ
9U9¹eO\e9
9U;6[v
9U;\e
9U[C87
9Udչm\rV
9V<7;Kt
9VBA;2
9VL;W
9W!s;{m
9W6!;x
9WQ;DVԻ\n
9W獷mf\r
9W裺Q>\v
9XEC8Ii
9XbN:9R
9XɹyH
9Y$v:D
9Y(1;bk
9Y_Q8
9Ypv'L
9Z3ʻeG
9Z47<75C
9Z<;Dp
9ZQK9J
9Zzɷb
9ZӠ9i
9\\\vh94
9\\dk9R
9\a><kY
9\aXN;m
9\az;bpj
9\b4B
9\b\ed;\b
9\b\fT9T
9\bqm:z
9\bwn
9\e:H
9\f;qK\n
9\fyͺR
9\nd7
9\nh_9I
9\r\tp
9\rz^;5
9\tRD
9\tx&;z
9\v j9hKU
9\v.S:V
9\v:x9\b
9\vFz9v
9\vQx
9\vde:U;:t5
9\vhe
9\v~8
9]!/9\txD
9]\am
9]o?9]o
9^ t"H
9_hs'H
9_ns:i3
9`C;No
9a*p:\n
9a,\a;Z
9avx5u\rf
9avx::BVH4Triangle4Intersector4HybridMoellerNoFilter
9aw\t;RA
9b!}Hp
9b;nj1
9ba4 Y
9ba|H
9bdt;vCb
9bl-:3l
9br%<7
9c-d:7
9c-m;A
9c\\99E
9csb9w
9d;e4
9e9O:e
9e:\rf\n
9et~;l
9e{\b
9e|I:P
9f.X8\a
9fQT:q
9ffffff
9gN>9N
9gfr9
9hG5:f
9hPJ;4
9hU<?km
9h\\F
9h\b9
9h\r;\alS
9ha\t:j
9i?>H
9iL$:-p
9ia{90
9ih\r:I
9j;i}W
9j<\e;9
9jK;Tl
9j`M;p
9k$vkJ
9kB\b:F
9kEM;v9
9khO9ad
9kv\b
9kwͺAB
9k{I:c
9kO[x:T
9lDŻط\f
9lt\e6
9m2?<W
9mN캘UQ
9mP/:U
9mRӹ\f
9mXZ:L
9mu8;#q
9n4\t:T
9nD=wD
9nT":B
9oE#9
9oF-:p|V:6
9oF\v:I1
9otx:7
9o|;967
9pS[7z
9p\aJ
9pfM:(\e
9p}\v
9q+B;nn
9q;tx
9q\aڻs:\t
9q\r8;$V
9rcE9V
9r~?9
9rļ8,w
9s$v}K
9s\aԻ{O
9s\b~63
9s\vY:n\v8
9s`A;L
9t$Pu\t
9t6%;w
9t:VW
9t:qY\n
9tL)9'e
9tVK9
9t\v96
9uve9
9v J;*0
9v.ƼS%B
9v\te9
9v\vE9M
9v\vz
9v_u;h
9vg@:A
9vů9tH
9vԼR5ȼri
9w3/:ͥs
9w8=H\v\n
9w9\t:lϏ9
9wPA:V
9w\bt'HcW\bH
9w\b~tL
9w\eS
9x,<dy
9x9;P
9x>\f
9xxr9SYo8
9yH9B
9yI?:r-ȹm
9y\b~\\Hc
9z8OH
9z\e5:{K
9z\eպ2
9zmp;oH\t
9{ M9Y
9{$vxN
9{6r:u\n
9{\bu\b9
9{\fu\t9
9{pv)L
9|7[9Uu
9~0t\vH
9~6ѺJ
9~C:9
9~D1;d
9~\tD
9·L0x:b
9ĉA:q
9Ļ]1q
9Ż;Zb
9ƎD;7\e
9Ƭ49hky
9ǘy9&\rw9
9ȮB80I
9ɖI;gu
9ɫѺ4t
9ɲi:kJW
9ɾCF8
9ʁ:pAv:3
9ʙF;'Aa
9ʚ˺GV|9Q0
9̔E<c
9Ϫλ iX8
9Ͼ1:U\r
9ӽr|ȽT0C
9Ժd=m:r
9դ?89
9ջrF2<J
9اB:J
9طx:9
9ٽ2Va
9ݙ-9X7
9ݶg;H|U
9ߛ?9F
9ߟ=x3
9ờy\e
9鷬9>H
9:Z\tI
9:uXQ
A :\a.L
A ;\f\r
A Hcy
A \\m A
A!{  źY
A"Yt/4
A# Generated by Steam Audio\n
A$¼1b0
A$ƻP7
A'i:E
A(H+A H
A(H9Bxs
A(I9@xs
A(L+A H
A*D;iײ9
A*YT3\b
A*_V A
A*_W H
A+=p7
A+]0A
A+^0A
A+}0A
A+~0A
A+ƉD$hD
A,8`e
A,ba~\b
A.5<sx
A2a<\\w
A2ٸcʞ8pm
A4\\L
A4\\M ŜY
A5;"f
A5g;e
A8<$u~M
A8G\buBI
A8G\buGI
A8H+A0I
A8H90t
A8L9 t
A8L9(t
A8L90t
A8M(u\rI
A8^8}SD
A8m(u=I
A8z,u\bH
A8{,u\bH
A8}(u\bI
A9(݊9\n
A90~(3
A94$~<E
A96u\bI
A99R\fH
A99~6H
A9<C;\e
A9>u\bI
A9F+\e;a
A9P0t\nI
A9\riֻ5
A9_H~6H
A9}H~<H
A:8ucI
A:HBι5
A:\at\vI
A;2#z
A;>M3
A;>VP
A;E8v#A
A;Exsd
A;H7,:x
A;I\b|K9
A;Jk\a
A;W\e
A;\aʆ93
A;\e7F
A;^Pc
A;czC
A;v<s;Kq
A;|$lu4A
A<$90
A<GfS
A<GmO
A<H9Bxs
A<HrH<\a
A<l;5
A=!U༾JL
A=:t9
A=\ews
A=\rw
A=cT9
A=k"N
A>{rS=t
A@I;J\b
A@K=q6I
AAW:uk
ABCDEFGHIJKLMNOPQRSTUVWXYZ
AB_W ŸT
AB_} E3
AC\b<\bU\e
ACh B`z
AC˹Y&2;C
AD4<;tH
ADVAPI32.dll
AG:^3
AHH+A@H
AHH+A@I
AHM+A@L
AHԻgɬ;q
AI(9%s
AI99C`N3A
AJ9"ݬ:R
AJC<w
AJL$P
AJL$PP
AJL$`P
AJ_W ŀT
AJ_t$ ŸT
AJ_|$ 3
AJ_|$ E3
AJ_} E3
AK;Hv
AKZ<X
AKi;)lr
AKn:h
AM:am:PM:pm
AMFInit
AMFQueryVersion
AMX-BF16
AMX-COMPLEX
AMX-FP16
AMX-INT8
AMX-TILE
AN;`U
AO library failed to initialize
AOڻUx
AP9\f g:O
APD90
APD9\b
APIName
APIVersion
APX҉D$$L;d$0
AP\r;li
APi9+\a
ARI SOFA API for Matlab/Octave
ARY\\/4
ASARAQAPRQAWAVAUATVWUSH
ASONASON
ASONASONASASASASSS
ATAUAV
ATAUAVAWH
ATAUAVAWUA
ATAUAVAWUH
ATAUAVH
ATAVAWD
ATAVAWH
ATAVAWUH
ATVU`E
AT}9dI3
AU?$BVHNBuilderFastSpatialSAH@$03UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$07UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03U?$QuadMi@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$03U?$QuadMi@$03@embree@@@sse2@embree
AU?$BVHNBuilderSAH@$03U?$QuadMv@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$03U?$QuadMv@$03@embree@@@sse2@embree
AU?$BVHNBuilderSAH@$03U?$TriangleM@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$03U?$TriangleM@$03@embree@@@sse2@embree
AU?$BVHNBuilderSAH@$03U?$TriangleMi@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$03U?$TriangleMi@$03@embree@@@sse2@embree
AU?$BVHNBuilderSAH@$03U?$TriangleMv@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$03U?$TriangleMv@$03@embree@@@sse2@embree
AU?$BVHNBuilderSAH@$03UInstanceArrayPrimitive@embree@@@avx@embree
AU?$BVHNBuilderSAH@$03UInstanceArrayPrimitive@embree@@@sse2@embree
AU?$BVHNBuilderSAH@$03UInstancePrimitive@embree@@@avx@embree
AU?$BVHNBuilderSAH@$03UInstancePrimitive@embree@@@sse2@embree
AU?$BVHNBuilderSAH@$07U?$QuadMi@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$07U?$QuadMv@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$07U?$TriangleM@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$07U?$TriangleMi@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$07U?$TriangleMv@$03@embree@@@avx@embree
AU?$BVHNBuilderSAH@$07UInstanceArrayPrimitive@embree@@@avx@embree
AU?$BVHNBuilderSAH@$07UInstancePrimitive@embree@@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03U?$QuadMi@$03@embree@@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03U?$QuadMi@$03@embree@@@sse2@embree
AU?$BVHNBuilderSAHQuantized@$03U?$TriangleMi@$03@embree@@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03U?$TriangleMi@$03@embree@@@sse2@embree
AU?$BVHNBuilderSAHQuantized@$07U?$QuadMi@$03@embree@@@avx@embree
AU?$BVHNBuilderSAHQuantized@$07U?$TriangleM@$03@embree@@@avx@embree
AU?$BVHNBuilderSAHQuantized@$07U?$TriangleMi@$03@embree@@@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UInstanceArrayPrimitive@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UInstanceArrayPrimitive@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UInstancePrimitive@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UInstancePrimitive@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07UInstanceArrayPrimitive@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07UInstancePrimitive@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$QuadMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$QuadMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleM@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$07U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafSpatial@$07U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@V<lambda_047818d7111865b148acce07eb0faa7d>@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@V<lambda_9936c1e45856e773928c8ee0d014a38a>@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNHairBuilderSAH@$03U?$CurveNi@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@avx@embree
AU?$BVHNHairBuilderSAH@$03U?$CurveNi@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@sse2@embree
AU?$BVHNHairBuilderSAH@$03U?$CurveNi@$07@embree@@U?$LineMi@$07@2@U?$PointMi@$07@2@@avx@embree
AU?$BVHNHairBuilderSAH@$03U?$CurveNv@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@avx@embree
AU?$BVHNHairBuilderSAH@$03U?$CurveNv@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@sse2@embree
AU?$BVHNHairBuilderSAH@$07U?$CurveNv@$07@embree@@U?$LineMi@$07@2@U?$PointMi@$07@2@@avx@embree
AU?$BVHNHairMBlurBuilderSAH@$03U?$CurveNiMB@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@avx@embree
AU?$BVHNHairMBlurBuilderSAH@$03U?$CurveNiMB@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@sse2@embree
AU?$BVHNHairMBlurBuilderSAH@$03U?$CurveNiMB@$07@embree@@U?$LineMi@$07@2@U?$PointMi@$07@2@@avx@embree
AU?$BVHNHairMBlurBuilderSAH@$07U?$CurveNiMB@$07@embree@@U?$LineMi@$07@2@U?$PointMi@$07@2@@avx@embree
AU?$BVHNSubdivPatch1BuilderSAH@$03@avx@embree
AU?$BVHNSubdivPatch1BuilderSAH@$03@sse2@embree
AU?$BVHNSubdivPatch1MBlurBuilderSAH@$03@avx@embree
AU?$BVHNSubdivPatch1MBlurBuilderSAH@$03@sse2@embree
AU?$ClosureTaskFunction@V<lambda_0024bcf8e81a2d3c58300fbfd9103d80>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0030f00a5e4b606d0e971bdec63ddb10>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_01e78add476ee64591d212d347611c34>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0213e868568a0590d5a6e7478aeffe59>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_026d2c143a4704203e26115b30033a7e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_02a4c2292fe29a65ea8c3fb3f26225e6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_02f3a38d2275fed79a8addf16cf8f528>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_033159cd3ebdc6ce506113048fcbdf6b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0371f14733f91309eab1e347a6ce43a2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_03c7424d9f028a9606915d0496c01f18>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_03cdbb8637085504ce2e3fcba2fdee88>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_042051442674d4548f3e7b91e4528948>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_044a18a42e7de31c10648de78d2671f6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_04837824f4f0bedd7a75ebaa90419e77>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_05114b3a8281feb229e8d9a03d7e7e47>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_05aafa8a196f7cbc547cf996a6ef4525>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_060d5712a58b0a8af87618627b3892da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_07602f2a194208e4205be0291f13be53>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_07de0f251e965270305ec203c8b6e9d9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0814cdbadb8a5173c4cfeea2ae4f302b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_083e3bd4594ef7f00d2c94e74b29c74c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_08517f08d420646e992296e14801bb67>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0885a70d220feabdf9303e2939db32cd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_09088dddb6927132574b77b086f6b36a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_09407a3271040925f4fceb52e380d07b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_096ca84a1c60496f499fbf4b5eef8960>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_099499f898d1d7d80c0459cf68597da8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0a474d271fa60dff9f2a83b993ca6178>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0adf253de07a18f0c2e748d83564ab24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0afe9913bbe2b4ee42844c2c3e840f2c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0b2be1a484962cd800262b330814f1de>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0b6c244aa5117ff6cb23fe95cf44c184>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0c0a5a6cbc8701b12fe2458b6d4e40e9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0cc63a2e8096dbcfa469e526f9ac67bc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0ce9ec1eea5672226870f0d95b0d8d55>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0d21f1cdb247fe597b86934275e0b708>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0daf2ca5388613cebccbb043ff03c16a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0e88312090160e82af251a4da72838a4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0eb0e2ebd58a530d55aabffd278b99ed>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0f559157fb5662d7891b63ad6e931f3b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0f6c92485fd120fd30ff2ea33fb74918>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0f740edcd945bd48bd033e5353c5ecc1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0fa3f2155c9458f67f16ebc9f312781a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0feeb39ee693c756bfd486a7ffd0c92b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1035e5e5a21b569b1def157beb590cf4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_109b7626629525eafb4540a0946cba9f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_10d99383a1976f56b47124d2080fc88d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1112c1f2c76a1dbd2aeb49881d1607d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_119fe46b6a3977013964303834047c0f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_11f24b3ee78b54f79f725c9ee9204620>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_124da7ba53a013040a48f6e9ed335801>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_12e745946c06d3d8b337883a9d7c5fc6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_133a08432e1aaa722e74ca66040875ff>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_13a972f04b06ecb0ebc4b9fc5c2d48a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_13fcf6cc4585a6fe73bc5faaad9020f1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_14490ccb86cd39b0224b54da910caa1b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_14fac03f211fd6832936142e29a0777e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_15753f47449fe66b14ab8908ff161c25>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_15a461355c4c085ec0521d4d0b8174ce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_15b8ec1b4d06d296b526a7c01f2647c2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_161792b59506b0e243b9421a11fb53c6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1623387536f7e828faf75a09fa0cc88b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_16507b9f5162c2d591c8f4dff7003a69>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_167578685c3c04eab5604af5daf83720>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_16e697cfb76eb1bd6b0790e9e3bc6adc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_16ec1e211f558c43769f7472f9e403d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_17a90b2fed4fb5958544f01a080099c6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_18734b8af68c34370c50bc30a5c9c857>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1885fdba2acb15556d50774105afb275>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_193744cb1c915341b5bb6737caf797c0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_198bf666c2663bbb4a0feb13d55511d9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_19f30a0eb5df57dbedd0c84114bff5b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1a3993dba263e5690ea9bf69b4ef7edc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1a944e10bba0f3e84997c380290491a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1a947dc89c6b9ab9e3a4cfb6b6cc45c8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1ad45517c1e5c7227e24447239ff3349>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1b5e9ebed3caa5fa860097409e03bd26>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1bb728ab7b766b4e2c5e88cee13385c7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1bee079479d0dbb628b75b1da3c803ec>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c5284e74fa23bb2d0b2b7ea36748084>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1cb05ca108c9c9112a5b03fcb46fb78d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1ddec102839920631de350f345b42060>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1f23186a3a8c1a7b6767112cd745c956>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1f86655c0a0e0f14ef564fa5eed6b449>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1fd65ee1ddf25fb753f2e89b4fb5574b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2015edd9e7383ca08b9b8aa11ac680e3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_203f2cfea287abe84603fd650e7c1936>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2069df407464296b824ca33f4197ec8a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_217933724b3e1e5d7f053029c75bd240>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_21e16987f9d206f7fc5d860fed99bbc1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_21f2033cd4e1e1fcd41e0b00fc20cffa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_220f611b778ea856d93bf0e211d27d71>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_22711db9e5ddf7a51cf447ed70ce779d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_229206f515929ad1ba9e168f0e6ee2df>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_229abbc98af76657ecc1cb6274373f95>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_22c68614e55cd8b62d6c0779500773c0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_23142700a9555ff72207d391d51ce6dd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_235c9eb9817cecea87f7512f1fecc41c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2448e154e60101894cd67305875e3b6b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_246348e99bf1cd7ed3d8ac88aa288179>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2472e4d841f7f03660d748c390f1c98f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2483c16ec48aa3c5c58efc47057a1853>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_24970f05f9b01e01366afabca885cd69>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_26017e49e8211245a572175b97c64817>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_26289c1d6266bcc542c4ca7f53a436f6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_26829afa5f772235d0977761886690b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_26cee26626710417ae1cf4d059005ee8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_27623e1956a57b63dfdee190db4556f8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_28529c0ff0131ba92ad62cbff51a3cd2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_286bd1d6a0f07e8c63a90b26f807c0e6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_28c02f1c7eb8db37c8ae76ffb122fc29>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_29105f6038351f6621829cecd6cb8664>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_299af8be55152cdf9783cc0483c69833>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2a076dce94f4c4b6a6c58fd6d1f48e1b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2a3ad7c4e0ebc3501c1616cc9aa0cd06>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2a489e71024aec5fe813d46ad3a31570>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2a56ab4daa45c2f3005a672a7a15c149>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2a602e16c4f2059988628d1f11824a24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2bac7050c3dc6359bac7976d366c71ce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2c69a2c63e1e63973cc31a8cf626f9ee>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2c9fa0006e910f9b3daf238cb1fbec80>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2ce8273b9bbebbdda203a84ff150d13a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d27d428d4171a9e0f280ef49b907ef2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d3efedeb51b5c9276502289b48c792b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d6b0be554fafb436403f0f923548fab>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d7fcb48b69a84705b3e2d8dc569ff38>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2dde72380efe6bab1a8b149def276c51>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2df1f5b51de114e3bef21076ebb8f05d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2e4bc3d61274d2539571c3c0eb2de7ab>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2e8f55e295f14faa238ef7391caf1f4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2f366eb6feec37ed90356f5fc15a6156>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2fedd5b4bdf5a11138840b6ec1ce4843>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3005691052ba073da28d1a65dddd03e6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3010c61967799e829b97ab66b258f05d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3128dfe3161cba5a5ca732b6e955fc28>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_31abc9818e6657a5790caa0fe9e9bfdc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_31bca5a5764f6326df48e269af89a89c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_31e522b549c852d949774f5d54cf5913>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_321e0653b0901b39f81fbb82133a8756>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3263695fa4cc9a170b0a8054b3f999ae>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_33790d479592710aae7302a904ce5f79>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_33ca8656f54e2ad82c94a88dbf2be988>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3497d57cd08a9b7f78a3dd3f7d547803>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_359de6937990ac67c286ad8713812619>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_35a500d90860fd3871f353608489b26e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_35f265f65f08dc2cc4c40fb9bcdffd1e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_365a0bd2c068055f821754f68e443b9e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_36a116821d74362473183a7d40d7fa55>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_36bb0b59aec300714419584057f878ca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_36c60084a6d73354f1cd48cc05a32560>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_36da6c31b7b60073023d94af080b51d8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_37224258c447acd5c6d247646c994b9a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_37386a6c02b7a67ed35c5567e5481328>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_378818ca25bfe2a2361aeb6b2999e355>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_378c1163259730c23a5a528d70de10a6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3796d84557900da352d32ddcd8b4dce0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_37acfaa8c6e6343835f9bda4ed3e364e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_37fdffb284dff321a481363426a427c0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_38044c841a7fa06e3d9de58a6ec98623>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_390784685fe47bde8503f81eb6d6a2ba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_394868370a8daa23c01bd7f92b2f5740>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_39ababf5ed880c62e50b1a0db9f45af2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_39f94d2d8b7dd757a7400310f738f3be>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3a47ec42a72918bd5c8d386aa10beb98>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3a51fe6647c19bafa319c081bd1cb55c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3a5e5b6edffcb1ac25e777303d41d832>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3abfa7a00ddeca61cfbb7b7b3ef10605>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3af1a79f4b81807e541df4e58302761a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3c7b8943b47802e490352de9aed664e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3cd047a95ffd41b9c532df9a463f6179>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3d018466e1411f557b6449e327ecfb97>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3d6f66a0bf56f20c25bb7fd7c432f5f2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3dd2614e74c2ad1e0fba3ecf269a3ef4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3f2dd4aefc837e44368379a9b1d6c723>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_40d8d6c6e0cfde73f951339fb4102a1e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_41452cd6f43dbed322f93ff51b577859>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_41b6f16634da9272ddd1858235809b6b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_41d6c2671055d4dbddee3056329ce6b5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_431a79ffbb10332b2b5162509b8cb2b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4356b8d5a707512399938863bfd9d382>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4381fc2d97d3969fee821fc71aa2a316>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4387768260f4b024b8e817fe8a6b8fee>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_444397cdb5c169fe1e4891cdc5d51774>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4454fd3ec8f5263414d2eb5c93d502ac>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_44be1663ccf7e78d7b1be1a89d14ca1b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_45239a73c6820cf96ab2702dbb009eba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_45546463236c03f673f4b115b81e1608>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_45b3164beeb3810966b28faef1c81325>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_45d16dc16e8144f2a51eef2e95073c7f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4667454256e65fd53b20073f22204cb3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_46e5054ac5048a2a443acc0e1639f11a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4780a2a58680f986b6e37ff3e02a2982>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_48072216621c7087b2f04608c2342a4a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49ab7ca2c9d85f3d01999a8e82f2836c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49bc2397a1c426192cc7f20317a590bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49bf9a02359b64d4f0afa99c458891bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49cc0220240abb2aedf5fd506051b52b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4a5a410c0853f25642491011d68add24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4b1382523c70c8ef1348da0d7711b4f9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4b7bc775bf679c669856f34596c88dac>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4bcd2bd801e7475eb68ae3895d5ea9a7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4c247ea948221e6acbe8efce8327e4cf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4c24e299999fc377afa4186737b9c42f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4ca5996dd98cebac7d8ee1236963ef35>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4cbf9b965a00f6253a395e7fd118fff3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4cdd26a2d3f1b3fe24a3211567d60170>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4d8404b02e5194f828c4424bdd4ff911>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4e2e92ed585301a5a43a1dada7fe9313>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4e351548b46f0d1fa6fdfe029b7cd294>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4f37194615f9f1744f62b1f0022aa711>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5054633584ac972ffb22cd8d0d4203bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5079c5c37fc9ad4848b845ed32f4e678>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_516293bb833f48f1e2cbe7aac54000ad>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_51dc10bddc1c5c3e8820e30c45c4abe4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_51dec9fdab6341900e2419ea45af0b34>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_526dd3239686290631445ec03d8d3021>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_535e5ca58567e12ea77a5368008fa98e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_53c30b1d8dcaea7ff298687d7da7b11a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_53fcac6429f03c4597e94071b0254a50>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_54a9ea568962a4fb29330904f65151be>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5524c1a9be4a940521d4c5bbb584ea38>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_562550e5d8cb2cf70f252647d9a5920f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_563152df29b86cdeb790347e7d1bac63>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_565a9b18701d850d39669fc656de7b65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_577783d36a0c5bf05071cec41f550f78>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_57891ad27ccefb610dbf74b1364c461a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_58016dc23dd77668b5aa682bf036f8a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_586f0a3885e5cfcf083c2c1c13c74519>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_58a5c0866a7b0b1091e77b8a910c6596>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_58e9c0ee7d1f13f82fe1306ebd3871eb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_58f8fe9599b923d0b4ee14168d2fa039>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_59e79ba20fbd512190e36c0067a5cb10>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a0a5de012d970f12882092b4ffd1a39>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a0d5be35d3e68045a558544c9546cd0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5b40b99f8f56676940f7b079692833cf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5bfd24340b8bfe4eff8106c8e46d3870>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5c5ec6423a9671276bbaac49f8e921a1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5cee3e073cbc9ae9b92a51f1290ab58c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5cf460ac937e1f0afe8a6ab198480de5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5d22228fe17b732922439fee1ce79dec>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5dddc2cc159a46e17398e0e8fcaafb34>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5de1cbb3b08f280eb83d6d11fcbd7368>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5de527b9879fc3f8cdb392d0199e1a88>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5e130f814614ecc84bcb89daea5764ae>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5edea0583b37da90ef70fa88e0541ffe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5f337c2bc8562e18b4b4e4a07e7e74c1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5f7483bf006a96d967bbf46091fb3fde>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_600a5f3da280e2146f70347cd4876dc8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_614af2630066497070eb0951f17946b3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6194bc74867d6dd16cd0e025d5beab31>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6199ffdf7c605c0962f8ee91aecfa222>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_61b537d16b2ce540d2f960e3629101da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_621182ea2d11f76d1d1780deb835d4f0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_62d4297180986feffb3cfcc6c568bf01>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_633a1dbd0995496ba172f39a33227588>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_635089e5c135bb0785f0469e676d0d55>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_635bc4cf338d63581ffa71816e842d9b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_63d3d06a8b4bdf315b3dc4389d23f969>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_645ea0bf9267bc361051031346249148>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_64654bd0714d00476b8742f71a4d80e8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_64d7aacab79d78e1839598294f79875d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6508322f2548b185963781813571c4cd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_659b512ced93268a072be38668acc579>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_65a5a5236cccd5733608900f8c0f68cc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6682a6a5daf4aaa3bc5e43650ebc7a27>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_66997bf790596b4ebb6784b732723012>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_66aa4899cf2aeb19034592275aa55aaf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_66bf7bc1396202a758e3bdfca0f6cb16>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_66c890872cd6326baedd418eb5729e82>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_671231246a87fd7a13d2fcfbdddf27df>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_680480ce568449b4972d393da631f705>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_686005430ff528c2b108b70919850707>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_686bea96912e6b4b47a704c8b2dd519e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6870e76e71acc0f8b3eae5cac5789e9d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6901b1fc4e0cb81cb186943fa17a69c7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_691e0e78c708db8bfdb6800391fa9392>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6995898df38b358a5d10ff2c4c57e35c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_69c8a88f1a9a33e3c7ad5d8eefe444e1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_69edf7856f9b6802ee513b838e3bec62>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6acb9948264813306a762466a123315f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6b2dcd8b05c0800a63e166106b6ef9d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6b37e2b27f8c5b3f9ca8d935d5ed57cd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6bb446e1068360230919261ce332d342>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6bc0b1ca028eaf3d7f5d41a49a4df4b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6bd5dc4fab940007ef9cc8d7da12da96>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6c03367c8fad854e347513725e083444>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e4133399869a06deff01f67e42fe122>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e55edd3ffc08c55469454db08aa67b2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6edb511084291be638cfc9c67438c7fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6edc17e9809f35847b5eaee0400da517>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f35d9dfc0ba84dbf7d35fa74624f5c2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f542470329bed6c4c66a36d06d14334>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f597f0adb7bad19dc31d05e75508c56>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f6a1b007af587684cf180ac31743296>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_702761377da5c33ab10882ef0a9f9613>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_70cac3ca1e000a927b6180abdbe6e940>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_70d7221af433ebb85ffb36e5455edf5a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_70f0faf1caaa177deb944f52f1449154>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_71451476c37f97081611f5ea829f29f2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7154e1ebe472631ef1b05a9302dcfdcd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7200e1986d527611eb071d8ffabd23b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7248274c3903408ff0817833dac35e88>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7273cce94103302f23587c6c0452c444>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7337cf1ea24ec60c4e6dcb0d22a3b6fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_73441d37594cd410767342079a5a83ce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_739a0d7b4c90947bbdb2c8bc20e9d572>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_73d30c51962feb4ef86c7347b074bdd4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_73dcb5f84263bc36f698d83c038d746c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_744bf7a2a480012d2fb14d16b4a28ec6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_746070a74440bd63945a38b44726c128>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_74f4229eee634cbe75e654589b334bbe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7535c6db0d4f55ff53f7d2e193f65ab2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_75d63927bd8c93e5f39afa24ba394c7f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_75ddfd4864ee31b97d839677798dcc24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_778e6c49a63b0698fccf8f4a3da3f26e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_78321a064c8b4eb1aec0511a72fd2793>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_788bf76417a85fb8fa45519060407e73>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_78dcbacac0ca25ca4e43dd11d31e4128>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_78e4b017df22f65d1b36e0496f9291d3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7afe4f071675355f5b1e830ef55e33d9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7b402df8b7d41bf08649d0e9f52354f3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7b6ebb61703070207d51ded066c0dadf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7b87ebee8bb3b6d1512c86b84fce8c6a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7bb2944cc757dcd2ef8f5c88f6e5b799>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7bdbdb19bf782076291c63745a719b0d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7beef361d11076ba7425f1840b9eedec>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7c0d825109794192d8d8263a752bbcae>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7c411916e1d0a6e87a685e4c1edbe31a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7caf708b7e23fd758ae9290652fa0ba6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7cef2cb558b52dcf4bd6c94a19ff8cce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d456c3788fe70edf1b2114c340c9b7e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d92333caef7837b2bf4495ffb70380a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7dbcf3cf8c8438b960335b19117e3373>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7e8a3c0f497b0da0eddcab57fce05c56>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7e9cb177d7585e28d555112178425f3b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7efd00a1f76513d4c1d46dd35e9fd5a0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f545fb40a06a06322d13d059804b31a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f71ade2efa05174b994598a3f261500>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7fc8ba9d7c551aef912924f6f12c2e7c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_803f6650a167b6f47a7b10cb8e7674fc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8062ca6b1deed1ad3e12492705f4f331>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_80c0d4336ef3fe0d7d9917d1da032763>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_80e263fdbdf421b894db1802513e2a09>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_80f1b0220db27cb2be01d2d3a6769b1b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_80f20d98566c55ad920451df7ca53b61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8111aebf023d31fcac8250f0d2a12015>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_811fb9c34a8127f38a96d14cf6c03198>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_815ae63246bcbf4a1b5c0d6209c65560>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_81930aee378f640b1582e999dcab74fe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_81b7904dd56cc10cecc495a62ff9c22e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_823fc14eabe432385eacefdc6cbd419d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8288334d84ccd5b79b33f9f297e4dac1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_82bc3d882b4f26dfac6792c8c167c55b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8374a87a5cca4de905a3f004470ac711>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_839d447d24cad75a6bcd81fb5b61c565>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83a71fe449bc6f5002d85bd2738be885>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83a76296660a4d55f3d1489bd0501f95>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83cf4e5dda569c06e27f80c41529ff35>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83f0edf1da5fd4de6a218aac5aadd0d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83fe557856fdb40a5e34f8835f41cd3b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_84bfb157e162affd3e4008b7f068b782>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_851c8b5768c9b150ef259bcdf13be37b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_853dbec48977496a0a1e6ac8909e5e31>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_855be20ea4ba174a443c5d5dc4ade2e2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_85695079964ef0e23c7287354d07a1d0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_85a9bc3b5bf6d176179a222ff19cba4f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_861b42b66bfbe2e796407a255aa8c3a0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8679ab18ac79668c8eed982489788fcc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_868ff1066f259cedf167ac42a4ecb3bd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_869e61bc3c0ecbf77c8b92b290922136>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_86ffb82e68280122c8ffe01f6f8008a9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8716c3f5a4d866d364991242b9233dba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_87290051f4605df76699c4b474119dd2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_87303021dbbf095be0f28af5889d378b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_876a1f8e70794e01a1dec7021fa96099>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_876cfff3d255189ff87007d1dfc85e4b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_877121b9f3bad228247cf6e44eb44968>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8813cc6976f152ea08e9b049359a788c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8879d3a4c55d8218529c702f8b52ef23>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_88afaef865556decb587a9251a810ca4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_88e8ca69e9e5e86c96003685381e2d06>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_88fb7e44981b20c1f38b57c3bfc718d5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_890e406e033480635f5a75339cf483cd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8910feed0536114d7cf9db6a8d87c131>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_896d620115832d82de1e416eb8e53a72>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_89a3c6f1ab7ac7f23955e5a9ce674f97>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a0746281ccff9faa58e37250200e224>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a20f6c9d8cac76f6ba44ed5eaab493c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8ae6eb62fee5242249a948f1ebbaff2f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8b150a87f1113fcb12311b0d8b57510a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8b476c0f32c860ffd1638a90adb96b4b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8bf012444ce69c4ff8ae71c4abc7c196>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c19f7aaeb30dc3978b87335ebe40834>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c30a42f7e3938f634d4093dd4ef47b3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c9dc09b3defb3bef77af1d41d6bb1b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8d781b82c6d59a3eedd50ca90a198159>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8db1e9f51e7e4c95faffe328f0c0ed1c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8dd8be53b45b21dafb3314f58fe8b9d1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8de6d6541115e2c810c527b1ac9a16ec>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8df992af5ffb599088e1ae7caed40147>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8e28e317f08a8a0997af9e765e9e1a60>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8e6f4fb6ea6c801b6960a5746c69eefa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8eddbf4ff55b0d91e19f7c65e24a64b3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8f28e23dc6f3c60943d9ab421aa9e473>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8f515e7dc3461352cf40a1ed1106d2d3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8f82710f6eb001ba6e5bf86b133d1e55>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8fa9d00ed25facc0e28b218e3edd5992>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_902f0f121b4e009c34663596d7d556a5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9031c020359c8afa6b67c8047f99c45d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_90961f00b9dd5c2b7609ea09de0b5415>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_91d35e626329522d0b551d6f42329f4a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_91ea088e6a06225cdf64aa45d3b43187>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9239f2a5220c2cbfb17e6c494c181939>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_92640afd2fb1d7af683ac4bfa266b179>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_92ca463f302283856057910e34bc3acb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_93c2e4fb980e4a61fd4f5e03cb6b803c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9416fda5f68a232015cdebcb06be7981>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_941727d8d759c1212a51343214b6e742>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_946df7e4f3c60714904767dd569c8e50>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_94a62b72749b66823e9b5a9c4f05fbc1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_94b1137b67317c7f70b631af08e98d18>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_95570f1dc3ba862b524172560d6d333a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_955f2f5ef9fedb8bde9166d4450fc3d0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_95be1246cdb559379b9f866e93c0ff9e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9619ce5204db736bdfc6dce396fecfa6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_965d79945878ad2c8ad2ae117b6970bc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_965ed77bb303f4e87bdc259fb470abb7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9687822d38239fdf200ba388366db1e3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_969e7d53d79503e4109354f3251fe63f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_96d1f2ad41d2ed7e7fdc9089d00443e3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_97477056f9ecc004eff501b79e2669d0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_979d939e6212f7f46baf5608d7b86816>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9827d153b12a342a67a05cdb795851b3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_98ab25b2c01817f1651675856d465e58>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_99074ef999807c5a6d636d3a0512dd9a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_990bc7e98738cc35cca082ff38f4ef3b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_99d71ed3eb4b103d9491d8fa0a3d228c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9a01e634fa0a2227900db5052b12697d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9a112f5bf9f7bc11ef97af307f60464d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9a9ce54e3dbf12dbbed068a808ce4b8b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9cf575c2374d0d88f0ffda710a1a0f23>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9d3f74554c4b0cda880d2adf42bd7362>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9d6f132abf697cba2bfc6b0ff8ca24c0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9dc5c48dea1b3358dbd5bc98165f18e8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e318d026b4e950dbacd0ac381b33ebd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e56912550e5d9499ad157c2f1ce7ec3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e5e454c1d23043f03e1e5abd47ff290>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9eb2af13d21fd6d2b3dc254f27ed56eb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9edf3f37c03ebb052600f734c1482456>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9f3310760927c5803e44e1492260c56e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9f70a1623b6a8bfbeae0f3e780c744d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9f9dfca852c2c15eaf745b873505435f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9f9e6ab7a83eb283874989fde14deead>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a0217c5f93caab01dc4294c8f63845a1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a170e58775316bbb54844832abb937bf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a1c1dd3e85eb20c8b83027ad291de2d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a1c5009d4c36c9dadd5d0cbafe518f2f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a244a591b8cbcfc88ee2b071c96fe463>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a281f8220a198ca285d88fccfcf0c8d4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a28f43485fe1d7a28a02fcdc4f37f448>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a2e46bae1ade70cc0392e741606286d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a38c856de3ce790f968c4b688bdbb9ba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a45e010aaaa2c65e8e197900847e8de2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a4c8ade5fe04bc25c8529fee4fbf7531>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a4ca95a1b7349358e0d661b52ae3201e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a5369ce6cc74699da52b375c9fd1bea5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a58b75ef9f0f07de6fdb610db2f1c1c5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a5f5e92c0ac0201423327b326e38c7d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a64f939f44ef7c73c6e9be1b61dbca8b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a792c2f7222c2ad1d8d1f2ee31b392c1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a8258d0b64a22c877befc8508f1f5c2a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a89a6402f83eadc104565dcc7c94c22a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a9053c29dbfb9b818b04a4ce1f365ec4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a9981998c4adee45e993ff40f84727e9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a9dcbd0901dbe6a0526e3149916024fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aa4d7382fb00183a7b4b053586cb86a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aae78fcd381bd8f4ab21a33cedcbb12c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aafaab80b06382548c9816e60217fb2a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ab01d573dba01507cbf76a4774774e8f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ab9c6b328185185470188d8627e6bc75>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_abdc40dacab9168755a153536b1a0df0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ac00258851e15327d14b55b2204b72a6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ac1fcb52fb269fee6f8e3b5eebae7104>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ac4abeae2d7be2e571ebcddf34adb4ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ac764b4ac022df116ad7798dcc46cb5d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_acc13046f42a183a1a6bb77c3462d857>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ad089268009b4c2ef9aeeab2404f870c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ad6fdd4f000ebf37143a0db2d8e3e1d1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ae508c7e8f6b0b34717c46973565ba0f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aee57a9ec7f1864cfd19aa04abaa1763>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af162eb4e3b7d8ba1ed3d60d884132ea>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af1abd5eb9635d656b8c5f6048372f41>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af35c386fc11d5ed82390cd7cbf57029>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af8477c9fbb7a29b5eee142ffe0e89d9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_afe0cf013e809ac876b419d8874ee9db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_affdfea5d21959006b44fd28cde0f3b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b08c87a62f0e164a5736fd051e8df282>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b21fde0070eddd1cf447763bd268fd46>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b249b54b0056fbabda011f906b92d550>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b2575ee5400683423b9d807b02fc6585>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b28443ecafd57281e6be33badf3f47db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b2e8c86ec91591da91a95207b442656f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b2f79a76641f894a0367a7459f3b5009>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b3c4ae6dbc014350e59fe903a04ceceb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b4485e36769ec1bb1ed67d4878bede6b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b44af5efbccddd75ba520a3f58a7284f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b4bfc57a369bb816757a83416da3c615>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b5c4771f6b90aff993be7b941e0abfda>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b616859263bcf3525618cd13ec4f64fd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b632145456bde4523c27e66167a66917>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b66dd42b9199e1ecb6e25bb68830e35f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b6ce85aaf5c3053977a5589987dec0f1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b7efb867a4b95aad1215cee37f5f2142>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b837374e4ba6a7ab2040ba2b3a734144>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b85b6d0f7df8509e2ad7026b7a5f6c88>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b88f573435203e70bf9e820a4e618d25>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b8d58bd793c19a67d8dca265a87fea90>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b916857f9f8ade0f1f4bcafc68a335c2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b995cbb9d022c465bf9b9edd30cca0a0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ba5acaffeb96ddaf2f2fa486e3ed6c50>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bc45ae81a4dbae30960fccd210dba5d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bca8bb1ee08a261923a9a5c5407e534c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bcd4a0a46b6f7b4201dd8b058388fc6d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bf0c4ed8c022a08dcd12d0d6cbb86710>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bf1cca3bc6d52c320fc05436dbfcdc65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bf424a489a6f557c136cadd331b0866b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bf48d485bf02abcd5c601cbfca7bb2bf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c081681a52f86b07f9d0f192f63b899e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c083324be672c94e2890c2cb3c89331e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c0e8669fba56ef5f426f70cc77cfa061>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c0f8eeebedb703b426afc0b9ae9ff25c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c23911a372d39ae9a7062eb225e637b0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c2a68b60fac42d0d1bcdec19ffb00d9e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c3666ecae0d234b01feba663b499d263>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c38bda02cd657f62d0f4dc82c0ea7087>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c3b588eee0e82440118111bf549ab226>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c461869bb46105db74380596745643d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c490c6ab2ac02721add773ebbeb99a5a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c579bbb53a4bad13c633f759c8ca8154>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c63808ed64f955a4063ede9ca8b8c6a0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c6493f5f359ed09541ecde014e185573>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c6c7f24a88c7cd3b12bfd8e21ed98a55>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c781000d1485cb2c960e7cfb563e36b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c7d85ead6b60f33341cb01bbd933b0f8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c7e2c96d52e3ccaa7a15bddbcd459338>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c8556e4af94afc2ca1360a76bd2c78a5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c85d82a9c841eb595dddb2d2a00f4c5d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c958e5ac2e55dcd4f0073524c1ad5d89>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c9f579788a18e27baeec9e1b9cb5b66b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ca0c7f7136424db903b645996de01b82>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ca612f9e3c54afa1f008fe58c5c66e47>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ca7c85bc616eafcb79501e98a6ef221f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ca842ad169340b0a4c2cc9c0d2906e92>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cab5151eac1d1f1ebf96c129c72628e0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cac0f0d6c8eb4863815c691d60c3d1ee>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_caf50a991bb498dfd7133d32e35eb360>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ccac3127f022a773a5074e9b5699a069>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cd353a39892e67b26bca8ff71c6f55c5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ce3d6070b3486216c729ac165f168c16>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ce7b7ce43e7e4239949e276493a59a84>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ce93c2f06fd73d2b505d21df05dcc177>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ceef896624d62938180e0434ee72e1fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cf04015a059de75b957d6b27aed72ff6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cf7316951f548bf833b2f937b5171c80>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cfc5d0496b00e235832687eb4324a570>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cfdba0d8733391b4d2f4f5074a29f496>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d004d9bf5ad68546b90f794d5f915a18>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d15a90c44de0e52ed60cecb17e2931fd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d19831b225590e3b72feed772274e3fe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d1f25f780760fcf68b60b9f52bd66ed5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d237763cd8703e7e4d3ab6ea4dec8a4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d2a096ea3008a769f1d0a5d9fa9626a6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d2ab08f67f90557ea5a379379fd8f31a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d32214ab40f9bd376f0b8ccd41c0120c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d3a5d6e49e2a8fb062900790ddf2f456>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d3fd630bbb07b377c1311a814056ccf5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d53dbb7b00e3417f4c49193bf9e823e5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d5a0b7a49d40fe88de6805f838040242>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d5b39d4b3629e2ca9f48ba6b116de02a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d5b93663d4fc1c8c235e1201babc2c99>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d6cbe29a10fb7e7ce5175a7aadae667f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d6e0874cd049b6a0c3d8c9f416e1ba82>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d6e4c2cdb47883faf381c60d0ba89e1e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d741e773bb4b5d34ae95c74e912a3f82>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d83cae0e9e449f82ade0590fa9651642>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8555f8264ddc8c27c692522e7479bf6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8cd0cc594f3b9a769e2b4a76f3d83a3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8d6eca292ff642ebd3701bbc6e721a9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8ea4ec5648c466c2dbc8a82ee558253>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d916cd841beb8339e6d2597cc1af6b1f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d95fb0a170d3f5b4df7a6f2bac21c866>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d99d96c98c7c4feb24d25ae17a8985cd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d9c38379cc43d509550f59340b208533>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dac94eccbb0379033bd4a8f7775d82f0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_db327d59d66e9b1beb44e69e6536ecbf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_db3faf5232c1c2b45b156560d2cac541>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dcbabfaaff2d923fb9f2c3d1e19217d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dd4220754104e7575208b111b403f328>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_de1685b513ba6c31e4476d5737fd7d53>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_de3e5458c6eaa270b0bcdc4f15580d09>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_de75b1b44c17fdef9238049d120b83be>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e03e45e50e3862820dd3284a7b57be9a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e08894c8f999401c473c4ba01f59c4bf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e17805844c133e5b20fa14e53603e1d4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e1f73f88667243e4dfa7145431e4a44b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e214213d881d89d7adb52857c6d2aefd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e26e91dcb11f475af39ad56e91fbc607>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e2b2caf2f7858ed7858d76f8568ac4e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e35f6062474ce6ca748236d731af0d41>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e3d9d041f0c9ac03b9e9b4c3ae3eee12>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e49a935b5f3f9e8a26e3e63193e59783>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e535c1f041f135e812ec5f1c9823fcca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e6b63058b272e0472e88102d338a5131>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e7486cb21f645cd2b2445f3a90ec3bfc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e7500e7f1573afdd1fb08ef3f01bc7ca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e812a25f8d5cad6e240b9c18c7575373>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e862096fc7a7438568f356fe7e413858>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e896149c2946eddccc4ab9ef181e6692>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ea5b7edd9df89bd04b914340e5341fbd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ea7c067843ae96f05229b0f2f22e8c2d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ea8c88b41df3346ebb090e86a08c71ad>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eac8b2770af5340139d733fbb60f6f60>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eaf482e3bdb031d54388a1e99418fa62>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eb4094f6bcb50b2ef1848f3e7425698e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eb6d56346b0cdacd5eebce566519d2a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ebd4e378db90af50f6aba8f69e3e940c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ec10b2aec968e6524f478a8d08baa384>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ece1ea04a10ae492ebca08240941a8d8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ecfeba1e5f7dfd81ce429a7d4653fb65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ed5e5038ae08979dfba0c9a9e0f51364>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ed63482bb9ca1543cf0b75373d0b6c05>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_edcffd2c15a35679915cad728bcfcd48>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f00224905c7c414e603a52589bb6bae6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f018a6b0f1abe094e8eb6668ba5fe5bc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f13dbb34a7f4c43a2cb3556cb1dd0fc1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f158009f4006d857c70245c816b7aa13>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f1a327ffba7e4d3100b6ce9fddc14c40>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f2207893870ffe8903bedfb216ccc08e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f2226345030ad60d78ca18c42d614451>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f2a457c5807d156b084c834ff2352f51>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f40bc526c99d8d8dee76e5fe54013d97>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f429706aa4ac2799776c103b918221cc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f42b01f3d48d8587bb8faed06d1b579e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f486556a77674d99569bd35705d7acc0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f4b84df0350e66df479f27e4f97f5b97>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f5122e1852d15845b738a95ad8ff8a2a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f581254d4dffef07f79940652afc751c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f58ffadb091f22e8aa802a4c2fa969a7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f5c08a050b95ca0bfcad7d124c91f1f6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f5dece463422488d30c2c89b3d2148ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f5ee90bb95be40c20b32fdcb68a22778>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f5fe3537bf016b3f5534fa7a6598c3bf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f60c33299596573253845873a7bb8248>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f6e12d99244e1018d1be86c2e1506644>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f6fcf4f866d392b98993022e70fb4401>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f746d35ae7fcc2376134a266c1dc6e5e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f751a6ca7ae32f27644c6fc0986ca946>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f7b59d1f1a1d4fc4e4c2881d6658a7ca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f7f718d365a535bb2a319a21b5941c1f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8c993317ad74b90b6e741f961d76526>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8f0e2119f9d40ba8ab7f69ddbe1f06e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9f1cc558235afe7edd56fde1290c9ca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9f4799b06ec2ea9b89e41484ce5ab29>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9f8cda5934eadbb148a99f98e678ad1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fa093b9e35abac3b068a038cbca44e28>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fab2cf6f33b1d2be7e7d7b70a851c9ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fb0a3f474d47b7786c96863d67e73e11>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fb4fd7d45e628efb1fc1863228f6c06f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fb5138a54a25afc4d078cdeb479c7e7d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fc607dc3de28109c4c3a1ac5e33b96b8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fd5ca79ed74bac0af2a32b0efe206109>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fdd05f94bd7fc6c395db548c279d8cab>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fdee1d02b664fbe3665fa40ad8a9cf33>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fe67745a02a112e368e7ad898826f26f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fe7d74574e9a622c8632ba794e2f2bef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fed48f89dd4ca93d5f116f87726dddba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ff48972c831a564100a94d3cb3dc29ca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ff65b411161532cbff105380da1514ee>@@@TaskScheduler@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx2@embree@@$$YBezierCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx2@embree@@UBSplineCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx2@embree@@UCatmullRomCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx@embree@@$$YBezierCurveT@3@@avx@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx@embree@@UBSplineCurveT@3@@avx@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx@embree@@UCatmullRomCurveT@3@@avx@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@sse2@embree@@$$YBezierCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@sse2@embree@@UBSplineCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$00UCurveGeometryInterface@sse2@embree@@UCatmullRomCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$00UHermiteCurveGeometryInterface@avx2@embree@@UHermiteCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$00UHermiteCurveGeometryInterface@avx@embree@@UHermiteCurveT@3@@avx@embree
AU?$CurveGeometryISA@$00UHermiteCurveGeometryInterface@sse2@embree@@UHermiteCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx2@embree@@$$YBezierCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx2@embree@@UBSplineCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx2@embree@@UCatmullRomCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx@embree@@$$YBezierCurveT@3@@avx@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx@embree@@UBSplineCurveT@3@@avx@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx@embree@@UCatmullRomCurveT@3@@avx@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@sse2@embree@@$$YBezierCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@sse2@embree@@UBSplineCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$01UCurveGeometryInterface@sse2@embree@@UCatmullRomCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$01UHermiteCurveGeometryInterface@avx2@embree@@UHermiteCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$01UHermiteCurveGeometryInterface@avx@embree@@UHermiteCurveT@3@@avx@embree
AU?$CurveGeometryISA@$01UHermiteCurveGeometryInterface@sse2@embree@@UHermiteCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx2@embree@@$$YBezierCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx2@embree@@UBSplineCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx2@embree@@UCatmullRomCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx@embree@@$$YBezierCurveT@3@@avx@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx@embree@@UBSplineCurveT@3@@avx@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx@embree@@UCatmullRomCurveT@3@@avx@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@sse2@embree@@$$YBezierCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@sse2@embree@@UBSplineCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@sse2@embree@@UCatmullRomCurveT@3@@sse2@embree
AU?$CurveGeometryISA@$0A@UHermiteCurveGeometryInterface@avx2@embree@@UHermiteCurveT@3@@avx2@embree
AU?$CurveGeometryISA@$0A@UHermiteCurveGeometryInterface@avx@embree@@UHermiteCurveT@3@@avx@embree
AU?$CurveGeometryISA@$0A@UHermiteCurveGeometryInterface@sse2@embree@@UHermiteCurveT@3@@sse2@embree
AU?$CurveGeometryInterface@$$YBezierCurveT@embree@@@avx2@embree
AU?$CurveGeometryInterface@$$YBezierCurveT@embree@@@avx@embree
AU?$CurveGeometryInterface@$$YBezierCurveT@embree@@@sse2@embree
AU?$CurveGeometryInterface@UBSplineCurveT@embree@@@avx2@embree
AU?$CurveGeometryInterface@UBSplineCurveT@embree@@@avx@embree
AU?$CurveGeometryInterface@UBSplineCurveT@embree@@@sse2@embree
AU?$CurveGeometryInterface@UCatmullRomCurveT@embree@@@avx2@embree
AU?$CurveGeometryInterface@UCatmullRomCurveT@embree@@@avx@embree
AU?$CurveGeometryInterface@UCatmullRomCurveT@embree@@@sse2@embree
AU?$HermiteCurveGeometryInterface@UHermiteCurveT@embree@@@avx2@embree
AU?$HermiteCurveGeometryInterface@UHermiteCurveT@embree@@@avx@embree
AU?$HermiteCurveGeometryInterface@UHermiteCurveT@embree@@@sse2@embree
AU?$ProgressMonitorClosure@V<lambda_d7487f8c9ea7cb96899891cb9a3ea4a8>@@@embree
AU?$ProgressMonitorClosure@V<lambda_f901d1c1d337b769ca822836207e498c>@@@embree
AU?$deleter@VIScene@ipl@@@ipl
AUAVAWH
AUAVAWUH
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@avx@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@sse2@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$07@avx@embree
AUBuildProgressMonitor@embree
AUBuildProgressMonitorInterface@Scene@embree
AUCalcBufferHolder@RadeonRays
AUCalcEventHolder@RadeonRays
AUCurveGeometry@embree
AUInstance@embree
AUInstanceArray@embree
AUInstanceArrayISA@avx2@embree
AUInstanceArrayISA@avx@embree
AUInstanceArrayISA@sse2@embree
AUInstanceISA@avx2@embree
AUInstanceISA@avx@embree
AUInstanceISA@sse2@embree
AULeafBoundsInterface@?$BVHNRefitter@$03@avx@embree
AULeafBoundsInterface@?$BVHNRefitter@$03@sse2@embree
AULeafBoundsInterface@?$BVHNRefitter@$07@avx@embree
AULineSegments@embree
AULineSegmentsISA@avx2@embree
AULineSegmentsISA@avx@embree
AULineSegmentsISA@sse2@embree
AUMemoryMonitorInterface@embree
AUPrimitiveType@embree
AUQuadMesh@embree
AUQuadMeshISA@avx2@embree
AUQuadMeshISA@avx@embree
AUQuadMeshISA@sse2@embree
AURegressionTest@embree
AUState@embree
AUSubdivMeshISA@avx@embree
AUSubdivMeshISA@sse2@embree
AUTaskFunction@TaskScheduler@embree
AUTaskScheduler@embree
AUTriangleMesh@embree
AUTriangleMeshISA@avx2@embree
AUTriangleMeshISA@avx@embree
AUTriangleMeshISA@sse2@embree
AUType@?$CurveNi@$03@embree
AUType@?$CurveNi@$07@embree
AUType@?$CurveNiMB@$03@embree
AUType@?$CurveNiMB@$07@embree
AUType@?$CurveNv@$03@embree
AUType@?$CurveNv@$07@embree
AUType@?$QuadMi@$03@embree
AUType@?$QuadMv@$03@embree
AUType@?$TriangleM@$03@embree
AUType@?$TriangleMi@$03@embree
AUType@?$TriangleMv@$03@embree
AUType@?$TriangleMvMB@$03@embree
AUType@InstanceArrayPrimitive@embree
AUType@InstancePrimitive@embree
AUType@Object@embree
AUType@SubGrid@embree
AUType@SubdivPatch1@embree
AUUUUUU
AU_Crt_new_delete@std
AUbarrier_sys_regression_test@embree
AUcache_regression_test@embree
AUcollision_regression_test@sse2@embree
AUctype_base@std
AUfast_allocator_regression_test@embree
AUmessages_base@std
AUmoney_base@std
AUrtcore_error@embree
AUtime_base@std
AV<lambda_0a5eb190081202e0f28c290d3f31c81b
AV<lambda_11109a99d7bbd452d4f1159b09c495b9
AV<lambda_13a1aeb28e4e0bac28d36bed730a97d9
AV<lambda_3e54074239d9181f190e21fe31b2ebd5
AV<lambda_498b6f04f2beccab8c714618b3ad669c
AV<lambda_4de24228018b536c3da2a1177966e9d3
AV<lambda_62a9d32afc8d6b63df56e96e440ec261
AV<lambda_816ac016707b2a67b11e96aff710a40f
AV<lambda_845e6907f0dbd1951683b9def278af13
AV<lambda_ab2e5214d93248d9c1a2f348abe6f0b1
AV<lambda_cdbbba9119ddeae309deb8db07daea64
AV<lambda_dff3c1b6999eee227e24249907461f6e
AV<lambda_ee6a2105f198a1070623061950e8e630
AV<lambda_f5a6bbee718852bc735793355e363d30
AV?$BVHN@$03@embree
AV?$BVHN@$07@embree
AV?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNBuilderTwoLevel@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNCollider@$03@avx2@embree
AV?$BVHNCollider@$03@avx@embree
AV?$BVHNCollider@$03@sse2@embree
AV?$BVHNCollider@$07@avx@embree
AV?$BVHNColliderUserGeom@$03@avx2@embree
AV?$BVHNColliderUserGeom@$03@avx@embree
AV?$BVHNColliderUserGeom@$03@sse2@embree
AV?$BVHNColliderUserGeom@$07@avx@embree
AV?$BVHNMeshBuilderMorton@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNRefitT@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree
AV?$BVHNRefitT@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree
AV?$BVHNRefitT@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AV?$BVHNRefitT@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree
AV?$BVHNRefitT@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNRefitT@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNRefitT@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree
AV?$BVHNRefitT@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AV?$BVHNRefitT@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$CLWBuffer@D
AV?$CLWBuffer@H
AV?$CLWBuffer@M
AV?$ReferenceCounter@PEAU_cl_command_queue@@$1?clRetainCommandQueue@@YAHPEAU1@@Z$1?clReleaseCommandQueue@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_context@@$1?clRetainContext@@YAHPEAU1@@Z$1?clReleaseContext@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_device_id@@$1?clRetainDevice@@YAHPEAU1@@Z$1?clReleaseDevice@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_event@@$1?clRetainEvent@@YAHPEAU1@@Z$1?clReleaseEvent@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_kernel@@$1?clRetainKernel@@YAHPEAU1@@Z$1?clReleaseKernel@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_mem@@$1?clRetainMemObject@@YAHPEAU1@@Z$1?clReleaseMemObject@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_platform_id@@$0A@$0A
AV?$ReferenceCounter@PEAU_cl_program@@$1?clRetainProgram@@YAHPEAU1@@Z$1?clReleaseProgram@@YAH0@Z
AV?$Stream@H@embree
AV?$Stream@VToken@embree@@@embree
AV?$_Ebco_base@V?$allocator@UImpulseResponse2@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VBinauralEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VBufferedIndirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VCompressedEnergyFields@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VCompressedProbeBatch@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VContext@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VDirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VDirectSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeInstancedMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEnergyField@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHRTFDatabase@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHybridReverbEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHybridReverbEstimator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VImpulseResponse@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectMixer@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectPartitioner@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VInstancedMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VInterpolatableImpulseResponse@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VJobGraph@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VNonUniformProbeBatch@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOpenCLDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOpenCLDeviceList@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOverlapSaveFIR@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOverlapSavePartitioner@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPanningEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPathEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPathSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeArray@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeBatch@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeClusterMap@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeNeighborhood@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VRadeonRaysDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VReconstructor@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VReflectionSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VReverbEstimator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VScene@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSerializedObject@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSimulationData@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSimulationManager@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VTANDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VThreadPool@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VVirtualSurroundEffect@ipl@@@ipl@@$00@std
AV?$_ExceptionPtr_static@Vbad_alloc@std@@@?A0xad5a25bc
AV?$_ExceptionPtr_static@Vbad_exception@std@@@?A0xad5a25bc
AV?$_Func_base@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_base@XM@std
AV?$_Func_base@XPEAVBuffer@Calc@@@std
AV?$_Func_base@XPEAVDevice@Calc@@@std
AV?$_Func_base@XPEAVEvent@Calc@@@std
AV?$_Func_impl@V<lambda_498b6f04f2beccab8c714618b3ad669c>@@V?$allocator@H@std@@XPEAVBuffer@Calc@@@std
AV?$_Func_impl@V<lambda_62a9d32afc8d6b63df56e96e440ec261>@@V?$allocator@H@std@@XPEAVDevice@Calc@@@std
AV?$_Func_impl@V<lambda_dff3c1b6999eee227e24249907461f6e>@@V?$allocator@H@std@@XPEAVEvent@Calc@@@std
AV?$_Func_impl_no_alloc@V<lambda_0a5eb190081202e0f28c290d3f31c81b>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_11109a99d7bbd452d4f1159b09c495b9>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_13a1aeb28e4e0bac28d36bed730a97d9>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_3e54074239d9181f190e21fe31b2ebd5>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_4de24228018b536c3da2a1177966e9d3>@@XM@std
AV?$_Func_impl_no_alloc@V<lambda_816ac016707b2a67b11e96aff710a40f>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_845e6907f0dbd1951683b9def278af13>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_ab2e5214d93248d9c1a2f348abe6f0b1>@@XM@std
AV?$_Func_impl_no_alloc@V<lambda_cdbbba9119ddeae309deb8db07daea64>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_ee6a2105f198a1070623061950e8e630>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_f5a6bbee718852bc735793355e363d30>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Iosb@H@std
AV?$_Mpunct@D@std
AV?$_Mpunct@G@std
AV?$_Mpunct@_W@std
AV?$_Ref_count_obj_alloc3@UImpulseResponse2@@V?$allocator@UImpulseResponse2@@@ipl@@@std
AV?$_Ref_count_obj_alloc3@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@V?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl@@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsBinauralEffect@ipl@@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsDecodeEffect@ipl@@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsEncodeEffect@ipl@@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsPanningEffect@ipl@@V?$allocator@VAmbisonicsPanningEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsRotateEffect@ipl@@V?$allocator@VAmbisonicsRotateEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VBinauralEffect@ipl@@V?$allocator@VBinauralEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VBufferedIndirectEffect@ipl@@V?$allocator@VBufferedIndirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VCompressedEnergyFields@ipl@@V?$allocator@VCompressedEnergyFields@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VCompressedProbeBatch@ipl@@V?$allocator@VCompressedProbeBatch@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VContext@ipl@@V?$allocator@VContext@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VDirectEffect@ipl@@V?$allocator@VDirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VDirectSimulator@ipl@@V?$allocator@VDirectSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeDevice@ipl@@V?$allocator@VEmbreeDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeInstancedMesh@ipl@@V?$allocator@VEmbreeInstancedMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeStaticMesh@ipl@@V?$allocator@VEmbreeStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEnergyField@ipl@@V?$allocator@VEnergyField@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHRTFDatabase@ipl@@V?$allocator@VHRTFDatabase@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHybridReverbEffect@ipl@@V?$allocator@VHybridReverbEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHybridReverbEstimator@ipl@@V?$allocator@VHybridReverbEstimator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VImpulseResponse@ipl@@V?$allocator@VImpulseResponse@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectEffect@ipl@@V?$allocator@VIndirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectMixer@ipl@@V?$allocator@VIndirectMixer@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectPartitioner@ipl@@V?$allocator@VIndirectPartitioner@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VInstancedMesh@ipl@@V?$allocator@VInstancedMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VInterpolatableImpulseResponse@ipl@@V?$allocator@VInterpolatableImpulseResponse@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VJobGraph@ipl@@V?$allocator@VJobGraph@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VNonUniformProbeBatch@ipl@@V?$allocator@VNonUniformProbeBatch@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOpenCLDevice@ipl@@V?$allocator@VOpenCLDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOpenCLDeviceList@ipl@@V?$allocator@VOpenCLDeviceList@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOverlapSaveFIR@ipl@@V?$allocator@VOverlapSaveFIR@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOverlapSavePartitioner@ipl@@V?$allocator@VOverlapSavePartitioner@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPanningEffect@ipl@@V?$allocator@VPanningEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPathEffect@ipl@@V?$allocator@VPathEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPathSimulator@ipl@@V?$allocator@VPathSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeArray@ipl@@V?$allocator@VProbeArray@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeBatch@ipl@@V?$allocator@VProbeBatch@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeClusterMap@ipl@@V?$allocator@VProbeClusterMap@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeNeighborhood@ipl@@V?$allocator@VProbeNeighborhood@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VRadeonRaysDevice@ipl@@V?$allocator@VRadeonRaysDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VRadeonRaysStaticMesh@ipl@@V?$allocator@VRadeonRaysStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VReconstructor@ipl@@V?$allocator@VReconstructor@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VReflectionSimulator@ipl@@V?$allocator@VReflectionSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VReverbEstimator@ipl@@V?$allocator@VReverbEstimator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VScene@ipl@@V?$allocator@VScene@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSerializedObject@ipl@@V?$allocator@VSerializedObject@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSimulationData@ipl@@V?$allocator@VSimulationData@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSimulationManager@ipl@@V?$allocator@VSimulationManager@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VStaticMesh@ipl@@V?$allocator@VStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VTANDevice@ipl@@V?$allocator@VTANDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VThreadPool@ipl@@V?$allocator@VThreadPool@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VVirtualSurroundEffect@ipl@@V?$allocator@VVirtualSurroundEffect@ipl@@@2@@std
AV?$_Ref_count_resource@PEAVIScene@ipl@@U?$deleter@VIScene@ipl@@@2@@std
AV?$allocator@UImpulseResponse2@@@ipl
AV?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl
AV?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl
AV?$allocator@VBinauralEffect@ipl@@@ipl
AV?$allocator@VBufferedIndirectEffect@ipl@@@ipl
AV?$allocator@VCompressedEnergyFields@ipl@@@ipl
AV?$allocator@VCompressedProbeBatch@ipl@@@ipl
AV?$allocator@VContext@ipl@@@ipl
AV?$allocator@VDirectEffect@ipl@@@ipl
AV?$allocator@VDirectSimulator@ipl@@@ipl
AV?$allocator@VEmbreeDevice@ipl@@@ipl
AV?$allocator@VEmbreeInstancedMesh@ipl@@@ipl
AV?$allocator@VEmbreeStaticMesh@ipl@@@ipl
AV?$allocator@VEnergyField@ipl@@@ipl
AV?$allocator@VHRTFDatabase@ipl@@@ipl
AV?$allocator@VHybridReverbEffect@ipl@@@ipl
AV?$allocator@VHybridReverbEstimator@ipl@@@ipl
AV?$allocator@VImpulseResponse@ipl@@@ipl
AV?$allocator@VIndirectEffect@ipl@@@ipl
AV?$allocator@VIndirectMixer@ipl@@@ipl
AV?$allocator@VIndirectPartitioner@ipl@@@ipl
AV?$allocator@VInstancedMesh@ipl@@@ipl
AV?$allocator@VInterpolatableImpulseResponse@ipl@@@ipl
AV?$allocator@VJobGraph@ipl@@@ipl
AV?$allocator@VNonUniformProbeBatch@ipl@@@ipl
AV?$allocator@VOpenCLDevice@ipl@@@ipl
AV?$allocator@VOpenCLDeviceList@ipl@@@ipl
AV?$allocator@VOverlapSaveFIR@ipl@@@ipl
AV?$allocator@VOverlapSavePartitioner@ipl@@@ipl
AV?$allocator@VPanningEffect@ipl@@@ipl
AV?$allocator@VPathEffect@ipl@@@ipl
AV?$allocator@VPathSimulator@ipl@@@ipl
AV?$allocator@VProbeArray@ipl@@@ipl
AV?$allocator@VProbeBatch@ipl@@@ipl
AV?$allocator@VProbeClusterMap@ipl@@@ipl
AV?$allocator@VProbeNeighborhood@ipl@@@ipl
AV?$allocator@VRadeonRaysDevice@ipl@@@ipl
AV?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl
AV?$allocator@VReconstructor@ipl@@@ipl
AV?$allocator@VReflectionSimulator@ipl@@@ipl
AV?$allocator@VReverbEstimator@ipl@@@ipl
AV?$allocator@VScene@ipl@@@ipl
AV?$allocator@VSerializedObject@ipl@@@ipl
AV?$allocator@VSimulationData@ipl@@@ipl
AV?$allocator@VSimulationManager@ipl@@@ipl
AV?$allocator@VStaticMesh@ipl@@@ipl
AV?$allocator@VTANDevice@ipl@@@ipl
AV?$allocator@VThreadPool@ipl@@@ipl
AV?$allocator@VVirtualSurroundEffect@ipl@@@ipl
AV?$basic_filebuf@DU?$char_traits@D@std@@@std
AV?$basic_ifstream@DU?$char_traits@D@std@@@std
AV?$basic_ios@DU?$char_traits@D@std@@@std
AV?$basic_iostream@DU?$char_traits@D@std@@@std
AV?$basic_istream@DU?$char_traits@D@std@@@std
AV?$basic_ostream@DU?$char_traits@D@std@@@std
AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$basic_streambuf@DU?$char_traits@D@std@@@std
AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$codecvt@DDU_Mbstatet@@@std
AV?$codecvt@GDU_Mbstatet@@@std
AV?$codecvt@_WDU_Mbstatet@@@std
AV?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std
AV?$collate@D@std
AV?$collate@G@std
AV?$collate@_W@std
AV?$ctype@D@std
AV?$ctype@G@std
AV?$ctype@_W@std
AV?$enable_shared_from_this@VIScene@ipl@@@std
AV?$messages@D@std
AV?$messages@G@std
AV?$messages@_W@std
AV?$money_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$money_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$money_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$money_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$money_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$money_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$moneypunct@D$00@std
AV?$moneypunct@D$0A@@std
AV?$moneypunct@G$00@std
AV?$moneypunct@G$0A@@std
AV?$moneypunct@_W$00@std
AV?$moneypunct@_W$0A@@std
AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$num_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$num_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$numpunct@D@std
AV?$numpunct@G@std
AV?$numpunct@_W@std
AV?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$time_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$time_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$time_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$time_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$wstring_convert@V?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std@@_WV?$allocator@_W@2@V?$allocator@D@2@@std
AVAWMcq\bH
AVAWUF
AVAWUH
AVAccel@embree
AVAccelData@embree
AVAccelInstance@embree
AVAccelN@embree
AVAllocator@flatbuffers
AVBakedPathData@ipl
AVBakedReflectionsData@ipl
AVBatchedReflectionSimulator@ipl
AVBuffer@Calc
AVBuffer@RadeonRays
AVBuffer@embree
AVBufferClw@Calc
AVBuilder@embree
AVBvh2lStrategy@RadeonRays
AVBvh@RadeonRays
AVBvhStrategy@RadeonRays
AVCAmbisonicsBinauralEffect@api
AVCAmbisonicsDecodeEffect@api
AVCAmbisonicsEncodeEffect@api
AVCAmbisonicsPanningEffect@api
AVCAmbisonicsRotationEffect@api
AVCBinauralEffect@api
AVCCompressedProbeBatch@api
AVCContext@api
AVCDirectEffect@api
AVCEmbreeDevice@api
AVCEnergyField@api
AVCHRTF@api
AVCImpulseResponse@api
AVCInstancedMesh@api
AVCLWCommandQueue
AVCLWContext
AVCLWDevice
AVCLWEvent
AVCLWException
AVCLWKernel
AVCLWPlatform
AVCLWProgram
AVCNonUniformProbeBatch@api
AVCOpenCLDevice@api
AVCOpenCLDeviceList@api
AVCPanningEffect@api
AVCPathEffect@api
AVCProbeArray@api
AVCProbeBatch@api
AVCRadeonRaysDevice@api
AVCReconstructor@api
AVCReflectionEffect@api
AVCReflectionMixer@api
AVCScene@api
AVCSerializedObject@api
AVCSimulator@api
AVCSource@api
AVCStaticMesh@api
AVCTrueAudioNextDevice@api
AVCValidatedAmbisonicsBinauralEffect@api
AVCValidatedAmbisonicsDecodeEffect@api
AVCValidatedAmbisonicsEncodeEffect@api
AVCValidatedAmbisonicsPanningEffect@api
AVCValidatedAmbisonicsRotationEffect@api
AVCValidatedBinauralEffect@api
AVCValidatedContext@api
AVCValidatedDirectEffect@api
AVCValidatedEmbreeDevice@api
AVCValidatedEnergyField@api
AVCValidatedHRTF@api
AVCValidatedImpulseResponse@api
AVCValidatedInstancedMesh@api
AVCValidatedOpenCLDevice@api
AVCValidatedOpenCLDeviceList@api
AVCValidatedPanningEffect@api
AVCValidatedPathEffect@api
AVCValidatedProbeArray@api
AVCValidatedProbeBatch@api
AVCValidatedRadeonRaysDevice@api
AVCValidatedReconstructor@api
AVCValidatedReflectionEffect@api
AVCValidatedReflectionMixer@api
AVCValidatedScene@api
AVCValidatedSerializedObject@api
AVCValidatedSimulator@api
AVCValidatedSource@api
AVCValidatedStaticMesh@api
AVCValidatedTrueAudioNextDevice@api
AVCValidatedVirtualSurroundEffect@api
AVCVirtualSurroundEffect@api
AVCalc@0
AVCalcClw@Calc
AVCalcIntersectionDevice@RadeonRays
AVCalcIntersectionDeviceCl@RadeonRays
AVCompressedBakedReflections@ipl
AVCompressedProbeBatch@ipl
AVCustomScene@ipl
AVDefaultAllocator@flatbuffers
AVDevice@Calc
AVDevice@embree
AVDeviceCl@Calc
AVDeviceClw@Calc
AVEmbreeInstancedMesh@ipl
AVEmbreeReflectionSimulator@ipl
AVEmbreeScene@ipl
AVEmbreeStaticMesh@ipl
AVEnergyField@ipl
AVEvent@Calc
AVEvent@RadeonRays
AVEventClw@Calc
AVException@Calc
AVException@RadeonRays
AVException@ipl
AVExceptionClw@Calc
AVExceptionImpl@RadeonRays
AVExecutable@Calc
AVExecutableClw@Calc
AVFatBvhStrategy@RadeonRays
AVFlatBuffersAllocator@ipl
AVFunction@Calc
AVFunctionClw@Calc
AVGeometry@embree
AVHRTFMap@ipl
AVHlbvh@RadeonRays
AVHlbvhStrategy@RadeonRays
AVIAmbisonicsBinauralEffect@api
AVIAmbisonicsDecodeEffect@api
AVIAmbisonicsEncodeEffect@api
AVIAmbisonicsPanningEffect@api
AVIAmbisonicsRotationEffect@api
AVIBakedData@ipl
AVIBakedReflectionsLookup@ipl
AVIBinauralEffect@api
AVIContext@api
AVIDirectEffect@api
AVIEmbreeDevice@api
AVIEnergyField@api
AVIHRTF@api
AVIHRTFMap@ipl
AVIImpulseResponse@api
AVIInstancedMesh@api
AVIInstancedMesh@ipl
AVIOpenCLDevice@api
AVIOpenCLDeviceList@api
AVIPanningEffect@api
AVIPathEffect@api
AVIProbeArray@api
AVIProbeBatch@api
AVIRadeonRaysDevice@api
AVIReconstructor@api
AVIReconstructor@ipl
AVIReflectionEffect@api
AVIReflectionMixer@api
AVIReflectionSimulator@ipl
AVIScene@api
AVIScene@ipl
AVISerializedObject@api
AVISimulator@api
AVISource@api
AVIStaticMesh@api
AVIStaticMesh@ipl
AVITrueAudioNextDevice@api
AVIVirtualSurroundEffect@api
AVImpulseResponse@ipl
AVInstance@RadeonRays
AVInstancedMesh@ipl
AVIntersectionApi@RadeonRays
AVIntersectionApiImpl@RadeonRays
AVIntersectionDevice@RadeonRays
AVMesh@RadeonRays
AVNonUniformProbeBatch@ipl
AVOpenCLEnergyField@ipl
AVOpenCLImpulseResponse@ipl
AVOpenCLReconstructor@ipl
AVPrimitives@Calc
AVPrimitivesClw@Calc
AVProbeBatch@ipl
AVRadeonRaysReflectionSimulator@ipl
AVRadeonRaysScene@ipl
AVRadeonRaysStaticMesh@ipl
AVReconstructor@ipl
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AVRefCount@embree
AVReflectionSimulator@ipl
AVSOFAHRTFMap@ipl
AVScene@embree
AVScene@ipl
AVShape@RadeonRays
AVShapeImpl@RadeonRays
AVSplitBvh@RadeonRays
AVStaticMesh@ipl
AVStrStream@embree
AVStrategy@RadeonRays
AVSubdivMesh@embree
AVTokenStream@embree
AVVWSH
AVVWSPH
AVVWUSH
AVWorld@RadeonRays
AVX23L
AVX2_E1
AVX512
AVX512BW
AVX512CD
AVX512DQ
AVX512ER
AVX512F
AVX512F H
AVX512IFMA
AVX512IFMA52
AVX512PF
AVX512VBMI
AVX512VL
AVX512_4FMAPS
AVX512_4VNNIW
AVX512_BF16
AVX512_BITALG
AVX512_E1
AVX512_EH
AVX512_FP16
AVX512_MIC
AVX512_MIC_E1
AVX512_VBMI2
AVX512_VNNI
AVX512_VP2INTERSECT
AVX512_VPOPCNTDQ
AVX53D
AVX_10_1
AVX_10_1_512
AVX_IFMA
AVX_NE_CONVERT
AVX_VNNI
AVX_VNNI_INT16
AVX_VNNI_INT8
AV_ExceptionPtr_normal@?A0xad5a25bc
AV_Facet_base@std
AV_Generic_error_category@std
AV_Iostream_error_category2@std
AV_Iostream_error_category@std
AV_Locimp@locale@std
AV_Ref_count_base@std
AV_System_error@std
AV__non_rtti_object@std
AVbad_alloc@std
AVbad_array_new_length@std
AVbad_cast@std
AVbad_exception@std
AVbad_function_call@std
AVbad_typeid@std
AVbad_weak_ptr@std
AVcodecvt_base@std
AVerror_category@std
AVexception@std
AVfacet@locale@std
AVfailure@ios_base@std
AVios_base@std
AVlength_error@std
AVlogic_error@std
AVout_of_range@std
AVrange_error@std
AVruntime_error@std
AVstl_condition_variable_interface@details@Concurrency
AVstl_condition_variable_vista@details@Concurrency
AVstl_condition_variable_win7@details@Concurrency
AVstl_critical_section_interface@details@Concurrency
AVstl_critical_section_vista@details@Concurrency
AVstl_critical_section_win7@details@Concurrency
AVsystem_error@std
AVtype_info
AW&qB
AWAVATVWSH
AWAVATVWUSH
AWAVAUATVWSH
AWAVAUATVWUS
AWAVAUATVWUSH
AWAVAUATVWUSL
AWAVAUATVWUSPH
AWAVVWS1
AWAVVWSH
AWAVVWUSH
AX:gex:J
AXH+API;D$0
AXH+APL
AXX䋄$0
AX\\D
AYAXZY
A[YƋL$0H
A\\A]A^A_YZAXAYAZA
A\a9Ћi
A\b3Ҋ\bI
A\bA;ŋI\fA
A\bH;\bu
A\bI;D$\b
A\bL;\bu
A\b_t\b0
A\b_w I
A\bba|\b
A\bi:L
A\eP;g
A\fba~\b
A\nYL
A\nYT
A\nba|\b
A\nba~\b
A\ny:\a
A\rba|H
A\t8;:X\a
A\t;vk
A\t<&a0
A\tB(M
A\tE\a0W
A\v:O)3
A\vE\b0W
A]A\\]_^[ÐSVWUATAUH
A^A]A
A_A]A
A_A^A
A_A^A]A
A_A^A]A\\_^[ÐSVWATAUAVAWUH
A_H<r
A`+AX
AbYd/4
AccelN::intersector1
AccelN::intersector16
AccelN::intersector4
AccelN::intersector8
Access violation - no RTTI data
AcquireSRWLockExclusive
AdjustTokenPrivileges
Advanced Micro Devices
Ady;.s
Af<ZXk
AfC`ěA
Affff
Affffff
Ag5<I
Ah\f;o
Ai<ִv
AjYT3\bz
AjY\\4\fz
Ak==9
Ak\f<\a
Ak»mS
Al\\l
AmQ,BP\a
Am\a9D
An error/warning message cannot be saved in the file
An unclassifiable error occurred
An>uCv
AoҼh9
ApY<\aL
ApY<\aŰY
AppPolicyGetProcessTerminationMethod
AppPolicyGetShowDeveloperDiagnostic
AppPolicyGetThreadInitializationType
AppPolicyGetWindowingModel
Aq:UV
Aq:k\n
AreFileApisANSI
As< g
Asg<0gk
Assertion failed
Assertion failed: %Ts, file %Ts, line %d\n
Assigning DPAR(1)=%e
Assigning DPAR(2)=%e
Assigning IPAR(8)=IPAR(9)=1. This means that DFGMRES routine will do the
At least one of parameters IPAR(8), IPAR(9), or IPAR(10) must be equal to 1
At least one of the parameters IPAR(8), IPAR(9), or
Attempted to create SOFA HRTF without either a file name or a data buffer
August
Auth3D$4
Auu:L
AvÄ\t-T
Aw9/1
Awj;:m\e
Ax/T$\f
Ax5;U
AxH+ApH
AxH+ApI;E8
AxXd$0
Ax\\D
Ay<xeV
Aynt\f0
Ayn|\fd
AzoLQ\n
AzoLT\n
AzoLU\n
AzoLV\n
AzoLW\n
AzolQ\nK
AzolQ\nĂy!L
AzolQ\nĢy!D\t
AzolU\nH
AzolV\nH
AzolW\nH
A{A=dg
A{L.B
A|(TD
A|(tE
A|=T2P
A||                                    %f
AƼCNϼ\fc
Aʼ;\vdb
A˻bC3<\aHN
A̪;VB
A̻fsv<?c
À:bf
A֟;Sr
Aໂi\a
A酼Xto
A튺r*o
B :;NM0
B :UsK
B"B&B*B.B2B6B:B>BBBFBJ(8
B(<t5A
B(I9A(u\r
B)bA|\b
B+N>ZaS
B+Q4\a
B-H<WP
B0;0=k
B0i9B
B0ɼ"7
B1<J\aJ
B93)\v
B9<ybl
B9L8\ft A
B9dڕ8nO
B9ᑙ:7m
B:BbZ:R
B:\f0u M
B; rs9
B;"3J;g
B;(kW
B;0JH
B;Q医9
B;RbT
B;WO5
B;XNN;$9J;6
B;Y)Y;2N
B;ZwH
B;\bEO
B;jOH
B;peL
B;íc8hxs
B<;YV1
B<\t\r\b8
B<xym<[\nM
B=2}\t=Cٞ=i6h=JC
B=Jk8
B=R67
B>Bh9?\a
B>F\fE
B>\tSԽe
B>zZ\v
B>{Pn
B?d!\vY
B?d"C
B@bQ|\n
BB:;o\t
BB<.m
BCŻHl5
BCױbc}IC
BC߱bc}IC
BD>Lɏ<s
BD\v7
BENCHMARK_BUILD
BF8<pjM
BF>XoT
BH;% H
BJ8=R
BJƼ{K
BK=\b
BL0<:;H
BM<mcW
BM];Ha
BMa=!9
BMr:Km
BN9"X
BN:;lY
BNe<\v@P
BNi;\b
BOO<̊r
BP<p\r
BQ#"C\n
BQZ:K:G
BRANCH
BSp<fm0;\a
BT{zb
BUY:P
BUμVx
BXHc\bI
BXI+KPI+BPH
BXQ<ŊXy
BXm:|v
BY,T,L
BY\t>w
BYԀB8B
B\\s;Mse<\vu0
B\a8pUx
B\bH9A\bu\rH
B\bHcEgH
B\bbQ
B\bba|\b
B\e>fH\b
B\eCW&qB
B\n:Q+K
B\nba|\b
B\nba~\b
B\r0\fp\v`\n
B\r;Lnm
B\r;oN9
B\rV:9
B\rbA|\b
B\t;n*l
B\t=L\v3
B\tA(L;wHr
B\vba~\b
B]\n>wZU
B_N ŸT
B_Y E38
B_y E38
B_z E38
B`H;K\br
B`L;S\br
B`ěAi\\BB
Bad dynamic_cast
Bad facility code
Bad severity number
Base Class Array
Base Class Descriptor at
Bba~\b
Bd#<miE
Be.V I
Be.o I
Bffff
Bffffff
Bfڻm`3
Bg; T7
Bhba|\b
Bi'LCNאB
BitHistogram
Bj'?I
Bj:\vB5ڻBI
Bjûoc
Bk(#B3
Bm\b> H
Bm^<C\ef
Bn<pZ
BnB=^D
BnE;UN
BnI<Bb
Bpֹ=7G;Z
BqȻ"s
Br!<35
Br=/y
Bu<\a|p
Build
Build cancelled
BuildHierarchy
BuilderFastSpatialPresplitSAH
BuilderFastSpatialSAH
BuilderMBlurSAH
BuilderSAH
BuilderTwoLevel
Bw:<F
Byź`2
BzŰC*!3B0y
B{t:6
B|nZB\r
B}ļ G
B~0GB
B~Z=Q
Bŕ\rB
BȉA(H;oHr
BȻoH뻎A
B̻w\fлJ
BϻLd0
Bґ<mg
BһR1q;\e
Bպ+TO
Bք\tAl1"B
B۸YI>9
B⽦qG;t
C 9t$0
C!p;l
C$ɺ12
C&:5Q\f
C(D;i2
C(Hc\f\aH
C(Hc\f\aI
C):4Z\e
C);PNO
C);nnA;p
C*!3B
C+;87
C09p\btU
C0;^F
C0F;<\n
C0H+C(H
C0HcH\bL
C0HcH\fH
C0Hc\tH
C1<tA
C23;}K
C2j:v
C2u<ӐK
C4=mwV
C5J0t
C8;C4s
C8H+C0I;D
C8H+C0I;E
C8O:;Ŵ6
C9_S8
C9n,.;8j
C:&\fS9
C:,lu)C
C:/buildslave/phonon_main_win64/build/core/deps-build/mysofa/install/windows-x64/share/libmysofa/default.sofa
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_morton.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_sah_mb.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_subdiv.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_twolevel.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_refit.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_statistics.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/common/scene_subdiv_mesh.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/geometry/grid_soa.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/geometry/instance_array_intersector.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/geometry/instance_intersector.cpp
C:/buildworker/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/subdiv/subdivpatch1base_eval.cpp
C:70W:ﯸ7sK
C:GpK
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\mysofa\\src\\mysofa\\src\\hrtf\\easy.c
C:\\buildworker\\phonon_main_win64\\build\\core\\build\\windows-vs2019-x64\\src\\core\\Release\\phonon.pdb
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\algorithms\\parallel_for.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\algorithms\\parallel_sort.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\math\\../simd/simd.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\math\\range.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\math\\vec3fa.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\math\\vec3ia.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vboolf4_sse2.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vboolf8_avx.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vfloat4_sse2.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vfloat8_avx.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint4_sse2.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint8_avx.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint8_avx2.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vuint4_sse2.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vuint8_avx.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vuint8_avx2.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\../math/vec2.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\../math/vec3.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\alloc.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\sysinfo.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\vector.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\tasking\\taskschedulerinternal.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\tasking\\taskschedulerinternal.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../../common/algorithms/parallel_filter.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../../common/algorithms/parallel_for_for.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../../common/algorithms/parallel_partition.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../../common/algorithms/parallel_sort.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../builders/heuristic_binning_array_unaligned.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../builders/heuristic_strand_array.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../builders/splitter.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_binning.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_binning_array_aligned.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_openmerge_array.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_spatial.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_spatial_array.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_timesplit_array.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\primref_mb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../../common/algorithms/parallel_for.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../../common/algorithms/parallel_for_for.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/bvh_builder_hair.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/bvh_builder_msmblur.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/bvh_builder_msmblur_hair.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/bvh_builder_sah.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/primrefgen_presplit.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../common/alloc.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/curveNi.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/curveNi_mb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/curve_intersector_virtual.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/grid_soa.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/instance.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/instance_array.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/linei.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/pointi.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/quadi.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/quadv.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/triangle.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglei.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglev.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglev_mb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh4_factory.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh8_factory.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_morton.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_sah_mb.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_subdiv.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_twolevel.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_twolevel.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector1.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_hybrid.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_node_aabb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_node_aabb_mb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_node_base.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_node_obb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_node_obb_mb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_node_qaabb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_node_ref.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_refit.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_statistics.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_traverser1.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\node_intersector_packet.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/algorithms/parallel_for.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/algorithms/parallel_map.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/math/lbbox.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/sys/array.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../subdiv/bezier_curve.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../subdiv/bspline_curve.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../subdiv/catmullrom_curve.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../subdiv/half_edge.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../subdiv/patch.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../subdiv/patch_eval.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../subdiv/patch_eval_simd.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../subdiv/tessellation_cache.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\accel.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\acceln.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\alloc.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\buffer.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\context.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\device.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\device.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\geometry.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\geometry.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\instance_stack.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_curves.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_instance.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_instance.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_instance_array.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_instance_array.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_line_segments.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_quad_mesh.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_subdiv_mesh.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_subdiv_mesh.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_triangle_mesh.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\state.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\vector.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\../common/scene.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\curve_intersector_oriented.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\curve_intersector_sweep.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\grid_soa.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\grid_soa.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\instance_array_intersector.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\instance_intersector.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\intersector_epilog.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\quadi.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\quadv.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\triangle.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\trianglei.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\trianglev.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\trianglev_mb.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\bezier_patch.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\bilinear_patch.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\bspline_patch.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\catmullclark_coefficients.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\catmullclark_patch.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\catmullclark_ring.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\feature_adaptive_eval.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\feature_adaptive_eval_grid.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\feature_adaptive_eval_simd.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\gregory_patch.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\gridrange.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\patch_eval_grid.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\subdivpatch1base.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\subdivpatch1base_eval.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\tessellation.h
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\tessellation_cache.cpp
C:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\subdiv\\tessellation_cache.h
C:oMt
C;%La
C;=Db
C;L\v0
C;Mub
C;S\t
C;XDb;S
C;e৺HB
C;i,N;4
C;i{j
C;t嬺0
C<2sR
C<;C4A
C<CPX7
C<G;g
C<I9Fxs
C<I9Gxs
C<Tzv
C=8,z
C=B \b
C=M5)=7
C=\v8
C=p\eཛྷ6
C=z"d9
C>5x=h4
C>7hk
C>9^a6
C>\b84>eJ
C>t}C
C@H98t$H
C@H9\bt
C@I=5P
C@f91H
C@f99H
CB';t
CC>/b
CD:\nE2
CG<UlX
CGj:zK
CH;\n
CHEGST
CHH+C@H
CHI;w\br
CHٹ`N7
CI9y\bi;)o\a
CJ>sm
CKW;b
CKc=YC
CL interop not supported
CLDEMOTE
CM:TkJ
CMF}A
CMJɰt
CMPCCXADD
CN@=!kC
CNNFTNFNNFTNF
CNR:%s
CO ;qd
CO9`2
COMPATIBLE
CONOUT
CPHc\bI
CPU does not support SSE2
CPU does not support selected ISA
CPU frequency: %8.3f GHz
CQȺ0\\Ǻty
CRT$XCA
CRT$XCC
CRT$XCL
CRT$XCU
CRT$XCZ
CRT$XDA
CRT$XDZ
CRT$XIA
CRT$XIC
CRT$XIZ
CRT$XLA
CRT$XLC
CRT$XLZ
CRT$XPA
CRT$XPX
CRT$XPXA
CRT$XPZ
CRT$XTA
CRT$XTZ
CS;"i
CW&qB쾩C
CWD>~3
CXH+CPI;G0
CXH+OPH+CPH
CXHc\bI
CXL+CPH
CYA>HM
CZ滘dٻO
C\\,50J
C\a>8B\a
C\a>8B\r
C\b;e4ƹZ
C\bH;0r
C\bH;8r
C\fA]A
C\fHcOLH
C\fbA
C\nżi3
C\r\r;M
C\v$9!J
C\v;f7
C`H+CX
C`H;CXt
C`H;CXt#A
C`N3A
C`N3Gs
Ca;=\nJ
CalcMortonCode
Calculate any intersection \n            hitresults[ridx] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process \n__global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process                     \n__global int* hitresults  // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,      // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \n__global int const* numrays,     // Number of rays in the workload \n__global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest(&scenedata, &r, &isect); \n            // Write data back in case of a hit \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \n__global int const* numrays,     // N
Calling r8write without FORTRAN_IO, iparam(9)=0
Cannot create file %s
Cannot create file MKL_Poisson_Library_Log.txt
Cannot proceed as the system failed to provide
Cannot proceed with calculations as
Cannot proceed with calculations as input
Cannot proceed with calculations as input matrix has
Cannot proceed with calculations as input maximum
Cannot proceed with calculations as input size
Cannot proceed with calculations as matrix has either
Cannot proceed with calculations as small diagonal
Cannot proceed with calculations as the system failed
Cannot proceed with computations
Cannot read the contents of a file
Cannot run %s - not enough memory
Caｎ ~=7
CcR;9
Cf;4AC
CfC=&p
Cffff
Cffffff
CfνP\\T
Cg8\t
ChL+C`H
Ch\n=*S
CiK=>N
Ci^;XW
Cj:\vBs\t
Ck(#B
Ck(#Bsx
Class Hierarchy Descriptor
Class name
CloseHandle
CloseThreadpoolTimer
CloseThreadpoolWait
CloseThreadpoolWork
ClŻBq
Co:}j
CoTaskMemFree
Column-replicated array -- copy in process column: %d
Columnwise
CompanyName
CompareStringEx
CompareStringW
Compiler
Complete Object Locator
Computational layer library for Cluster FFT not loaded
Computations have stopped. The result may be incorrect
Conditional numerical reproducibility mode is turned OFF
Conditional numerical reproducibility mode is turned ON
Config
Conjugate
Conventions
CoordinateSpace* listeners,\n                           global const Directivity* directivities,\n                           uint numRays,\n                           uint numBounces,\n                           float irradianceMinDistance,\n                           global const Ray* rays,\n                           global const Hit* hits,\n                           global const float3* normals,\n                           global const int* materialIndices,\n                           global const Material* materials,\n                           uint numDiffuseSamples,\n                           global const float4* diffuseSamples,\n                           uint randomNumber,\n                           float scalar,\n                           global Ray* shadowRays,\n                           global Ray* reflectedRays,\n                           global float4* energyDelay,\n                           global float4* accumEnergyDelay)\n{\n    size_t numChunks = max(numListeners, numSources);\n    size_t numPrimaryRays = get_global_size(0) / numChunks;\n    size_t numShadowRays = get_global_size(0);\n\n    uint rayIndex = (numListeners > 1) ? get_global_id(0) : (get_global_id(0) % numPrimaryRays);\n    uint chunkIndex = get_global_id(0) / numPrimaryRays;\n    uint listenerIndex = (numListeners > 1) ? chunkIndex : 0;\n    uint sourceIndex = (numSources > 1) ? chunkIndex : 0;\n    uint shadowRayIndex = get_global_id(0);\n\n    // If this ray is disabled, don't do anything.\n    if (rays[rayIndex].extra.y == 0 || hits[rayIndex].primid < 0)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        reflectedRays[rayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n        return;\n    }\n\n    // Random number generation for work group.\n    local RNG rng;\n    local float randomFloat;\n    local uint randomUint;\n    if (get_local_id(0) == 0)\n    {\n        initRNG(randomNumber + rayIndex, &rng);\n        randomFloat = randFloat(&rng);\n        randomUint = randUint(&rng);\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    // Calculate hit point.\n    float3 rayDirection = rays[rayIndex].d.xyz;\n    int triangleIndex = hits[rayIndex].primid;\n    float hitDistance = hits[rayIndex].uvwt.s3;\n    float3 hitPoint = rays[rayIndex].o.xyz + hitDistance * rayDirection;\n\n    // Calculate hit normal.\n    float3 hitNormal = normals[triangleIndex].xyz;\n    if (dot(hitNormal, rayDirection) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    // Calculate hit material.\n    Material hitMaterial = materials[materialIndices[triangleIndex]];\n    float3 hitMaterialAbsorption = (float3) (hitMaterial.absorptionLow, hitMaterial.absorptionMid, hitMaterial.absorptionHigh);\n\n    // Calculate shadow ray direction.\n    float3 source = sources[sourceIndex].origin;\n    float hitToSourceDistance = distance(hitPoint, source);\n    float4 hitToSource = (float4) (normalize(source - hitPoint), 0.0f);\n\n    // Skip the ray if:\n    //  a) the hit point is inside the listener, or\n    //  b) the hit point is too close to the source, or\n    //  c) the ray hit a backfacing triangle.\n    if (hitDistance <= LISTENER_RADIUS ||\n        hitToSourceDistance <= irradianceMinDistance ||\n        dot(hitToSource.xyz, hitNormal) < 0.0f)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n    }\n    else\n    {\n        // Generate the shadow ray.\n        shadowRays[shadowRayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * hitToSource.xyz, hitToSourceDistance);\n        shadowRays[shadowRayIndex].d = hitToSource;\n        shadowRays[shadowRayIndex].extra = (int2) (0xffffffff, 1);\n\n        // Calculate shading values.\n        float3 energy = (1.0f / PI) * hitMaterial.scattering * max(0.0f, dot(hitNormal, hitToSource.xyz));\n        energy += ((SPECULAR_EXPONENT + 2.0f) / (8.0f * PI)) * (1.0f - hitMaterial.scattering) * pow(fabs(dot(normalize(hitToSource.xyz - rayDirection), hitNormal)), SPECULAR_EXPONENT);\n        energy *= scalar;\n        energy
CorExitProcess
Core Broadwell
Core Cannon Lake
Core Comet Lake
Core Haswell
Core Ice Lake
Core Ivy Bridge
Core Kaby Lake
Core Sky Lake
Core Tiger Lake
Could not open file %s
Could not open file %s, aborted
CoҺcP
CpH9Cxs
CqY:Y
Cr;Npl
Cr;WVz
CreateEventA
CreateEventExW
CreateEventW
CreateFileW
CreateSemaphoreExW
CreateSemaphoreW
CreateSymbolicLinkW
CreateThread
CreateThread failed
CreateThreadpoolTimer
CreateThreadpoolWait
CreateThreadpoolWork
Ct-<D
Ct;ti
CtK<Dv
Current date/time: %s
Cw:\b
Cw;CD:\t
CxH+CpH
CxH+CpI;D
Cy2@K
Cy9LH$9\r
Cylinder test
Cylinder { p0
Cz,;\nfS
Cz\e<L
C|nZB
C}żDiмo
Cú9eo
CŻ9AE
Cȼ=8Q;g
CʺfhƺeY5
C˽YL\e=F
C̉L$<E3
Cӷ;fYt
Cք\tA
Cڳ; \fm<Q
Cߺ\vo0
C㏻|h编ZR
D  fB
D AMD
D AMD_MEDIA_OPS
D W?{W
D WIN32
D!l$xA
D"<k7
D"D&n,n2
D#\rBsK
D$ 3\tD$,H
D$ 9A
D$ ;D
D$ BǄ\a
D$ D3
D$ E3
D$ H;A\b
D$ H;D
D$ H;D$X
D$ H;D$\bH
D$ H;D$p
D$ H;Gxr'A
D$ H;L
D$ H;L$P
D$ H;Q
D$ H;T$H
D$ H;V
D$ H;\r
D$ H;\r1
D$ HcL$8H
D$ I;U
D$ I;X\b
D$ J;D3
D$ L;cxr
D$ L;kxr
D$ L;l
D$ L;t
D$ M;d
D$ M;l
D$ `fD
D$ b!|M
D$ ba
D$ ba|\b
D$ fA
D$ fE
D$ fff
D$ s\a
D$ s\vH
D$ veH
D$ ġzYL
D$ ŀYm
D$ ňXD$P
D$ ňXE
D$ ŘY
D$ ŰY
D$ ŸY
D$$bb}H
D$$uJH
D$(H!L$ E3
D$(H9D$H
D$(HcL$4H
D$(fff
D$0@8
D$0A;\b
D$0D;L$(u
D$0E3
D$0E3\tD
D$0H9D$8
D$0H;D
D$0H;D$8
D$0H;{xr
D$0H\vD$(I\v
D$0HcH
D$0HcL
D$0HcL$,H
D$0I;X\b
D$0L+D$ L
D$0L9H s\n
D$0Lc
D$0M;d
D$0M;d\a
D$0M;l
D$0M;l\a
D$0fA
D$0fD
D$0fE
D$0ff
D$0fffff
D$0soH
D$0suH
D$0u>H
D$0u\f3
D$0ŀYm
D$0ŰY
D$18F(u\bH
D$2E3
D$4Lc
D$4u2H
D$4u4H
D$4u<H
D$4uBH
D$8D8T$1u\f
D$8E3\tD$0D
D$8H;D$0
D$8H;S
D$8HcJ
D$8HcL
D$8L98
D$<0b
D$<HcT$<H
D$@H;D$ H
D$@HcH
D$@HcL
D$@HcL$<H
D$@HcL$LH
D$@HcL$PH
D$@HcT$<H
D$@HcT$P1
D$@L;D$Hu
D$@Lc
D$@fA
D$@fD
D$@fE
D$@ŨYE ŐY
D$DDtRH
D$HD9@$t
D$HD;l$4s\vH
D$HH+D$@H
D$HH;D$8
D$HL9gXt
D$Hr~I
D$HtgH
D$Hx0I
D$H~JN
D$L;D$x
D$PH;D
D$PH;D$ H
D$PH;E8
D$PH;EH
D$PH;r\b
D$PH;t\a
D$PJ;D3
D$PL;D$Xu
D$PL;\r
D$PL;d\a
D$PM;d\a
D$PM;l
D$PM;l\a
D$PfA
D$PfD
D$PfE
D$Ps!f
D$Pu A
D$PŀYE
D$PŀYmp
D$XH;A
D$XH;D$H
D$XHcE
D$XI+D$PI;E0
D$XI+D$PI;E8v*H
D$XI+D$PI;E8v,H
D$XJ;D3
D$Xs!f
D$Xt$f
D$\bH;A
D$\bH;D
D$\bHcL
D$\bIcL
D$\bbA|\b
D$\f0bc%\b!l$l
D$\fH;A
D$\fba|\b
D$\nba~\b
D$`D9;u
D$`H+D$hH
D$`H9~\bt
D$`HcH
D$`Hcq\bE3
D$`I9v\bt
D$`J;D3
D$`Lc
D$`fA
D$`fD
D$`fE
D$`tGM
D$`tKM
D$`t\fH
D$`ŸW51
D$`ŸW5Y
D$`ŸW5n
D$d:v
D$h9t$P
D$hB9L(\ft A
D$hB9L(\ft!A
D$hH9D$@L
D$hH;A
D$hH;C
D$hH;D$pwBH
D$hHcC8H
D$hJ;D3
D$hL;t$0M
D$hLc\t
D$hfffff
D$hs!f
D$hsC
D$ht4A
D$n<od
D$pA;w
D$pD8~ t\fH
D$pD;g
D$pH;L\a
D$pH;V
D$pH;t\a
D$pHc
D$pHcH
D$pHc\bL
D$pI9
D$pL;t
D$pL;t\a
D$pM;l
D$pba|\b
D$pfA
D$pfD
D$pfE
D$pt\nH
D$ptyf
D$pu"H
D$pu\bH
D$pŐXE0
D$pŠY
D$t+D
D$t\vD$p
D$w<NL
D$xH;D$pL
D$xHcA
D$xHd
D$xI;V
D$xI;i\b
D$xba
D$xba~\b
D$xteH
D%;m5\r
D%<V7
D%k;w
D&pA;l$l
D';kzT
D(:s8
D(T=FD\n
D)Hv)A
D*0fB
D*Hv\t
D*\r<3y
D+T$Hfff
D+t$8A
D+{HD
D.\ab!D
D.ǻJH
D1؉D$t
D2Hv\fF
D2ٺV\a\v
D2庈-p
D3 b1
D39\aW-;R
D3\fI
D3f\bD3n\fH
D3мuxc
D4S<U
D6\v:߬B
D6r:w`w
D8+t\nD8k
D81uUL9r
D84\bu\t
D8APttH
D8G\buBH
D8G\buIH
D8G\buOH
D8L$0uP
D8W\buOH
D8Z\bt
D8\\$8uOH
D8]\v
D8g\buAH
D8i2uvH
D8l$<tNI
D8l$@tOI
D8o\bu@H
D8o\buFH
D8o\buHH
D8o\buNH
D8t$Hu\n
D8t$ht\nH
D8|$Ht\fH
D8}?t\tH
D9!t\tH
D9"t4H
D9"u\eH
D9*t1H
D9*t4H
D91AO<zDy;ɛ\r
D92<a
D92~&A
D92~0A
D92~0H
D9:t4H
D9I ~wHc
D9J0~<A
D9K0~NA
D9K\b~+A
D9N$~1H
D9N(~4I
D9S\f~J
D9\vucL
D9c4t\bH
D9c\f~C
D9g0~xI
D9s\bu\t9k\f
D9} ~t
D:#)g:rEy9
D:E7\n
D:H\b
D:M+B
D:Q<r\t
D:UT\e
D:\b| D8R
D:\b|$D8R
D:\f0u6H
D:\f0u:H
D:vXh:Y6
D;#rg
D;(u\vf9t$bu
D;-Bb
D;A$s9
D;A$s9A
D;H$t\n
D;M<J
D;RN8=0r
D;S\b}8A
D;bY\e
D;iHJ
D;t$4s
D;yLj:Sj
D;}CQ
D<\bW59\n
D=7@U
D=;\axb
D=maQ
D>#U7
D?\f<fVO:5
D?\v9:U
D@Q=s
DA9wX3
DAL_BLAS_COMPUTE_MODE
DAb<eE
DBY^uB
DB]8Ta
DC:th
DC;ӫ7
DCh9js
DDhu"E
DFGMRES routine
DFGMRES routine. Otherwise, the maximal number of iterations is equal to
DFԽNk
DG9:N2
DGл\r}ܻsD
DH>=h
DI;?mQ8
DIMENSION_LIST
DJQ;Bƅ:وn
DJ\b=<a
DK8ɠ\t
DK;n5
DKO;g
DKf:5
DLڻL\f\n
DN];h
DOm;c
DPAR(2)=%e should not be equal to 0.0 simultaneously. The FGMRES
DQa<Ua
DQ»߃ͻKF
DR;97
DRB<b
DS<tl1
DSYGST
DSp;d
DVe@A\v
DWM`ŴY
DWU`ŬY
DW\r/Dm
DWغ*o
DX4"H
DX<"H
DXƻ&1y
D\a\aba|H
D\b;o1o;f
D\eƻp
D\f;rb
D\f<Sa
D\fHI+D\f@H
D\n$ fG
D\n40E
D\n=OQK
D\n\abq|H
D\n\bbA|H
D\n\e;U
D\n\nba|H
D\nt$PL9
D\t<4W6
D\thġx
D\v\nba|H
D\vf:%b
D^F<n
D^ӻmq
D_FORWARD_TRIG_TRANSFORM/D_BACKWARD_TRIG_TRANSFORM routine
D_ԼW6q
Da<ll{;d
Data.Delay
Data.IR
Data.SamplingRate
DataType
Dba~\b
December
DecodePointer
DeleteCriticalSection
Dfb:'Q
Dffff
Dfffff
Dgi;d
DigiCert Trusted Root G40
DigiCert, Inc.1;09
DigiCert, Inc.1A0
Distributed Matrix Input Format is used for CPARDISO (iparm(40) = %d
Division by 0 occurred
Division by zero occurred. Computations have stopped. The result may be incorrect
Division by zero occurred. The D_COMMIT_TRIG_TRANSFORM routine was not called
Division by zero occurred. The S_COMMIT_TRIG_TRANSFORM routine was not called
Division by zero occurred. The d_commit_trig_transform routine was not called
Division by zero occurred. The s_commit_trig_transform routine was not called
Division by zero occurred: At iteration number %s, the rotated Hessenberg
Division by zero occurred: parameter DPAR(5)=%e should
Division by zero occurred: parameter DPAR(7)=%e should not be equal to 0.0
Division by zero occurred: the new rotation for Hessenberg matrix is degenerate
Dk;hYn
Dm4<x5
DoG;R
DoL9I
DpɹjYj
Dqt=c
Duf<"`4
Dva<R
Dvc:e4
Dvz;N
Dw<\r\a
DyH<B
Dyn:%d
D|;qyf
D|>9f
D~ "H<O
D~9q\n
D¼9\vr
Dƨ:pR1<2
Dƻ0\ae
DɺlNv
D˻mĥ8
DЋ;M4
Dйl\e;b
DҼl9ؼD
Dܼ1x̼2
D眻F뗻4w
E H;_xr
E H;t\a
E HcT$0H
E L;d\a
E L;oxr
E L;sxr
E L;|\a
E Lc0A
E M;d\a
E M;l\a
E ńXE
E ŜY='S
E ŸT\r7
E żWU
E ż_U
E"(<ZOw
E$G=@Mt=w6
E%9/q3
E%s%s\n
E'@6?2s
E(E+E0D
E(G<R
E(M;d\a
E(M;l\a
E);I\ni
E)B:In
E*:Vh
E*ѼL7
E+}0E
E+܉t$ D
E.ѻ2j
E0H;Ep
E0H;t\a
E0H;z\b
E0HcH\fD
E0L;T$p
E0L;d\a
E0L;l\a
E0L;wxr
E0Lc`\fI
E0M;p\b
E0fff
E0u\vfE
E1ɀ|$pNI
E1ۀ|$xNI
E2S9>E
E2[<oO
E2\f<@b
E2j:?z
E3\nS\tI
E3\nW\tI
E3\rQ\vH
E3\vD$8A
E3\vT$<L
E3ɅɊ\vA
E3ɉl$P
E3ɉl$PL
E3ɉ|$ D
E3҉U(N
E4;"y
E4?;H
E6;Mm
E6x<E\b\a
E80t"A
E8E\buHI
E8E\buLI
E8E\buQI
E8E\buWI
E8H)MHH)MPH
E8H;Ep
E8M;l\a
E8]\buXI
E8a(u\fH
E8a>9
E8q(u\bH
E8q(u\rH
E9 tPH
E9 u\eH
E9(tMH
E9(tPH
E9.u\aA
E91~)3
E91~3H
E92:W
E98tPH
E9<$A
E9N:5\a
E9Q0~GE
E9e\b~p3
E9e\f~i3
E9l$\f~k3
E9|$\f~k3
E9}\b~h3
E9}\b~k3
E9}\f~k3
E9}\f~k3ېE3
E:+cW
E:2dB
E:6QP
E:<2P
E:<9o
E:Zfl
E:\t=680
E:r?ԻXT
E:yu;29Y
E;*dݺx\ny
E;3>F
E;?tv
E;Fh}AO
E;J+x
E;O䴹R
E;P\n
E;S\rһB
E;Wtg
E;X (;+Zy
E;`2Q
E;kW2
E<<uw
E<MF3
E<P\et
E<nZ\r
E<sS;y
E<tdp
E<uZ*<z
E<xQv
E=E*a
E=WIf
E>p;v
E@H9~\b
E@H9~\bt
E@H;L\a
E@H;sxr
E@H;t\a
E@I9v\bt
E@J;D
E@J;D3
E@L;T$p
E@L;d\a
E@L;l\a
E@L;t\a
E@L;wxr
E@L;{xr
E@M;l\a
E@ňYD
E@żWU
EA5;Ɗs
EACǱb#eAC
EBN9[Bo
EBs<YV6
EDw>P
EGԼ)G
EHJ;D
EI;zL
EID$8H
EJ;8N\t;vj<;nN
EJ;D]\f:M
EJ;^i\t
EJӻegk
EKa;q
EL#Ul\v
EL;\r
ELH9dR{9N
EMcɃ~\b
EMcɃ~\f
ENQCMD
EOʼ.s
EP<+t
EP<0u
EP<0u\a
EP<0u\t
EPH;L\a
EPH;t\a
EPJ;D
EPL;d\a
EPL;l\a
EPL;t\a
EPŰYE0
ERROR
ERV:8DN
ES:2k
ET;#Pz;ѸU
ET;OB7
EU*?N
EU;&C
EU=\ve
EUG;0c
EVٻ4rY
EWb"e
EX"<f&9
EX%%Q
EX3ҋM`D
EX6;RV
EXI+EPI
EXI+EPI;D$0
EXI+EPI;D$8v6M
EXI+EPI;G0w
EXI+EPI;G0w\eI
EXJ;D
EXJ;D3
EXv5A
E[;V3
E[S;i
E[\rn?gc
E[b"m
E\abQ|H
E\auNH
E\b:_h6
E\bH;A\b
E\bH;E
E\bH;EX
E\bHcu`M
E\bJ;D3
E\bM;d\a
E\bM;l\a
E\bbA|J
E\bbQ5H
E\bba}Hp
E\bfA9]\n
E\btGE3
E\bŊYM
E\bŢYM
E\bŪYM
E\bŪYM8
E\e<GQպh
E\ebQT
E\fbA|H
E\fŢYM
E\n::cXG
E\r<j e:Q&F
E\v\bdD\v
E\vbA|H
E\vbQ|H
E_<two
E`H;_xr
E`H;t\a
E`H;{xr
E`J;D
E`J;D3
E`L;d\a
E`L;l\a
E`L;sxr
E`bbu
E`ŰYE0
E`żWM
Eb>>Hu
Ec:ud9
Ecb>aS
Ed<+8G
Efffff
Effffff
Eg1<rK
Eg\n;a
EhH;E
EhI+E`H
EhJ;D
Ehv5A
Ei:݈0;x
Either parameter TT_TYPE in the D_INIT_TRIG_TRANSFORM routine
Either parameter TT_TYPE in the S_INIT_TRIG_TRANSFORM routine
Either parameter tt_type in the d_init_trig_transform routine
Either parameter tt_type in the s_init_trig_transform routine
Either the D_INIT_TRIG_TRANSFORM routine was not called
Either the S_INIT_TRIG_TRANSFORM routine was not called
Either the d_init_trig_transform routine was not called
Either the parameters were altered by mistake outside of the DFGMRES
Either the s_init_trig_transform routine was not called
EkZ;Q
Em1>ap
Em\t:f
Embree
Embree Ray Tracing Kernels
Embree device is no SYCL device. Device pointer argument must not be valid, pass NULL instead
EmitterPosition
En[vP
En\b>w
EncodePointer
End of tests
EnterCriticalSection
EnumSystemLocalesEx
EnumSystemLocalesW
Eo;Ki
Eo<\e:3
EpI9Exs
EpL;t\a
Ep\a>9
Epsilon
EpŨYN
EpŰX] ŸXd$p
Error (VML_STATUS_BADMEM) in %s: NULL pointer is passed
Error (VML_STATUS_BADSIZE) in %s: array size %d is not positive
Error (VML_STATUS_ERRDOM) in %s: argument is out of domain
Error (VML_STATUS_OVERFLOW) in %s: argument caused overflow
Error (VML_STATUS_SING) in %s: argument caused singularity
Error (VML_STATUS_UNDERFLOW) in %s: argument caused underflow
Error code=%s and/or %s
Error code=%s and/or %s. Computations have stopped
Error code=%s. Computations have stopped
Error in PARDISO  (        reordering_phase) error_num= %d
Error in PARDISO  (        reordering_phase) error_num= %lli
Error in PARDISO  (        reordering_phase) internal error_num= %d
Error in PARDISO  (      open OOC tmp files) error_num= %d
Error in PARDISO  (      open OOC tmp files) error_num= %lli
Error in PARDISO  (      open OOC tmp files) internal error_num= %d
Error in PARDISO  (     insufficient_memory) error_num= %d
Error in PARDISO  (     insufficient_memory) error_num= %lli
Error in PARDISO  (     insufficient_memory) internal error_num= %d
Error in PARDISO  ( internal_error,unclass.) error_num= %d
Error in PARDISO  ( internal_error,unclass.) error_num= %lli
Error in PARDISO  ( internal_error,unclass.) internal error_num= %d
Error in PARDISO  ( not enough mem. for OOC) error_num= %d
Error in PARDISO  ( not enough mem. for OOC) error_num= %lli
Error in PARDISO  ( not enough mem. for OOC) internal error_num= %d
Error in PARDISO  ( numerical_factorization) error_num= %d
Error in PARDISO  ( numerical_factorization) error_num= %lli
Error in PARDISO  ( numerical_factorization) internal error_num= %d
Error in PARDISO  ( sequence_ido,parameters) error_num= %d
Error in PARDISO  ( sequence_ido,parameters) error_num= %lli
Error in PARDISO  ( sequence_ido,parameters) internal error_num= %d
Error in PARDISO  (32-bit overflow problem.) error_num= %d
Error in PARDISO  (32-bit overflow problem.) error_num= %lli
Error in PARDISO  (32-bit overflow problem.) internal error_num= %d
Error in PARDISO  (incorrect input matrix  ) error_num= %d
Error in PARDISO  (incorrect input matrix  ) error_num= %lli
Error in PARDISO  (incorrect input matrix  ) internal error_num= %d
Error in PARDISO  (prereordering_mtype11,13) error_num= %d
Error in PARDISO  (prereordering_mtype11,13) error_num= %lli
Error in PARDISO  (prereordering_mtype11,13) internal error_num= %d
Error in PARDISO  (read/write OOC data file) error_num= %d
Error in PARDISO  (read/write OOC data file) error_num= %lli
Error in PARDISO  (read/write OOC data file) internal error_num= %d
Error in PARDISO memory allocation: AFTER_REORDERING, allocation of %d bytes failed
Error in PARDISO memory allocation: AFTER_REORDERING, allocation of %lli bytes failed
Error in PARDISO memory allocation: ALLOCATE_GLOBAL_STRUCTURE, allocation of %d bytes failed
Error in PARDISO memory allocation: ALLOCATE_GLOBAL_STRUCTURE, allocation of %lli bytes failed
Error in PARDISO memory allocation: BASIC   , size to allocate: %d bytes
Error in PARDISO memory allocation: BEFORE_INIT_PARALLEL_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: BEFORE_INIT_PARALLEL_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: BEFORE_REORDERING, allocation of %d bytes failed
Error in PARDISO memory allocation: BEFORE_REORDERING, allocation of %lli bytes failed
Error in PARDISO memory allocation: BEFORE_SYMBOLIC_FACTORIZATION, allocation of %d bytes failed
Error in PARDISO memory allocation: BEFORE_SYMBOLIC_FACTORIZATION, allocation of %lli bytes failed
Error in PARDISO memory allocation: CGS_ARR , size to allocate: %d bytes
Error in PARDISO memory allocation: FACTORIZE_SOLVING_LU_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: FACTORIZE_SOLVING_LU_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: FACTORIZE_SOLVING_WORK_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: FACTORIZE_SOLVING_WORK_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: FACT_ADR, size to allocate: %d bytes
Error in PARDISO memory allocation: FACT_L&U, size to allocate: %d bytes
Error in PARDISO memory allocation: LOC_INT1, size to allocate: %d bytes
Error in PARDISO memory allocation: LOC_INT2, size to allocate: %d bytes
Error in PARDISO memory allocation: MATCHING_REORDERING_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: MATCHING_REORDERING_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: OOC_TREE_STRUCTURE, allocation of %d bytes failed
Error in PARDISO memory allocation: OOC_TREE_STRUCTURE, allocation of %lli bytes failed
Error in PARDISO memory allocation: REALLOC_OOC_ARRAYS, allocation of %d bytes failed
Error in PARDISO memory allocation: REALLOC_OOC_ARRAYS, allocation of %lli bytes failed
Error in PARDISO memory allocation: SOLVING_ITERREF_WORK_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: SOLVING_ITERREF_WORK_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: STRUC_FI, size to allocate: %d bytes
Error in PARDISO memory allocation: STRUC_S0, size to allocate: %d bytes
Error in PARDISO memory allocation: STRUC_S1, size to allocate: %d bytes
Error in PARDISO memory allocation: STRUC_S2, size to allocate: %d bytes
Error in PARDISO memory allocation: UP_UPLEN, size to allocate: %d bytes
Error in PARDISO memory allocation: WORK_I0 , size to allocate: %d bytes
Error in PARDISO memory allocation: WORK_R0 , size to allocate: %d bytes
Error in PARDISO: cgs error iparam(20) %d
Error in PARDISO: cgs error iparam(20) %lli
Error in PARDISO: cgs error iparam[19] %d
Error in PARDISO: cgs error iparam[19] %lli
Error in PARDISO: clean impossible (ido
Error in PARDISO: ido<-1
Error in PARDISO: ido<1 and initialization
Error in PARDISO: internal error, insufficient memory factorization
Error in PARDISO: minimal memory required by OOC mode (%dMB) is less than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%dMB
Error in PARDISO: minimal memory required by OOC mode (%lliMB) is greater than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%dMB
Error in PARDISO: minimal memory required by OOC mode (%lliMB) is greater than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%lliMB
Error in PARDISO: only symbolic factorization diagonal matrix case %d
Error in PARDISO: only symbolic factorization diagonal matrix case %lli
Error in PARDISO: preordering failed after %d neqns out of %d
Error in PARDISO: preordering failed after %lli neqns out of %lli
Error in PARDISO: unclassified error
Error in PARDISO: wrong matrix number, clean %d
Error in PARDISO: wrong matrix number, clean %lli
Error in PARDISO: zero or negative pivot, A is not SPD-matrix
Error in PARDISO: zero pivot
Error is not in the area of OOC I/O. Check it manually, error=%d, %s
Error is not in the area of OOC I/O. Check it manually, error=%lli, %s
Error message has been written in %s
Error: Intel oneMKL TT backward transform failed with status=%d in FFTW3 interface to Intel oneMKL
Error: Intel oneMKL TT commit step failed with status=%d in FFTW3 interface to Intel oneMKL
Error: Intel oneMKL TT forward transform failed with status=%d in FFTW3 interface to Intel oneMKL
Error: Intel oneMKL TT initialization failed with status=%d in FFTW3 interface to Intel oneMKL
Error: info returned=%i
Et9Z\v
Et;Z( ;x
Et<]0M
Eu+=V
Eu:Ovûv7Y
EvD<l
Ev\a;6;J
Ew8<AF
Ewx:kۜ7
ExI+EpH
ExitProcess
ExitThread
Export functionality error: CODE PATH = %d not supported
Export functionality error: DATA_NAME = %d not supported
Export functionality error: INVALID DATA_NAME = %d
Export functionality error: INVALID OPERATION = %d
Export functionality error: INVALID handle
Export functionality error: NULL handle
Export functionality error: OPERATION = %d not supported
Export functionality error: distrubution overlap is not supported
Export functionality error: integer overflow, consider using ILP64 interface
Export functionality error: not all required pointers has been provided before calling main export routine
Export functionality error: some of the input pointers are NULL
Export functionality error: unidentified error
Expression
Ez=uB$>0
EzR;Oo
E{:cAq
E|#9A
E|H9q
E|\f;Zr
E»QZ9P
EûmME
EǋD$8
Eǣ=B\v7
EΎ<z6Z
EщT$xD
EӍZ\bD
Eٹ\tn0
F A+N0A
F D9d0\f
F D9d8\f
F D9d8\fu
F D9d\a\f
F D9d\a\fu
F D9l0\fu>H
F D9t\a\fuBH
F D9t\a\fuFH
F HcT$0H
F LcL$4I
F#<2z|8r0
F$H9E t
F%:Xy0
F&p;bH
F'<nBJ
F(,:Ts3
F(9=lt
F(A+F0A
F(D:9
F(I<U
F):o4\e
F)n;rW
F-N;ro
F19:\n
F2BlJ2HnL
F6:LUP:~so8Ì8;\n
F6û\b2
F8}-L
F9!\aֹP
F9N֑:M
F9Z39
F9`;p
F9o<BwV
F: PӺ\nX
F:4Gǻ\f
F:CVH
F:OKzԣW
F:^Gk
F:j\v
F;8;sG
F;D6S
F;Iy(;De
F;Og{9ޞH
F;Psb;j
F;Q\fL
F;YR3
F;gS¼ʤu
F;nL0;-g
F;tZǺt
F;wr\\6
F;~SS
F<B1v
F<ptO
F<x$Y=zI
F=%=034
F=0;1
F=;AkV
F>qUxv
F?b;yU
FATAL ERROR
FB;:L
FBݻ,DE
FC>yR\t
FDI+F<H
FDƼ\e
FE?>G
FFCCRR
FF\n@asinf
FGMRES method has lost the orthogonality property, or the FGMRES method was
FGMRES method without restarts, set IPAR(15)=IPAR(5)-IPAR(4) which is equal to %s
FH8;xI
FHD:]T
FHI+F@I;E
FI;d]N8Qo
FIg=k4
FJ ;>'k
FL;D$8
FL_;eS
FMc\bIk
FOϹLC*;rF
FPH+FHH
FPLcN\bI
FT;IXY
FVN;\f
FWӻǎg
FX=rV?=0
FXH+FPH+KPH
FXH+FPI
FXI+FPI
FXSAVE
FZ$:Ue9
FZ<Th9
FZ_9\a
F[6:f
F\\V9^J
F\a;R\b¹v
F\a<EG
F\a=LH\e
F\b t$A
F\b8H0t
F\b9D$(}s
F\b@t$A
F\bH90u
F\b\bt"A
F\b\bt$A
F\em;Y
F\n t%A
F\n:5V
F\n;F
F\n@t%A
F\n\bt#A
F\n\bt%A
F\t;RwN
F\tl<a
F\v;Dq
F\v;q
F\v=u
Fa;Q}p
Factorization step
Factorization step (100
Factorization: Time for reading from files: %f
Factorization: Time for writing to files  : %f
Factors L and U
FastMM:%d
Fatal error (error message=%s
Fatal error: Division by zero occurred. Computations have stopped
Fatal error: Failed to normalize the right-hand side
Fatal error: Internal memory error. Computations have stopped
Fatal error: Memory cannot be allocated/deallocated
Fatal error: Memory cannot be allocated/deallocated. Computations have stopped
Fatal error: Trigonometric Transform commit step failed to complete
Fatal error: Trigonometric Transform forward/backward step failed to complete
Fatal error: Trigonometric Transform has failed to release the memory
Fatal error: Trigonometric Transform initialization failed to complete
Fbb}H
Fc*99
FdU</3\b
Features
February
Feẜo蹠k
Ff;ivv
Fffffff
Ffջ(zQ;mv
Fg9\bZ
Fh 9e
Fh:O"c<-W
Fh<9̓=w
FhL+F`H
FhM+F`H
FhY<\nKX
FileDescription
FileVersion
FindClose
FindFirstFileExW
FindNextFileW
Fj!;o5F
Fj9lmc
FjB:C2
Fk.9db
FlsAlloc
FlsFree
FlsGetValue
FlsSetValue
FlushFileBuffers
FlushProcessWriteBuffers
Flº\t
FoO;pb
Foj;w
For information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts
FormatMessageA
Forward
FpI9Fxs
Fpbal
Fq;_S
FreeEnvironmentStringsW
FreeLibrary
FreeLibraryAndExitThread
FreeLibraryWhenCallbackReturns
Friday
Fseek failed
Fu:.T
Fv;T\f
F{$gT
F|w;b\a
F};AS5
FȈD$HH
FͼV\t
FкZ"G
FջN(J=S
FֻK^N
Fܺ#3R<co
Fݻ3kU;L
Fޘ;Ftf;rJ
G A+G0A
G ŐXmp
G"e;D
G(A+O0A
G(D+G0D+ËG
G(H+G H
G-;wX
G0HcH\bL
G1m:4I
G20=l
G4l;9k
G4u\f@2
G6<3yp
G6<ʺL
G7:B6
G7;TO
G8);M
G8;XW
G8z:qW
G9Z!¹p
G9zn7<T
G:$eC
G:UL0
G:j-۸kQ
G:ncG
G:~lD
G:~mQ:U
G:՚ϺZJ6;q
G;0=x
G;M1s
G;Shd
G;brD
G;j,S
G<)mk
G<1\a
G<H9Fxs
G<I9Fxs
G<P\b\f
G<VO+<K
G<\aVлd
G<`Q0
G=0~K
G>l\f
GB:h38
GC;.X\b:3
GEG;\rs
GENERIC_IA32
GFw<5W
GG=2{ĽV
GG??L
GGHRD
GGR8|Q
GH;#H
GH='l
GHI+G@H
GI\a<s
GJ:F\b
GJ繭?G
GJ켟u!=8
GL9\rXѹcv
GL;M\e,;L
GLUHBQZS
GM;\vL
GNp:W
GPH+GHH
GPUUtilities.dll
GRC<r
GSλiPg
GU\r=L
GX$8aQ
GXH+GPH
GXH+GPI
GXH+GPL
GXL+GPH
GX˻.zֻXJ
GYd;em
GZu<M
G[<Ax
G[I;y"g
G\a:Hd
G\aO;\ehs
G\bH+\aH
G\b\bt"A
G\b\bt$A
G\bba|H
G\n;[wD
G\n\bt#A
G\n\bt%A
G\nf;E\ttT
G\nf;E\ttW
G\r<i
G\r=t|s
G\ri;0
G\t4;H
G\t:E\btK
G\t:E\btO
G\t:E\ftO
G\t:E\ntO
G\t:E\nu`H
G\t:E\nubA
G\t<I
G\v\bdF\v
G]H;I
G_ rr\e
G_a=6
Gbb}H
GdͽUW\n
Generated by Steam Audio\n
Genu3D$4
GenuineIH9
GenuineIntel
Genuu\aH
GetACP
GetActiveProcessorCount
GetActiveProcessorGroupCount
GetActiveWindow
GetCPInfo
GetCommandLineA
GetCommandLineW
GetConsoleMode
GetConsoleOutputCP
GetCurrentPackageId
GetCurrentProcess
GetCurrentProcessId
GetCurrentProcessorNumber
GetCurrentThreadId
GetDateFormatEx
GetDateFormatW
GetEnvironmentStringsW
GetEnvironmentVariableA
GetExitCodeThread
GetFileInformationByHandleEx
GetFileSizeEx
GetFileType
GetLargePageMinimum
GetLastActivePopup
GetLastError
GetLocaleInfoEx
GetLocaleInfoW
GetLogicalProcessorInformationEx
GetModuleFileNameW
GetModuleHandleExW
GetModuleHandleW
GetOEMCP
GetProcAddress
GetProcessHeap
GetProcessWindowStation
GetStartupInfoW
GetStdHandle
GetStringTypeW
GetSystemInfo
GetSystemTimeAsFileTime
GetSystemTimePreciseAsFileTime
GetThreadLocale
GetTickCount64
GetTimeFormatEx
GetTimeFormatW
GetTimeZoneInformation
GetUserDefaultLCID
GetUserDefaultLocaleName
GetUserObjectInformationW
Gez\es$;J
Gf<@s
Gffffff
Gg;Ӎo
Gh9wpvR
GhI+G`H
GhL+G`H
Giy:S
Gj;Wk0
Gk:cd
Gk<D\eS
GkӼ\bHN
Gl;h3
Glu?A
GlubA
Gm轜ls
GnC<O
Gn\t>\b
GpH9Gxs
GpH9Oxs
GpL9oxs
GpL9wxs
Gr@;vA
GrJoq
Gr\r<G
Gs:97
Gs;k~\a
Gv;|J1
Gv<3;N
Gvκ6d
Gx9]uP
GxH+GpH
Gyƻq5
G|b=52
G}F92wu
G}G;S
GĒ:WL
Gɹq@a:t
Gݾ\bWB
GᅻD\e
H 9Y\b
H : %M
H : %M : %S
H A;\bt
H SATAUH
H SVWH
H UATAUAVAWH
H USVWATAVAWH
H USVWAUAVAWH
H USVWAUAVH
H USVWAVAWH
H UVWATAUAVAWH
H WATAUAVAWH
H!D$ I
H!K=eC
H!L$ D
H!L$hA
H!T$0D
H"<jV\t
H"\r6
H#L$0H
H#ƈbc}H
H#ƈbs}H
H#߈bs}H
H%B;IM4:G
H(% hn
H(%BSV
H(-VXV
H(۸33
H)G0E3
H*:IE
H*=I8
H+D$0H
H+D$8H
H+D$HH
H+D$PH
H+D$hH
H+D$pH
H+D$xH
H+D$xL
H+E\bH
H+E\bI
H+HXH+P
H+HhH+P
H+L$ xFH
H+L$0L
H+L$\bH
H+L$\bL
H+L$hH
H+L$pH
H+L$xH
H+N`H
H+OPH
H+Q\bI
H+T$hH
H+T$pH
H+T$xH
H+X`H
H+p`I
H+r;pq
H+t$hH
H+x`I
H+ЋG0
H0:~bV
H1<sF\b
H1ʻ;9
H2\t;c44
H30;t
H39dYk
H3E H3E
H3̋D$ H;\r
H3ۉl$P
H5<M\bv
H5<mN
H5ڻ>1M
H7;5Ӫ:Z\n
H7\r%iV
H7\r<vV
H7\rC
H7\re2
H7\r{yV
H8DQ7;s
H8|UT
H9'wٻP
H9/t\fH
H91vAH
H91vCH
H91v[H
H92t\tH
H92t\tI
H97u+A
H99v$H
H99v/H
H99v2H
H99v;H
H9:t\fH
H9=\t\te
H9=yPx
H9>&X
H9A u\bH
H9A\btgH
H9Axs
H9C s(H
H9D$ t;A
H9D$@t;A
H9D$Ht;A
H9D$Ht>A
H9D$`H
H9D$`t>A
H9D$pt>A
H9E8s
H9E@t>A
H9E\bt>A
H9G\bu\nA
H9H s
H9K\bv|I
H9L$ r A
H9L$Ht?H
H9L$pI
H9L$xu
H9S\buKH
H9S\bu\fH
H9T$ v2f
H9U r#A
H9U\br#A
H9W0vTI
H9W0v\\I
H9WXv.I
H9WXv2I
H9Y\bv(3
H9Y\bv(fff
H9\at\tH
H9c(8
H9i\bujH
H9k\bt\vH;C\bv
H9t$0H
H9t$@t\f
H9y\bv(3
H9y\bv+H
H9{\bt\nH;C\b
H9|$8H
H9|$xt
H9溅s
H:7-9
H:<qkv
H:H=I
H:y\n\t
H;0c4
H;3u-I
H;3u0I
H;3u7H
H;3u:H
H;5\bB:\eL
H;A w4A
H;A w6
H;A wB
H;B0s M
H;B\bw\e
H;CXt
H;C\bv\f2
H;C\bw
H;C\bw H
H;C\bw!H
H;C\bw"H
H;C\bw"L
H;C\bw#A
H;C\bw#H
H;C\bw*H
H;C\bw\e
H;C\bw_L
H;C\bwiH
H;D$ r
H;D$0H
H;D$8u"H
H;D$8u"L
H;D$PH
H;D$Pt
H;D$Pu\bM
H;D$\bH
H;D$hs
H;D$pH
H;F w*H
H;G(sXH
H;H s\bH
H;H\bu\rL
H;H\bv\a
H;K w\v
H;K\bt\bH
H;L$0u H
H;L$PH
H;Mxr%A
H;NPt
H;NPt)A
H;P\bu\fL
H;P\bu\rL
H;Qz";R
H;S8v\bH
H;UPv\rD
H;Uxr%A
H;W t\t
H;WXr
H;XXs\v
H;X\b
H;\at$H
H;\btIH
H;\n8
H;\rO[K
H;\rR\fi
H;\rn
H;\vu-I
H;\vu:L
H;_ sJH
H;l$0u'L
H;l$8
H;l$H
H;l$PH
H;l$\bH
H;m(0
H;oxr)A
H;oxr1A
H;sxr
H;sxr A
H;sxr#A
H;sxr'A
H;sxr(A
H;sxr+A
H;t$ H
H;t$0L
H;t$0t
H;t$8M
H;t$8u'L
H;t$PH
H;tjy
H;uXr!A
H;wxr#A
H;wxr+A
H;xXu5
H;x\b
H;yNa
H;yxr
H;z\b
H;{Xr A
H;{xr
H;{xr(A
H;{xr+A
H;|80u\nK
H<(i1
H<8La
H<9&l
H<=wU9ܾc
H<Z깻L4
H<cmV
H=e<Ui
H=hSm
H=pd\b
H>*OA
H>7T켆F
H>hl\f
H>́h?5u
H@\r2
H@\r4X
H@\rR
H@\rUm
HA=\f/A
HA^A]A
HA_A^A
HB廨}ȻA\bx
HC<VX
HCL;o
HFX=ej
HG<?wQ
HGݻsp
HH:mm:ss
HH;^Hs
HH;{Hs
HHH+H
HI96v
HIԼ\nK\f
HJ\n?J
HL:Ƅp
HLc@\fIc
HM9\bJJ;(\f
HMcɃ~\b
HMcɃ~\f
HO<A!R
HPH+HHH
HR;xu
HR><y5
HRESET
HS伳q\r=0
HT9)\a
HT\a;H
HV:N<H
HV^<1
HW:m,ݻ6
HWҼ6j
HX%8j
HX'bQ|H
HX-5F
HX-IG
HX-bM
HX-vN
HX/bQ|H
HX=(w
HX=*E
HX=WR
HX=\tM
HX=]D
HX?bQ|H
HX?bq<XYE
HX\rF
HX\rQr
HX\rZj
HX\r\az
HX\r\e
HX|$R
HY&:g
HY,+bA
HY,\ebA
HY1:Q
HY:.G
HYM\nbQtHY
HYd$p
HYe\fbAT@Ye
HYt\a\fb
HYu\fbA
HZ%ɧp
HZ\rl!m
HZh<s
H\a\b;u
H\b9b\f
H\b:Z
H\bAUAVAWH
H\bAVAWH
H\bH+\bH
H\bL9I\bu\bD9
H\bSAUAWH
H\bSUVWATAUAVAWH
H\bSVAWH
H\bSVWATAUAVAWH
H\bUATAUAVAWH
H\bUSVWATAUAVAWH
H\bUSVWATAUAWH
H\bUSWATAUAWH
H\bUVATAUAWH
H\bUVAUAWH
H\bUVWATAUAVAWH
H\bUVWAVAWH
H\bUWATAUAWH
H\bUWATH
H\bUWAUAWH
H\bUWAUH
H\bVAUH
H\bVWATAUAVAWL
H\bVWATAVAWH
H\bVWAVH
H\bVWAWH
H\bWATAUAVAWH
H\bWATAUAWH
H\bWAVAWH
H\e/=n9
H\f;xz6
H\f<C|8
H\r4:k
H\r<w*f
H\t#;8A
H\t<gT\t
H\tt\f8C2u\aH
H\vT$PH
H\vT$PH3
H\vl$@H\v
H]A]A
H]A^A
H]A_A
H]A_A^A
H]A_A^A]A
H^=NTm
H^T<u
H_D8f
H`3\bD$8H
Ha=RjR
HaL;K
HairBuilderSAH
HairMBlurBuilderSAH
Hba~\b
HcAHH
HcB0M
HcD$ A
HcD$(H
HcD$(I
HcD$,H
HcD$<H
HcD$\\H
HcD$xLi
HcD$xM
HcE0I
HcF$E3
HcF(Hk
HcF(Lk
HcH\bH
HcI\bLk
HcL$ B
HcL$p3
HcL$pL
HcS\bH
HcS\bHc
HcS\bIc
HcS\bNcD
HcS\fHcK
HcT$$H
HcT$<H
HcT$`H
Hc\\$ I
Hc\\$ f
Hc\\$0I
Hc\\$0f
Hc\\$XH
Hc\\$pA
Hc\\$pE3
Hc\tt$H
HciHH
Hcl$`LcT$pLc|$h
Hcp8Lcx\bD
Hcq;:&g
Hct$ E
Hct$pD
Hc{\bIc*H
Hc|$PH
Hc|$xH
HcȉD$0
HcȋB\bA
HcˉD$P
HcҋE0H
HcҋEHH
Hcҋl$`M
Hc؉E@H
HcډD$4H
Hd<BZ\n
Hd<g{7
Hd\e:hE
Hdͻ\rr
Hdлp/\r
He3<9
HeapAlloc
HeapFree
HeapReAlloc
HeapSize
Helmholtz coefficient ?PAR(4)=%e should be non-negative
Helmholtz coefficient ?par[3]=%e should be non-negative
HfD9#A
Hfǹ4IX
Hg%;e5
Hi1:I
Hjֻ*Jn
HkL$ 8H
HkM\b8H
HkM`8H
HkT$HpH
HkT$`pA
HkT$xpH
Hkv=k_E
Hm<x\vw
Hmm>\r
Hn\v:v
Hnռ\ajX
Ho% DV
Ho% X
Ho%>Q
Ho%DK
Ho%HT
Ho%KO
Ho%MOV
Ho%\nCV
Ho%cc
Ho-@jV
Ho-Mq
Ho-WoV
Ho-\bQ
Ho-\niV
Ho-oyV
Ho-yV
Ho-~T
Ho5%=m
Ho5GeV
Ho5zDm
Ho5}Am
Ho;lJ5
Ho=.2
Ho=v)m
Ho@;i
HoD:\ab
HoK=eM
Ho\r&R
Ho\r5\b
Ho\rA\a
Ho\rG}V
Ho\rL\n
Ho\rM6V
Ho\rN*m
Ho\rP\nW
Ho\rQ9
Ho\r\f\tW
Ho\r_:V
Ho\re5
Ho\rr
Ho\rըV
Hp$1b
Hp$qH
Hp$qb!}Hp\f
Hp$±b
Hp$±b!4HY
Hp$±b!D@Y
Hp$ñb
Hp$ȱb
Hp$ȱb!4HY
Hp$ʱL
Hp$ʱbq\\H
Hp$˱H
Hp$˱b
Hp$رb
Hp$ٱb
Hp$ڱH
Hp$ڱb
Hp$ܱbQ}Hp\fԱbR\r
Hp,qb
Hp,qba}Hp
Hp,ñb
Hp,ȱb
Hp,ɱb
Hp,ʱb
Hp,ʱbAT@YU
Hp,˱b
Hp,˱ba<@Y
Hp,бI
Hp,бb
Hp,бb"E
Hp,бba4@Y
Hp,ұb
Hp,ԱbA}Hp
Hp,رb
Hp,رb!}Hp4бb!tHY
Hp,ڱb"5H
Hp,۱I
Hp,۱ba|H
Hp1b!}HpԱb
Hp1b!}Hpرb
Hp1b2M
Hp1bA|H
Hp1bA}Hpձbq|H
Hp1ba|H
Hp1ba}Hpʱbr}H
Hp1bq|H
Hp4±bQL@Yu\nb
Hp4ñbq
Hp4ıbQ}Hp\fܱb
Hp4ȱb
Hp4ʱL
Hp4ʱb
Hp4ԱbQ}Hp<ܱb
Hp4ֱI
Hp4ֱbQ}Hp<ƱbA}Hp
Hp4رb
Hp4رbq
Hp4ڱL
Hp4ڱb
Hp4ޱb
Hp<1b
Hp<1bq$HY
Hp<qb
Hp<±b
Hp<ñbq$HY
Hp<ıb
Hp<ƱbA}Hp\f
Hp<ȱb
Hp<ʱb
Hp<ʱbQDHYM\fb
Hp<ʱba}Hp,ڱbQDHYM\fbA
Hp<̱bA}Hp
Hp<бb
Hp<ұb!}Hp
Hp<ұbQ|H
Hp<ֱbq,HY
Hp<ױb
Hp<ڱL
Hp<ڱb
Hp<ڱb!}Hp
Hp<ܱb
Hp<ޱb
Hp<߱b
Hp\f1L
Hp\f1b
Hp\f±b
Hp\fƱbQDHY
Hp\fȱb
Hp\fʱb
Hp\fʱb!}Hp
Hp\fʱbAtHYE
Hp\fϱbQDHY
Hp\fбbat@Y
Hp\fұb
Hp\fұb"EH
Hp\fرb
Hp\fڱf
Hp\fܱb
Hpqb!D@Y
HpqbA|H
Hp±b!}Hp
Hp±bA|H
Hp±ba}Hp
Hpñb2
Hpñba|I
Hpñbqt@Y
HpıbA|I
Hpűb!L@Y
HpűbQ}Hp
Hpűba|H
HpƱb2E
HpƱbA
HpƱbQ}Hp
HpƱba|H
HpǱb1}Hpӱb
HpǱbA
HpǱbQ}Hp
HpǱba}Hp
HpǱba}Hpѱb
Hpȱb!|H
Hpȱba\f@Y
Hpɱb!|H
Hpɱb!}Hp1b
HpɱbQ|H
HpɱbQ}Hp
Hpɱba
Hpɱba|H
Hpɱbb
Hpɱbq}Hp̱b1}Hp߱b1}Hp
Hpɱbr}H
Hpʱb"U
HpʱbA|H
Hpʱba|H
Hpʱbr}H
Hp˱bA|H
Hp̱bA4H
Hp̱ba|H
HpͱbAD@Y
Hpͱbq}Hp1b
Hpαb!}Hpбb
Hpϱb!L@X
Hpϱb!|H
Hpϱb!}Hp1batH
Hpϱba}Hp
Hpбb!|H
Hpбb1
Hpбba|H
Hpѱb!TH
HpѱbA,@YU
HpѱbAD@Y
HpѱbQ}Hp
Hpѱba
Hpұb!|H
Hpұb!}Hp
Hpұb2UH
HpұbA|H
HpұbQ,HYU
HpұbQ}Hp
Hpұba|H
Hpұbr
Hpӱb!|H
HpӱbA}Hp
HpӱbQ\\HY
HpӱbQ}Hpݱb
Hpӱba}Hp
Hpӱbq|H
HpԱbA,@YU\vbB
HpԱbQ,HYU\rbB-H
HpԱbr
Hpձb"=H
HpձbA,@YU\abB
HpձbQ,HYU\tbB-H
Hpձba|H
HpֱbA}Hp
HpֱbQ,HYU
Hpֱbr}H
Hpױb!|H
Hpױb1|H
HpױbA,@YU\rbB
HpױbQ
HpױbQd@Y
Hpرb!}Hp
HpرbA}Hp
HpرbaD@X
HpرbaL@X
Hpٱb!|H
Hpٱb1,HY
Hpڱb!\fHY
Hpڱb!}HpԱbrM
Hpڱb1
Hpڱb1|H
Hpڱba}Hp
Hp۱b!|H
Hp۱bA|H
Hp۱bBUH
Hp۱bQ}Hp
Hp۱ba
Hp۱ba|H
Hp۱bbE
HpܱbAl@Yu\bb
HpܱbQ,@Y
Hpܱba|H
Hpܱba}Hp
Hpݱb1,HY
Hpݱb1|H
Hpݱba|H
Hpݱba}Hp
HpޱbQ}Hp
Hpޱba4@Y
Hp߱bAd@Y
Hp߱ba|H
HqP:\ai
Hq\e9\a
Ht:;HA
Hu;`4F
HvvGa
Hybrid Solver PARDISO with CGS/CG Iteration
HyͻKR
H{<no6
H{\f<OUv<8Ra
H|m;J
H~S=ita
Hǽ:pJe
H͛:pL
HлLj\t9j
Hա:Fo
Hܐ> 8o>d
H廼 \a
H쐼l6ϼD
I : %M : %S %p
I ;64
I I;W0r
I \v; x1:H
I brMH
I!>HuR
I"9U/x
I#<ILK
I#=fW
I%7M\f\r7
I'9J\r
I(<4K
I(H+H H
I(L+I H
I+3;c
I+A0I+K
I+N`H
I,<zuH
I.Q;<ZI9Q
I/:6BB
I0T<UO
I0ŪXi
I2ּak
I3=8I
I3?;1
I3s:Ɂ\f:5u
I6<3b
I7,QG9d
I7v9#rX=O
I87:F:G:s
I98t\fL
I98u*A
I99C\eG
I9D$xs
I9N\bu\n
I9kj^;b
I9q sEI
I9w0v-H
I9}(tiH
I:'kh
I:2T\r9
I:5r:q
I:U+i
I:c:3ޙ9
I:k\f69c)4;x
I:ýND\v
I;1~NH
I;4$L
I;6\nw;uL
I;:\vje
I;;DC
I;A s>I
I;A`s?I
I;D$ w"I
I;D$ w*H
I;D$ w-H
I;D$Pt
I;D$Pt%A
I;E w I
I;E w*H
I;E wiH
I;E woH
I;EPt
I;F w*H
I;G vnH
I;G w I
I;G w*H
I;G w-H
I;L$ w\n
I;L$ w\t
I;M w;I
I;M w\n
I;M w\t
I;O w\n
I;O w\t
I;U w\tI
I;W w\tI
I;Y\b
I;\\$xsBH
I;\\$xsEH
I;\\$xsIH
I;\bt\aH
I;is\n
I;pf7
I;q s?I
I;s8A
I;t$\bs
I;t$\bs\e
I<$wh
I<N:8
I<RRĻ8
I=0\aW
I=Xwm
I=jm\b
I=xvW
I=|WZ
I>TtɾI
I>[eL>G
I?N;j
I@L9{8u\vH
IA:)Nx
IC;Z{k
ICMF}A
ICμyj
ICܱb!}Lp
ID + n-1 <= set.ext_range_size
ID$ D
ID$dL
ID<d-\n
IG4=>V
IH9;MK\r
IH9B\ftEHcR\fI
IHHcB\fJcL\b
IHŪ\\yP
IIݻEQ
IJL$PP
IJL$`P
IKD:fx
IKg<k
IM1:MT
IM<\e%2
IND)ind
IND)ind)SNAN
INFO code =: %d
INTEL oneMKL ERROR: %s
INTEL_ISA_DISABLE
IP<ga
IP<qN
IPAR(10) must have the value 1
IPAR(15)=%s. Parameters IPAR(14) and/or IPAR(15) were probably
IPAR(4) is greater than or equal to IPAR(5
IPAR(5)-IPAR(4)=%s
IPAR(5)=%s is less or equal to the current value of the iteration
IPH;W0r
IPLAirAbsorptionModelType
IPLAmbisonicsType
IPLAudioEffectState
IPLBakedDataType
IPLBakedDataVariation
IPLDeviationModelType
IPLDirectEffectFlags
IPLDirectSimulationFlags
IPLDistanceAttenuationModelType
IPLHRTFInterpolation
IPLHRTFNormType
IPLHRTFType
IPLOcclusionType
IPLOpenCLDeviceType
IPLProbeGenerationType
IPLReflectionEffectType
IPLReflectionsBakeFlags
IPLSIMDLevel
IPLSceneType
IPLSimulationFlags
IPLSpeakerLayoutType
IPLTransmissionType
IPLbool
IPLbyte
IPLfloat32
IPLint32
IPPCODE
IPPDATA
IQj=n
IS8Lpn:\nb
ISӻ\e\t
IZ;gFE
I\\\e;VYJ
I\aba|H
I\aba|\b
I\aba~\b
I\bI+\tH
I\bba~\b
I\f@;z0u
I\fD;N
I\nba^\bX
I\nкH
I\rba~\b
I\v<K6M
I\vڻXa
I_MPI_NUMBER_OF_MPI_PROCESSES_PER_NODE
I_MPI_PIN_MAPPING
I_MPI_THREAD_LEVEL
I`W<b
Ia<\t
Ib&:0\b
Ib:2\vP
Ib\t<2
Ic;HcS\bH
IcD$\fL
IcD$lL
IcElL
IcL$lF
IcY\fIcI
Ic}\bIcu
Id7;9O
IdP=s
If you are sure that everything is correct, you may force the
Iffffff
Ig8-QʹD19
Ij$>P
Ij;#mD:K
IjL;C
Ik?<g
Iks:og
Il(;R
Il?333333c
Il\n;x
Ilu;Q
Il8L\b
Index is out of bounds
Infinite loop
Infinite loop. At least one of parameters IPAR(8), IPAR(9), or IPAR(10) must be equal to 1
InitOnceExecuteOnce
Initialization failed to complete, or the parameter IPAR(7)=%s
Initialization failed to complete, or the parameter ipar[6]=%s
InitializeConditionVariable
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
InitializeCriticalSectionEx
InitializeSListHead
InitializeSRWLock
Initialized AMD Advanced Media Framework v%d.%d.%d.%d
Initialized Embree v%lld.%02lld.%02lld
Initialized OpenCL device: %s %s (%s
Initialized OpenCL platform: %s %s (%s
Initialized Radeon Rays v%.2f
Input absolute value of tolerance is greater than
Input check: Sequential OOC mode of factorization is incompatible with sequential IC mode of reordering
Input check: Two-level factorization algorithm does not work in OOC mode
Input check: empty input arrays ia and/or ja
Input check: i=%d, ia(i)=%d, ia(i+1)=%d are incompatible
Input check: i=%d, ia[i]=%d, ia[i+1]=%d are incompatible
Input check: i=%d, j=ia(i)=%d, ja(j)=%d are incompatible
Input check: i=%d, j=ia[i]=%d, ja[j]=%d are incompatible
Input check: i=%d, ja(i)=%d, neqns=%d are incompatible
Input check: i=%d, ja[i]=%d, neqns=%d are incompatible
Input check: i=%lli, ia(i)=%lli, ia(i+1)=%lli are incompatible
Input check: i=%lli, ia[i]=%lli, ia[i+1]=%lli are incompatible
Input check: i=%lli, j=ia(i)=%lli, ja(j)=%lli are incompatible
Input check: i=%lli, j=ia[i]=%lli, ja[j]=%lli are incompatible
Input check: i=%lli, ja(i)=%lli, neqns=%lli are incompatible
Input check: i=%lli, ja[i]=%lli, neqns=%lli are incompatible
Input check: ia(neqns+1)_new %d _old %d are incompatible
Input check: ia(neqns+1)_new %lli _old %lli are incompatible
Input check: ia[neqns]_new %d _old %d are incompatible
Input check: ia[neqns]_new %lli _old %lli are incompatible
Input check: ido_new %d (out of bounds
Input check: ido_new %lli (out of bounds
Input check: internal error, counted number of threads %d
Input check: internal error, counted number of threads %lli
Input check: iparam(6) %d (out of bounds
Input check: iparam(6) %lli (out of bounds
Input check: iparam[5] %d (out of bounds
Input check: iparam[5] %lli (out of bounds
Input check: j=%d, ja(j)=%d, ja(j+1)=%d are incompatible
Input check: j=%d, ja[j]=%d, ja[j+1]=%d are incompatible
Input check: j=%lli, ja(j)=%lli, ja(j+1)=%lli are incompatible
Input check: j=%lli, ja[j]=%lli, ja[j+1]=%lli are incompatible
Input check: matrix_number_new %d ido %d are incompatible
Input check: matrix_number_new %lli ido %lli are incompatible
Input check: matrix_type_new %d (out of bounds
Input check: matrix_type_new %d _old %d are incompatible
Input check: matrix_type_new %lli (out of bounds
Input check: matrix_type_new %lli _old %lli are incompatible
Input check: max_fac_store_in %d matrix_number_in %d
Input check: max_fac_store_in %lli matrix_number_in %lli
Input check: max_fac_store_new %d _old %d are incompatible
Input check: max_fac_store_new %lli _old %lli are incompatible
Input check: nb_new %d ido %d are incompatible
Input check: nb_new %lli ido %lli are incompatible
Input check: neqns %d or ia[neqns_in] %d are invalid
Input check: neqns %lli or ia[neqns_in] %lli are invalid
Input check: neqns_new %d
Input check: neqns_new %d _old %d are incompatible
Input check: neqns_new %lli
Input check: neqns_new %lli _old %lli are incompatible
Input check: nproc %d is not equal to counted number of threads %d
Input check: nproc %lli is not equal to counted number of threads %lli
Input check: preprocessing %d (out of bounds
Input check: preprocessing %lli (out of bounds
Input check: unexpected error with working arrays ia and/or ja
Input data or print help ? Type [data]/help
Input error is not equal to ZERO, error=%d
Input error is not equal to ZERO, error=%lli
Input parameters: inconsistent error= %d max_fac_store_in: %d
Input parameters: inconsistent error= %lli max_fac_store_in: %lli
Input value of DPAR(31) equals zero
Instanced scene is not set. Use rtcSetGeometryInstancedScene to set the scene to instance
Intel oneMKL BLACS fatal error: cannot allocate memory, aborted
Intel oneMKL DCSRILU0 ERROR
Intel oneMKL DCSRILU0 WARNING
Intel oneMKL DCSRILUT ERROR
Intel oneMKL DCSRILUT WARNING
Intel oneMKL DFTI ERROR: Configuration parameter DFTI_NUMBER_OF_USER_THREADS is not set
Intel oneMKL DFTI ERROR: Descriptor is uncommitted or corrupted
Intel oneMKL DFTI ERROR: Error in OpenMP
Intel oneMKL DFTI ERROR: Functionality is not implemented
Intel oneMKL DFTI ERROR: Inconsistent configuration parameters
Intel oneMKL DFTI ERROR: Incorrect status
Intel oneMKL DFTI ERROR: Internal error
Intel oneMKL DFTI ERROR: Invalid configuration parameters
Intel oneMKL DFTI ERROR: Not enough memory to allocate
Intel oneMKL DFTI ERROR: Transforms with number of points N of a non-unit stride dimension exceeding 2^(27-p) - 1 for N a power-of-two, or 2^(23-p) - 1 for N not a power-of-two, are currently not supported, where p=0 for single precision and p=1 for double precision
Intel oneMKL DFTI SUCCESS: No error
Intel oneMKL ERROR: CPU %d is not supported
Intel oneMKL ERROR: Incompatible optional parameters on entry to %s
Intel oneMKL ERROR: Parameter %d was incorrect on entry to %s
Intel oneMKL Extended Eigensolvers ERROR: Problem from Inner Linear System Solver
Intel oneMKL Extended Eigensolvers ERROR: Problem with array parameters
Intel oneMKL Extended Eigensolvers ERROR: Problem with input parameters
Intel oneMKL Extended Eigensolvers ERROR: Problem with internal memory allocation
Intel oneMKL Extended Eigensolvers ERROR: Problem with reduced system
Intel oneMKL Extended Eigensolvers Error: Matrix B is not positive definite
Intel oneMKL Extended Eigensolvers WARNING: No eigenvalue has been found in the proposed search interval
Intel oneMKL Extended Eigensolvers WARNING: Only the subspace has been returned
Intel oneMKL Extended Eigensolvers WARNING: Size subspace M0 too small
Intel oneMKL Extended Eigensolvers WARNING: Solver did not converge (number of loops reached maximum allowed
Intel oneMKL Extended Eigensolvers have successfully converged (to desired tolerance
Intel oneMKL Extended Eigensolvers: List of input parameters fpm(1:64)-- if different from default
Intel oneMKL Extended Eigensolvers: Resize subspace %d
Intel oneMKL Extended Eigensolvers: Size subspace %d
Intel oneMKL Extended Eigensolvers: complex double precision driver
Intel oneMKL Extended Eigensolvers: complex single precision driver
Intel oneMKL Extended Eigensolvers: double precision driver
Intel oneMKL Extended Eigensolvers: fpm(%d)=%d
Intel oneMKL Extended Eigensolvers: single precision driver
Intel oneMKL FATAL ERROR: Cannot load %s
Intel oneMKL FATAL ERROR: Cannot load %s or %s
Intel oneMKL FATAL ERROR: Error on loading function %s
Intel oneMKL FATAL ERROR: MKLMPI wrappers are NULL
Intel oneMKL FATAL ERROR: This system does not meet the minimum requirements for use of the Intel(R) Math Kernel Library
Intel oneMKL FATAL ERROR: cannot load %s
Intel oneMKL FATAL ERROR: cannot load %s or %s
Intel oneMKL FATAL ERROR: dynamic library %s is not convenient for this processor
Intel oneMKL FATAL ERROR: memory allocation error
Intel oneMKL INTERNAL ERROR: Condition %d detected in function %s
Intel oneMKL INTERNAL ERROR: Insufficient workspace available in function %s
Intel oneMKL INTERNAL ERROR: Issue accessing coprocessor %s
Intel oneMKL INTERNAL ERROR: Not enough work memory in function %s
Intel oneMKL INTERNAL ERROR: Optimization cache's size limit exceeded
Intel oneMKL POISSON SOLVER ERROR
Intel oneMKL POISSON SOLVER WARNING
Intel oneMKL RCI CG ERROR
Intel oneMKL RCI CG WARNING
Intel oneMKL RCI FGMRES ERROR
Intel oneMKL RCI FGMRES WARNING
Intel oneMKL ScaLAPACK fatal error: cannot allocate memory, aborted
Intel oneMKL TRIG TRANSFORMS ERROR
Intel oneMKL TRIG TRANSFORMS WARNING
Intel oneMKL WARNING: %s function associated with Intel(R) Xeon Phi(TM) x100 Product Family has been deprecated. Intel(R) Parallel Studio XE 2017 is the last supported version for this function
Intel oneMKL WARNING: CPU type %d is not suitable for this processor
Intel oneMKL WARNING: Library %s (oneMKL type %d) is not suitable for this processor (oneMKL type %d
Intel oneMKL WARNING: PGI support is deprecated and will be removed in the Intel oneAPI Math Kernel Library 2025.0 release
Intel oneMKL WARNING: Support of Intel(R) Advanced Vector Extensions (Intel(R) AVX) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library will use Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) instructions instead
Intel oneMKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions
Intel oneMKL WARNING: Support of Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library will use Intel(R) Streaming SIMD 2 Extensions (Intel(R) SSE2) instructions instead
Intel oneMKL WARNING: incorrect conditional numerical reproducibility mode, MKL_CBWR_AUTO is set
Intel oneMKL function load error: %s
Intel oneMKL function load error: cpu specific dynamic library is not loaded
Intel(R) 64 architecture
Intel(R) Advanced Vector Extensions (Intel(R) AVX) enabled processors
Intel(R) Advanced Vector Extensions (Intel(R) AVX) with F16C instructions support
Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX-2) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost
Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2) enabled processors
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) enabled processors
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, FP16 (limited) instructions, and Intel(R) Advanced Matrix Extensions (Intel(R) AMX) with INT8 and BF16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, FP16 (limited) instructions, and Intel(R) Advanced Matrix Extensions (Intel(R) AMX) with INT8, BF16, and FP16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, and FP16 (limited) instructions
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost) and bfloat16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost), EVEX-encoded AES and Carry-Less Multiplication Quadword instructions
Intel(R) Architecture processors
Intel(R) Streaming SIMD Extensions 2 (Intel(R) SSE2) enabled processors
Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled processors
Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) enabled processors
Intel(R) oneAPI Math Kernel Library Version
InterlockedFlushSList
Internal error
Internal error in %s: memory leak
InternalName
IntersectAny
IntersectAny2L
IntersectAnyRC
IntersectAnyRC2L
IntersectClosest
IntersectClosest2L
IntersectClosestRC
IntersectClosestRC2L
Invalid argument
Invalid call sequence
Invalid error code
Invalid error number
Invalid factor option
Invalid message argument descriptor
Invalid message level
Invalid message request. This should never happen in a normal situation
Invalid message request. This should not happen under normal circumstances
Invalid operation
Invalid option
Invalid reorder option
Invalid string descriptor
Invalid structure option
Invalid termination level
Io;<W
Io;mS
IpŢ\\i0
IpƱba}Jpqb
Ipɱba}Jpڱb
Ip˱bA|H
Ip̱bA|H
Ip̱ba|H
Ipͱba|H
Ipαba}Jp±b
Ipѱba}Jp۱b
IpԱbA|H
IpݱbA|H
Ipݱba|H
Iq~;Y
Ir==s
IsDebuggerPresent
IsProcessorFeaturePresent
IsValidCodePage
IsValidLocale
IsValidLocaleName
Is\t;n
It is also possible that parameter IPAR(1) was altered by mistake outside of the routine
It is also possible that parameter ipar[0] was altered by mistake outside of the routine
It is possible that future usage for replacement of small diagonal values
It may be an error in one of the parameters
It may be an error in one of the parameters. The method may fail to proceed
It was probably altered by mistake outside of DFGMRES routine. The solution may be wrong
It was probably altered by mistake outside of the routine, or some characters in
It was probably altered by mistake outside of the routine, or the fifth character in the
It was probably altered by mistake outside of the routine, or the first character in the
It was probably altered by mistake outside of the routine, or the fourth character in the
It was probably altered by mistake outside of the routine, or the second character in the
It was probably altered by mistake outside of the routine, or the sixth character in the
It was probably altered by mistake outside of the routine, or the third character in the
Iv*;zy
Iz!4\a
Iz&94Z
Iz\t;OJ
I}ļm\vs
IƟ;Zo
Iɾy?ԽDC
I˔;\agi
I̺\epF
Iͤ:oq\t
Iιy9o
IϼX>R
Iм)lv
Iػ3ld;R79
IⱾ" V
J"bA|\b
J%:9J
J(=Y\tu
J(ba|\b
J):\bzs
J)\r;xhX
J,ba~\b
J-;kUQ
J-;mhۻg
J.i:_TC
J0:LN
J0:fQ
J0W;%\t
J0úJM
J2<2h
J4ba~\b
J5<#h\a
J5ջ\rFz
J79 X
J93ζ9
J9\re+:\e
J9`?Y
J:;5W;dw
J:@ž7v6z
J:B9\t
J:`\nx9
J;8n9d
J;K[U9ly
J;Lk5;9
J;Un#;J
J<0"0i3
J<Q2F
J<UP6
J<X[A
J<Ӻju
J=<qX
J>F*j=s
J?:RFk
J?\v<Xb
J@1;C
J@>HBh
JAKgdB
JAj;P
JBԓpBXchB
JCmQ,B
JG1>jY
JG<zf
JIU<:O
JJ:2uQ
JK\t;H
JL\v;C㍻qB\a;m\b5
JLνn;\b
JO2<i7y
JS9\fuq
JSv:J
JT:wx\t
JTxV`TXX
JU/9F=3
JVC;fN
JVͻM(1
JW,:IYK
JW,:k
JWP:>О7t
JWP;\a
JWĻCb
JX.<C
JXI źXy
JY8H;{xr
JY;.iF;\rl
JY\rԉw
JYk;\n
JYl\al
JZ;pm
J\a;rd\v
J\ab!|H
J\abA|\b
J\aba|\b
J\b?ZU1
J\bba|\b
J\bba~\b
J\f=d3a
J\f\b
J\fba~\b
J\nbA
J\nba|\b
J\nba~\b
J\r9<c
J\rbA|\b
J\t:4
J]f=Dh
J_D$ A
J_D$ H
J_E\fE3
J_T$ H
J`;3j
Ja':q
Ja8N؍:\vn
Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December
January
JbT:;ZB
Jbk9f
Jc,;_Yc;Gd6
JcD0\fI
Jgv<p
Jgн˜3=F\a
JhȽ|z
JkS>1C
Jl<MnA
Jnj:.N
Jo;ZQK
Jpαba}Ip
Jq<ٴN
Jq=\bt
JqӽoA
Jr5<P
Js\e;$E
Js~<b\t
JtC=L
Jv,=H5
JwH;k5
JxѻPK
Jy:<P
J|iNd
J~A<q\vi
Jž1k\t
Jƞ;\v6T
JʻamȻf
Jώ;M7
Jј<z1
JӰ9+Y9;4
Jӻv}i
Jԋ>I0
JֺVT98
Jٹ?Zi:7
JڹF\v
K IcG\f
K SUVWAVH
K ġz^L
K ŠYL$0
K"ԺWT
K#̈bS-J
K#͈bC\rL
K%2;V
K%Z;h
K(3\tD$4H
K(3\tD$4I
K(y:j
K)=2m
K*;1r\b
K*w;B
K+U<_jr
K-;EzY
K-k<C$C
K.Z9R
K.Ϻ5 ݻJe
K0HcQ\f
K0HcQ\fD
K0L;p\b
K4:{e
K4w;E
K7r:3`9:%0
K8:˾Q
K8H;\rx
K90;\f
K9Hu^9
K9Tљ9n
K9Y3u
K9k_(;mA4
K9v4%;Fu&:G
K;"bH
K;7`8
K;A\a@9
K;GqY
K;Nٰ8S"5;N=6
K;T3L
K;j2ļyP8
K;zj\r
K<V=s
K<aXG;0
K<gOo;k
K=9ev
K=o64=y\bc
K={wl>r1
K>H(L>Sg
K>exU?3
K>g'9
K@H;\rn
K@ŤYM
KAF:0
KB;1R\v
KD$ E3
KD=;k
KD?;h
KE; H
KERNEL32.DLL
KERNEL32.dll
KEѻSN
KF:)uV
KG\n;I
KHH;\rd
KHf9}rx9
KHi;\\h
KI;)hR
KIڽ02
KJ;7-\a
KJ;?U
KJj;Z
KJn>EN
KM:\r
KM:^C\b
KN;\eN
KT,>w
KTW;Xr
KW;0'\t:T
KW;wy
KW\r;Υu;i
KWc;jۛ;a
KXH;\ro
KXM+KPI
KZI:5\t
KZ[:i!N
K[:cc
K\aU:3Of
K\abr}X
K\b;b
K\b<ic
K\b=CŹ=Yg
K\bATAUAVH
K\bAUAWH
K\bH;\rC
K\bLc@\b
K\bSUVWATAUAVAWH
K\bSUVWAUAWH
K\bSUVWH
K\bSVWAVAWH
K\bUATAUH
K\bUATAVAWH
K\bUAVH
K\bUSVWATAUAVI
K\bUVWATAUAVAWH
K\bUVWATAUAVAWI
K\bUVWATAUAVH
K\bUVWATAUAVI
K\bUVWATAUAWH
K\bUVWAUAVAWI
K\bUVWAVAWH
K\bUWATAUAVI
K\bUWAUAVAWI
K\bVWATAVAWH
K\bVWAVH
K\bWATAUAVAWH
K\bWAVAWH
K\bbA|H
K\fġz^L
K\n9[M
K\r<3S\a
K\r?z
K\v\bdJ\v
K\v\tr\r0n
K]F;^3O
K]o9\v4
K]taM
K^a9ma
K`H;\re
Ka=tCP
Ka|ptt
KbP9v
Kd %f %f %f\n
Kd:>J
Kernel32
KhH;\rr
Kj:\f[H
Kk;\\S39
Klh:Rw
Klɻ22\r
KmV<3
Km|;jV7
Knջdx
Ko\v=Y
KpH;\rh
KpI;J
Kq6:_\r
Ks %f %f %f\n
Ks9\n
Kt@<TN
Kw!=>h8
KxH;Kpt2
KxH;\r
KxS:HQ
Kxɻ.U17n
Kz<1fS
Kz_;Zk
K{J9y
KŻ9\vo;\f
K˼g%7
KѼ\vC
Kѽ8:t
KԻY{G
KֻO\eͻz
Kּ]bK
K؉D$ H
K؉D$lH
K؉D$pH
K؉D$tH
K؉D$xH
KݻbW9
Kޢ;FM
L  fB
L 0fC
L <gtȻl
L F"p&F
L v"X
L" fC
L#\r.KK
L#\rnUK
L#܈bs]I
L$ E3\v1
L$ H+L
L$ H;H\b
L$ H;T$P
L$ HcT$ H
L$ L;L$\b
L$ SUVAU
L$ SUVAUAWH
L$ SUVWATAUAVAWH
L$ SUVWH
L$ SVATAUAVAWH
L$ SVWAT
L$ SVWAW
L$ SVWH
L$ SWH
L$ UATAUAVAW
L$ UATAUAVAWH
L$ USVH
L$ USVWAVAWH
L$ USVWAVH
L$ USVWAWH
L$ USWATAVH
L$ USWAUAVH
L$ UVWATAUAVAWH
L$ UVWAVAWH
L$ UVWH
L$ VWATAUH
L$ VWAVH
L$ bA~\b
L$ ba~\b
L$ fA
L$ fD
L$ fff
L$ t!A
L$ z\au
L$ ŲYM
L$ ŲYN
L$ ŸXUP
L$(3ɉD$ D
L$(A2
L$(HcT$4H
L$(bb
L$(fff
L$,fD
L$0H+L$ H
L$0H+L$8H
L$0H;K\bt
L$0I;H\b
L$0L;sxr
L$0Lc@\b
L$0bA~\b
L$0ba~\b
L$0fA
L$0fD
L$0fff
L$0tBH
L$0tGH
L$0t\rA
L$0ŰYE
L$4+L$8
L$4+L$H
L$89L
L$8E18
L$8H;u
L$8HcI\fH9
L$8M;7
L$8bb
L$8fffff
L$8t2H
L$<bb
L$@A9MP
L$@E)uP
L$@HcQ
L$@HcT$PH
L$@HcT$dH;D
L$@fA
L$@fD
L$@tBH
L$Bba~\b
L$HH+L$@H
L$HH;\ra
L$HL+L
L$HL;T
L$Hb!|H
L$Hs!E
L$P+M0D
L$P1ɺN
L$P1ɺ\b
L$P1ɺ\t
L$P3\tD$8H
L$P<\au
L$PD9v
L$PH;L
L$PbA~\b
L$Pba~\b
L$PfA
L$PfC
L$PfD
L$PfH
L$PŀYL$p
L$PŨXU0
L$PŨY
L$THc
L$Vba~\b
L$X+M0D
L$XI+L$PI;M
L$Xt!A
L$Xu3H
L$Xu<H
L$Xv\b3
L$\bATAUAVH
L$\bATAVAWH
L$\bAVH
L$\bE
L$\bL;L
L$\bSAUAWH
L$\bSUVWATAUAVAWH
L$\bSUVWATAUAVAWL
L$\bSUVWATAVAWH
L$\bSUVWAUH
L$\bSUVWH
L$\bSVWATAUAVAW
L$\bSVWATAUAVAWH
L$\bSVWAVAWH
L$\bSVWAVH
L$\bSVWH
L$\bSWAUH
L$\bUATAUAVAW
L$\bUATAUAVAWH
L$\bUAV
L$\bUH
L$\bUSATH
L$\bUSH
L$\bUSVWATAUAVAW
L$\bUSVWATAUAVAWH
L$\bUSVWATAUAVH
L$\bUSVWATAVAWH
L$\bUSVWATAVH
L$\bUSVWATH
L$\bUSVWAUAWH
L$\bUSVWAVAWH
L$\bUSW
L$\bUSWATAVAWH
L$\bUSWH
L$\bUVW
L$\bUVWATAUAVAW
L$\bUVWATAUAVAWH
L$\bUVWAUAVH
L$\bUVWAUH
L$\bUVWAVAWH
L$\bUVWH
L$\bUWATAVAWH
L$\bUWAVH
L$\bVAW
L$\bVWATAVAWH
L$\bVWAUAWH
L$\bVWAUH
L$\bVWAVH
L$\bWATAUAVAWH
L$\bWAU
L$\bWAVAWH
L$\bba
L$\bba~\b
L$\bffff
L$\f b
L$\tba~\b
L$`H+t$PH
L$`L;d$PM
L$`fA
L$fba
L$fba~\b
L$hH+t$PH
L$hL9t$pu\bL
L$hba6
L$hƇ\bI
L$pH9E
L$pH;D$h
L$pbA~\b
L$pba~\b
L$pfA
L$pfB
L$pfD
L$pfff
L$pŀYm
L$pŰW\rG
L$pŰYL$P
L$pŸY
L$x3ۉT$XD
L$xH;t$h
L$xL;T
L$xba~\b
L&U for matrix number %d deleted
L&U for matrix number %lli deleted
L'3>7
L( fB
L* fC
L+L$8L
L+L$PL
L+L$xL
L+T$0H
L+T$hI
L+d$8H
L+d$8I
L+d$PL
L+d$XL
L+l$\bJ
L+l$pH
L+p`H
L+t$ O
L+t$hL
L+w>p{B
L+x`I
L. >Y
L0;CV\b
L3 b1
L38;<d
L3:\a
L3;Kp
L3=,J
L3\bJ+\f3H
L4\fā(]L4
L5#;48
L5;Wp
L5<4끼<o
L6<v|Q
L7=Vo
L7A@V
L8<wNb
L8\fB9L.\ft A
L8\fB9L.\ft!A
L8\fC9L<\ft A
L8\fC9L<\ft!A
L9"t\rH
L90u H
L9;0ʍ:Y
L9;<T
L9@JL;4w
L9B\bt\vH;B\bv
L9D$8vnI
L9D$8vuI
L9D$8vvI
L9D$8v{I
L9D$XvhI
L9D$XvxI
L9D$`L
L9FHv[A
L9GHvDI
L9GHvJI
L9GHvLI
L9GHvNI
L9S\bvmI
L9S\bvoI
L9S\bvuI
L9[\bt\vH;C\bv
L9` s\nD
L9aHu\nL9aPu
L9h\bu\bD
L9hc\n
L9l$xt
L9s.λJ
L9s`uIH
L9s`uJH
L9s`uLH
L9{\bt\vH;C\bv
L9|$PA
L:%kM
L:Bx\f
L:E\bC:Tv
L:Zfc
L:nl~:85\f
L:x\e
L:{Lr9
L; u9H
L;#u7H
L;3u-I
L;3u0I
L;3u7H
L;3u8H
L;3u:H
L;3u;H
L;3u=H
L;3u>H
L;6r A
L;9Bl;.u
L;;u0I
L;;unH
L;;utH
L;<\r9j
L;>r A
L;D$0r
L;D$0u#H
L;D$0u8H
L;D$8L
L;D$8u
L;D$8u H
L;D$HM
L;D$hM
L;GHr
L;L$8M
L;L$8u H
L;L$HM
L;L$XM
L;PPZ
L;Q0s M
L;T$8M
L;X-x
L;\buFI
L;\r/KK
L;\r1XK
L;\rBVK
L;\rRLK
L;\rWUK
L;\roUK
L;\rt)L
L;\t8g
L;\tM&9
L;a s|H9V\b
L;a\ac:C
L;cxr A
L;cxr#A
L;cxr'A
L;cxr)A
L;d$HH
L;d$X
L;d$\bM
L;d$pM
L;d0H
L;fxr!A
L;gxr!A
L;i%R
L;l$0H
L;l$PM
L;l$X
L;o\br
L;oxr(A
L;oxr)A
L;oxr.A
L;sMi9䳮8
L;sxr
L;sxr A
L;sxr#A
L;sxr(A
L;sxr+A
L;t$X
L;t$pM
L;u}W
L;wxr
L;wxr#A
L;wxr&A
L;wxr'A
L;wxr(A
L;wxr*A
L;wxr+A
L;wxr.A
L;x w7
L;x\b
L;z\b
L;{xr!A
L;{xr#A
L;{xr(A
L;{xr+A
L<%OW
L<iWj
L<j_J
L<pAͺNt
L<q\fs<8
L<tsF
L=C\e
L?UUUUUUU
L?n(Zy
L@Y<9b
L@YA\vbaL@Yi
L@YI\fb
L@YQ\bb
L@Ya\tbaL@Ya\rbaL@Yq\nb
LA;$H
LAPACKE_NANCHECK
LAPACKE_sgesvd
LAPACKE_sgesvd_work
LAѼ\tx
LB 9J\bMc
LB89J\bMc
LBʺ,1
LCIDToLocaleName
LCMapStringEx
LCMapStringW
LCW&qB
LC_ALL
LC_COLLATE
LC_CTYPE
LC_MONETARY
LC_NUMERIC
LC_TIME
LCr;xp
LD_LIBRARY_PATH
LEv;B
LGλߞ4:nF
LHYu\bb
LHYu\fbBMH
LHYu\nb
LJ;t*6;\r
LL(;sd
LLS;D\n
LM 9U\bL
LM>:Gs
LNNLNNUNNLNN
LNNRNNUNNRNN
LNUNN
LNUNNN
LO=IKR=i
LP A9x\b
LQ::3F;U
LQ<\fm
LR;xP
LRVTBFBLVFBTFBBFBRVFBTFBBFB
LT fC
LT$0A9L
LTW;zh
LTϻpz
LU fC
LV{;z
LX<"H
LXֻK\t
LY\e<<A
LZ6;Dc
LZ><5
LZCNT
L[:u5
L\a;h
L\a\nbQ|H
L\af;w
L\b;J\aU
L\bt;n
L\e:\ep\b
L\n  fG
L\n00
L\n\\;oPZ:rq
L\n\vba|H
L\r+;22
L\r<oK8
L\t<c(Y
L\t>J沾fQ
L\vN;Ye39
L\v\r)JK
L`;wm
La9;F
Lba~\b
Lc*D;l$P
Lc@\bIc
Lc@\bJcT
LcA<E3
LcB\fHcJ
LcD$(I
LcD$4I
LcD$xH
LcI\bLc
LcL$,L
LcL$<HcT$<H
LcL$<L
LcSlI
LcT$4L
LcT$`Lc\\$pLc|$h
Lc]lI
Lcd$8M
Lcd$HM
Lcd$TD
Lcd$TM
Lcd$dM
LcmwHc
Lct$DI
Lc}\bM
LcȐD;C8
Lcʍ\fRL
LcщL$HI
Lc҉T$4I
Ld;6,R
Ldy<x4
LeaveCriticalSection
LegalCopyright
Level Zero raytracing support missing
Leպj'g
Lf ;1
LfH;xR
Lffff
Lffffff
LgQ<R
Lgk<pMm
Linear system Ax = b
Linear system Ax = b > < transpose
ListenerPosition
ListenerUp
ListenerView
LjȼF0
Lk6;S
LkڻA\n
Ll;=Z
LoadLibraryA
LoadLibraryExA
LoadLibraryExW
LoadLibraryW
LocalFree
LocaleNameToLCID
LookupPrivilegeValueW
Loop | #Eig  |    Trace     | Error-Trace |  Max-Residual
Lpd9\b
LsY;w
Lt:-q
Lu*E;t
Lu:/vR
Lu;4\a
LuȻS!T
Lw#;aR
LwCԓpB
LwZ:\aa
Lx4;V
LzdA9
L{;JlA
L{=R7
L}7;R
L~Z<9
Lú,vE
LǼhE強U
LȺ`FU
L۾=kmT
Lܟ<Fi
Lܻ/h0<S
L毺#$p9M
L溬U2<2
L뢺HCA;(sպ\tG
M <= max_total_elements
M M;4
M ňYT
M ŤY\r
M ŤY\rG
M ŤY\rg
M Ū_B\f
M ŴY\r
M ŴY\re
M ŸXUp
M źYML
M#g\bt
M#l$\bt
M#o\bt
M%;3J}6i
M&t:Z
M'y>0y
M(A+M0
M)\r=Dk
M+2;5V
M+D$PI
M09L8\bu
M0H;H\b
M0H;z\b
M0żWU
M0ȹ6,h
M19uA
M1ػ\r
M2\e>(G0
M5D:\t
M6%:V\b
M8J<^N
M8L+M0L
M9,<o
M9w0v'I
M::\fR6=F0
M:FWC9\a
M:F\t
M:F]T;i
M:i\r
M:mZI
M:~\aO9
M; Tz
M;=0c
M;Cis
M;D$0u
M;Iq
M;O w\n
M;O w\t
M;\vC
M;\vu.H
M;_\n0<d7
M;a)Y:cWa
M;gzѻj
M;oH|\nM;GP
M;uZ)9
M;yKL
M;y\b
M;|$ w8A
M<Z⣼je
M<g-7
M<okk
M<u\a
M<v4S=dp
M<|nZ
M=F\rp
M>9rT
M>N:hO
M>jYX
M?ؼ5T
M@9GlL
M@;\buA
M@fff
M@ňY\r5
M@ŐY\rW
M@ŔYq
M@ŤY\rM3F
M@ŤY\rSVF
M@ŤY\rr
M@ŨY\rh
M@ŰYM
M@ŲYMl
MA!;b
MAh9k
MB (100.00
MC'<x
MC|D\t
MD#Έb3}D
METIS algorithm at reorder step is turned ON
ME\r<*j
MFغBV
MHLcC\bI
MIC_LD_LIBRARY_PATH
MK&;A
MKLROOT
MKL] [MIC %02d] [AO %s %s Time] %f seconds
MKL] [MIC %02d] [AO %s %s->%s Data] %llu bytes
MKL] [MIC --]   [AO %s Workdivision] %s
MKL] [MIC --]   [AO Function] %s
MKL_CBWR
MKL_DISABLE_FAST_MM
MKL_DOMAIN_ALL
MKL_DOMAIN_BLAS
MKL_DOMAIN_FFT
MKL_DOMAIN_NUM_THREADS
MKL_DOMAIN_PARDISO
MKL_DOMAIN_VML
MKL_DYNAMIC
MKL_ENABLE_INSTRUCTIONS
MKL_FAST_MEMORY_LIMIT
MKL_MPI_PPN
MKL_NUM_STRIPES
MKL_NUM_THREADS
MKL_SOMATCOPY(%c, %c, %zu, %zu, %f, %p, %zu, %p, %zu
MKL_VERBOSE
MKL_VERBOSE %s %s\n
MKL_VERBOSE WARNING: %s\n
MKL_VERBOSE oneMKL %d.%d
MKL_VERBOSE_OUTPUT_FILE
ML;\rN
MM/dd/yy
MM<-r
MM[<\fb
MM\v;S
MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON
MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON
MO=#II
MOVDIR64B
MOVDIRI
MOy:O
MP9'/r
MP;4nf
MP;H(s\bD
MP;H8s\bD
MP>9(4
MPH+uXK
MPI_LOCALNRANKS
MPL+uXI
MPuAH
MPŰYM
MPżWU
MQ8;q\b
MQO;AG
MR:}U8
MS:DP
MSRLIST
MVC9bj
MW(;a\v
MW\\;yP
MXCSR
MXI+MPI;L
MXL+MPL
MXL+MPM
MYZ=t
MZC;\b\n
M\\Z:Zc
M\a>LmB
M\abQ|H
M\bH;z\b
M\bH;{\br A
M\bbA|H
M\e"<Pp
M\e;C3B:r
M\fC:E
M\fbA|H
M\nbQ4HV
M\nbQ|H
M\r=e
M\rb"eH
M\rbQ|H
M\t<T3
M\t\f
M\tbA\\@YE\fbbu
M\tbA|H
M\tbb
M\v\bdL\v\r
M\vb"5H
M\vbQ|H
M]k9đ9;,h
M`u\vfE
M`ňY\rA
M`ňY\rO
M`ŤY\rl
M`ŨY\rPL
Ma%=sQ
Making IPARM(16) comply with IPAR(1) and IPAR(15
Making IPARM(17) comply with IPAR(1) and IPAR(15
Making IPARM(18) comply with IPAR(1) and IPAR(15
Making IPARM(19) comply with IPAR(1) and IPAR(15
Making IPARM(20) comply with IPAR(1) and IPAR(15
Making IPARM(21) comply with IPAR(1) and IPAR(15
Matching is turned ON
Matrix checker is turned ON
Max split depth
MaxRealTimeComputeUnits
MaxRealTimeComputeUnits2
Maximum fill-in input parameter is greater than or equals
Maximum memory requested that can be used=%llu, at the size=%u
McA\bHc
McD$lL
McL$l3
McL$lI
McL$lL
McU\fMc
Mc\rL
MessageBoxA
MessageBoxW
Mf:\nVD:1
Mfffff
Mh<<l
Mhttp://crl3.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0S
Mhttp://crl4.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0
Microsoft Visual C++ Runtime Library
Min node overlap
Minimal supported version of the memkind library is 1.1.0
Minimum degree algorithm at reorder step is turned ON
Mi̻OT
Mj: <;e
Mkd;`8
Mkλ\f
Ml><\rm
MlJ;DhE
MmE;=\t
Mn,<e
MnY>g
Mnݺ?K
Monday
MpL;kxr
Mp\e<I⩼K
Mpqba}Npɱb
Mprim/s
Mpu\vfE
Mp±ba}Npѱb
MpňY\rd
Mpȱb!}Np1b
Mpбb!}Npqb
Mpܱb!}Np
Mpݱb!}Np
Mpޱb!}Np
Mp߱b!}Np
MtR:gTK9
MultiByteToWideChar
Mw黋hºY
Mx=;81
MxI;Mpt5
MxI;Mpt6
M{<g5\b
M~ӻeD\r
MÅ9bs
M˻Voû9B
Mѻf'N
MԺXH:U
Mވ;TI
N 6:f
N 9M L
N < 2*SIZE
N"7<aX3
N()8Ix
N(+N0
N(+N0A
N(A+N0
N*;eaL;A
N+h:J\t
N-<odm
N.9c\fu
N0M;u\b
N0M;}\b
N0l;g\a\n
N12:T\rz
N2Lɭ3
N3;:qV
N5:<3
N7w:\a
N8=?3w
N9T,8vgM
N9T,8voM
N9Ɏm;q
N9ꚨ9*x
N:"l9;H0
N:&kK
N:,ZX
N:6hҺI
N:@ok
N:Bnz:l
N:I\n
N:\fJ
N:d$p9
N:xV 9lwm:L
N;2]P
N;:3S
N;EN\f<Wm
N;\eu\t;oV
N;yF(;d
N<(MAX_RING_FACE_VALENCE
N<<O0
N<MAX_PATCH_VALENCE
N<R*NbJ*HI
N>?mt
N>O=I9
N?6;\t9
N?m;WN\n
NA;Re0
NAN(IND
NAN(SNAN
NB;9*\e
NC<\r&O
NCŻrB
NEչ;F9
NF-;FE
NGV:ps
NHv<\b4
NK"<4
NK=XiG
NNLUNNLNNLNN
NNNNLNNLNN
NNNNLNNRNN
NNNNLUNNNN
NNNNNLNLNN
NNNNRLNNNN
NNNNRUNNNN
NNNNUNNLNN
NNNNUNNRNN
NO+;p
NP:DJt
NRNLLU
NS[;\br
NU:tv
NUֺRv
NVG<j
NW;Jʘ:I
NWW=D
NZt>R
N\a7>YP
N\bHc]\f
N\bL91u
N\bYL$\\b
N\bYt
N\bYt$ b
N\eh;nD
N\f<5\e
N\fňYEP
N\n<6,u
N\n<g蚻=sM;Ez
N\n>m
N\v;S
N\vk;d5
N\vxV
N`LcF M
Nb!L@X
Nb!|H
Nb!}Hp
Nb!}HpǱb
Nb!}Ip
Nb!}Jp
Nb!}Kp
Nb!}Lp
Nb!}Mp
Nb!}Np
Nb!}Op
Nb"5@6
Nb"5Ce
Nb"]Oe
Nb"uMe
Nb1|H
Nb1}Hp
Nb1}Jp
Nb1}Kp
Nb2\rOe
Nb;f4
Nb<]f
NbA|H
NbA}Hp
NbA}Jp
NbA}Kp
NbA}Lp
NbA}Mp
NbA}Np
NbA}Op
NbB-Be
NbB-Ce
NbBMKe
NbBUCe
NbB]Me
NbBeDe
NbBmDe
NbB}Me
NbQ|H
NbQ}Jp
NbQ}Kp
NbQ}Lp
NbQ}Mp
NbQ}Np
NbQ}Op
NbR5Ce
NbRMKe
NbR]Me
NbR}Me
Nba|H
Nba}Hp
Nba}HpP
Nba}Jp
Nba}Kp
Nba}Lp
Nba}Mp
Nba}Np
Nbb5@6
NbbE@6
NbbUMe
Nbb}Me
Nbq\\HX
NbqdHX
Nbq|H
Nbq}Hp
Nbq}Jp
Nbq}Kp
Nbq}Lp
Nbq}Mp
Nbq}Np
Nbr%Le
Nbr%Ne
Nbr\rMe
Nbr]Me
Nbr}Me
Nc\\\b\fF
Nc|0\fA
Nehalem
NfD9d$pu
Nf\a<@\n1
Nfffff
Nffffff
Ng;a7a
NhH+N`H
NhI+N`H
Nhttp://crl3.digicert.com/DigiCertTrustedG4TimeStampingRSA4096SHA2562025CA1.crl0
Ni)9sW3
Nj7<h
Nl/7D\e
Nm,:p3
No (P)CG iterations will be performed as parameter
No Error
No ErrorH
No FGMRES iterations will be performed as the limit for the iteration counter
No such kernel in program
No transpose
Node overhead
Non-unit
Not a square matrix
Not enough memory for OOC mode
Not enough memory to allocate work array in %s\n
Not enough memory to transpose matrix in %s\n
November
Npqba}Mpɱb
Np±ba}Mpѱb
Npȱb!}Mp1b
Npбb!}Mpqb
Npܱb!}Mp
Npݱb!}Mp
Npޱb!}Mp
Np߱b!}Mp
Nq);p
Nr维iT
Nso<Uh <[EF
Number of CPUs: %i
Number of columns less than one
Number of cores: %i
Number of items read=%d
Number of items read=%lli
Number of nodes
Number of nodes in corresponding non-split BVH
Number of non-zeros greater than nRows*nCols
Number of non-zeros less than nRows
Number of rows less than one
Number of tests: %i
Number of threads: %i
Number of triangle refs
Number of triangles
Number of unknowns computed in backward solving step
Number of unknowns computed in forward solving step
Nv<v\b
Nwܻ[Q
Nx || (Ny && Nz
Nxr;z}C
NzQ759
NÒ9a/ֺG
NʹKwR
Nʼ8\r
NʽqQ;<b
Nйh4L
Nѫ8F k
NӹE0ٺ[YF
N֖<Hj
NֻM?c
Nސ:aG
N߈<7m\e
N꺑了9w
O +O0
O 9M A
O <6qﻁ?8
O!9u\tr
O"<Fox
O%<bZ7
O&G=GM
O(+O0
O(+O0+M
O(D;O,L
O*u;C
O+ԻFcU
O,;42
O/;2R
O/M:Yj
O0S:#Q
O0Ő_G
O2\r:T
O3 <9
O34<u
O3<\rL
O7;CN\a
O8eq۹9
O9:\e
O9>g+̾F~C
O9k\eL;7
O:L`z;6G
O:OI\t
O:XZ0
O:\rI
O:j\vκ\f6
O:n%I
O:n&c
O;)Kh97H
O;0JV
O;3eu
O;>Kf
O;EMX:L1
O;Q;0S
O;xY~:3
O;ʊZ9I
O<+Ch
O<I8r<55
O<PTS
O<RoL
O<\nm\a;U
O<o|x
O=Эl=rf
O>'Nz
O>A\v
O>a4\e
O@H+GHH
OB9>&L
OC;Ox
OE:;Cmɺn
OF<;AX
OFȻQ=\n
OI2;#C#8T9
OI>4v
OK;)n
OMPI_COMM_WORLD_LOCAL_SIZE
OMP_NUM_THREADS
OMs9Gr
OP4=q
OPH;OXw
OPň_G
OR<nNE
OS<\eoS
OT9IGU9
OU=\t9
OUA:\v
OXH+OPI
OXH;OPt
OXL+OPI
OY;;T
O\a\btV\a
O\bH99u
O\e{dP\r<u
O\r?e
O\ru>O\r
O\v⼋G
Obk:nz
OcE9H
Oci;60
October
Od:KF
Of ;EKr
Offffff
Oh6>I
Oh:t84;˴A
Oh;1O
Oi;Ǒs
Ok˻\n}4
Ol\f>k
Ol{gN
Om;Fq29"U
Oo<C`2
Oos<"m
Ooy:G9c
OpenCL compile failed:\n\n%s
OpenCL.dll
OpenProcessToken
OriginalFilename
Osq<%\e
Otherwise, set the 1st and the 2nd character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, set the 3rd and the 4th character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, set the 5th and the 6th character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, the Poisson solver may fail to proceed
Ou:|J\a
Ou=g[P
Out of Memory
Out of core Mb
Out of core time (in percent
Out of memory
OutputDebugStringA
OutputDebugStringW
Overflow
OwR<H
Oxb;V
Oy;_R\n
OyR=MI
OyT]Z
Oz;80\b
O}'<soV
O}Q;\ec
O}|8x
OŸdxp
Oȹa5\a
OȺaOι/x7
Oɻ\fS
Oλh%S
Oμ\btF
OϺ+i1
Oջ\fN
OܼRZȼS:S
OܼYGƼ9
O춻_xB;d
P ;Q8t
P#8\bUo
P$;5vc
P%8=R
P%;7vy
P&u:.Qs
P':Udo
P)e:J
P*;0pz
P+z;%\nP9
P,9E5
P.<dcm
P.T:X
P2<C.s
P4Ի.Co
P5=BM
P7%Cs
P7*;Y
P7g<hVB
P88EB8j
P90p»N2
P9ue!9
P9v_W
P9vۊ:y
P:;VNZ
P:KH2;v`\n
P:PYi
P:bB|:N^i
P:c!F
P:glm9
P:o!w
P:o/9
P;-sp;Q
P;2p-:cY
P;5\t
P;9G\b
P;:u6
P;;%z9P
P;;uD
P;HSr=P65
P;\eZ
P;nRǻ\b
P;ތh9
P<6{e
P<;pVq;y
P<_zûx8
P<x:C
P<zZ\t
P=X&a
P=id1=u
P> {r
P>FDO=mJg
P>q_Y
PARDISO Internationalization error. Message %d is unknown
PARDISO Internationalization error. Message %lli is unknown
PARDISO PERFORMANCE WARNING: Insufficient memory to obtain solution with %d nrhs in single step.\n    RHS will be split in %d parts with %d columns maximum.\n    To optimize performance increase MKL_PARDISO_OOC_MAX_CORE_SIZE (now: %dMB, should be %dMB
PARDISO PERFORMANCE WARNING: Insufficient memory to obtain solution with %lli nrhs in single step.\n    RHS will be split in %lli parts with %lli columns maximum.\n    To optimize performance increase MKL_PARDISO_OOC_MAX_CORE_SIZE (now: %lliMB, should be %lliMB
PARDISO error: internal error
PARDISO error: unknown bit size of pint
PARDISO is running in In-Core mode, because iparam(60)=0
PARDISO is running in In-Core mode, because iparam(60)=1 and there is enough RAM for In-Core
PARDISO is running in Out-Of-Core mode, because iparam(60)=1 and there is not enough RAM for In-Core
PARDISO is running in Out-Of-Core mode, because iparam(60)=2
PARDISO message: Interrupted by the mkl_progress function
PARDISO_OOC_CLOSE_FILE_ERROR occurred: %s
PARDISO_OOC_DELETE_FILE_ERROR occurred: %s
PARDISO_OOC_NUMBER_OF_READ_EQUAL_ZERO occurred: %s
PARDISO_OOC_NUMBER_OF_READ_NOT_EQUAL_COUNT occurred: %s
PARDISO_OOC_NUMBER_OF_WRITE_EQUAL_ZERO occurred: %s
PARDISO_OOC_NUMBER_OF_WRITE_NOT_EQUAL_COUNT occurred: %s
PARDISO_OOC_OPEN_FILE_ERROR occurred: %s
PARDISO_OOC_OPEN_MODE_FILE_ERROR occurred: %s
PARDISO_OOC_READ_EOF_ERROR occurred: %s
PARDISO_OOC_READ_INPUT_PARAMETERS_INCORRECT occurred: %s
PARDISO_OOC_READ_SEEK_ERROR occurred: %s
PARDISO_OOC_WRITE_EOF_ERROR occurred: %s
PARDISO_OOC_WRITE_INPUT_PARAMETERS_INCORRECT occurred: %s
PARDISO_OOC_WRITE_SEEK_ERROR occurred: %s
PA^A]A
PA_A^A
PA_A^A]A
PAq=?Mp
PBNDKB
PC6>g
PC<C\r
PCLMULQDQ
PCONFIG
PCż<0
PD9H t
PD@?h
PE3\tFDD
PE:WGO
PE:[U
PE:ߴf
PG;82
PH9MHH
PI+@HH
PJ;I:qE
PJ;ug5;mɤ:|\r6
PJ<\f>ʻTH0
PKS;L
PL;t$h
PL>\e7J
PLci\fM
PM<H\eW
PME<NT
POPCNT
PO˴@N
PPPPPPP
PQLNQQPQPP
PQN;n
PREFETCHI
PS;RG
PSMGGLNNPUFULQUNNFQUULLQPUNNFULQRNPUULQUFFLNLLQRNUULUQPUFFLNFLLQRNPUULUQPUFFLNLULQRNPULULQUNNFLLQRNULULUQPUNNFFLLQRNPULULUQPUNNFLULQRNPUULQUPQPUUUUNNQUFLUPUNNFPLLUUPQUNNFLUPLTQULUPUNNUUPLTULULPQUNNFUUPLTQULULPQUNNULUPLTQUULUPUNNFUUPLTUULULPQUNNFFUUPLTQUULULPQUNNFULUPLTQULLQUPQPLLLGGGG
PS~;ok
PT:\bnL
PTWRITE
PT`zYu
PUUUUU
PV:R3\f
PX2?q\v
PZ)>0X\b
P\aX=db
P\bG<A\f2
P\bJ<"ac
P\eR;g
P\rT91
P\rbA
P\t:YN9
P\tt\f8C:u\aH
P\v;I7\f
P\vT8D5
P\v˻b
P]A_A
P]A_A^A
P]DSH
P`H+PXH
P`m8ս\t
Parallel Direct Factorization is running on %d MPI and %d OpenMP per MPI process
Parallel Direct Factorization is running on %d OpenMP
Parallel Direct Factorization is running on %lli OpenMP
Parallel Direct Factorization with number of processors: > %d
Parallel METIS algorithm at reorder step is turned ON
Parameter ?PAR(1)=%e (the size of the domain along x-direction
Parameter ?PAR(2) was probably altered by mistake outside of the routine
Parameter ?PAR(2)=%e (the size of the domain along y-direction
Parameter ?PAR(3)=%e (the size of the domain along phi-direction
Parameter ?PAR(3)=%e (the size of the domain along z-direction
Parameter ?PAR(4)=%e (the size of the domain along theta-direction
Parameter ?par[0]=%e (the size of the domain along phi-direction
Parameter ?par[0]=%e (the size of the domain along x-direction
Parameter ?par[1] was probably altered by mistake outside of the routine
Parameter ?par[1]=%e (the size of the domain along theta-direction
Parameter ?par[1]=%e (the size of the domain along y-direction
Parameter ?par[2]=%e (the size of the domain along z-direction
Parameter DPAR(5)=%e should be positive
Parameter DPAR(7) was probably altered by mistake outside of the DFGMRES
Parameter DPAR(7) was probably altered by mistake outside of the DFGMRES routine
Parameter DPAR(7)=%e should not be negative
Parameter IPAR(1) is not equal to the parameter N
Parameter IPAR(1) must be a positive integer
Parameter IPAR(1) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(1)=%s is not equal to the parameter N=%s
Parameter IPAR(1)=%s must be a positive integer
Parameter IPAR(10)=%s is not in the admissible range {0,1,2
Parameter IPAR(11)=%s (the number of intervals in phi-direction
Parameter IPAR(11)=%s (the number of intervals in x-direction
Parameter IPAR(12)=%s (the number of intervals in theta-direction
Parameter IPAR(12)=%s (the number of intervals in y-direction
Parameter IPAR(13)=%s (the number of intervals in z-direction
Parameter IPAR(14)=%s is not in the admissible range from 1 to
Parameter IPAR(14)=%s should be equal to 0 before the first call to
Parameter IPAR(15)=%s should be positive
Parameter IPAR(15)=%s should be positive. If you wish to run the
Parameter IPAR(16) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(16)=%s must be a positive integer
Parameter IPAR(17) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(17)=%s must be a positive integer
Parameter IPAR(18) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(18)=%s must be a positive integer
Parameter IPAR(19) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(19)=%s must be a positive integer
Parameter IPAR(20) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(20)=%s must be a positive integer
Parameter IPAR(21) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(21)=%s must be a positive integer
Parameter IPAR(23) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(23)=%s must be a positive integer
Parameter IPAR(3) must be equal to 1 before the first
Parameter IPAR(3)=%s is not in the admissible range {0,1,2
Parameter IPAR(3)=%s should be equal to 1 before the first call to
Parameter IPAR(4) must be equal to 0 before the first
Parameter IPAR(4)=%s is not in the admissible range {0,...,15
Parameter IPAR(4)=%s is not in the admissible range {0,...,63
Parameter IPAR(4)=%s should be equal to 0 before the first call to
Parameter IPAR(4)=%s was altered outside of the routine or commit
Parameter IPAR(5) must be greater than or equal to 0 before
Parameter IPAR(5)=%s is not in the admissible range {0,1,2
Parameter IPAR(5)=%s should be greater than or equal to 0 before the first
Parameter IPAR(6)=%s is not in the admissible range {0,1,2
Parameter IPAR(7)=%s is not in the admissible range {0,1,2
Parameter IPAR(8)=%s is not in the admissible range {0,1,2
Parameter IPAR(9)=%s is not in the admissible range {0,1,2
Parameter ipar[10]=%s (the number of intervals in phi-direction
Parameter ipar[10]=%s (the number of intervals in x-direction
Parameter ipar[11]=%s (the number of intervals in the y-direction
Parameter ipar[11]=%s (the number of intervals in theta-direction
Parameter ipar[12]=%s (the number of intervals in z-direction
Parameter ipar[2]=%s is not in the admissible range {0,1,2
Parameter ipar[3]=%s is not in the admissible range {0,...,15
Parameter ipar[3]=%s is not in the admissible range {0,...,63
Parameter ipar[3]=%s was altered outside of the routine or commit
Parameter ipar[4]=%s is not in the admissible range {0,1,2
Parameter ipar[5]=%s is not in the admissible range {0,1,2
Parameter ipar[6]=%s is not in the admissible range {0,1,2
Parameter ipar[7]=%s is not in the admissible range {0,1,2
Parameter ipar[8]=%s is not in the admissible range {0,1,2
Parameter ipar[9]=%s is not in the admissible range {0,1,2
Parameters IPAR(1), IPAR(15) and IPAR(16) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(17) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(18) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(19) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(20) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(21) have incompatible values
Parameters IPAR(4)=%s and from IPAR(5) to IPAR(10) equal %s, %s, %s, %s, %s, %s do not agree
Parameters IPAR(4)=%s and from IPAR(5) to IPAR(8) equal %s, %s, %s, %s do not agree
Parameters IPAR(5)=%s and IPAR(6)=%s do not correspond to each other
Parameters IPAR(7)=%s and IPAR(8)=%s do not correspond to each other
Parameters IPAR(9)=%s and IPAR(10)=%s do not correspond to each other
Parameters are set to
Parameters ipar[3]=%s and from ipar[4] to ipar[7] equal %s, %s, %s, %s do not agree
Parameters ipar[3]=%s and from ipar[4] to ipar[9] equal %s, %s, %s, %s, %s, %s do not agree
Parameters ipar[4]=%s and ipar[5]=%s do not correspond to each other
Parameters ipar[6]=%s and ipar[7]=%s do not correspond to each other
Parameters ipar[8]=%s and ipar[9]=%s do not correspond to each other
Patch %d
Pb!|H
Pb3]A
PbQ;y
PbQ}Hp
Pba~\b
Pbb=\b
Pc;J,Z
Pc<mf\t
Pd=J=j
Pe?9ȭ9
Percentage of computed non-zeros for LL^T factorization
Performance Summary (GFlops
Periodic boundary conditions can be used only for a pair of boundaries simultaneously
Permutation contains %d multiple element pairs (first: %d -> %d
Permutation contains %d multiple element pairs (first: %d -> %ld
Permutation contains %d out-of-range elements (first:  %d -> %d
Permutation contains %d out-of-range elements (first:  %d -> %ld
Permutation contains %lli multiple element pairs (first: %lli -> %lli
Permutation contains %lli out-of-range elements (first:  %lli -> %lli
Permutation is inconsistent
Pffff
Pfffff
Pffffff
Ph=\tcw
Phttp://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt0\t
Pl;=r
Pl>FE\e
Platform
Please contact Intel oneMKL Technical Support and provide as many details as possible
Pm<̱g
Pn_;A\fݺ9
PoԻ\b
PpH;G\btpH
Pr3<1
Precision
Preprocessing with input permutation
Preprocessing with multiple minimum degree with constraints
Preprocessing with multiple minimum degree, tree height
Preprocessing with state of the art partitioning metis
Press Retry to debug the application - JIT must be enabled
Probably the data were altered by mistake outside of DCG routine
Probe clustering complete. (%lld probes, %lld clusters
Proceed with (-value) if IPAR(7)>0, aborting otherwise
Product
ProductName
ProductVersion
Program
Ps >O2
PsӼ{Q
Pt*9Z
Pt\n<et
Pt\v<et\fA
Pv\f;n
Pw;D\a
PwK:7
Px$9ϧH;[Fs;M:B;6
Px:1IN
Px\e=5
Pxm=b
Pz}b!\n
P{;tiO
P{\b80\r
P}W9c\n
P~|94
PŘY}p
PŠYM`ŀY
Pũ;jR
Pƹ:HV9b/x
PʽJX@=1\b
Pꁺz1\r
Pﺜkn;TB
Q ba|\b
Q g;#a39e
Q!k8 źY
Q!l$P
Q)9&T
Q)G>v
Q*;9fͻ5
Q*\n8
Q,9mv
Q.>39
Q09ز1
Q0\n;Q
Q2;Wg
Q2\v>r
Q5rHg
Q6:%E
Q6:jkf
Q8+<\rp
Q8:@uZ9
Q8Kڐ:s
Q9-LM
Q99Ȋ9o
Q: 䙻l^K;v
Q:(ky
Q:@8R
Q:D=J
Q:Xji
Q:nDa
Q:|mH9
Q;3ң9
Q;9\e
Q;i\t4;8
Q;k$K
Q;rP,;9
Q;v#N
Q<6;˹hs
Q<Ee5
Q<LL㻷M
Q>)Hu
Q>.3Z
Q>9;D
Q?;4v
QA;ll
QC<CL\a
QCN:J
QC{;b
QDI:w
QF<k\nϻ,O
QF<wt9
QGջ}7;T
QH;Af;=jlG
QHI+Q@L
QI);mF
QJI?me
QJr<h$4
QJ ~;F$I
QK[;pe
QL"<z
QLNPRT
QM:&WJ
QO<^UC
QQH:Nj
QRAPAQ
QRU=$m
QS:o|2
QT;3RB
QUٻtv
QW1<|KؼY
QXX9l
QXz<%V
Q\a:RM6
Q\a\btX\aj3S
Q\aba~\b
Q\bI9Q\bu
Q\bba~\b
Q\f:z
Q\fba|\b
Q\fba~\b
Q\v=\tx\a
Q\v>'QP
Q\vb!f\bX
Q\vbaN
Q\vba~\b
Q]2<4
Q`1<l3
Q`H+QXH
Q`O;F
Qa;\rE
Qa湥\fY
Qc<rGP
Qd~;lM
Qffffff
Qg;]bĺn
Qg\t;\b
Qg󻤍f<P
Qhttp://cacerts.digicert.com/DigiCertTrustedG4TimeStampingRSA4096SHA2562025CA1.crt0
Qh٢%v
Qi9<`N
Qi<;qӼf
Qj2<2
Qkkbal
Qk}9UHĻP
Qlp9iFٺ[Uk
QlغT7G
Qm9\b
QoF9vG
Qp:P3W
Qp;4^B
Qp\v;\f
Qq@<k`9
Qt"=3
Qu;|k99
QueryPerformanceCounter
QueryPerformanceFrequency
QwI;2
Qx$=nE
Qx:+BF
QzhÐ;3
Q{:re
Q~N;I
QĹh1F96(6
QŌ=ZF\a
QȻP1L
Qɼf+l
Qѻ6,L
Qڊ;\e 8
Qܼg1Z
Q於o~t<z
R!;6K
R$ba|\b
R$p;K
R&0 0
R&:1L
R&ٺrO
R(ȻTL
R+<cD
R-;\rqE
R-L;4
R-b:Z
R0<^2
R0<`6
R2<S1r
R3#;q
R3:#6
R4.:;bF
R6;:E膺8
R6;S+O
R8?Bh9
R8bXźN
R8sjz9
R8|=r
R9.vӹ\a
R9=Io9<}D5
R9A\f\f
R9D:U
R9NPh
R9Wd9
R9m>,P
R:7=K
R:=uo
R:o1j
R;F\n
R;JIG
R;[x~9\fA
R;g\eN
R;zY<h
R;ĹmS
R<jeźO%4
R<l6y=E`0
R<omۻ@} :zhg
R=xRl
R>B/e
R>z☿i
R@L;GHr
RA4;9
RAA;z\b
RAO_INT
RC=hb
RCF;Z
RD=6>k
RDATA
RDRAND
RDSEED
RE\n;zD
RF:9RL
RFVLFV
RH<PX\e<ڀ=2Bk
RHлBnk
RIQ:az
RK>VWI=N
RM:PS
RN;Q5u
RNP=eN
RO;Uk
RPܻ=K
RRG<F0
RRX8Cv
RTC_GEOMETRY_TYPE_GRID is not supported
RTC_GEOMETRY_TYPE_POINT is not supported
RTC_GEOMETRY_TYPE_USER is not supported
RX;u1n
R[<bRl<v`p=4
R[N;n
R\aba|\b
R\b+z\bA
R\bba|\b
R\bbb
R\ebA|\b
R\fba~\b
R\fӻA@\t8
R\nK9r#M
R\nba|\b
R\r4:BF
R\r;C
R\rp\f`\v0
R\rp\f`\vP
R\rϺi\aC
R\t:f3
R\tba|\b
R\v:V
R\vۊk
R`Q<l\r
R`bA|\b
Ra;-jf
Ra\e:dB
RaiseException
Rb=ib>>s
Read failed
Read type=%d
Read type=%lli
ReadConsoleW
ReadFile
Reb;,9
ReceiverPosition
Reduction for efficient parallel factorization
Ref duplication
RefitBounds
Release
ReleaseSRWLockExclusive
Replicated array -- copy in process (%d,%d
Requested options conflict
ResetEvent
ResetEvent failed
Residual checks FAILED
Residual checks PASSED
RhbR%H6
RiF7B4
RjԻ6bM
Rk/<r
Rn黵_s9
RoInitialize
RoUninitialize
Row-replicated array -- copy in process row: %d
Rowwise
Rp3\tD$4I
Rs\e>$i
Rt>Y\v
RtlCaptureContext
RtlGetVersion
RtlLookupFunctionEntry
RtlPcToFileHeader
RtlUnwind
RtlUnwindEx
RtlVirtualUnwind
Rx.:M
RxL;l$P
RyV;I7
Rzh;~օ9%SP;iO
R~R;o
RĢ: x
RźE_M:j
RƺZWg
R˷cu*:Q
R֞:PC
Rݻ\eYP
R􂻬9ɻ1
S * numSamples) + (i * numSamples) + sample];\n    }\n\n\timpulseResponse[(batch * numChannels * numSamples) + (channel * numSamples) + sample] = value;\n}\n
S \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localkeys.x; \n            keys[newoffset.y] = localkeys.y; \n            keys[newoffset.z] = localkeys.z; \n            keys[newoffset.w] = localkeys.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localkeys = ((__local int4*)keys)[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals = ((__local int4*)keys)[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n        int4 bin = (localkeys >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.x; \n            out_values[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.y; \n            out_values[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.z; \n            out_values[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.w; \n            out_values[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        scanned_histogram[localid] += sum; \n    } \n} \n \n \n__kernel void compact_int(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_g
S$\r;ua
S%2;n
S%R;1mi
S)<:GO;4W
S,f<Ma
S-K=5
S0<CwS
S19=-o
S1<H6Y
S2<!fE
S2D<U
S38u\f
S76ƛ:G
S7;31
S8-pԺ7g
S8pŕ:r3\t
S8}!H
S8}$H
S9US}9Do
S9\e1ƺx_u;d
S9b,T:G
S9bmD:M
S:5\fI
S:RRݻʇE
S:^6O
S:a5B
S:jg.;O
S:nHJ
S:orA
S:tJ\a
S:u{q
S;AT5
S;ThM
S;XUѺ\r
S;\nKa
S;\vK
S;p\eg:ya
S<0M\e
S<;NI
S<DQӽ?\aQ
S<dl\f
S<dxU
S=E砽\f4\v
S>$hkDh$h>[2
S>ɽ\v5R
S?ۺuj
S@bR5@6
S@bR=@6
SATAUAVAWH
SATAUAVAWUH
SATAUAVH
SATAUAVUH
SATAUAWH
SATAWUH
SAVAWH
SAVAWUH
SAVAWUI
SBDSQR
SBx;L
SD<\fs6
SE,<1x
SELLLFFRNNULUUFFLNNU
SELLLRUNNAARLNN
SE˻E\f
SG;t'\e
SGEBD2
SGEBRD
SGELQ2
SGELQF
SGEMMT
SGEMQR
SGEQR
SGEQR2
SGEQRF
SGESVD
SGETSQR
SHA512
SHARED TESSELLATION CACHE
SIVE_PART_4(float) \n \nDEFINE_DISTRIBUTE_PART_SUM_4(int) \nDEFINE_DISTRIBUTE_PART_SUM_4(float) \n \n/// Specific function for radix-sort needs \n/// Group exclusive add multiscan on 4 arrays of shorts in parallel \n/// with 4x reduction in registers \nvoid group_scan_short_4way(int localId, int groupSize, \n    short4 mask0, \n    short4 mask1, \n    short4 mask2, \n    short4 mask3, \n    __local short* shmem0, \n    __local short* shmem1, \n    __local short* shmem2, \n    __local short* shmem3, \n    short4* offset0, \n    short4* offset1, \n    short4* offset2, \n    short4* offset3, \n    short4* histogram) \n{ \n    short4 v1 = mask0; \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y; \n    shmem0[localId] = v1.w; \n \n    short4 v2 = mask1; \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y; \n    shmem1[localId] = v2.w; \n \n    short4 v3 = mask2; \n    v3.y += v3.x; v3.w += v3.z; v3.w += v3.y; \n    shmem2[localId] = v3.w; \n \n    short4 v4 = mask3; \n    v4.y += v4.x; v4.w += v4.z; v4.w += v4.y; \n    shmem3[localId] = v4.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + shmem0[(2 * localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + shmem1[(2 * localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + shmem2[(2 * localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + shmem3[(2 * localId + 1)*stride - 1]; \n        } \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    short4 total; \n    total.s0 = shmem0[groupSize - 1]; \n    total.s1 = shmem1[groupSize - 1]; \n    total.s2 = shmem2[groupSize - 1]; \n    total.s3 = shmem3[groupSize - 1]; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    if (localId == 0) \n    { \n        shmem0[groupSize - 1] = 0; \n        shmem1[groupSize - 1] = 0; \n        shmem2[groupSize - 1] = 0; \n        shmem3[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem0[(2 * localId + 1)*stride - 1]; \n            shmem0[(2 * localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1]; \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem1[(2 * localId + 1)*stride - 1]; \n            shmem1[(2 * localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem2[(2 * localId + 1)*stride - 1]; \n            shmem2[(2 * localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem3[(2 * localId + 1)*stride - 1]; \n            shmem3[(2 * localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + temp; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    v1.w = shmem0[localId]; \n \n    short t = v1.y; v1.y = v1.w; v1.w += t; \n    t = v1.x; v1.x = v1.y; v1.y += t; \n    t = v1.z; v1.z = v1.w; v1.w += t; \n    *offset0 = v1; \n \n    v2.w = shmem1[localId]; \n \n    t = v2.y; v2.y = v2.w; v2.w += t; \n    t = v2.x; v2.x = v2.y; v2.y += t; \n    t = v2.z; v2.z = v2.w; v2.w += t; \n    *offset1 = v2; \n \n    v3.w = shmem2[localId]; \n \n    t = v3.y; v3.y = v3.w; v3.w += t; \n    t = v3.x; v3.x = v3.y; v3.y += t; \n    t = v3.z; v3.z = v3.w; v3.w += t; \n    *offset2 = v3; \n \n    v4.w = shmem3[localId]; \n \n    t = v4.y; v4.y = v4.w; v4.w += t; \n    t = v4.x
SJ:U]\r
SJ;uK0
SL:o\vu
SLAQRF
SLARFT
SLASQ2
SLASRT
SLD<;d
SLY:Ca
SMٻEG
SOFA file %s contains non-zero values for Data.Delay; this is not currently supported
SOFAConventions
SORG2R
SORGBR
SORGL2
SORGLQ
SORGQR
SORMBR
SORMLQ
SORMQR
SQ@>X
SR=:\bB
SS<J\f
SSE4.1
SSE4.2
SSE43D
SSE4_1
SSE4_2
SSSE3
SSTEQR
SSYGST
SSYR2K
STJ>T
STRICT
SU;CB
SUATAVAWH
SUATH
SUAUAVAWH
SUAUH
SUAWH
SUVATAUAVAWH
SUVATAUAVH
SUVATAUH
SUVATAVAWH
SUVATAW
SUVATH
SUVAVAWH
SUVWAT
SUVWATAUAVAWH
SUVWATAUAVH
SUVWATAUAWH
SUVWATAVAWH
SUVWATAWH
SUVWATH
SUVWAUAVAWH
SUVWAUAVH
SUVWAUH
SUVWAV
SUVWAVAWH
SUVWAVH
SUVWAW
SUVWAWH
SUVWH
SUWATAUAVAWH
SUWATAUH
SUWAUAVH
SUWAUH
SUWAVH
SVATAUAVAWUH
SVATAUAVH
SVATAVAWH
SVATAVAWUH
SVATAVH
SVATAWUH
SVAUAVAWH
SVAUAVH
SVAUAWH
SVAVAWH
SVAVAWU
SVAVAWUH
SVAVH
SVAWH
SVWATAUAVAWH
SVWATAUAVAWU
SVWATAUAVAWUH
SVWATAUAVH
SVWATAUAVUH
SVWATAUAWH
SVWATAUAWUH
SVWATAUH
SVWATAVAW
SVWATAVAWH
SVWATAVAWU
SVWATAVAWUE
SVWATAVAWUH
SVWATAVH
SVWATAWH
SVWATH
SVWATUH
SVWAUAVAWH
SVWAUAVAWUH
SVWAUAVUH
SVWAUAWUH
SVWAVAWH
SVWAVAWUH
SVWAVH
SVWAWH
SVWAWUH
SVWUATAUAVAWH
SVWUATAUAVH
SVWUATAUH
SV{TIJ
SV|;Th
SVۺcj
SWATAUAVAWUH
SWATAUH
SWATAVAWH
SWATAVAWUH
SWATAVUH
SWATAWH
SWATAWUH
SWAUAWH
SWAVAWH
SWAWH
SWVUATAUAVAWH
SX<ZoG
SX<eTk
SX=fmZ
SXH+SPH
S\a>1J
S\aN>pl
S\a\btZ\a
S\aba
S\fbr}X
S\n99\f6
S\n\e;V@3
S\t=Bo
S\tbr}X
S\vl<\b
S\v˻3X
S_FORWARD_TRIG_TRANSFORM/S_BACKWARD_TRIG_TRANSFORM routine
S`H+SXH
S`Q;Udc
Safe minimum
Sandy Bridge
Saturday
Sb<DPL
Sc\\9Y
Scaling is turned ON
ScatterKeysAndValues
Scene is empty
SeLockMemoryPrivilege
Search interval [%.15e;%.15e
Search interval [%.7e;%.7e
September
SetEndOfFile
SetEnvironmentVariableW
SetEvent
SetEvent failed
SetFileInformationByHandle
SetFilePointerEx
SetLastError
SetStdHandle
SetThreadAffinityMask
SetThreadAffinityMask failed
SetThreadGroupAffinity
SetThreadGroupAffinity failed
SetThreadIdealProcessor
SetThreadIdealProcessor failed
SetThreadIdealProcessorEx
SetThreadIdealProcessorEx failed
SetThreadpoolTimer
SetThreadpoolWait
SetUnhandledExceptionFilter
Sffff
SimpleFreeFieldHRIR
Simulating reflections for %d sources, which is more than the max (%d). Some sources will be ignored
Single-level factorization algorithm is turned ON
Size   LDA    Align.  Average  Maximal
Size   LDA    Align. Time(s)    GFlops   Residual     Residual(norm
Size   LDA    Align. Time(s)    GFlops   Residual     Residual(norm) Check
Sj-;16\r9
Sj<#1\e
Sk0;1Z
Sk;|2M
SleepConditionVariableCS
SleepConditionVariableSRW
Sls<69
Sm<HF
Smc:[oT
Sn8:\bn
Sn;-\fO
Sn;\t
Solution step
Solution step (100
Solution:      Time for reading from files: %f
Some of the parameters were probably altered by mistake outside of the routine
Some of these parameters were probably altered after DFGMRES init routine
Some parameters were probably altered by mistake outside of the DFGMRES routine
Some values from IPAR(11) to IPAR(21) were probably altered by mistake outside of the routine
Some values from ipar[10] to ipar[20] were probably altered by mistake outside of the routine
Sorry, no statistics for %s in case of a diagonal matrix
SourcePosition
Sp>g8d
SplitBvh\n
Sp커斻K
Ss=pM
Ss\b>(a
St;c|B
StJ:z7
StO9>T
Statistics
Steam Audio
Steam Audio Core
Stopping parameters DPAR(1) and DPAR(2) should not be
StringFileInfo
SubGridQBVH4
SubGridQBVH8
SubdivPatch1BuilderSAH
SubdivPatch1MBlurBuilderSAH
SubmitThreadpoolWork
Success
Summary PARDISO
Summary: ( cleaning phase
Summary: ( factorization phase
Summary: ( reordering phase
Summary: ( solution phase
Summary: ( starting phase is factorization, ending phase is solution
Summary: ( starting phase is reordering, ending phase is factorization
Summary: ( starting phase is reordering, ending phase is solution
Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday
Sunday
Sv\a>6
Svڻ%W
SwitchToThread
SxH+SpH
SxH+SpI;U8w\fI
SxH+SpI;U8w\tI
Sy*>TE
System error in PARDISO
SzԺ`3
S{h;R
S~:\bz,9F
SŴ:p1i
Sƒ6jp
Sʅ;QV
SӀ:FfZ91
SӋ>x0
SӺWs\f
SԹk@Y
Sռk\r콆1
SܹS0-;\aX
S߹\rX6
S溝OƻlU
T  fB
T 6<.è7k
T :H]Z
T!;\fAI=HH
T!<qf
T" fC
T"9xh
T$ :T$0uj
T$ :T$pu2
T$ D)s
T$ H;D
T$ I;P\b
T$ bA~\b
T$ fA
T$ fD
T$ u?H
T$ ŠY
T$ ŨXE
T$":T$RuV
T$#:T$cuL3
T$$w\tE
T$(ba
T$01\t
T$09t
T$0H;D
T$0H;T
T$0I;D
T$0M;f
T$0fA
T$0fD
T$0fE
T$0ŨTD$p
T$83ЉT$8I
T$89T
T$8E+T$\bE
T$8H;T$P
T$8fffff
T$8ffffff
T$8t8E
T$8ġzYl
T$<9T$D
T$@E3
T$@HcElH
T$@fA
T$@fD
T$@fE
T$@uVH
T$Dba6
T$Dba~\b
T$H3\tD$8
T$H3ۉL$P
T$H9SD
T$HH+T$@H
T$HH;D
T$HL9
T$Hb!|H
T$PH9E
T$PH;D
T$PH;{xr
T$PHcL$LH+L$0A
T$PI;D
T$Pb!|H
T$PbA~\b
T$PfA
T$PfD
T$PfH
T$Pffff
T$Pr%H
T$Pw\t
T$Pw\vE
T$PŀW
T$PŀW%a
T$PňYu
T$PŸY
T$XH;T$P
T$XH;t$0
T$XI+T$PI;U0w\fI
T$XJ;T3
T$XL;T$ps-I
T$XL;T$ps.I
T$\bvpA
T$\fba6
T$\fba~\b
T$\fuPH
T$`A9r\b
T$`HcۉD$XHc
T$`fA
T$`fD
T$`fE
T$`ff
T$`w\vE
T$db!6
T$dba~\b
T$fb!6
T$fba~\b
T$hH;t$h
T$hJ;T3
T$hL;T$h
T$hu1H
T$pE3
T$pH9E@H
T$pH;D
T$pI;D
T$pfA
T$pfD
T$pfE
T$pff
T$pfffff
T$pw\t
T$pŨYE
T$t<tA
T$xba
T$xbb
T$xffffff
T$xuMA
T$xuQ
T%L/m
T%O;J
T( fB
T* fC
T*\abA|H
T+=\elA
T+\aba|H
T,7#1T:g
T,Z=T
T.;WLY
T/;ivJ
T1R:3
T1X;2\v
T1\\;kO
T2E:m
T2]:v
T2xġjYT2
T3:.a19
T3:\rc`:0
T4;r~c<v2
T5JW7
T8*NR:5
T8-9D
T8^<r
T8e;!RT
T8Ǽ6뽣s
T9E)y; 9o
T9Q=C
T9i5Z:\tH
T:/Iu:0
T:7*h
T:9(j9
T:I:Z
T:ZXW;10
T:\aEe
T:\ts
T:r~s8
T;9?N
T;\nb
T;f%g;An ;6
T;hD\e
T;s@K
T;лIB
T<@zɽA\fC
T<gLk:F\fX
T<p;ol
T<q\tӼ\tI
T=,Dl
T=/22
T=G\n
T=Pms
T=fQμ\n
T=f]1
T=~Mk
T>G'i>s;I
T>\fLc
T?E;EAf
T?j?Y
T@YU\bb
T@Ym\nb
TANCreateContext
TANCreateConvolution
TAz<)o
TBgvlC~0GB
TC:i5
TC>0L
TCg:G
TD;J t
TEP:$q
TEPŸTU
TG ŤT
THY-Йx
THYT\a\fb
THYɍT
TIf:'XȻz
TJ;Z6
TKS;X
TKS< R
TL;\rm
TL¼\vR
TMPŸTE
TMd;g
TN;?l
TN@ŰT
TNPŘTV
TNǻo\f
TO0ŰT
TO@ŰT\a
TOPŀTG
TOPŀTW
TOPŐTG
TOPŘTW
TOPŠTG
TOPŸTW
TQ\v;K
TS;0C
TT fC
TT.:77
TTRVLVRVVRLVRVLVRVVRLVRVLVRVRVLVTTRBVLBVRBVRBVBLVRVLVRVRVLVRFVFLVRFVRFVLFVRBVLBVRBVRBVBLVRFVFLVRFVRFVLFVRVLVRVRVLV
TTo;\t
TU fC
TV;<\fd
TV;l>n9
TWM@ŴY
TWM`ŴY
TX,"H
TX\f1L
TY,>5
T[9d%D
T\a<Vn4<rD
T\a\bba|H
T\a\bbq|H
T\a\tbQ|H
T\a\v:8
T\a\vba|H
T\b<J
T\fU;Sm
T\n( fG
T\n(v5B
T\n00N
T\n80E
T\n<a5
T\nM90A
T\n\bba|H
T\n{O<W
T\nŀTB
T\nŸTB
T\r+rJ
T\r9tm
T\rDdb
T\rY[5
T\r\f3n
T\r\trL
T\robh
T\rqUL
T\rq^j
T\rxNK
T\tƻZ
T\v8=\vO
T\v<a\a
T^9;qA
T_:4Y
Targets
Task does not fit RAM, OOC LU factorization algorithm is turned ON
Task does not fit RAM, OOC NLL factorization algorithm is turned ON
Task fits RAM, OOC NLL factorization algorithm is turned ON
Tasking
Tba:Wi
Tbߺ1h
Te;hQG
TerminateProcess
Teջ\rKD
Tf %f %f %f\n\n
Tffff
Tffffff
Tf黌:7
Th'= s\r
The CPU is not supported in this Intel oneMKL version
The absolute and relative stopping parameters DPAR(1)=%e and
The absolute stopping parameter (zero norm tolerance) DPAR(8)=%e
The absolute stopping parameter DPAR(2) is out of
The absolute stopping parameter DPAR(2)=%e is out of admissible interval [0,infinity
The computations may fail to proceed and/or The result may be incorrect
The computations may fail to proceed and/or the result may be incorrect
The data in parameter DPAR were probably altered by mistake before
The data in parameter SPAR were probably altered by mistake before
The data in parameter dpar were probably altered by mistake before
The data in parameter spar were probably altered by mistake before
The dimension of the trigonometric transform %s should be
The file %s was not opened
The file was not closed
The input vector value |F(1)|=%s is bigger than the tolerance
The input vector value |F(IPAR(1)+1)|=%s is bigger than the tolerance
The input vector value |f[0]|=%s is bigger than the tolerance
The input vector value |f[ipar[0]]|=%s is bigger than the tolerance
The local (internal) PARDISO version is                          : %d
The local (internal) PARDISO version is                          : %lli
The matrix is probably (almost) non-positive definite
The maximum number of elements for scan exceeded\n
The mesh size in the direction theta, ?PAR(2)=%e, must be positive
The mesh size in the direction theta, ?par[1]=%e, must be positive
The mesh size in the direction y, ?PAR(2)=%e, must be positive
The mesh size in the direction y, ?par[1]=%e, must be positive
The method may fail to converge
The method may fail to proceed
The number of OMP threads defined by parameter IPAR(10)=%s should be
The number of OMP threads defined by parameter ipar[9]=%s should be
The parameter IPAR(15) was probably altered by mistake outside of DFGMRES routine
The parameters were probably altered by mistake outside of the routine
The previous call to a Intel oneMKL Trigonometric Transform routine produced an error
The previous call to a Poisson solver routine has failed or has not been made
The previous call to a Trigonometric Transform routine produced an error
The problem is degenerate due to rounding errors. The approximate solution
The processor must support the Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions
The processor must support the Intel(R) Streaming SIMD 2 Extensions (Intel(R) SSE2) instructions
The processor must support the Intel(R) Streaming SIMD 3 Extensions (Intel(R) SSE3) instructions
The processor must support the Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) instructions
The processor must support the Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) instructions
The relative stopping parameter DPAR(1) is out of
The relative stopping parameter DPAR(1)=%e is out of admissible interval [0,1
The result may be inaccurate
The result may be incorrect
The solution may be wrong
The solvers_ee interval generator has failed to find the requested number of eigenvalues. Try\n increasing the number of requested eigenvalues, as this can increase likelihood of success
The tolerance parameter DPAR(1)=%e is not in the admissible range [0,infinity
The tolerance parameter SPAR(1)=%e is not in the admissible range [0,infinity
The tolerance parameter dpar[0]=%e is not in the admissible range [0,infinity
The tolerance parameter spar[0]=%e is not in the admissible range [0,infinity
The type of the trigonometric transform %s is not in the admissible range {0,...,5
The value of input tolerance parameter is negative
This binary version of the SMP LINPACK benchmark is optimized for and runs on only genuine Intel processors
This device does not support HLBVH construction\n
This is a netCDF dimension but not a netCDF variable
This message reserved for future use and should not be displayed
This->leafIntersector
Threads
Thursday
Time A to LU
Time cgs
Time fulladj
Time malloc
Time numfct
Time parlist
Time reorder
Time solve
Time spent in additional calculations
Time spent in additional calculations                            : %f s
Time spent in additional calculations                            : %f s total - sum: %f s
Time spent in allocation of internal data structures (malloc
Time spent in allocation of internal data structures (malloc)    : %f s
Time spent in allocation of internal data structures (malloc)    : %f s total - sum: %f s
Time spent in calculations of symmetric matrix portrait (fulladj
Time spent in calculations of symmetric matrix portrait (fulladj): %f s
Time spent in calculations of symmetric matrix portrait (fulladj): %f s total - sum: %f s
Time spent in copying matrix to internal data structure (A to LU
Time spent in copying matrix to internal data structure (A to LU): %f s
Time spent in copying matrix to internal data structure (A to LU): %f s total - sum: %f s
Time spent in data preparations for factorization (parlist
Time spent in data preparations for factorization (parlist)      : %f s
Time spent in data preparations for factorization (parlist)      : %f s total - sum: %f s
Time spent in direct solver at solve step (solve
Time spent in direct solver at solve step (solve)                : %f s
Time spent in direct solver at solve step (solve)                : %f s total - sum: %f s
Time spent in factorization step (numfct
Time spent in factorization step (numfct)                        : %f s
Time spent in factorization step (numfct)                        : %f s total - sum: %f s
Time spent in iterative solver at solve step (cgs
Time spent in iterative solver at solve step (cgs)               : %f s
Time spent in iterative solver at solve step (cgs)               : %f s total - sum: %f s
Time spent in matching/scaling
Time spent in matching/scaling                                   : %f s
Time spent in matching/scaling                                   : %f s total - sum: %f s
Time spent in reordering of the initial matrix (reorder
Time spent in reordering of the initial matrix (reorder)         : %f s
Time spent in reordering of the initial matrix (reorder)         : %f s total - sum: %f s
Time spent in symbolic factorization (symbfct
Time spent in symbolic factorization (symbfct)                   : %f s
Time spent in symbolic factorization (symbfct)                   : %f s total - sum: %f s
Time symbfct
Time total
Times
Timing linear equation system solver
Tj(<1Q
TjO;]eD;W
TjQ>g
Tl<W*G
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
Tm`ŔY
Tn":xH\r
To;d|\v
Total size of data transferred
Total time (100
Total time spent
Total time spent                                                 : %f s
Total time spent                                                 : %f s total - sum: %f s
Translation
Transpose
Traversable is NULL. The scene has to be committed first
Tree height
TrueAudioNext.dll
TryAcquireSRWLockExclusive
TryEnterCriticalSection
Trying to free NULL matrix
Tts;1
TtƼ_T
Tu;S{A
Tuesday
Two-level factorization algorithm is turned ON
Type Descriptor
T~780
T~=\rwZ
T~żpA
TúfW5
Tü\tFF
Tƻj\rŻZ
Tʃ;zN
TҨ>6y
Tָ/7^94LȻ5
Tٽlh\b
Tۥ<zo
Tݓ>Hmg
T㈼y2G
T溚0c;Uw
T󶹡xȺ30
U 5<'\aZ
U bA, X
U t\tAk
U w\tE
U ŐYM
U ŠYd
U";<1dP
U%bRE
U(A+U0A
U(t2E1
U)x;TJ
U*=\vPe
U,9Sn
U.2<TNM
U09\f
U0;9iS:\\K
U0<\at!A
U0A9T$0A
U0w\tE
U0żWU
U27<S
U2弇:l
U5<\aB
U6+;b
U6<F4̻K
U6w<N
U7>\nt\e
U7y;O
U8LOR9Y
U:$I=9ZLo
U:)MK
U:,D6
U:,VO9
U:6<r
U:93w
U:\eje;F7
U:\rCV
U:\vgR
U:oF,;i
U;'97
U;)f7
U;6<QY
U;A\vu
U;Bu=;7o\a
U;ES-9b
U;L]@9XbE
U;\egr
U;\tpZ
U;mRj
U<&e0
U<Os:TP
U<g<4.n
U=.m0
U=9xk
U=dh!?K
U>s82
U?q:dq
U@@53g
U@M;p\b
U@u\vfE
UA>N0Wl
UAH:dxe
UATAUAVAW
UATAUAVAWH
UATAUAWH
UATAUH
UATAUI
UATAVAWH
UATAVAWI
UATAVH
UATAWH
UATAWI
UAUAVH
UAUAVI
UAUAWH
UAUAWI
UAVAWH
UAWAVAUATVWS
UAWAVAUATVWSH
UAԻV1
UAݽ{FO
UBdn~C
UDm;hʤ<o'Z
UDź_M
UDݺ\f\b
UEͻv{\v
UF,:fAG
UF>yd
UFLUNNUF
UGݼ|Gӻc
UH#ψbc}H
UH#ψbs}H
UHG;8X
UHJ;T
UHM<g
UJ%:R\v
UNKNOWN
UNNRNNLNNRNN
UNNTTNT
UO <\n
UOW9\b
UP;;c
UPw\tE
UPżWU
UQq;"O
URn<t
US;z\tP
USATAUAVH
USAUAVH
USAUAWH
USER_MSR
USM allocation cannot be combined with OS allocation
USVATAUAWI
USVATAVH
USVATAWH
USVAUAVH
USVAUI
USVAVAWH
USVWATAUAVAWH
USVWATAUAVH
USVWATAUAWH
USVWATAUH
USVWATAUI
USVWATAVAW
USVWATAVAWH
USVWATAVH
USVWATAWH
USVWATH
USVWAUAVAWH
USVWAUAVH
USVWAUAWH
USVWAUH
USVWAV
USVWAVAWH
USVWAVAWI
USVWAVH
USVWAWH
USVWH
USWATAUAWH
USWATAUH
USWATAVH
USWATAVI
USWATAWH
USWATAWI
USWAUAVH
USWAUAVI
USWAUAWI
USWAVAWH
USWAVAWI
USWAVH
USWAVI
USWAWH
UT:N%\n
UTF-16LEUNICODE
UTc;֛b:su
UTu;HX\n;L
UTź_MP
UU;"V
UUUUUU
UUUUUUU
UV;ab
UVATAUAVAWH
UVATAUAVH
UVATAUAWH
UVATAVAWH
UVATAVH
UVATH
UVAVAWH
UVAVH
UVAWH
UVWATAUAVAW
UVWATAUAVAWH
UVWATAUH
UVWATAVAWH
UVWATAVH
UVWATAWH
UVWATAWI
UVWATH
UVWAUAVH
UVWAUAWH
UVWAUH
UVWAVAWH
UVWAVAWI
UVWAVH
UVWAWH
UV\e=o
UWATAUAVH
UWATAUAWH
UWATAVAWH
UWATAVH
UWATAWH
UWATH
UWAUAVAWH
UWAUAVH
UWAUH
UWAVAWH
UWAWH
UXI+UPH
UXI+UPI;T$0w\rI
UXI;UPt
UXJ;T
UXvjA
UZ%;w
UZ;\f{D
UZ?5t,?G
U\\:s&c9e
U\aI>^v
U\abA|H
U\af;b
U\b4>L
U\b<x/2
U\bbA|H
U\bt;X
U\fw\tE
U\nbQ|H
U\r;Z
U\t<Gd
U\t>u
U\tbA|H
U\vbA|H
U_;F6
U_d:Fd!;q
U`J;T3
U`w\tE
Ua;pr
Ua=Wf
UaK<N36
Uba4AY
Uba4BY
Uba|XZ
Ubq4IY
Ubq4JY
Ubq4XYK
Ubq<XYC
UcY:(3\b;3B
UdǺ8I
Ufj:0
Uft;]a
Ug)<pD
Ug;B"a
UhJ;T
Ujn;Lr\b
Ul;uN\\8
Ulw\tE
Um<bn
Unable to create OpenCL kernel %s. [%d
Unable to load SOFA data. [%d
Unable to load SOFA file: %s. [%d
Unable to open verbose output file
UnhandledExceptionFilter
Unknown CPU
Unknown CPU (error
Unknown error
Unknown error in %s
Unknown exception
Unsupported CPU
Unĺ\r
Uo:DR
Up;LG\t
UpHcM0I
Update %d
Upw\tE
Urp;kv6
User provided fill-in reducing permutation is turned ON
Using %d CUs for convolution, %d CUs for IR update
Using OpenCL device: %s %s (%s
Using OpenCL platform: %s %s (%s
Ut\b<u
Uu;)L
UuL;Cb
UvW;aRr
Ux;=k
UxI+UpH;S8w\fH
UxI+UpH;S8w\tH
Uzz:C\b
U{pNo
U|j;c
U|r*C
U|w\tE
UĻ@LS
Uź_u A
Uź_v A
UƹS9B9
Uɹjbs
Uк0\a
Uټo 3
U܄;r\nD
Uܹ8Q˺ז8
Uܺp(D
Uݺ;y71
U㽼T_D
V!;i5
V&ͽRU
V'Z<_2P
V(A+V0A
V)< R
V-s=Qj
V.;Yw麑\rG
V/f9% 1
V/ҺKc\v
V0z\vx
V0};ur
V38sHR
V5=os
V7:ZC
V8<W&B
V9#EM:z
V:<kv:i
V:Lj\v:9
V:bsr;\b
V:dX;:o
V:dz8
V:nfP:{&z
V:s.q
V:w1f
V;-IM:Z
V;0Lq
V;3{59
V;=dY
V;Bx\r;w
V;Gw\t
V;LwR<0
V;WU3;N
V;gs\f
V;h=vCN
V;j5X
V;wR\a
V;͞j;mm19h2u;z
V<<f06
V<D~j<s\v
V<GZs
V<`gg
V<l;Bk
V=/6R
V=2KN
V=ʸ\rAf;d
V>\aV
V>h:w
V>o6A
V?&pW?SHX?j
V?:wF
VA';e
VA7<5
VATAUAVAWUH
VATAUAVH
VATAWH
VATAWUH
VAUAVAWH
VAUAVH
VAVAWH
VAVAWUH
VAVAWUI
VCϺNp
VEa9Sk
VFổfa;'W
VHI+V@H
VKV:E
VL;B?3
VOȽGd :v
VPCLMULQDQ
VPI;VXw
VQ[;Ba
VQߺ2z
VR0;X
VS<kS
VS_VERSION_INFO
VUUUA
VUUUUUUUH
VV}:j
VWATAUAVAWH
VWATAUAVAWU
VWATAUAVAWUH
VWATAUAVH
VWATAUAWH
VWATAUH
VWATAVAW
VWATAVAWH
VWATAVAWUH
VWATAVAWUL
VWATAVH
VWATUH
VWAUAVAWH
VWAUAVH
VWAUAWUH
VWAVH
VWAWH
VWUSATAUAVAWH
VXH+VPH
VXH+VPI;W0w\fI
VXS;\n\t
V\\:SUn
V\\t;aFe
V\a=F@Y<N
V\bF\nV\f
V\bXy\bb
V\b\\a\vb
V\b\\i\bb
V\fffffff
V\fлZj
V\r9>Q
V\rO8M\n
V\tT;5
V\ta<Y
V\v6I]Dc
V\v;N
V]8iMĺÇI
V]ügHS
Valve Corporation
Vam;9lE
Vba~\b
Vc=N-\t
Vc>L\bH
Vd;kT
VeO<Qm
VeU:Z
Vg}9OE
Vh>6Q&?f
VirtualAlloc
VirtualFree
VirtualProtect
VirtualQuery
Visual C++ Compiler
Vlۼd\e
Vr<NfݼA9k
Vs:=2
Vs^<WV
Vu;ӿl
VuK<y
Vv;JQf
Vv;LL4
Vw:;u\f
VzO:ӪO
V{N;jyr
V|3<K\f9
V|;6fb
V}0<NTq:Q
Vƺ60N
Vƻ_ZV
VǽHc7
Vȼ5D<p
Vμ4R»Z
VϺBh6
Vӻ8%t;y
VԹBQZ
W A+W0A
W \aae
W%.;JtS
W%3<Wx
W%9Jo
W%BCy
W%Lgm
W%\t=DX
W%jxy
W%s2M
W%t<l#s
W%ҼMN
W&b<O3
W)9\a
W+A>zgD
W,;Yb
W,<fr
W,=gzq
W.s;j
W1a>C
W2:L3
W2ʺ`m
W2ؼFl
W35;|p
W5?Jz
W5L:q6
W6;s6
W6\tf
W8<UW
W8WAD
W8m;A
W9>58l
W9BHA9Y
W9j^!;U
W9u#3
W9}0Y
W9ЪG:D
W:'Bl;A
W:7CW
W:7eO95
W:KwӺd
W:L~V9
W:R㸹s
W:j)b;N
W:uls
W:xs`9
W;&wS
W;'8J
W;*I6
W;JJD
W;\bj\a
W;\fVA;av
W;d A
W;j\vl;A
W;ԼJ9
W<96裻\e
W<>Sa
W<XrR
W="am
W=*zd=z
W=UՒ>Sb
W>EWC
W>P$D
W@ӻhK
WAITPKG
WARNING: "Flush to Zero" or "Denormals are Zero" mode not enabled
WARNING: AdjustTokenPrivileges failed to enable SeLockMemoryPrivilege: Add SeLockMemoryPrivilege for current user and run process in elevated mode (Run as administrator
WARNING: AdjustTokenPrivileges failed while trying to enable SeLockMemoryPrivilege
WARNING: LookupPrivilegeValue failed while trying to enable SeLockMemoryPrivilege
WARNING: OpenProcessToken failed while trying to enable SeLockMemoryPrivilege
WATAUAVAWH
WATAUAVAWL
WATAUAVAWUH
WATAUAVH
WATAUAVUH
WATAUAWUH
WATAUH
WATAUUH
WATAVAWUH
WATAVH
WATAWH
WAUAVH
WAUAWH
WAVAWH
WAVAWUI
WAֹDl
WBNOINVD
WC<p\f
WCQ;ǡA
WCv;Щ29D
WD2:o
WD;N \b9f
WD<Ig
WG$85d
WHM+W@H
WIDE-KL
WJ=Q$a
WK?;7zx:i4
WN;Z2
WNd;S
WPB:YQ
WPŨYE
WQ-<P
WR-:L
WR2;D
WR;RmA
WRMSRNS
WS<_Z
WSVATH
WT=lY
WU(;O
WU3:\n
WU;t9d
WUUUUU
WVSATAUH
WXH+WPH
WXH+WPI;T$0w\rI
WX½\bT6
WXмhcO
WYֽ]a
WZp:h9!<B
W[k;W
W\b:vC0:J
W\b>xX\b5hY\b,4
W\bM;P\b
W\bfD9g\n
W\bʼ9c
W\bʼN
W\f0A
W\ns;.X
W\r +Y
W\r <h
W\r&ub
W\r+jW
W\r-vh
W\r.X
W\r/Af
W\r0*f
W\r3;I
W\r6 n
W\r9yd
W\r:pJ
W\r>0쏽W
W\rAf
W\rB,P
W\rBkP
W\rG\na
W\rH i
W\rS]4
W\rShH
W\rU\tX
W\r\\mC
W\r\voV
W\r^T3
W\r`g
W\rbOl
W\rcZH
W\rhtV
W\rkva
W\roKi
W\ro\e
W\rps
W\rq@X
W\rsEa
W\ryU
W\rz=pc
W\rziE
W\t=T\b\n
W\tL$ H
W\t˺l8
W_2;1\a
Wa:wvf
WaitForSingleObject
WaitForSingleObjectEx
WaitForSingleObjects failed
WaitForThreadpoolTimerCallbacks
WakeAllConditionVariable
WakeConditionVariable
Warning
Warning message has been written in %s
Warning: Consider use of MKL_RODFT00 instead of FFTW_RODFT00 in planning r2r transforms with FFTW3 interface to Intel oneMKL (see Intel oneMKL Reference Manual
Warning: incorrect parameter %s (%i
Wc;!42
Wd>;5\b
We appreciate your assistance and apologize for any inconvenience
We appreciate your assistance and apologize for any inconvenience resulting from
We)=D
We9 =N
Wednesday
Wg;;n
Wg~;R
Wh9<.WC
WhƹcJ\n
WideCharToMultiByte
Windows (64bit
Wj;Z;x9
Wk%;t
Wk̼;l3
WkֻTdp
Wl*<0`w
Wl;eEH
Wm:\b`a9
WnȼPQ
Woy:\v\a
Wp>;vi
Wqݻ)D
Wr95B
WrM<dr
Write type=%d
Write type=%lli
WriteConsoleW
WriteFile
Wrong number of vertices per face
Wrong parameter %d in %s\n
Wrote %d items
Wrote %lli items
Ws,<WrQ
Wv:u5B
WvQ;:Mj
WwN<&yx
Wx;GoI
Wz+9Sx
Wz{:u
W|F<u
W}U:8h
W}u;C\v7
Wí9QcW9q
WƼqѼV
WȮ9WH\r
WɄ:AaI
W̼\raq
Wκ[5J
WӚ>n2
W⊼ \t
X 843"8
X @8u/t
X UVWATAUAVAWH
X UVWATAVH
X UVWH
X UWAVH
X VWATH
X VWAVH
X VWAWH
X rwI
X"<Ikd
X&:9G
X)9/j
X,;dJ
X,;s 5;xA
X2ԺK\r6
X3g=Xx
X3ۉT$HD
X4:[447)9
X5w9}^O;}C
X69}%r
X6;H3\e
X7f:\e\r\r
X9=\f
X9\bY
X9iAy:g
X9}ٓ8e
X9ܰt:4
X:9.08
X:=Ic
X:AuI<WBV
X:\e8\a
X:\et0
X;%Cu
X;\v$p;C2
X;yb!<v
X< w\eI
X<\e1M
X<\evx
X<f<2
X<f\vw
X<o`5
X<t\eu
X=[g8>t
X=t\vu<E
X>7iad8
X>\ek
X?bq<XYE
XA(źXy
XA_A^A]A
XC\b;R_\b
XF:g.A
XG.:n8
XG;uٯ9p
XG\a<\\ 3
XHH;_0r A
XHcM0I
XHսi7
XI+@PH
XI+@PI+JPH
XI@źXy
XI\tba
XIm< A
XKO<#B
XL#@ġDY
XL$ ŀX
XL&@āLY
XL+@ġDY
XL.@āLY
XL.@ġLY
XL/ ġHY
XL0@L
XL0@āLY
XL0@ġLY
XL1@āLY
XL1@ġLY
XL2@H
XL2@ġLY
XL4@āLY
XL4@ġLY
XL6@āLY
XL7 ġHY
XL7@āLY
XL7@ġLY
XL8 ġHY
XL;@ġDY
XL>@āLY
XL\a ġHY
XLc_lA
XOK;gL
XOK;t
XP\e9
XQ\fŢXi
XR?9Dz
XRe76o
XS&=0
XSh;Yq
XT$@ŀWD$p
XT$pŨX
XT,9Иk:0
XT<ZO
XTR;|b
XU ŘX
XU@ŬX
XU`ŔY
XU`ŸX
XV27U
XW;\a
XW<\tv
XY$ŢXi
XY<(ŠYe
XY<Dm
XY\f\aŨY
XY\nba^\bXI\tb
X\\tH$5
X\a;yh
X\bUVWATAUAVAWH
X\bUVWAVAWH
X\bm;5
X\r;3
X] ŬX
X]A_A
X]A_A^A
X]A_A^A]A
X]PŨX
X`I9Xhu
X`I9XhuA
X`n:a
Xa:vE>;t
Xa\vbaN
XbS;~Y
XbbE\b
Xbt<f
Xc;FKu
Xc=+Xc=+Xc=+Xc
Xd$@fD
Xe=kme
Xe@ŌY
XeL;'2
Xeon Broadwell
Xeon Haswell
Xeon Ice Lake
Xeon Ivy Bridge
Xeon Phi Knights Landing
Xeon Phi Knights Mill
Xeon Sky Lake
XepňX
Xfffff
Xfy9q
Xhl:(D
Xi Ś\\I
Xi\fbaF
Xj:Gnw
Xl$@fD
Xl$\bba
Xl:n")9
Xl;\a\a
Xl<-W
Xm.=o9R
Xm\b?#8
Xob:ͪ\v
Xp:IH
XpI9Xx
Xq3;f\e
Xq4Ś\\aT
XqLł\\iL
Xq\fba
Xs.<(1V
Xt$ Ăy
Xt$ ŨX
Xt$,fA
Xt$,fD
Xt$0Ăy
Xt$PŠX
Xu ŬX
Xu0Ăy
Xu@ŤX
Xu`Ăy
Xu`Ģy
Xu`ŠX
Xu`ŤX
Xu`ŬX
XupĂy
Xvϻqz
Xw>YZ
Xwj:β;9
Xwǽ5c
Xx;YmƽϺ\t
X~úY9
X~ʼcg
Xʒ:5d
Xʻ6M3
X̼Y漼yh
Xͻ\t2
XыD$8D
XӺ+5q
XԻk%v
Xⷸ%PZ
Y F;R
Y H;{xr
Y a:j
Y ba|\b
Y ŢXY
Y!;yU
Y!\f8
Y!\f9
Y!g` H
Y$:7l
Y%&nt
Y%2;+5n9
Y%:nFh
Y%AJE
Y%Aab
Y%BBG
Y%KZb
Y%\raF
Y%\rkF
Y%\to0
Y%a0L
Y%a[G
Y&:hj
Y&<b2B
Y'̺3T
Y(H;{xr
Y*<5Y
Y+9)K
Y-D<G
Y-kcL
Y-w;W\rA
Y/o<Ww
Y/Ļoon
Y0<9m
Y0H;{xr
Y4+bA|@Yt
Y4>M&\f
Y4ba~\b
Y5!EF
Y5(WO
Y5.%B
Y5;\fG
Y5AJG
Y5NqA
Y5\boA
Y5_0G
Y5bEi
Y5q0T
Y5}Yi
Y76<(\v
Y83hѺF
Y8H;{xr
Y8ba~\b
Y8~\t
Y9;H&E
Y9Q\b_9
Y9\rHN9
Y:ZhJ;*Xߺ4h
Y:aB3;Y
Y:dKb
Y:vg~9D
Y:~fw
Y;%ki
Y;/Bg
Y;9b\t;s
Y;<t2
Y;\f g
Y;\r3e
Y;\tw\f;M
Y;gk2>xQ
Y;p9f;Ԡf
Y;xbV
Y;z)k
Y<\v8X<Vh
Y<_B6
Y<ba~\b
Y=%Ej
Y=Qvk
Y=\f\eI
Y=\vMj
Y=a\bj
Y=ank
Y=u:2
Y=u<R
Y=v6L9
Y=}4A
Y>eu>>S
Y>kX>M\e
Y?;oB
Y@[9ϩs9L
Y@pŰYH0
YBT>x
YC`ňY
YC`ňYK0
YD$ H;\r
YD$ H;\rF
YD$ H;\rf
YD$ fD
YD$ ŀY
YD$ ňY
YD$ ňYL
YD$ ŨYL
YD$ ŨYM
YD$ ŸY
YD$0fA
YD$0ŀYU
YD$0ňYL$p
YD$0ŠX
YD$0ŨYL
YD$@ŠYM
YD$@ŰYMP
YD$PŠY
YD$PŨY
YD$PŨYL
YD$PŰYL
YD$`Hc
YD$`ŘTm
YD$`ŠYL
YD$`ŠYM
YD$`ŰYL
YD$pE2
YD$pMc
YD$pŀYU0
YD$pŘX
YD$pŠYL
YD$pŠYL$P
YD$pŰYL
YD> Ģq
YDؼ4g
YE ńY
YE ŔY
YE ŠYM
YE ŠYM0
YE ŤY
YE ŤYM
YE ŨY
YE ŰY
YE(<e
YE0ŰYM
YE@ŀY
YE@ńY
YE@ŌY
YE@ŨY
YE@ŨYM0
YE@ŰX
YE@ŸYM0
YEPŀY
YEPŀYL
YEPňYM
YEPŠY
YEPŰY
YE\vbQ
YE`ńY
YE`ŜY
YE`ŠY
YE`ŠYM
YE`ŠYMP
YE`ŤY
YE`ŨY
YE`ŰY
YE`ŴY
YE`ŸX
YEpŸY
YF\n<Z
YG`ňY
YG`ňYO0
YH ŠY
YH ŰY
YH0ŠY
YH0ŰY
YH@ŤY
YHH;_0r
YHS;rM
YH`ŤY
YHa>K]I
YHb=0
YI@ŨYE
YI`ŨYAP
YJ1:u
YK ŘYC
YK0ŸYC
YL!<h5
YL$ ŘY
YL$ ŘYD
YL$ ŘYE
YL$ ŸY
YL$0ŘX
YL$0ŘY
YL$0ŨY
YL$0ŰYD
YL$0ŰYE
YL$@ŀYE
YL$@ŰYE
YL$Lbb\r
YL$PŐYD
YL$PŠX
YL$PŰY
YL$`fD
YL$`ŰYE
YL$`ŰYEp
YL$pŀYD
YL$pŘY
YL$pŠYE
YL$pŨYE
YL$pŸY
YL$pŸYE
YL;Sw
YM Lc
YM ŀYU
YM ŀYU0
YM ŜY
YM ŤY
YM ŤYE
YM ŨY
YM ŨYD
YM ŬY
YM ŰYE
YM ŴY
YM ŴYE
YM ŸT
YM ŸYE
YM żYE
YM0ŊY
YM0ŰY
YM@ŌY
YM@ŐYD$p
YM@ŔYE
YM@ŜYE
YM@ŤY
YM@ŨYE
YM@ŬY
YM@ŬYE
YM@ŴYE
YM@żYE
YMPňY
YMPŐY
YMPŘYE
YMPŠYE
YMPŨYE
YMPŰY
YMPŰYE
YM\a:'Y
YM\fŒYE
YM\rbA|H
YM`ŌY
YM`ŤY
YM`ŤYE
YM`ŰY
YM`ŴY
YM`ŴYE
YM`żY
YMpŨY
YMpŰY
YMpŰYE
YMpŸYE0
YN0ŠYF
YN0ŰYF
YN0ŸYF
YNPŐY
YN\fŒYF
YNb=#uA
YNpŠYE
YNpŰYE
YNpŰYF
YNpŸYF
YO ŘYG
YO;ΝA
YO@:h
YO@ŨYD
YO`ŨYGP
YOz;7\b
YO캨9P
YPŊ\\I0
YQ0HcY
YQ<We9
YQȼzN
YR<U깺!aS
YT$ fD
YT$ ŰYL
YT$ ŰYMp
YT$0ŒYN
YT$0ŰX
YT$@Lc
YT$@fA
YT$PŠY
YT$PŨY
YT$PŰYM
YT$`Lc
YT$`ňYm0
YT$pŨY
YT0@H
YT;7]A
YU ŒYE
YU ŨY
YU żY
YU,ŚYD
YU0ŨY
YU0ŰY
YU;5Z\a<7
YU@ŨY
YUPŨY
YU\tbAD@Y}\vbBmH
YU`ŠYE
YUpŨY
YUpŸ\\E
YV,ŚY
YV;H]\b
YV;y]j;LkZ
YWw;j'w
YW˹l\b
Y[L;w
Y\\$pfD
Y\a=l
Y\aba|\b
Y\b<VS
Y\b>H
Y\b>p
Y\bba~\b
Y\e<V l
Y\f+Z\fA
Y\f.9\nX
Y\f1ġzY
Y\f>b
Y\f\aLc
Y\fba|H
Y\fba~\b
Y\nbA~\b
Y\nba~\b
Y\r =k
Y\r X5
Y\r \n\a
Y\r!cc
Y\r#9
Y\r$s\a
Y\r%4
Y\r%6B
Y\r%Qa
Y\r(e\a
Y\r(o6
Y\r*6k
Y\r*P5
Y\r+0Y
Y\r+f5
Y\r,F\a
Y\r,W
Y\r-sb
Y\r.88
Y\r/Ml
Y\r1,\a
Y\r1=.e
Y\r1\a\a
Y\r2=\a
Y\r2oT
Y\r3n\a
Y\r4NO
Y\r8)\a
Y\r846
Y\r8E
Y\r8\r
Y\r9Mb
Y\r9XJ
Y\r:5E
Y\r;2c
Y\r;5Q
Y\r;7I
Y\r;CW
Y\r=2c
Y\r=B\a
Y\r=iQ
Y\r>1
Y\r>VE
Y\r>h
Y\r?Ei
Y\rA\\c
Y\rA~d
Y\rC\a\a
Y\rCw\a
Y\rDiI
Y\rEf
Y\rEt
Y\rG7I
Y\rGh6
Y\rH\e\b
Y\rI+J
Y\rLp
Y\rMcc
Y\rN0T
Y\rN0\a
Y\rN1P
Y\rNbE
Y\rP0\a
Y\rPKb
Y\rP\t\b
Y\rPiI
Y\rQO
Y\rQ^5
Y\rV$\a
Y\rV\tW
Y\rW*J
Y\rWsa
Y\rXr0
Y\rYIW
Y\rY~b
Y\rZYi
Y\r[6I
Y\r[J\a
Y\r\\Lb
Y\r\\fP
Y\r\a2c
Y\r\aP
Y\r\aQW
Y\r\a\v9
Y\r\b
Y\r\eI
Y\r\nGO
Y\r\n\n
Y\r\r
Y\r\t
Y\r\t*P
Y\r\t\n\b
Y\r]d
Y\r^n8
Y\r_P5
Y\r_W5
Y\r_\e5
Y\r`J\a
Y\rb9c
Y\rbav\bX
Y\rc/\b
Y\rc\e\b
Y\rdSN
Y\rdSe
Y\rdhI
Y\rg2c
Y\rgTl
Y\rg\\M
Y\rhz4
Y\riiQ
Y\rl\n
Y\rm#h
Y\rm\e5
Y\rn\n\a
Y\rn\rW
Y\rne
Y\ror\a
Y\rp9
Y\rq*J
Y\rrV
Y\rr[R
Y\rr\a\a
Y\rs6I
Y\rs\n\a
Y\rsrX
Y\rt/\b
Y\ru6I
Y\rw8\a
Y\rwKj
Y\rx6k
Y\rzI
Y\rzL
Y\rz`H
Y\rzsb
Y\r{e
Y\r|hI
Y\t;4$n
Y\t;gdӻu
Y\t\b
Y\tba~\b
Y\vba~\b
Y\vl\rm p
Y] ŠXt
Y] ŠXt$ Ăy
Y] ŠYE@ŠY
Y]@ŠXu Ăy
Y]PŠXu
Y]PŰY
Y]PŰYE
Y]pŠXuPĢy
Y`>0\nS
Y`O:@8j
Yb :3:W
Ybo;`Ox
Yc;,6f
Yd$ fD
Yd$@ŰYD$p
Yd$`fA
Yd$`ŰYE
Yd\a\nb
Yd绝oۻ4
Ye0ŐY} ňY
Ye@ńYM
Ye\nbA|H
Yffff
Yh\a=V
Yi;PC
YiN<hA
Yk'>X
YkƻҳJ
Yl$0ŀY
Yl$@ŀYu
Yl$pŨYT
Yl>0Ģq
Yl\atĢY
Ym ŠY
Ym ŠYe
Ym ŰYe
Ym@ŐYu0
Ym@ŘYu
Ym@ŜY
Ym@ŸYe
YmPŀY
Ym\bb!4HY
Ym\bb"EH
Ym\bbbM
Ym\rbA\\@Y
Ym`ŀY
Ym`ŐYe
Ym`ŰYe
YmpňY
Ymں\tJ
Yn;ư*9E
Yn\v<fD
YnպյL;K
Yqz>~/k
Yr@;7
Ys\f;,F
Yt$PfE
Yt$`fA
Yt$pfA
Yu ŨY]0
Yu9l]A:5
Yu@ŨY
Yu\fb
Yu\nbA|H
Yu\vbA|H
YupŨY
Yvc;cT
Yw;\b0c
YwǼ)汼MTi
Ywۼ;Q
Yx:\n
YxԻwJo;{Q
Y}N:Mb
Y}\bbA4HYe
Y}\nbA<@Ym\fbA|@YE
Y~ügN\v
YĻyj
YƉD$hB
ỶD$XD
Yͼiuм5
YԉD$XE
YԋD$8D
YՉD$ f
Yև>0g
YۻK[W
Y܉D$ E
YbѼYZ̼r
Z <"F
Z ba~\b
Z!0;1
Z"R&f
Z#;Go8
Z':cn
Z'M;c
Z(8;H\b
Z(R&f
Z(\a<bt
Z)8E/W9
Z)bA|\b
Z+5<1
Z,R&8 `2
Z,ba~\b
Z0=M,N
Z0[<E
Z0bA|\b
Z2:Bm
Z2b:y Y9
Z30:Bq
Z3@<s
Z3m<B\t
Z3Խ3-d>R
Z4g<Vh
Z5-;iK
Z6=r^9
Z7s:9
Z8\e0
Z95~j
Z9F<rti;Q
Z:4\e
Z::Mt:t
Z:=QtS
Z:Glj8
Z:T4c:J
Z:d?p9
Z;"X4
Z;/aC;M
Z;K*c
Z;MUh
Z;\es
Z;b\v:b
Z;e3мU
Z<2b1
Z<N$O
Z<S;\rl
Z<cDݼ\b
Z<riw
Z=1ችDP
Z=\rIn=U
Z=qh\n>5
Z>6E\v
Z>M#O
Z?<Gsg
Z?ǻUa
Z@t<3y
ZC=\rg
ZCr;B
ZE:Ik1
ZE\t:l\f
ZFa=b
ZFλgX\e
ZGϺqFx
ZH<\f1
ZHEGST
ZI{;Ct
ZM:iR\a
ZN;\e
ZO:"k
ZR<)dl
ZRU=3e
ZS\b;EN\r
ZT;kJ
ZU<\v
ZWz;nc
ZX ;|i
ZX<xۣ;X
ZXXPHP
ZXǼDSC
Z\\Q4ŊXY0
Z\aba|\b
Z\b;\e4
Z\bZ\nZ\f
Z\bZ\nZ\fT
Z\bba|\b
Z\e{&1q
Z\eŻle
Z\f:Md
Z\fbA
Z\rbA|\b
Z\rκ9;9
Z\t1<Ⱦ9
Z\tbA
Z\tba|\b
Z\vbA
Z\vo>8
Z]輴dY
Z^<C9
Za;\a
Zb(<N\vG
Zci:eF
Zd;،g;s
Ze+:g
Zero pivot detected
ZgC;d
Zj9dtK
Zk;k袻K
Zk\r9
ZlͻZm\v
Zrk;D
Zu1;At
Zw:3>f
Zy9\b
Zy;R齺ݺE
ZzS;\t
Z{Etm;,M
Z{L:J
Z}F7Q;l
Z~@f#aCW
Z¼n4\b=v
ZȺ2AE
Z̻y\rR
ZЕ;Jcm
ZԻEs3
ZԻ[S2
ZոV\b6
Z㻩t:r2
a >= 0 && a <= 255
a D=Q
a e=^v
a non-negative integer. Assigning to the parameter IPAR(10) the default value
a non-negative integer. Assigning to the parameter ipar[9] the default value
a!4\n
a";gn
a"C<EV
a#Ib?AG
a$9\n
a$ba~\b
a%;vGj
a';N8
a*c:n
a-2<H8
a/1<MX
a/ݻi\ne
a09;z
a0;JJs
a0;u8
a1R;\t
a1\t9(f
a2;%\bn
a32:1
a3<U2
a3F:γ4
a3ɉt$(H
a4-;Z
a5::I
a5;hE
a5ӻ\n@Y
a8ܻA_軙14
a9,_W8
a9;E\e :2
a9<4Lṻ1
a9=2ں|Q
a9F$ 9
a9\bfr
a9k}\f
a9t;2
a9z9|v
a:&Ex
a:0)b8
a::\amٺUI
a:;Pi
a:?h\nx
a:IrQ:q
a:VHZ
a:ZlH:co
a:\eEF
a:\rnߺi
a:mᗼN
a:oF\n
a:r?a8
a:wݑ9
a:䋆:RGI
a;"jf
a;/kY
a;GI\b
a;HJ\n9
a;ScֺM
a;W9滻b
a;WHj
a;Wvp
a;\f\rh
a;\te7;a
a;\vUe
a;\vis:3
a;djE;AXO
a;hzx
a;ja».E
a;mG\r
a;o\n
a;o}K
a;qϠ6/do
a;rX\n
a;v&G
a<#o9
a<%hf
a<)pL
a<)q2
a<CuRH
a<KN\n9
a<K嘻sk\b
a<SXԼ2
a<V"a9
a<XBF
a<\au.A
a<\auDH
a<\au\eE
a<\aufI
a<\aulH
a<\ausI
a<\tWZ<omJ
a<a櫼\fy
a<x0\a4h1\a,4l
a=#qn
a=,ücAv
a=FA8
a=X5i
a=b4D
a=bV\n
a=fiJ
a=lHe>z
a=lV\e
a=o=1
a=v_g
a>2MR
a><gAd
a>B}h
a>Q>TQ
a>Ud6>O7n
a>uZ>2
a>x~\a5h
a?;RFe
a?a:s
a@;C3
a@b;zO
aAͽ:\f5
aAݻis
aB=i\n\r
aCo7"L
aE3\nS\tI
aE3\nW\tI
aE<zQ
aEh;VB
aF\r:0i
aH9D$8t
aH9D$8t0
aHL;c0r
aHcwHB
aHh:P
aIcp\bH
aJ:TRH
aJn?L
aKi;E훺b
aL;<V
aL<Z\f
aL=T\a8
aM+\vE+C\bL
aM5;k
aNX<C
aO=W"L
aP3:GG
aP5<L1Q
aP<ut
aQ8=S
aQ;l&\n
aQ<6`d
aQ<=u
aQżqK3
aR=?3
aS;_a\b9
aSU:LD
aT0:b
aT4;#L
aT4>m
aTI=\f
aU_=d
aV\n;gt
aX:8m
aY>7%Z
aYw;e
aYỒ;C
a\a<\a0
a\aba|H
a\aba~\b
a\abq|H
a\b<z
a\bL+!I
a\bL\ne\v
a\bbQ|H
a\bba~\b
a\bd(\a
a\bd*\af
a\bd.\a
a\bd0\a
a\bf=\a
a\bt,\aQ|T
a\bt,\aa
a\bt\n\azJS
a\e<\va
a\f$9
a\fba|\b
a\n8_F
a\n;V
a\n;x3
a\n<ps\b
a\n^=ci
a\nba~\b
a\r9l}M
a\rm;\fS#:xx
a\rx:T\f
a\rӺE
a\tD;A
a\tba~\b
a\v:6
a\v:x
a\vba~\b
a]:MyH
a_\r;wVD
a`h;ziV
a`ۼRZ
aa\b;t
ab!|H
ab!}Hp
ab5;a
ab<0\ba
abA|H
abA~\b
aba|H
abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
abq}Hp\f
acc.type
accel
accel_mb
accels
activeTimeSegments > 0
acۺT?I
addProbe
addProbeArray
addProbeBatch
address family not supported
address in use
address not available
admissible interval [0,1]. Assigning DPAR(1) to
admissible interval [0,infinity). Assigning DPAR(2) to
advapi32
ae<~Q
aeD<]\f
aeG<L
ae\r=W
af7<\af
af\n=X
affinity
ag=<zM
agH;\tD
ah9{SR
aho9K>\t
ai9\aiI:bq
ai;"q
ai\n;qGV
airAbsorption
airAbsorption[iArray
aiܻbiE<j
aj;P\vB;L
ajq;U
ak:Pq
ak˺<lQ
align & (align-1)) == 0
align <= maxAlignment
all(valid, ray.tnear() >= 0.0f
all(valid, ray.valid
all(valid,i<Nc
all(valid,i<patch->N
all(vuint<M>(geomID()) == geomIDs
alloc
allocSize >= bytes
alloc_i
alloc_main_block_size
alloc_num_main_slots
alloc_single_thread_alloc
alloc_thread_block_size
allocate enough memory for TMP array
allocateAudioBuffer
allocation exceeds size of tessellation cache segment
allocation is too large
allocator == gridOffset
already connected
alse; \n} \n \n#ifndef GLOBAL_STACK \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    if (r->o.w < 0.f) \n        return false; \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            leftleaf = LEAFNODE(node.lbound); \n            rightleaf = LEAFNODE(node.rbound); \n \n            lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, isect->uvwt.w); \n            righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, isect->uvwt.w); \n \n            if (leftleaf) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node.lbound), r, isect); \n            } \n \n            if (rightleaf) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node.rbound), r, isect); \n            } \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = (int)node.rbound.pmax.w; \n                    deferred = (int)node.lbound.pmax.w;; \n                } \n                else \n                { \n                    idx = (int)node.lbound.pmax.w; \n                    deferred = (int)node.rbound.pmax.w; \n                } \n \n                if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                { \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        gsptr[i] = ldsstack[i * 64]; \n                    } \n \n                    gsptr += SHORT_STACK_SIZE; \n                    lsptr = ldsstack + 64; \n                } \n \n                *lsptr = deferred; \n                lsptr += 64; \n \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = (int)node.lbound.pmax.w; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = (int)node.rbound.pmax.w; \n                continue; \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return isect->shapeid >= 0; \n} \n#else \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    if (r->o.w < 0.f) \n        return false; \n     \n    int stack[32]; \n \n    int* sptr = stack; \n    *sptr++ = -1; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        leftleaf = LEAFNODE(node.lbound); \n        rightleaf = LEAFNODE(node.rbound); \n \n        lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, isect->uvwt.w); \n        righthit
altered by mistake outside of the DFGMRES routine. The solution may be wrong
am\r<R
america
american
american english
american-english
amfrt64.dll
amx-bf16
amx-complex
amx-fp16
amx-int8
amx-tile
an integer number greater than or equal to 2
an;̴Q
anVZ$k
and/or The result may be incorrect
and/or the result may be incorrect
anonymous namespace
anx;[I
any(valid
apU;\v
api-ms
api-ms-win-appmodel-runtime-l1-1-2
api-ms-win-core-datetime-l1-1-1
api-ms-win-core-fibers-l1-1-1
api-ms-win-core-file-l1-2-2
api-ms-win-core-localization-l1-2-1
api-ms-win-core-localization-obsolete-l1-2-0
api-ms-win-core-processthreads-l1-1-2
api-ms-win-core-string-l1-1-0
api-ms-win-core-synch-l1-2-0
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-2-1
api-ms-win-core-winrt-l1-1-0
api-ms-win-core-xstate-l2-1-0
api-ms-win-rtcore-ntuser-window-l1-1-0
api-ms-win-security-systemfunctions-l1-1-0
applications
applyIIRFilter
apy<S@n
aq6;~t
aq=)R
ar:X}E7
ar;\aR4
arFileInfo
area(left.geomBounds) >= 0.0f
area(lset.geomBounds) >= 0.0f
area(right.geomBounds) >= 0.0f
area(rset.geomBounds) >= 0.0f
argument list too long
argument out of domain
as:7Ձ9
asQ=1wU
as|:p\a
at least one topology has to exist
at=L;\rN=f
at\n:g<F
atp:T~P
at؈\akȉ\ab
at؎\akȏ\ab
au\b=0
audioBuffer
audioSettings
audioSettings->frameSize
audioSettings->samplingRate
australian
aut;\eF
av%yb
av%{s
av/;J
av;\v
av\v=H7
avf;wOu
avx10.1-256
avx10.1-512
avx2::BVH4ColliderUserGeom
avx2::BVH4InstanceArrayIntersector1
avx2::BVH4InstanceArrayIntersector4Chunk
avx2::BVH4InstanceArrayIntersector8Chunk
avx2::BVH4InstanceArrayMBIntersector1
avx2::BVH4InstanceArrayMBIntersector4Chunk
avx2::BVH4InstanceArrayMBIntersector8Chunk
avx2::BVH4InstanceIntersector1
avx2::BVH4InstanceIntersector4Chunk
avx2::BVH4InstanceIntersector8Chunk
avx2::BVH4InstanceMBIntersector1
avx2::BVH4InstanceMBIntersector4Chunk
avx2::BVH4InstanceMBIntersector8Chunk
avx2::BVH4OBBVirtualCurveIntersector1
avx2::BVH4OBBVirtualCurveIntersector1MB
avx2::BVH4OBBVirtualCurveIntersector4Hybrid
avx2::BVH4OBBVirtualCurveIntersector4HybridMB
avx2::BVH4OBBVirtualCurveIntersector8Hybrid
avx2::BVH4OBBVirtualCurveIntersector8HybridMB
avx2::BVH4OBBVirtualCurveIntersectorRobust1
avx2::BVH4OBBVirtualCurveIntersectorRobust1MB
avx2::BVH4OBBVirtualCurveIntersectorRobust4Hybrid
avx2::BVH4OBBVirtualCurveIntersectorRobust4HybridMB
avx2::BVH4OBBVirtualCurveIntersectorRobust8Hybrid
avx2::BVH4OBBVirtualCurveIntersectorRobust8HybridMB
avx2::BVH4Quad4iIntersector1Moeller
avx2::BVH4Quad4iIntersector1Pluecker
avx2::BVH4Quad4iIntersector4HybridMoeller
avx2::BVH4Quad4iIntersector4HybridPluecker
avx2::BVH4Quad4iIntersector8HybridMoeller
avx2::BVH4Quad4iIntersector8HybridPluecker
avx2::BVH4Quad4iMBIntersector1Moeller
avx2::BVH4Quad4iMBIntersector1Pluecker
avx2::BVH4Quad4iMBIntersector4HybridMoeller
avx2::BVH4Quad4iMBIntersector4HybridPluecker
avx2::BVH4Quad4iMBIntersector8HybridMoeller
avx2::BVH4Quad4iMBIntersector8HybridPluecker
avx2::BVH4Quad4vIntersector1Moeller
avx2::BVH4Quad4vIntersector1Pluecker
avx2::BVH4Quad4vIntersector4HybridMoeller
avx2::BVH4Quad4vIntersector4HybridMoellerNoFilter
avx2::BVH4Quad4vIntersector4HybridPluecker
avx2::BVH4Quad4vIntersector8HybridMoeller
avx2::BVH4Quad4vIntersector8HybridMoellerNoFilter
avx2::BVH4Quad4vIntersector8HybridPluecker
avx2::BVH4SubdivPatch1Intersector1
avx2::BVH4SubdivPatch1Intersector4
avx2::BVH4SubdivPatch1Intersector8
avx2::BVH4SubdivPatch1MBIntersector1
avx2::BVH4SubdivPatch1MBIntersector4
avx2::BVH4SubdivPatch1MBIntersector8
avx2::BVH4Triangle4Intersector1Moeller
avx2::BVH4Triangle4Intersector4HybridMoeller
avx2::BVH4Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH4Triangle4Intersector8HybridMoeller
avx2::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH4Triangle4iIntersector1Moeller
avx2::BVH4Triangle4iIntersector1Pluecker
avx2::BVH4Triangle4iIntersector4HybridMoeller
avx2::BVH4Triangle4iIntersector4HybridPluecker
avx2::BVH4Triangle4iIntersector8HybridMoeller
avx2::BVH4Triangle4iIntersector8HybridPluecker
avx2::BVH4Triangle4iMBIntersector1Moeller
avx2::BVH4Triangle4iMBIntersector1Pluecker
avx2::BVH4Triangle4iMBIntersector4HybridMoeller
avx2::BVH4Triangle4iMBIntersector4HybridPluecker
avx2::BVH4Triangle4iMBIntersector8HybridMoeller
avx2::BVH4Triangle4iMBIntersector8HybridPluecker
avx2::BVH4Triangle4vIntersector1Pluecker
avx2::BVH4Triangle4vIntersector4HybridPluecker
avx2::BVH4Triangle4vIntersector8HybridPluecker
avx2::BVH4Triangle4vMBIntersector1Moeller
avx2::BVH4Triangle4vMBIntersector1Pluecker
avx2::BVH4Triangle4vMBIntersector4HybridMoeller
avx2::BVH4Triangle4vMBIntersector4HybridPluecker
avx2::BVH4Triangle4vMBIntersector8HybridMoeller
avx2::BVH4Triangle4vMBIntersector8HybridPluecker
avx2::BVH8ColliderUserGeom
avx2::BVH8InstanceArrayIntersector1
avx2::BVH8InstanceArrayIntersector4Chunk
avx2::BVH8InstanceArrayIntersector8Chunk
avx2::BVH8InstanceArrayMBIntersector1
avx2::BVH8InstanceArrayMBIntersector4Chunk
avx2::BVH8InstanceArrayMBIntersector8Chunk
avx2::BVH8InstanceIntersector1
avx2::BVH8InstanceIntersector4Chunk
avx2::BVH8InstanceIntersector8Chunk
avx2::BVH8InstanceMBIntersector1
avx2::BVH8InstanceMBIntersector4Chunk
avx2::BVH8InstanceMBIntersector8Chunk
avx2::BVH8OBBVirtualCurveIntersector1
avx2::BVH8OBBVirtualCurveIntersector1MB
avx2::BVH8OBBVirtualCurveIntersector4Hybrid
avx2::BVH8OBBVirtualCurveIntersector4HybridMB
avx2::BVH8OBBVirtualCurveIntersector8Hybrid
avx2::BVH8OBBVirtualCurveIntersector8HybridMB
avx2::BVH8OBBVirtualCurveIntersectorRobust1
avx2::BVH8OBBVirtualCurveIntersectorRobust1MB
avx2::BVH8OBBVirtualCurveIntersectorRobust4Hybrid
avx2::BVH8OBBVirtualCurveIntersectorRobust4HybridMB
avx2::BVH8OBBVirtualCurveIntersectorRobust8Hybrid
avx2::BVH8OBBVirtualCurveIntersectorRobust8HybridMB
avx2::BVH8Quad4iIntersector1Moeller
avx2::BVH8Quad4iIntersector1Pluecker
avx2::BVH8Quad4iIntersector4HybridMoeller
avx2::BVH8Quad4iIntersector4HybridPluecker
avx2::BVH8Quad4iIntersector8HybridMoeller
avx2::BVH8Quad4iIntersector8HybridPluecker
avx2::BVH8Quad4iMBIntersector1Moeller
avx2::BVH8Quad4iMBIntersector1Pluecker
avx2::BVH8Quad4iMBIntersector4HybridMoeller
avx2::BVH8Quad4iMBIntersector4HybridPluecker
avx2::BVH8Quad4iMBIntersector8HybridMoeller
avx2::BVH8Quad4iMBIntersector8HybridPluecker
avx2::BVH8Quad4vIntersector1Moeller
avx2::BVH8Quad4vIntersector1Pluecker
avx2::BVH8Quad4vIntersector4HybridMoeller
avx2::BVH8Quad4vIntersector4HybridMoellerNoFilter
avx2::BVH8Quad4vIntersector4HybridPluecker
avx2::BVH8Quad4vIntersector8HybridMoeller
avx2::BVH8Quad4vIntersector8HybridMoellerNoFilter
avx2::BVH8Quad4vIntersector8HybridPluecker
avx2::BVH8Triangle4Intersector1Moeller
avx2::BVH8Triangle4Intersector4HybridMoeller
avx2::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH8Triangle4Intersector8HybridMoeller
avx2::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH8Triangle4iIntersector1Moeller
avx2::BVH8Triangle4iIntersector1Pluecker
avx2::BVH8Triangle4iIntersector4HybridMoeller
avx2::BVH8Triangle4iIntersector4HybridPluecker
avx2::BVH8Triangle4iIntersector8HybridMoeller
avx2::BVH8Triangle4iIntersector8HybridPluecker
avx2::BVH8Triangle4iMBIntersector1Moeller
avx2::BVH8Triangle4iMBIntersector1Pluecker
avx2::BVH8Triangle4iMBIntersector4HybridMoeller
avx2::BVH8Triangle4iMBIntersector4HybridPluecker
avx2::BVH8Triangle4iMBIntersector8HybridMoeller
avx2::BVH8Triangle4iMBIntersector8HybridPluecker
avx2::BVH8Triangle4vIntersector1Pluecker
avx2::BVH8Triangle4vIntersector1Woop
avx2::BVH8Triangle4vIntersector4HybridPluecker
avx2::BVH8Triangle4vIntersector8HybridPluecker
avx2::BVH8Triangle4vMBIntersector1Moeller
avx2::BVH8Triangle4vMBIntersector1Pluecker
avx2::BVH8Triangle4vMBIntersector4HybridMoeller
avx2::BVH8Triangle4vMBIntersector4HybridPluecker
avx2::BVH8Triangle4vMBIntersector8HybridMoeller
avx2::BVH8Triangle4vMBIntersector8HybridPluecker
avx2::QBVH4Quad4iIntersector1Pluecker
avx2::QBVH4Triangle4iIntersector1Pluecker
avx2::QBVH8Quad4iIntersector1Pluecker
avx2::QBVH8Triangle4Intersector1Moeller
avx2::QBVH8Triangle4iIntersector1Pluecker
avx512
avx5124fmaps
avx5124vnniw
avx512bf16
avx512bitalg
avx512bw
avx512cd
avx512dq
avx512er
avx512f
avx512fp16
avx512ifma
avx512pf
avx512vbmi
avx512vbmi2
avx512vl
avx512vnni
avx512vp2intersect
avx512vpopcntdq
avx::BVH
avx::BVH4ColliderUserGeom
avx::BVH4InstanceArrayIntersector1
avx::BVH4InstanceArrayIntersector4Chunk
avx::BVH4InstanceArrayIntersector8Chunk
avx::BVH4InstanceArrayMBIntersector1
avx::BVH4InstanceArrayMBIntersector4Chunk
avx::BVH4InstanceArrayMBIntersector8Chunk
avx::BVH4InstanceIntersector1
avx::BVH4InstanceIntersector4Chunk
avx::BVH4InstanceIntersector8Chunk
avx::BVH4InstanceMBIntersector1
avx::BVH4InstanceMBIntersector4Chunk
avx::BVH4InstanceMBIntersector8Chunk
avx::BVH4OBBVirtualCurveIntersector1
avx::BVH4OBBVirtualCurveIntersector1MB
avx::BVH4OBBVirtualCurveIntersector4Hybrid
avx::BVH4OBBVirtualCurveIntersector4HybridMB
avx::BVH4OBBVirtualCurveIntersector8Hybrid
avx::BVH4OBBVirtualCurveIntersector8HybridMB
avx::BVH4OBBVirtualCurveIntersectorRobust1
avx::BVH4OBBVirtualCurveIntersectorRobust1MB
avx::BVH4OBBVirtualCurveIntersectorRobust4Hybrid
avx::BVH4OBBVirtualCurveIntersectorRobust4HybridMB
avx::BVH4OBBVirtualCurveIntersectorRobust8Hybrid
avx::BVH4OBBVirtualCurveIntersectorRobust8HybridMB
avx::BVH4Quad4iIntersector1Moeller
avx::BVH4Quad4iIntersector1Pluecker
avx::BVH4Quad4iIntersector4HybridMoeller
avx::BVH4Quad4iIntersector4HybridPluecker
avx::BVH4Quad4iIntersector8HybridMoeller
avx::BVH4Quad4iIntersector8HybridPluecker
avx::BVH4Quad4iMBIntersector1Moeller
avx::BVH4Quad4iMBIntersector1Pluecker
avx::BVH4Quad4iMBIntersector4HybridMoeller
avx::BVH4Quad4iMBIntersector4HybridPluecker
avx::BVH4Quad4iMBIntersector8HybridMoeller
avx::BVH4Quad4iMBIntersector8HybridPluecker
avx::BVH4Quad4vIntersector1Moeller
avx::BVH4Quad4vIntersector1Pluecker
avx::BVH4Quad4vIntersector4HybridMoeller
avx::BVH4Quad4vIntersector4HybridMoellerNoFilter
avx::BVH4Quad4vIntersector4HybridPluecker
avx::BVH4Quad4vIntersector8HybridMoeller
avx::BVH4Quad4vIntersector8HybridMoellerNoFilter
avx::BVH4Quad4vIntersector8HybridPluecker
avx::BVH4SubdivPatch1Intersector1
avx::BVH4SubdivPatch1Intersector4
avx::BVH4SubdivPatch1Intersector8
avx::BVH4SubdivPatch1MBIntersector1
avx::BVH4SubdivPatch1MBIntersector4
avx::BVH4SubdivPatch1MBIntersector8
avx::BVH4Triangle4Intersector1Moeller
avx::BVH4Triangle4Intersector4HybridMoeller
avx::BVH4Triangle4Intersector8HybridMoeller
avx::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx::BVH4Triangle4iIntersector1Moeller
avx::BVH4Triangle4iIntersector1Pluecker
avx::BVH4Triangle4iIntersector4HybridMoeller
avx::BVH4Triangle4iIntersector4HybridPluecker
avx::BVH4Triangle4iIntersector8HybridMoeller
avx::BVH4Triangle4iIntersector8HybridPluecker
avx::BVH4Triangle4iMBIntersector1Moeller
avx::BVH4Triangle4iMBIntersector1Pluecker
avx::BVH4Triangle4iMBIntersector4HybridMoeller
avx::BVH4Triangle4iMBIntersector4HybridPluecker
avx::BVH4Triangle4iMBIntersector8HybridMoeller
avx::BVH4Triangle4iMBIntersector8HybridPluecker
avx::BVH4Triangle4vIntersector1Pluecker
avx::BVH4Triangle4vIntersector4HybridPluecker
avx::BVH4Triangle4vIntersector8HybridPluecker
avx::BVH4Triangle4vMBIntersector1Moeller
avx::BVH4Triangle4vMBIntersector1Pluecker
avx::BVH4Triangle4vMBIntersector4HybridMoeller
avx::BVH4Triangle4vMBIntersector4HybridPluecker
avx::BVH4Triangle4vMBIntersector8HybridMoeller
avx::BVH4Triangle4vMBIntersector8HybridPluecker
avx::BVH8ColliderUserGeom
avx::BVH8InstanceArrayIntersector1
avx::BVH8InstanceArrayIntersector4Chunk
avx::BVH8InstanceArrayIntersector8Chunk
avx::BVH8InstanceArrayMBIntersector1
avx::BVH8InstanceArrayMBIntersector4Chunk
avx::BVH8InstanceArrayMBIntersector8Chunk
avx::BVH8InstanceIntersector1
avx::BVH8InstanceIntersector4Chunk
avx::BVH8InstanceIntersector8Chunk
avx::BVH8InstanceMBIntersector1
avx::BVH8InstanceMBIntersector4Chunk
avx::BVH8InstanceMBIntersector8Chunk
avx::BVH8OBBVirtualCurveIntersector1
avx::BVH8OBBVirtualCurveIntersector1MB
avx::BVH8OBBVirtualCurveIntersector4Hybrid
avx::BVH8OBBVirtualCurveIntersector4HybridMB
avx::BVH8OBBVirtualCurveIntersector8Hybrid
avx::BVH8OBBVirtualCurveIntersector8HybridMB
avx::BVH8OBBVirtualCurveIntersectorRobust1
avx::BVH8OBBVirtualCurveIntersectorRobust1MB
avx::BVH8OBBVirtualCurveIntersectorRobust4Hybrid
avx::BVH8OBBVirtualCurveIntersectorRobust4HybridMB
avx::BVH8OBBVirtualCurveIntersectorRobust8Hybrid
avx::BVH8OBBVirtualCurveIntersectorRobust8HybridMB
avx::BVH8Quad4iIntersector1Moeller
avx::BVH8Quad4iIntersector1Pluecker
avx::BVH8Quad4iIntersector4HybridMoeller
avx::BVH8Quad4iIntersector4HybridPluecker
avx::BVH8Quad4iIntersector8HybridMoeller
avx::BVH8Quad4iIntersector8HybridPluecker
avx::BVH8Quad4iMBIntersector1Moeller
avx::BVH8Quad4iMBIntersector1Pluecker
avx::BVH8Quad4iMBIntersector4HybridMoeller
avx::BVH8Quad4iMBIntersector4HybridPluecker
avx::BVH8Quad4iMBIntersector8HybridMoeller
avx::BVH8Quad4iMBIntersector8HybridPluecker
avx::BVH8Quad4vIntersector1Moeller
avx::BVH8Quad4vIntersector1Pluecker
avx::BVH8Quad4vIntersector4HybridMoeller
avx::BVH8Quad4vIntersector4HybridMoellerNoFilter
avx::BVH8Quad4vIntersector4HybridPluecker
avx::BVH8Quad4vIntersector8HybridMoeller
avx::BVH8Quad4vIntersector8HybridMoellerNoFilter
avx::BVH8Quad4vIntersector8HybridPluecker
avx::BVH8Triangle4Intersector1Moeller
avx::BVH8Triangle4Intersector4HybridMoeller
avx::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx::BVH8Triangle4Intersector8HybridMoeller
avx::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx::BVH8Triangle4iIntersector1Moeller
avx::BVH8Triangle4iIntersector1Pluecker
avx::BVH8Triangle4iIntersector4HybridMoeller
avx::BVH8Triangle4iIntersector4HybridPluecker
avx::BVH8Triangle4iIntersector8HybridMoeller
avx::BVH8Triangle4iIntersector8HybridPluecker
avx::BVH8Triangle4iMBIntersector1Moeller
avx::BVH8Triangle4iMBIntersector1Pluecker
avx::BVH8Triangle4iMBIntersector4HybridMoeller
avx::BVH8Triangle4iMBIntersector4HybridPluecker
avx::BVH8Triangle4iMBIntersector8HybridMoeller
avx::BVH8Triangle4iMBIntersector8HybridPluecker
avx::BVH8Triangle4vIntersector1Pluecker
avx::BVH8Triangle4vIntersector1Woop
avx::BVH8Triangle4vIntersector4HybridPluecker
avx::BVH8Triangle4vIntersector8HybridPluecker
avx::BVH8Triangle4vMBIntersector1Moeller
avx::BVH8Triangle4vMBIntersector1Pluecker
avx::BVH8Triangle4vMBIntersector4HybridMoeller
avx::BVH8Triangle4vMBIntersector4HybridPluecker
avx::BVH8Triangle4vMBIntersector8HybridMoeller
avx::BVH8Triangle4vMBIntersector8HybridPluecker
avx::QBVH
avx::QBVH4Quad4iIntersector1Pluecker
avx::QBVH4Triangle4iIntersector1Pluecker
avx::QBVH8Quad4iIntersector1Pluecker
avx::QBVH8Triangle4Intersector1Moeller
avx::QBVH8Triangle4iIntersector1Pluecker
avxifma
avxneconvert
avxvnni
avxvnniint16
avxvnniint8
aw:R)z8f0
aw];C
ax5;T
axis < 2
axis < 3
ax仡iٻ0
ay.tnear() >= 0.0f
ay57u
az-AZ-Cyrl
az-AZ-Latn
az-az-cyrl
az-az-latn
az<hf
az=\t4d
azE:Ty
a{P;u
a}<7v
a~C<7P
aġynD
aĢy#D
aĢy#D0
aĢy#D8
aĢy#D\b
aĻs=8
aŜT\r -I
aŠY\rb)Y
aŠY\r|wd
aͼE\nȼL
aμ?sX=IV
aѻ44{0
aѻR\f
aѼV4M
aҹOTO
aּ%7F
aڛ;9k
aܼw-A
aݓ9EЕ9w
aᚼD-D
a㱼ڪL>ti
a꼍Cռs
a빺d`;ZQ
a캅4B:)L
aQzɻ\a
a8\t
b %d %H : %M : %S %Y
b 4;=\tQ
b \b=Uvc
b bB%H6
b ba|\b
b!,HY
b!4HY
b!4HYL
b!L@X
b!N\bY
b!T$h
b!T@YD
b!THYT
b!THYd
b!V\bY
b!W<2
b!\\HYt
b!d$L0b
b!d(Y
b!d@Y
b!dHYT
b!dHY\f
b!lHYt
b!l\bY
b!t@Y
b!t@Yd
b!v\b
b!|HY
b!}Hp
b!}Hp$1b
b!}Hp$±bA
b!}Hp$ڱbA
b!}Hp,1b
b!}Hp,ȱb2MH
b!}Hp,ʱb1LHY
b!}Hp,αb2MH
b!}Hp1b
b!}Hp1batH
b!}Hp4
b!}Hp41
b!}Hp4ȱL
b!}Hp4ȱb
b!}Hp4бb
b!}Hp4ұL
b!}Hp4ұb1}Hp\f
b!}Hp4ڱb
b!}Hp4ڱba}Hp\f
b!}Hp<رba}Hp
b!}Hp\f
b!}Hp\f±b
b!}Hp\fȱb
b!}Hp\fɱb
b!}Hp\fʱb
b!}Hp\fرb
b!}Hp±b
b!}Hpñb
b!}HpǱb
b!}HpǱb1|H
b!}HpǱbA|H
b!}HpǱbq|H
b!}Hpɱb
b!}Hpʱb
b!}Hp˱b
b!}Hp̱ba|H
b!}Hpαb
b!}Hpϱb
b!}HpϱbA|H
b!}HpϱbA|L
b!}Hpбb
b!}Hpұba}Hp
b!}Hpӱb
b!}HpԱb
b!}Hpձb
b!}HpձbA,@YU
b!}HpֱbA,@YU
b!}Hpֱbb}H
b!}HpױbA,@YU
b!}HpٱbQ}Hp
b!}Hpܱb
b!}Hpݱb
b!}Hp߱b
b!}Hp߱bA}HpƱb
b!}Jpбb
b!}Jpұb
b"=Ae
b"UH6
b"V<i
b"]Ae
b"]H6
b"eAe
b"mAe4
b#0<w
b#MBCƱb
b#UBCűb
b#a=TO
b#m\b!4
b#uCCqb
b#}BCбb
b#}BCرb
b%2<7
b&D<q
b&o<9
b';fN
b(V:W
b(l8X
b)A<2
b)A<6fg
b*<4S
b*d\e\b*4
b,;wEv
b-;jE
b-;oh
b-R>L1
b.lower.x <= b.upper.x
b.lower.y <= b.upper.y
b.lower.z <= b.upper.z
b09;\v
b0bA|\b
b1,@Y
b1,@YT
b14@Y
b14@YT
b1:2U\t
b1;:wM
b1<;p
b1D@Y
b1LHT
b1dHY
b1dHYt
b1|H+D
b1|H+L
b1|H+T
b1|H+d
b1|H+l
b1|H+t
b1|\bY
b1}Hp
b1}Hp$ɱba}Hp4
b1}Hp,1bQ,HY
b1}Hp,ƱbQ4@Y
b1}Hp,ڱb
b1}Hp4
b1}Hp4ȱb
b1}Hp4رbQ\\@Y
b1}Hp<1bA
b1}Hp<ڱb1}Hp\f
b1}Hp\f
b1}Hp\fȱbQ,HY
b1}Hp\fʱba}Hp$ڱbQ4HYU\fH
b1}Hp\fʱba}Hp$ڱbQ4HYU\fbq}Hp\f
b1}Hp±bA$@Y
b1}HpǱba}HpǱb
b1}Hp˱ba}Hp˱b
b1}HpӱbQ,HYU
b1}HpԱbQ,HYU\ab
b1}HpٱB
b1}Hp߱b
b2:ve2
b2=@6
b2MʘT
b3D<B\t
b3i>N
b3}C#Јb3uC#وb
b4;hK
b4=YTl
b4>0D&F
b4źꗢ9P
b58<A
b5K;n
b6P224>0D&F
b6\t;s
b7;6\f
b7<i7a
b8:X*r
b8\a/U:he\v
b8\nR\f
b8\nT\f
b8w7F
b92|뻮0
b989d
b9G;9
b9I"\b
b9M7Ϲr
b9W8@:\\R
b9i0x
b9p3 :t
b9üCZ<3QC
b: Vw:M
b:!3D
b:6?1
b:Dř8'yr
b:E\tuZH
b:KBV9
b:U;7
b:V\to
b:WlH:l
b:\f4i:褃:t02
b:\vg
b:p\bP
b;'mj
b;'mt
b;0\nN
b;21\r
b;7c\e
b;@Fb;P
b;@Qx
b;@xS
b;CӺ9Y
b;V3Ժk
b;VR\t
b;W\n
b;\nt
b;h68
b;n"V
b;w$t
b;y]L
b;z9\a
b;ռej
b<&vq
b<Iᙼf
b<c3j
b<c\r
b<pgW
b<w$\r=hR
b<z3?9
b<פQ;NX
b=4%1
b=6鏽uJ
b=8Sc
b=?wOj>\e
b=M\tR>08N>Hb
b=\rDU
b=e;\fS
b=z%7
b=zd1
b>,j1
b>9<mI
b>[rC
b>y<K
b?<of
b?Z<c?s
b?\bt\r
b?^Cy\r
b?xCz
b@ :i
b@>ca
bA$@X
bA$@Y
bA$@Yu
bA$HY,\vb
bA,@XW
bA,@YM
bA,@YT
bA,HY
bA,HYu\nbQ|H
bA4@XO
bA4@YL
bA4@Yu
bA4@Yu\b
bA4@Yu\bb"MH
bA4HY
bA4HYM
bA;oH
bA;uH
bA<@XF
bA<@YE
bA<@Ym\fL
bA<HYT
bA<HY\f
bA<HYm
bA>\b
bA@:r
bAD@Y
bAD@YE\fL
bAD@YE\fbA|H
bAD@YU
bAD@Ym\nb
bADHYL
bADHYm
bALHX
bAT@YU
bA\\(XM
bA\\@YE\fb"u
bA\\@YU
bA\\HY
bA\\HYe
bA\\HYe\bb
bA\\HYe\fb
bA\\HYe\nb
bA\\HYe\vb
bA\f@Xw
bA\f@Y
bA\f@YU
bA\v?C
bAd@Y
bAl X
bAl@YM\nb
bAl@Ym\bL
bAl@Ym\bb
bAl@Yu
bAl@Yu\fb
bAt(YU
bAt@YM
bAtHYE
bA|@YE\bbA
bA|@Ym
bA|@Yt
bA}Hp
bA}Hp,ܱbA}Hp
bA}Hp1b
bA}HpT
bA}Hpl
bA}Hpqb
bA}Hp±b
bA}Hpñb
bA}Hpűb
bA}HpǱbB-H
bA}Hpɱb
bA}Hpʱb
bA}Hpϱb
bA}HpѱbA,@YU
bA}Hpұb
bA}HpӱbA,@YU
bA}HpԱb
bA}Hpձb
bA}Hpֱb
bA}Hpױb
bA}HpױbQ}Hp
bA}HpرbQ|H
bA}Hp۱b
bA}Hpݱb
bA}Hpޱb
bA}Hp߱b
bA~(o
bA~(ou
bA~\b
bA~\bYy
bAջ]ux
bB5@6
bBO:N
bBellevue1
bB~H5
bBƼj\vt
bC 9,o
bC:9Y;Nu
bCM\b
bCP=֙Q
bCZ;=O\n
bD =v
bD8T$1u
bD91t
bD9}\bLc
bD;S\f
bD;\n|Q
bD;\n|U
bD;d$P
bD;l$P
bD;t$P
bD\n>\f
bDɹmt绨b
bE;e\b
bE;e\f
bE;l$\f
bE;wH
bEu:VQ
bEӻ=lv
bF'<s
bF:hʼ9x*%:MAB
bFEMh\f
bFl:z
bG<\ty\v<v
bH"9JJ\n
bH+]\bH
bH+|$hH
bH+|$pH
bH+|$xH
bH9(u
bH;P A
bH;P\b
bH;X\b
bH;l$`H
bHN&n
bHbQ|H
bI;D$\b
bI;L$\b
bIcI8
bJ7>]b
bJ^<t
bJɻ1P
bK*:dj
bL';m
bL+;I
bL+t$PD
bL+|$hL
bLcl$pM
bM;x\rx
bMcH03
bO>BfL
bP";T
bP:\ehG
bP\n,\f
bQ$@YM
bQ$@Ye
bQ4HY
bQ;mRA;T\n
bQ<@Yu
bQ<HY
bQ<HYu
bQLHY
bQLHYm
bQT@Ym\bb
bQ\fHX7M
bQ\fHX7b
bQ\fHX7bQ|H
bQ|\n
bQ}Hp
bQ}Hp1b
bQ}Hp1b"eH
bQ}Hp1bq}Hp
bQ}Hp4ƱI
bQ}Hp4ǱL
bQ}Hp\f
bQ}Hp\fıb
bQ}Hp\fԱbR\r
bQ}Hp\fرbQ
bQ}Hpqb
bQ}HpƱb
bQ}HpɱbA}Hp
bQ}HpɱbQ}Hp
bQ}HpɱbQ}Hp۱b
bQ}Hpʱbq}Hpױba|H
bQ}Hp˱b1|H
bQ}Hp˱bq|H
bQ}Hpͱb
bQ}HpϱbA$@Y
bQ}HpϱbA}HpޱbQTHY
bQ}HpбbQ$HY
bQ}HpбbQ,HYU
bQ}HpшbQ}Hp
bQ}HpѱbQ
bQ}HpѱbQ,HYU
bQ}Hpұb
bQ}HpұbbU
bQ}Hpұbr%H
bQ}HpԱb
bQ}HpֱbA}Hpرb
bQ}Hpڱbr}H
bQ}Hp۱b
bQ}Hp۱b2
bQ}Hp۱b25H
bQ}Hp۱b2M
bQ}Hp۱bq}Hp
bQ}Hp۱brM
bQ}HpޱbA}Hp
bQ}Hp߱b
bR%H6
bREH6
bRF=in
bR\n0\f0
bS;oh
bS;µźxs
bSM>X
bSUH%̖b
bSUH%̖bre
bSܻKP\r
bT:(j6:2\a
bU<.O
bUVWATAUAVAW
bUVWATAUAVAWH
bUVWAVAWH
bUVWH
bUú+eH
bWD;q
bWڻufa
bX*9>K4
bX6ba.\bX
bX<$bA
bXD$\tb
bXY@ŪXi
bXY\fŪY
bXa\ab
bXba|\b
bXf:R
bY$9L
bY1:to
bY=WJ
bYD;\aH
bY\\\ad
bY\t;q
bZ <lP
bZ-;H
bZ<tq3
bZR;v
bZW<{c
b[ <A8\a
b\\<LXJ
b\\A\aba
b\\I\abqf
b\a;i
b\a<Q
b\b A
b\b8FF
b\b8Fڭy
b\b<VlE
b\bF\n5\v
b\b\b
b\b\b\b
b\b\e9u
b\bdB\by
b\e<L2A
b\f0\vP\np\t`\b
b\fU;1
b\n8t\t\n
b\n:S4o
b\n;11
b\n;6
b\n\b
b\nba|\b
b\nba~\b
b\r?z]D
b\rb!d(Y
b\rbA
b\t7<j
b\t?s
b\tq?\b\tq
b\v\a9
b\vbb-@6
b\vbb]H6
b]x;I
b`:nA
b`?<0HH
ba$ Y
ba$ Y%\bw
ba$PY
ba,AY
ba,BY
ba,PYU
ba4 Y
ba4@X
ba4PYM
ba;\vc1
ba<@Y\f;ba<@YD
ba<PYE
baL X
baL@Yt
baLHYِH
baT(W
baT@X
baTHY<9b
baTHYd
baT\bY\r
baV\bY5\a
ba\\H
ba\f Y
ba\f Y=B
ba\fAY
ba\fBY
ba\fPY5
ba\fPYu
bad address
bad allocation
bad array new length
bad cast
bad conversion
bad exception
bad file descriptor
bad function call
bad locale name
bad message
bad(W=DEm
bad@Y
bad@Y%r
bad@Y%t
bad@Y\r
bad@Y\rq
bad@Y\ru
bad_weak_ptr
bakePaths
bakeReflections
bal(W-N`m
bal@X
bal@Y,/b
balHYA
balHYy\aba|H
barrier_sys_regression_test
based
bat(W
bat(Y
bat@Y
bat@Y-\a
bav\bY
ba|@Y<7b
ba|@Yd
ba|HY
ba|HY=7
ba|HY=׃w
ba|\b
ba|\b.\r9
ba|\b.\r\bqw
ba|\bW=u
ba}Hp
ba}Hp$±b
ba}Hp$ȱb
ba}Hp$رb
ba}Hp$رbb]H
ba}Hp,ȱb!}Hp
ba}Hp,ڱb
ba}Hp1b
ba}Hp4
ba}Hp4±b
ba}Hp4ȱb
ba}Hp4ʱbA\f@Ye
ba}Hp4бL
ba}Hp<ȱI
ba}Hp<ʱb
ba}Hp<ʱbA
ba}Hp<ٱb
ba}Hp<ٱb"uH
ba}HpY
ba}Hp\f
ba}Hp\fڱb
ba}Hp\fڱbq}Hp
ba}Hpqb
ba}HpqbA}Hp
ba}Hp±b
ba}Hpñb
ba}Hpıb
ba}Hpűb
ba}HpűbQ|H
ba}HpƱb"M
ba}HpǱb
ba}Hpȱb
ba}Hpɱb!|H
ba}Hpʱb
ba}HpʱbA}Hpݱbq|H
ba}Hp˱b
ba}Hp̱b
ba}Hpͱb
ba}Hpбb
ba}Hpѱb
ba}Hpұb
ba}HpұbA,@YU
ba}Hpӱb
ba}HpԱb
ba}HpԱbA,@YU
ba}Hpձb
ba}Hpֱb
ba}Hpױb
ba}HpرL
ba}Hpرb
ba}Hpٱba}Hp
ba}Hpڱb
ba}HpڱbQ
ba}HpڱbQt
ba}Hpݱb
ba}Hpޱbq|H
ba}Jpűb
ba}Jpͱb
ba}Jpбb
ba}Jpѱb
ba}Jpұb
ba}Jp۱b
ba}Mp
ba~(o%&Sm
ba~(o%:Cm
ba~Ho
ba~Ho%nCm
ba~Ho0bq~HoH
ba~Ho5
ba~Ho=*>m
ba~Ho=NBm
ba~Ho=T>m
ba~Ho=|=m
ba~HoI
ba~Ho\r\\Cm
ba~Hoa
ba~Hoi
ba~Hoq
ba~\b
ba~\bYD
ba~\bYL
ba~\bYT
ba~\bYa
ba~\bo5
bb!|H
bb!|IY
bb!}Hp
bb!}Hpٱb
bb1}Hp
bb1}HpױbQt@Y
bb5Hw
bb5Hwh
bbA4\bX
bbA|H
bbEAe
bbMAe
bbMAe4
bbQ|H
bbQ}Hp
bbUAe
bb\r@w
bb\v<D[c
bbaf\bX
bbal@Y
bba|\b
bba}Hpұb
bbeH@%0
bbq}HpɱbA$@Y
bbq}Hp۱bQ\fHY
bbuAe\f
bbuH6
bb}HX
bb}HX% B
bb}HX%0
bb}HX\r
bb}HZ
bb}HZ5
bb}HZ5\r
bbպ'\as
bc=\b
bcu@%ږbQd
bd;vK3
be9Pl
before the call to the DFGMRES_CHECK routine. Make sure to
begin == pinfo.size
beginID < BINS
belgian
benchmark
bestSAH >= 0.0f
bf-;ytZ;\a
bf;E\a
bfA\v
bfB9<A}1L
bfD94Q}\bI
bfE\v
bffffff
bg*;s31
bh;nݰ8\a
bh<<WDD
bh<V@z
bhP:sQ
bhk;D
binID < BINS
bin[dim] >= (int)0 && bin[dim] < (int)BINS
bj=UWi
bjn;\ez
bjӹaE
bjԽXG
bk;S8N
bk]<0
blockSize > 0
block_index < maxBlocks
block_index*16 <= size
blocks < switch_block_threshold
bmd;Z
bmt<\e
bmȺLE
bn~<xk
bo:JZ
bo=}qL
bp*<SZ
bpY>GTr
bp\a;u
bp\f*\n
bq$XY
bq, Y\r
bq,IY
bq,JY
bq,XYS
bq,XYU
bq4XYK
bq4XYM
bq<@Y
bq<XYC
bq<XYE
bq\\HY
bq\\HYt
bq\fIY
bq\fJY
bq\fXYs
bq\fXYu
bqd@Y
bqlHY
bq}Hp
bq}Hp$ʱH
bq}Hp$ʱbQ
bq}Hp$رbQ4@Y
bq}Hp,αbA
bq}Hp,رbA
bq}Hp1bA
bq}Hp4±b
bq}Hp<ڱb
bq}Hp\f
bq}Hp\fȱbQ$@Y
bq}Hp\fӱbrEH
bq}Hp±b
bq}Hpñbr}H
bq}Hpűb
bq}HpɱbA$@Y
bq}Hpαb
bq}HpαbQ}Hp
bq}Hpϱb
bq}HpбbQ4@Y
bq}Hpѱb
bq}HpѱbQ,HYU
bq}HpұbQ
bq}HpӱbQ,HYU
bq}HpӱbQD@Y
bq}HpձbQ
bq}HpձbQ,HYU
bq}HpֱbQT@Y
bq}HpױbQ,HYU
bq}HpױbQt@Y
bq}Hpޱb
bq}HpޱbA}Hp
bq}Hp߱bQ
bq}Hp߱bqTHX
bq~Ho
br<=q
brE@@\r
brR;$j
br\eL
br\t:H
britain
broken pipe
br}HX
br}HX5
br}HX=%A
br}HX=\ao
br}HX\r p
br}HX\reo
br}HwX
br}\bwL
bs-BA-Latn
bs-P%\r
bs-P%\rZ
bs-P%\rf
bs-ba-latn
bsN:7
bs]L#ԈbS
bs|;m\ar
bsܙ_>jj
bt:ۼF
bt\f;cfQ
bt\vǄ$L
bu&L;c
bu)t0f
bu;z9L
buMtSf
buMtUA
bu]tdf
buffer error
buffer range out of bounds
buffer too large
bufferSlot < numTimeSteps
bufferSlot < vertexAttribs.size
bufferSlot <= vertexAttribs.size
bufferType == RTC_BUFFER_TYPE_VERTEX && bufferSlot < RTC_MAX_TIME_STEP_COUNT) || (bufferType == RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE && bufferSlot < RTC_MAX_USER_VERTEX_BUFFERS
bufferType == RTC_BUFFER_TYPE_VERTEX && bufferSlot < numTimeSteps) || (bufferType == RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE && bufferSlot <= vertexAttribs.size
build threads
build user threads
builder
builder_mb
building BVH
buildslave\\phonon_main_win64\\build\\core\\deps-build\\mysofa\\src\\mysofa\\src\\hrtf\\resample.c
buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_hybrid.cpp
buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\device.cpp
buptxA
buӻ=h\f
bv:C/A
bvh.builder
bvh.force2level
bvh.forceflat
bvh.sah.extra_node_budget
bvh.sah.max_split_depth
bvh.sah.min_overlap
bvh.sah.traversal_cost
bvh.sah.use_splits
bvh.usesplits
bvh4.grid.eager
bvh4.quad4i
bvh4.quad4imb
bvh4.quad4v
bvh4.subdivpatch1eager
bvh4.triangle4
bvh4.triangle4i
bvh4.triangle4imb
bvh4.triangle4v
bvh4.triangle4vmb
bvh4.virtualcurve4imb
bvh4.virtualcurve8imb
bvh4obb.virtualcurve4i
bvh4obb.virtualcurve4v
bvh4obb.virtualcurve8i
bvh8.quad4i
bvh8.quad4imb
bvh8.quad4v
bvh8.triangle4
bvh8.triangle4i
bvh8.triangle4imb
bvh8.triangle4v
bvh8.triangle4vmb
bvh8.virtualcurve8imb
bvh8obb.virtualcurve8v
bvh_builder: branching factor too large
bvĻ\r
bw ;2
bw!;O
bw#bR}H
bw$bR}H
bw$br}H
bw:/Q
bw;:6
bw<?ZB
bw}:Lb
bx;ąJ
by.<u
bytes
bytes/prim
bz\b:I\r
b|\vD8C
b}Z8 \t
b~3;lI
b»rZͻ\f
bġ*Yt2t
bō;U2
bŒYT)D
bŻxo%;c
bſ<Z1
bǺ6sZ
bȻT88
bɅ:ITP
bкLNM
bл9JY
bҰ=tH
bԐ9mu89
bںE8ۻM
bھ:\rJ6
bڿ;Rb
bެ;BC
b鍸h+ȸ2D
b벺)ff;5A
c != BVH::emptyNode
c UAVAWI
c [1>H
c \v=H
c$;dq
c%;j51:l
c)JT$P
c)JT$p
c)\f=iw
c-;aB
c0 != BVH::emptyNode
c0S<I2
c1 != BVH::emptyNode
c1!K\b
c1!L$p
c1!L\n
c1!L\v
c1!T$P
c39f욻Sr
c4:|Wz
c5ŽDH
c8YxT9hJA
c8]vo:1
c8z;)D
c9!@8
c9K#\r
c9f癹Y
c:;hz
c:LW99
c;7wR
c;9\ei
c;LL6;N
c;Stz
c;UUUUUU
c;Y[n;C
c;\br
c;b3s
c;nNl
c<CBX
c<\eX
c=Q53
c=iX<\r2
c=u)Q
c>T;4\t
c>uo¾L
c?FA@s
c@S;w\t
cA$;Y
cA$;d
cA;o|q:VC
cAJрŘY
cAMD3L$0\tzenti3T$,1
cC<G读y
cC<j6W
cC}=Hu
cEP=>L
cF+;UH
cG95_E
cG<AE\f
cGy;\r
cIJʀŘY
cIJʀŘYu
cIûL\e
cIͺ@09
cK;b=U
cK\a;C
cL;D$0
cLk>M\r
cMJðŬY
cN\ewun
cP7;b"R
cR=flT
cRH;4FQ;\e\r1;d2
cRü'8
cSպD<P
cU>an~o
cUI:ݙy
cV\n;mg
cW+;Ah
cX<8yQ
cY!K8
c\\R<1b
c\bH:TSk
c\b\r;6
c\bba
c\e>Gn
c\eպL\b
c\r;j
c\t!p
c\t!s
c\t!s\b
c\tr;\n
c];T3
c^;0\vQ
c^ٻVg
ca!A8
ca!I8
ca!L$,0
ca!T$P
ca>:C
caJd$0
caJe0P
cache_accesses
cache_flushes
cache_hits
cache_hits + cache_misses == cache_accesses
cache_misses
cache_num_patches
cache_regression_test
cache_size
calculateAirAbsorption
calculateDirectivity
calculateDistanceAttenuation
calculateRelativeDirection
call to DCG routine
call to DCG routine. Otherwise, the maximal number
call to DFGMRES routine. Otherwise, the maximal number of iterations is equal to
canadian
cannot unget that many items
cartesian
cas:0
cblas_sgemv
cb漰"6<w
cd4;]㖺IyF;2\t
cd>,DZ
cdecl
cdֻ+mw
ce$=B
ceS:b
ce\n;K
center < end
center <= numPrimitives
center > start
character
child != BVH::emptyNode
chinese
chinese-hongkong
chinese-simplified
chinese-singapore
chinese-traditional
ciM;D
ci\f;n'O:A
ck:Ug
cl-mad-enable -cl-fast-relaxed-math -cl-std=CL1.2 -I
clBuildProgram
clCompileProgram
clCreateBuffer
clCreateBuffer failed
clCreateCommandQueue
clCreateCommandQueue failed
clCreateContext
clCreateContext failed
clCreateKernel
clCreateKernelsInProgram
clCreateKernelsInProgram failed
clCreateKernelsInProgram return 0 kernels
clCreateProgramWithSource
clCreateProgramWithSource failed
clCreateSubBuffer
clEnqueueCopyBuffer
clEnqueueFillBuffer
clEnqueueMapBuffer
clEnqueueMapBuffer failed
clEnqueueNDRangeKernel
clEnqueueNDRangeKernel failed
clEnqueueReadBuffer
clEnqueueReadBuffer failed
clEnqueueUnmapMemObject
clEnqueueUnmapMemObject failed
clEnqueueWriteBuffer
clEnqueueWriteBuffer failed
clFinish
clFinish failed
clFlush
clFlush failed
clGetCommandQueueInfo
clGetDeviceIDs
clGetDeviceIDs failed
clGetDeviceInfo
clGetDeviceInfo failed
clGetEventInfo
clGetEventInfo failed
clGetKernelInfo
clGetKernelInfo failed
clGetMemObjectInfo
clGetMemObjectInfo failed
clGetPlatformIDs
clGetPlatformIDs failed
clGetPlatformInfo
clGetPlatformInfo failed
clGetProgramBuildInfo
clReleaseCommandQueue
clReleaseContext
clReleaseDevice
clReleaseEvent
clReleaseKernel
clReleaseMemObject
clReleaseProgram
clRetainCommandQueue
clRetainContext
clRetainDevice
clRetainEvent
clRetainKernel
clRetainMemObject
clRetainProgram
clSetKernelArg
clSetKernelArg failed
clWaitForEvents
clWaitForEvents failed
cl_amd_media_ops2
cldemote
cleaned memory, deleted number of L&U-factorizations: %d
cleaned memory, deleted number of L&U-factorizations: %lli
closure stack overflow
clrcall
cmpccxadd
cmѼ7-\a
co%;hxۻk
coarse_x <= fine_x
coarse_y <= fine_y
code, or the parameter IPAR(7)=%s was altered by mistake outside of the routine
code, or the parameter ipar[6]=%s was altered by mistake outside of the routine
collider
collision_regression_test
combineBandpassedImpulseResponse
compact
compile time enabled
computeAlignedSpace not implemented for this geometry
computeDirection not implemented for this geometry
connection aborted
connection already in progress
connection refused
connection reset
const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n /************************************************************************* \n   EXTENSIONS \n   **************************************************************************/ \n \n \n \n   /************************************************************************* \n    TYPE DEFINITIONS \n    **************************************************************************/ \n#define STARTIDX(x)     (((int)((x).left))) \n#define LEAFNODE(x)     (((x).left) == ((x).right)) \n#define STACK_SIZE 64 \n#define SHORT_STACK_SIZE 16 \n \n \ntypedef struct \n{ \n    int parent; \n    int left; \n    int right; \n    int next; \n} HlbvhNode; \n \ntypedef struct \n{ \n    // BVH structure \n    __global HlbvhNode const* nodes; \n    // Scene bounds \n    __global bbox const* bounds; \n    // Scene positional data \n    __global float3 const* vertices; \n    // Scene indices \n    __global Face const* faces; \n    // Shape IDs \n    __global ShapeData const* shapes; \n    // Extra data \n    __global int const* extra; \n} SceneData; \n \n/************************************************************************* \n HELPER FUNCTIONS \n **************************************************************************/ \n \n \n \n /************************************************************************* \n  BVH FUNCTIONS \n  **************************************************************************/ \n  //  intersect a ray with leaf BVH node \nbool IntersectLeafClosest( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n            return true; \n        } \n    } \n \n    return false; \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r
const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \n/************************************************************************* \n TYPE DEFINITIONS \n **************************************************************************/ \n#define STARTIDX(x)     (((int)(x->pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n \ntypedef struct  \n{ \n    // BVH structure \n    __global BvhNode const*       nodes; \n    // Scene positional data \n    __global float3 const*        vertices; \n    // Scene indices \n    __global Face const*          faces; \n    // Shape data \n    __global ShapeData const*     shapes; \n    // Extra data \n    __global int const*           extra; \n} SceneData; \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nvoid IntersectLeafClosest( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n        } \n    } \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    i
context
context->instID[0] != RTC_INVALID_GEOMETRY_ID
context->primID < size
context->similarityScale > 0.f
continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = node.right; \n                continue; \n            } \n        } \n \n        idx = *--ptr; \n    } \n \n    //if (get_global_id(0) == 1) \n    //printf("Exiting %d\\n", get_global_id(0) ); \n \n    return hit; \n} \n \n#else \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            if (LEAFNODE(node)) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node), r, isect); \n            } \n            else \n            { \n                lbox = scenedata->bounds[node.left]; \n                rbox = scenedata->bounds[node.right]; \n \n                lefthit = IntersectBoxF(r, invdir, lbox, isect->uvwt.w); \n                righthit = IntersectBoxF(r, invdir, rbox, isect->uvwt.w); \n \n                if (lefthit > 0.f && righthit > 0.f) \n                { \n                    int deferred = -1; \n                    if (lefthit > righthit) \n                    { \n                        idx = node.right; \n                        deferred = node.left; \n                    } \n                    else \n                    { \n                        idx = node.left; \n                        deferred = node.right; \n                    } \n \n                    if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                    { \n                        for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                        { \n                            gsptr[i] = ldsstack[i * 64]; \n                        } \n \n                        gsptr += SHORT_STACK_SIZE; \n                        lsptr = ldsstack + 64; \n                    } \n \n                    *lsptr = deferred; \n                    lsptr += 64; \n \n                    continue; \n                } \n                else if (lefthit > 0) \n                { \n                    idx = node.left; \n                    continue; \n                } \n                else if (righthit > 0) \n                { \n                    idx = node.right; \n                    continue; \n                } \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n \n    return isect->shapeid >= 0; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            if (LEAFNODE(node)) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node), r)) \n                    return true; \n
contraction rate is greater than 0.9, interrupt
contradiction (set ido>0) %d
contradiction (set ido>0) %lli
converged, or parameter DPAR(5) was altered by mistake outside of the DFGMRES routine
convertAmbisonicAudioBuffer
convertToDeviceRepresentation not implemented for this geometry
convolutionQueue
copy constructor closure
count == (x1-x0+1)*(y1-y0+1
counter IPAR(4)=%s
cq!L$,0
cqJT$P
cqJd$P
cqJep
cr=>U
createAmbisonicsBinauralEffect
createAmbisonicsDecodeEffect
createAmbisonicsEncodeEffect
createAmbisonicsPanningEffect
createAmbisonicsRotationEffect
createBinauralEffect
createContext
createDirectEffect
createEmbreeDevice
createEnergyField
createHRTF
createImpulseResponse
createInstancedMesh
createOpenCLDevice
createOpenCLDeviceFromExisting
createOpenCLDeviceList
createPanningEffect
createPathEffect
createPrimRefArray not implemented for this geometry
createPrimRefMBArray not implemented for this geometry
createProbeArray
createProbeBatch
createRadeonRaysDevice
createReconstructor
createReflectionEffect
createReflectionMixer
createScene
createSerializedObject
createSimulator
createSource
createStaticMesh
createTrueAudioNextDevice
createVirtualSurroundEffect
created scene intersector
criterion, but it cannot be replaced as IPAR(31)=0
cross device link
crt_strtox::floating_point_value::as_double
crt_strtox::floating_point_value::as_float
cu0Ǆ$\b
cu:'r\e=BL3
cur != BVH::emptyNode
cur != BVH::invalidNode
current.prims.prims)[start].geomID() == (*current.prims.prims)[i].geomID
current.prims.size() == 0) || ((leafSAH >= 0) && (splitSAH >= 0
current.size() == 0) || ((leafSAH >= 0) && (splitSAH >= 0
curve4i
curve4imb
curve4v
curve8i
curve8imb
curve8v
cuռ]m\r
cvC=Z
cx!:A
cy:1V\b
c~<H5Z
c~ǻkY
cŘ"rY
cƽ\bS
cѕ:Ix
cՄ;1s
cպF2R
d / %m / %y
d"9d l
d$ E3
d$ H;T$8
d$ L;sxr
d$ L;{xr
d$ O;d
d$ UAVAW
d$ UAVAWH
d$ bb
d$ bq|H
d$ fA
d$ fD
d$ fff
d$ w\tE
d$ ŀYl
d$ ŠYu ŠY]0
d$ ŨY
d$$bb
d$$bbE
d$( bc
d$(bb
d$(r3H
d$(w\tE
d$,fff
d$00b
d$0A_A^A]A
d$0H;{xr
d$0Hc
d$0M#l$\bt
d$0M#l$\btP
d$0M#l$\btѐA
d$0O;d
d$0]A^A]A
d$0ba~\b
d$0fD
d$0r5L
d$4D+d$0
d$4D+d$0D
d$4D8l$1u
d$4fff
d$8A_A^A]A
d$8M#l$\btѐA
d$8]A
d$8ba~\b
d$;j7\b
d$<ŨYD$0D
d$@D9fD
d$@D;fD
d$@Hc
d$@Lc]l
d$@fD
d$@fff
d$@u\vA
d$@w\tE
d$@ŠYu ŠY
d$Dbb5
d$HH;P\b
d$HH;p\b
d$Hba
d$Hba~\b
d$Hbb
d$Hfff
d$Hffff
d$LH+X`I
d$PH;P\b
d$PHc
d$PHǅ0
d$PIi
d$PLcSl
d$PfA
d$PfD
d$Pfff
d$PŠYu
d$PŨYu0ŐYm
d$PŰXU
d$PŸY
d$XA8_\t
d$XH;T
d$XHǅP
d$XIi
d$XbbM\b
d$\bbb
d$\f0b
d$\fba|\b
d$\fbb
d$`Hc
d$`Lc
d$`fA
d$`fD
d$`ŨYu ňYU
d$dD;d$ltY
d$dba~\b
d$hfff
d$pHc
d$pIk
d$pO;d
d$pfA
d$pfD
d$pr;H
d$pw\t
d$xE3
d$xL9wHvGI
d$x]A
d$xbb5
d$xff
d$xfff
d$xr-H
d$xr6L
d$xtWI
d';aV@9
d'ûdE
d+<0B
d,ܺLMb
d2^2\\HJ2H2<:f
d3;H*k
d3K;:[B
d5\bb"m\b
d5e<^L
d5ƺsD
d6:yi\a
d79Y\r-8
d84<5k
d8s;i
d93PM
d9<kQ
d9r<A
d:75S
d:Cva;z
d:Ei\b
d:b<K
d:b\a
d:hPG
d:o1g<W
d:pǭ;Sr
d;)惼w3f
d;*Zi
d;@AQ
d;_}T9eq2;yX
d;b3ԺS
d;qs5
d;wsj
d<(1T
d<9W\a
d<\bO
d<a<v
d<w|h
d=*X6
d>U"D=z
d?000000
d@Y]\bb
d@Y]\bbBe
d@Y]\fb
d@Y]\fb1DHY
d@Y]\nbBe
dC>@5X
dCºEp
dD:Ckl
dE;iyn
dFb:\n
dG\e:q
dGk<US
dHY,$I
dHY4\ab
dHYU\ab
dIɻDv
dK;qSH
dL=ܭ7=L
dMڼʥ4
dN:{2N
dP;4e
dP?=MQ
dQH;fdo
dRD;X
dS;Jo3
dS;\v
dS\r<nT
dT fC
dT%'zB
dTq<*A
dUK:6
dX4"H
dXU`Ō]E
dX\f"H
dX\f<Uy
dY%J~A
dY%K%F
dY%RfF
dY%Y(B
dY%\brA
dY%gkG
dY&:k
dYv ŔY
d\aPġRYl\aTĢi
d\a\abQ|H
d\b$;ol
d\b;UḺ4
d\b\f;Oi
d\bʸY0
d\fn:r
d\n  fC
d\n00M
d\n9<[yP
d\nO;SO
d\n\abA|H
d\n\fba|H
d\nջM
d\v3=D
d\v;W1*9
d\v\abA|H
d] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n
d^\n<lQ
d_O;.Cz;Z
d_forward_trig_transform/d_backward_trig_transform routine
data error
data must be 4 bytes aligned
data$r
data$rs
db:;9P;H
dba~\b
dbf:CK\t
db};c$v
dc\a;\vn\f
dc_\bA
dd+;P
ddPdudv
ddPdvdv
dddd, MMMM dd, yyyy
de5:e
de<2f
debug
default
default constructor closure
defaultBlockSize
deinterleaveAudioBuffer
delete
depth
depth > 0
depth limit reached
deque<T> too long
derTwoLevel
dest.eval_start_index < dest.face_valence
dest.face_valence <= MAX_RING_FACE_VALENCE
destination address required
device
device or resource busy
deviceDesc
deviceList
dex].o = (float4) (camera->origin, FLT_MAX);\n    rays[index].d = (float4) (normalize(du * camera->right + dv * camera->up - camera->ahead), 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\nkernel void generateListenerRays(global CoordinateSpace* listeners,\n                                 global float4* sphereSamples,\n                                 global Ray* rays)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t listenerIndex = get_global_id(1);\n    size_t index = listenerIndex * get_global_size(0) + rayIndex;\n\n    rays[index].o = (float4) (listeners[listenerIndex].origin, FLT_MAX);\n    rays[index].d = (float4) (sphereSamples[rayIndex].xyz, 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Sphere Occlusion Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat raySphereIntersect(global const Ray* ray,\n                         float3 center,\n                         float radius)\n{\n    float3 origin = ray->o.xyz;\n    float3 direction = ray->d.xyz;\n\n    float3 v = origin - center;\n    float r = radius;\n\n    float B = 2.0f * dot(v, direction);\n    float C = dot(v, v) - (r * r);\n    float D = (B * B) - (4.0f * C);\n\n    if (D < 0.0f)\n        return FLT_MAX;\n\n    float t = -0.5f * (B + sqrt(D));\n    return t;\n}\n\nkernel void sphereOcclusion(uint numSources,\n                            global const CoordinateSpace* sources,\n                            uint numListeners,\n                            global const CoordinateSpace* listeners,\n                            global Ray* rays,\n                            global Hit* hits)\n{\n    uint numRays = get_global_size(0);\n    uint rayIndex = get_global_id(0);\n\n    for (int i = 0; i < numListeners; ++i)\n    {\n        uint index = i * numRays + rayIndex;\n\n        float listenerSphereHitDistance = raySphereIntersect(&rays[index], listeners[i].origin, LISTENER_RADIUS);\n        if (0.0f <= listenerSphereHitDistance && listenerSphereHitDistance < hits[index].uvwt.s3)\n        {\n            rays[index].extra.y = 0;\n            hits[index].primid = -1;\n            return;\n        }\n\n        for (int j = 0; j < numSources; ++j)\n        {\n            float sourceSphereHitDistance = raySphereIntersect(&rays[index], sources[j].origin, SOURCE_RADIUS);\n            if (0.0f <= sourceSphereHitDistance && sourceSphereHitDistance < hits[index].uvwt.s3)\n            {\n                rays[index].extra.y = 0;\n                hits[index].primid = -1;\n                return;\n            }\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Shading + Shadow/Bounced Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat3 calculateHitPoint(Ray ray,\n                         Hit hit)\n{\n    return ray.o.xyz + hit.uvwt.s3 * ray.d.xyz;\n}\n\nfloat3 calculateHitNormal(Ray ray,\n                          Hit hit,\n                          global float4* normals)\n{\n    float3 hitNormal = normals[hit.primid].xyz;\n    if (dot(hitNormal, ray.d.xyz) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    return hitNormal;\n}\n\nfloat pointSourceIrradiance(float distance,\n                            float minDistance)\n{\n    float attenuation = 1.0f / max(distance, minDistance);\n    float irradiance = (1.0f / (4.0f * PI)) * (attenuation * attenuation);\n    return irradiance;\n}\n\nfloat3 reflect(float3 incident,\n               float3 normal)\n{\n    return normalize(incident - (2.0f * dot(incident, normal) * normal));\n}\n\nkernel void shadeAndBounce(uint numSources,\n                           global const CoordinateSpace* sources,\n                           uint numListeners,\n                           global const
df;qye
dg27\f%8
dhr;w
di.<GZ
diag[dim] > 0.0f
diagonal matrix problem
didat$2
didat$3
didat$4
didat$5
didat$6
didat$7
directory not empty
disabled
disabled\n
distribute_part_sum_int4
div-MV
div-mv
division by a small diagonal value will happen
dk:l]k
dk;qǇ9
dkU<U
dm9\e
dm{>b\bw?q
dm|9xu
do;P-X
downmixAudioBuffer
dscale == 1.0f
dst >= begin && dst < end
dst->data
dst->data[iChannel][dst->numSamples - 1
dst->numChannels
dst->numSamples
dst.hasValidPositions
dst[iArray
during initialization stage. Computations have stopped
during the initialization stage. Computations have stopped
dut;tE
dutch-belgian
dv);P7
dx].pmax.w); \n            // Set topidx \n            topidx = -1; \n            // Restore ray here \n            r->o = topray.o; \n            r->d = topray.d; \n            // Restore invdir \n            invdir = invdirtop; \n        } \n    } \n \n    return isect->shapeid >= 0; \n} \n \n// intersect Ray against the whole BVH2L structure \nbool IntersectSceneAny2L(SceneData* scenedata, ray* r) \n{ \n    // Precompute invdir for bbox testing \n    float3 invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    float3 invdirtop = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    // We need to keep original ray around for returns from bottom hierarchy \n    ray topray = *r; \n \n    // Fetch top level BVH index \n    int idx = scenedata->rootidx; \n    // -1 indicates we are traversing top level \n    int topidx = -1; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, r->o.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                // or containing another BVH (top level hierarhcy) \n                if (topidx != -1) \n                { \n                    // This is bottom level, so intersect with a primitives \n                    if (IntersectLeafAny(scenedata, &node, r)) \n                        return true; \n                    // And goto next node \n                    idx = (int)(node.pmax.w); \n                } \n                else \n                { \n                    // This is top level hierarchy leaf \n                    // Save top node index for return \n                    topidx = idx; \n                    // Get shape descrition struct index \n                    int shapeidx = SHAPEIDX(node); \n \n                    // Get shape mask \n                    int shapemask = scenedata->shapedata[shapeidx].mask; \n                    // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                    // otherwise skip the subtree \n                    if (Ray_GetMask(r) && shapemask) \n                    { \n                        // Fetch bottom level BVH index \n                        idx = scenedata->shapedata[shapeidx].bvhidx; \n \n                        // Fetch BVH transform \n                        float4 wmi0 = scenedata->shapedata[shapeidx].m0; \n                        float4 wmi1 = scenedata->shapedata[shapeidx].m1; \n                        float4 wmi2 = scenedata->shapedata[shapeidx].m2; \n                        float4 wmi3 = scenedata->shapedata[shapeidx].m3; \n \n                        // Apply linear motion blur (world coordinates) \n                        //float4 lmv = scenedata->shapedata[shapeidx].linearvelocity; \n                        //float4 amv = scenedata->shapedata[SHAPEDATAIDX(node)].angularvelocity; \n                        //r->o.xyz -= (lmv.xyz*r->d.w); \n                        // Transfrom the ray \n                        *r = transform_ray(*r, wmi0, wmi1, wmi2, wmi3); \n                        //rotate_ray(r, amv); \n                        // Recalc invdir \n                        invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n                        // And continue traversal of the bottom level BVH \n                        continue; \n                    } \n                    else \n                    { \n                        // Skip the subtree \n                        idx = -1; \n                    } \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                // This is an internal node, proceed to left child (it is at current + 1 index) \n                idx = idx + 1; \n            } \n        } \n        else \n        { \n            // We missed the node, goto next one \n            idx = (int)(node.pmax.w); \n        } \n \n        // Here check if we ended
dynamic
dynamic atexit destructor for
dynamic initializer for
dŮ=AI
dż;4i
dƼCQۼ89
dǘ:44
dʯ;Dz
d̺\vOM
dλQf'<u
dս\nw1=jj\t
dغ\vL
dܺQ#f
d䨹j6D
d濻Euz
e =pKH
e =Ӳf
e L;oxr
e M#l$\bt
e O;d
e ๏4\f
e!<fp
e"2<Z
e"?Dg
e$; \tB;1
e%89z
e%I<\n3
e%c<S1
e&<Nf
e&=4o\t
e'9\t5G;Y
e';YKY
e';gu
e'<lH
e(O;d
e)X;r
e)e>u
e*;=uo9\n
e*<0b\r
e*k:n
e+:EQ
e+W:F
e,I=waK
e->hasOpposite
e-ǻcZ
e.4nI
e.5;+oB
e.dn I
e.t/ I
e.|o I
e/;\vca
e/g<b
e/¼fr
e/ʺHo
e0<\at#A
e0<dV
e0A_A^A]A
e0ban\bY1ŊXA
e1>:L
e1G;J{f
e1^;8K\t
e1y;6
e1Ӻoq
e3:gN
e3;Tu
e4,;Tf
e4;Lv
e4="Q
e5;cw3
e5<7 &;z
e5S;T>g:0
e69\r:l
e6:&x
e6;G~G
e7#<X
e7.? bz
e7;B\te
e7;CE
e7<!\v0
e7t;@n3
e8G;]5
e99<9I
e9;N^J
e9^ä9
e: 涻G
e:Rfx
e:Z/8
e:\n l
e:rM\a9
e:uW{9
e:vCw
e:ΊzWd
e;( O
e;(UI
e;0an
e;YM]9J
e;YY\e
e;\aI
e;`Q5
e;d&i
e;fzp
e;g%H
e;g+C:9
e;oAV
e;ykv
e;ԃV=1Z
e;ޖd;W9
e< t ;C
e<!96
e<[P09o
e<\bl
e<`nH
e<eT\n<HY
e<hq\r
e<k8k
e=-Ke
e=Q0F
e=Q蒽I
e=rAe>U:f
e>+8j
e>K7\a
e>q<0H
e>uik
e>uu=Rp
e? =\rUֽb
e?5t,?d
e@A_A^A
e@ŠYT
eA1:HYS
eA\vЉT;\fH
eB@=HRS>vR
eBZ>̣m
eBٺ>Aj
eC2<Z
eC<$o
eCNאBO:#Cl
eCŻDX
eD?}\eD
eDigiCert Assured ID Root CA0
eEr;db
eF=9Aټp\f9>s
eFڻXvU
eG<!0
eG\v<}R
eGʻ2l
eH;{xr
eH@%%XV
eH@%*bV
eH@%4
eH@%4u
eH@%Ef
eH@%Ew
eH@%F
eH@%Lx
eH@%R
eH@%\rj
eH@%oi
eHA_A^A]A
eHH:)Z
eH\t=ME
eI ;1
eI<UGW
eI};giW
eIٺb8z
eJ.85
eJ5;WN\b;y5C
eL;6E
eL;swg
eL;sxr
eL<<g8G
eN9=3W
eO9ۻ\r
eO;JP\a
eO<dH
eOP9f
eP%;0
eP8RG:\t
ePH;u
ePw:1
ePŰXT
eQ(>1
eQ*=O
eQD;Q"*;tnt
eQۼ\fT
eR7<g
eRS:T
eS;{HA
eU<Dh
eVW=z
eV˻j6
eW=88z
eX;!7I
eXN;d
eXd;fs
eXܻ"U
eY=ht1=M\f
eYO9m
eY̼Xh
eZn:0
e[;4OV
e\a>8Na
e\abA|H
e\aͻ\bt
e\b+;NG
e\bO;d
e\bX=Tĭ>6
e\bb;x
e\e;脫98tt
e\ebA,(X
e\f:k~z
e\f\b
e\nb1d@T
e\r;eL
e\r>7
e\rbA|H
e\t;Q
e\tz:s
e\v5=%䥾VMx
e\vbA|H
e\vn?c
e\v։T;\fH
e^;iRe
e`:G\fb
e`ŴYU
easy->fir
eaܺͥ6
eb!|H
eb1t Y
ebA}Hpɱb
eba|H
ec;Wa
ec<\r
ed:"e
ed;\fO
ed;\t
ed<9i2
edData[localOffset.w] = val.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    // Now store to memory \n    if (((globalId + 1) << 2) <= numElems) \n    { \n        out_array[globalId] = sharedData4[localId]; \n        out_debug_offset[globalId] = localOffset; \n    } \n    else \n    { \n        if ((globalId << 2) < numElems) out_array[globalId].x = sharedData4[localId].x; \n        if ((globalId << 2) + 1 < numElems) out_array[globalId].y = sharedData4[localId].y; \n        if ((globalId << 2) + 2 < numElems) out_array[globalId].z = sharedData4[localId].z; \n    } \n \n    if (localId == 0) \n    { \n        out_histograms[groupId] = localHistogram.x; \n        out_histograms[groupId + numGroups] = localHistogram.y; \n        out_histograms[groupId + 2 * numGroups] = localHistogram.z; \n        out_histograms[groupId + 3 * numGroups] = localHistogram.w; \n \n        out_local_histograms[groupId] = 0; \n        out_local_histograms[groupId + numGroups] = localHistogram.x; \n        out_local_histograms[groupId + 2 * numGroups] = localHistogram.x + localHistogram.y; \n        out_local_histograms[groupId + 3 * numGroups] = localHistogram.x + localHistogram.y + localHistogram.z; \n    } \n} \n \n#define GROUP_SIZE 64 \n#define NUMBER_OF_BLOCKS_PER_GROUP 8 \n#define NUM_BINS 16 \n \n// The kernel computes 16 bins histogram of the 256 input elements. \n// The bin is determined by (in_array[tid] >> bitshift) & 0xF \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid BitHistogram( \n    // Number of bits to shift \n    int bitshift, \n    // Input array \n    __global int const* restrict in_array, \n    // Number of elements in input array \n    uint numelems, \n    // Output histograms in column layout \n    // [bin0_group0, bin0_group1, ... bin0_groupN, bin1_group0, bin1_group1, ... bin1_groupN, ...] \n    __global int* restrict out_histogram \n    ) \n{ \n    // Histogram storage \n    __local int histogram[NUM_BINS * GROUP_SIZE]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    /// Clear local histogram \n    for (int i = 0; i < NUM_BINS; ++i) \n    { \n        histogram[i*GROUP_SIZE + localid] = 0; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    const int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    const int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        /// Load single int4 value \n        int4 value = safe_load_int4_intmax(in_array, loadidx, numelems); \n \n        /// Handle value adding histogram bins \n        /// for all 4 elements \n        int4 bin = ((value >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.x*GROUP_SIZE + localid]); \n        //bin = ((value.y >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.y*GROUP_SIZE + localid]); \n        //bin = ((value.z >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.z*GROUP_SIZE + localid]); \n        //bin = ((value.w >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.w*GROUP_SIZE + localid]); \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int sum = 0; \n    if (localid < NUM_BINS) \n    { \n        for (int i = 0; i < GROUP_SIZE; ++i) \n        { \n            sum += histogram[localid * GROUP_SIZE + i]; \n        } \n \n        out_histogram[numgroups*localid + groupid] = sum; \n    } \n} \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE
edata
edge0 == edge3->next
edge0->isRegularFace
edge0->prev()->opposite()->prev()->hasOpposite
edge0->vertex_crease_weight == 0.0f || std::isinf(edge0->vertex_crease_weight
edge_level[0] >= 0.0f
edge_level[1] >= 0.0f
edge_level[2] >= 0.0f
edge_level[3] >= 0.0f
edge_levels[0] >= 1.0f
edge_levels[1] >= 1.0f
edge_levels[2] >= 1.0f
edge_levels[3] >= 1.0f
edge_valence>=i
ee2:w
ee:lYF
ef$;TE
ef;|jY
efG;R
effect
effectSettings
effectSettings->hrtf
effectSettings->irSize
effectSettings->maxOrder
effectSettings->numChannels
effectSettings->spatialize
effectSettings->speakerLayout.numSpeakers
effectSettings->speakerLayout.speakers
effectSettings->speakerLayout.speakers[iSpeaker].x
effectSettings->speakerLayout.speakers[iSpeaker].y
effectSettings->speakerLayout.speakers[iSpeaker].z
effectSettings->speakerLayout.type
effectSettings->type
effffff
eg<@s
eh vector constructor iterator
eh vector copy constructor iterator
eh vector destructor iterator
eh vector vbase constructor iterator
eh vector vbase copy constructor iterator
eh:N]\a
ehL;`\b
eh\f::t
ehttp://www.digicert.com/CPS0
eiX9t
ej;!Lx
el\f;n
el{n0t:e
em,=l
en097
enable_compressed_reverb_lookup
enable_dc_correction_for_phase_interpolation
enable_hybrid_eq_from_ir
enable_iir_order_8
enable_iir_order_switching
enable_paths_from_all_source_probes
enable_reverb_probe_caching_for_missing_probes
enable_selockmemoryprivilege
enabled
enabled (forced)\n
enabled\n
end-i == 1
endID < BINS
energyField
england
english-american
english-aus
english-belize
english-can
english-caribbean
english-ire
english-jamaica
english-nz
english-south africa
english-trinidad y tobago
english-uk
english-us
english-usa
enn:u
enqcmd
eo/<c
eoI;ef
ep:i9B;4
ep;VX
ep;ak
ep<\auv
eph<'c
equal to 0 simultaneously
er*:r
er\a<s
erd:*7W
erp:0
error PARDISO: iterative refinement
error PARDISO: reordering, symbolic factorization
error: more roots than expected\n
er~;1
es1;<7
estimatedSize
es{9Zu
et:5J\t9
et<3lA=M
euCȭU
euJ:52
evC=Eu
eval_start_index < face_valence
evaluateDirectivity(hitPoint, sources[sourceIndex], directivities[sourceIndex]);\n        energy *= pointSourceIrradiance(hitToSourceDistance, irradianceMinDistance);\n        energy *= accumEnergyDelay[rayIndex].xyz * ((float3) 1.0f - hitMaterialAbsorption);\n\n        float delay = (hitDistance + hitToSourceDistance) / SPEED_OF_SOUND;\n        delay += accumEnergyDelay[rayIndex].w - (distance(source, listeners[listenerIndex].origin) / SPEED_OF_SOUND);\n\n        energyDelay[shadowRayIndex] = (float4) (energy, delay);\n    }\n\n    barrier(CLK_GLOBAL_MEM_FENCE);\n\n    // Generate the bounced ray.\n    if (numListeners > 1 || sourceIndex == 0)\n    {\n        accumEnergyDelay[rayIndex].xyz *= ((float3) 1.0f - hitMaterialAbsorption);\n        accumEnergyDelay[rayIndex].w += hitDistance / SPEED_OF_SOUND;\n\n        float4 reflectedDirection = (float4) 0.0f;\n        if (randomFloat < hitMaterial.scattering)\n        {\n            uint sampleIndex = randomUint % numDiffuseSamples;\n            float3 transformedDiffuseSample = transformHemisphereSample(diffuseSamples[sampleIndex].xyz, hitNormal);\n            reflectedDirection = (float4) (transformedDiffuseSample, 0.0f);\n        }\n        else\n        {\n            reflectedDirection = (float4) (reflect(rayDirection, hitNormal), 0.0f);\n        }\n\n        reflectedRays[rayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * reflectedDirection.xyz, FLT_MAX);\n        reflectedRays[rayIndex].d = reflectedDirection;\n        reflectedRays[rayIndex].extra = (int2) (0xffffffff, 1);\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Image Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherImage(uint numSources,\n                        global const int* occluded,\n                        global const float4* totalEnergy,\n                        global float4* image)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t numRays = get_global_size(0);\n\n    for (uint i = 0; i < numSources; ++i)\n    {\n        if (occluded[i * numRays + rayIndex] < 0)\n        {\n            image[rayIndex] += totalEnergy[i * numRays + rayIndex];\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Energy Field Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherEnergyField(float scale,\n                              global const float4* totalEnergy,\n                              uint offset,\n                              global const int* occluded,\n                              global const float* shCoefficients,\n                              global int* energy)\n{\n\t// The number of global work-items for this kernel is #rays * #bands * #channels.\n\t// The number of local work-items for this kernel is #bins * 1 * 1. Here, #bins is a compile-time constant.\n\t// This kernel runs in three stages:\n\t//\t1.\tEach work-group operates on a subset of rays, and accumulates their energy into one of multiple\n\t//\t\tlocal-memory histograms.\n\t//\t2.\tEach work-group adds all of its local-memory histograms together.\n\t//\t3.\tThe work-groups cooperate and combine their local-memory histograms into a global-memory histogram.\n\n    uint rayIndex = get_global_id(0);\n    uint band = get_global_id(1);\n    uint channel = get_global_id(2);\n\n    size_t numRays = get_global_size(0);\n\n    bool isOccluded = (occluded[offset + rayIndex] >= 0);\n\n\t// FIXME: shouldn't this be just get_local_id(0)?\n    const int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\n\t// Each work-group stores NUM_LOCAL_HISTOGRAMS histograms in local memory. These are interleaved, i.e.,\n\t// bin i of histogram j is at index (NUM_LOCAL_HISTOGRAMS * i + j) in the buffer. We use multiple local-memory\n\t// his
evϼg%a
ew:ki6
ew;:x
ewM;3
ex;<d
exceeds maximum iteration number %d
exceeds maximum iteration number %lli
executable format error
ext-ms
ext-ms-win-ntuser-dialogbox-l1-1-0
ext-ms-win-ntuser-windowstation-l1-1-0
ext_elements.load() <= set.ext_range_size
ext_end >= range<Ty>::_end
exȺ3 c
ey:HBp
ez<8w
e|ѽ\fEH
e}4=Z
e}<LN3
e~8;o
e»vhq
e¼\vOǼJk
e¼t麼O
eġz^L\e
eġzot
eġzot0
eġzot8
eĢy!D\b
eǑ<qg
eɼ8%Y\r
eʻ"A0
e̽NOj>x
eҔ;b7d
eҢ9nuo
eӖ:s80
eԻqvϺTj
eؼCO\r=|a
eٻ#ur;9
eߨ;KS
e쫼F_G
f %d %d %d\n
f (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n \n// intersect Ray against the whole BVH structure \nvoid IntersectSceneClosest(SceneData const* scenedata,  ray const* r, Intersection* isect) \n{ \n    const float3 invdir  = make_float3(1.f, 1.f, 1.f)/r->d.xyz; \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    int idx = 0; \n \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        // If this is the leaf try to intersect against contained triangle. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, isect->uvwt.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                IntersectLeafClosest(scenedata, &node, r, isect); \n                idx = (int)(node.pmax.w); \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                ++idx; \n            } \n        } \n        else \n        { \n            idx = (int)(node.pmax.w); \n        } \n    }; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata,  ray const* r) \n{ \n    float3 invdir  = make_float3(1.f, 1.f, 1.f)/r->d.xyz; \n \n    int idx = 0; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        // If this is the leaf try to intersect against contained triangle. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, r->o.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                if (IntersectLeafAny(scenedata, &node, r)) \n                { \n                    return true; \n                } \n                else \n                { \n                    idx = (int)(node.pmax.w); \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                ++idx; \n            } \n        } \n        else \n        { \n            idx = (int)(node.pmax.w); \n        } \n    }; \n \n    return false; \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosestAMD( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process \n__global Intersection* hits, // Hit datas \n__global int*          raycnt  \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id  = get_global_id(0); \n    int local_id  = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    Intersection isect; \n \n    while (ridx < numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            IntersectSceneClosest(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[ridx] = isect; \n        } \n    } \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAnyAMD( \n    // Input \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices
f :F'\n
f s cgx iterations %d
f s cgx iterations %lli
f s total - sum: %f s
f u:gw
f"<dZ
f#b"eH
f$H9L
f$I9L$\bu\n
f$\e>zI
f$bA~\b
f$ba~\b
f&ba}Hp<ѱK
f':6J
f';KjX
f(-8y
f(k:0dR
f(ȹvǮ9B
f)\n;tq
f)\r<Gi
f+:qdA
f+bQ|H
f,6:N
f.bQ|H
f/8o J;;b
f0-<K
f0:;l
f0U808
f0\vP!s
f0\vP\np\t`\b
f0\vp\n`\t
f0b!L@X
f0u'H
f1.=y\e
f1L<ͅǻM
f1tlārY$\nJ
f2:!I4
f2\bp\a
f2\bp\aP
f2\n9I
f2b1|H
f2bA|H
f3bBm
f65;܂G
f6b:s
f8>1x:N
f8?ls7
f8ba\\H
f8ݗV:\fl
f9(t\eL
f9(t\fH
f9)u4H9j
f9)u:H
f9,P9
f9.9r
f9/t\tH
f94748
f9<H}\r
f9GGd9
f9\a=s:bcB
f9\bt\rH
f9\bt\tH
f9\bu3HcH<H
f9\nt\tH
f9b!lH
f9b1|H
f9i@w
f9w=`p
f9wZ~9
f9£i8
f:"Yv:d
f:'SK
f::OS
f:Sw$9
f:WV*;Td
f:YXn9
f:\fe
f:fQ\f
f:iby
f:itd:\t
f:ki{9
f:p\t
f:q;Q
f;)ax;K
f;*Ns
f;.tS
f;0H1
f;2Y}>k
f;8\rH9W
f;<wL
f;>YE
f;H9n
f;O^0
f;S;y
f;X\rM
f;X`e
f;Yt˹3
f;\bd
f;\n@a<RI
f;\nDf;VH
f;\tq1<[4I
f;\vuS
f;bA|H
f;k\nF:j
f;r4U
f;t'4<u
f;v\a
f;x)6
f;{\vq; E
f;~gF
f;Ä\b9 \rA
f<IR\t
f<Ol4
f<[6I
f<\fr6
f<\vzμs
f<]V̹AHP
f<f'f<I
f<mT\nE
f<s42
f=B^l=;or
f=G(H
f=HQ\v
f=dS\v>\n
f=j63
f>0Wy
f>>FN
f>Jd\b
f>\bAV>\f
f>\ncL
f?0UE
f?@9ke
f?R(1
f?T;p
f?br}H
f@A:2
f@HcC(H
f@Ye\nH
f@Ye\nb14HY
f@br}H
f@ŸYv
fA9,@u
fA9,Au
fA9,Qu
fA9,vu
fA91t A
fA;(t(fA98t
fA;8unI
fA;\at\rI
fB9,$O
fB9,Nu
fB94Ou
fB94ht\tH
fB9<@u
fB9<Bu
fB9<Hu
fB9<{u
fB9\fht
fB:)Tf
fC94wu
fC\a>8B
fC\r8\e
fD#\vD$\b
fD+c\bD
fD9 t\a
fD9 t\fH
fD9 t\vH
fD9!u\b
fD9$Hu
fD9$Ou
fD9$wu
fD9,Au
fD9,pu
fD91uTL9r
fD91u\r
fD94Au
fD94Cu
fD94H}aD
fD94Ku
fD94Pu
fD94iu
fD98u\fA
fD9;u\a3
fD9<Gu
fD9<Hu
fD9\bt\rH
fD9\tt(L
fD9d$pt+fD
fD9t$b
fD9|Dhu
fD9|Dhu1
fD9|DhuA
fD9|DhuO
fD\vD$HfD
fD\vd$LfD
fD\vd$PfD
fD\vd$TfD
fD\vu0fD
fD\v|$hfD
fDigiCert Inc1
fE2;B
fE9!fA
fE9,Fu
fE94Gu
fE94wu
fE98t
fE9<Au
fE:k\f
fES:헏:D
fE\n;T Z
fE\v\bfA
fEo;N
fF"=\rX5
fF<Muq
fFs;\e\em
fG9$Ou
fG;PB
fH:!H
fHY4\ebA\fHY\\\e
fH}aB
fHǄ$H\b
fI;n1
fI;tJ\b
fJ;I@a
fJāzY\f
fJԻyrg
fM7<Io
fNֺl/b:\v
fO*>V
fO;Qm
fP:zV
fP;?C";UI
fPҺ/X
fQѻ;q
fR <4c\f
fR\bp\a
fRռhg
fRؽ$C\t
fS>p%C
fSԻvyc
fT=O&n=V
fT\r<Zf2
fU\t=c
fV2:i
fV:Rǭ9
fV<\nL
fV=۠Q
fVE`A\v
fVM@A\v
fW;-I
fWo:Js
fX!t5
fXT=7E
fXT=dL
fXڻOa
fY)9I
fY;7a
fY] ńY
fYٻw\e
fZ;6=u
fZK;r
fZy=kJA
f[#9a'g
f[D;\nD
f[Ģy#D0
f[Ģy#D8
f\a96
f\a<Vhn
f\b!9D
f\b!<8M
f\b;"ep
f\bL:T\tn
f\b\\Q\nb
f\e0B
f\eba~Ho
f\f:|Zk
f\fv:m
f\n0A
f\n=@Z9
f\n>J0
f\nW;`wv
f\n\n;k
f\nba|H
f\nr8J
f\nāzY\f
f\r:D
f\r<\eV
f\r=j}5
f\tD$BH
f\tn:l
f\v<\tL
f\vT$HD
f\vT$LD
f\vT$Lf
f\vT$`f
f\vT<ӸG
f\vb!|H
f\vba|H
f\vba~\b
f]<o\af
f]P>uep
f]R=r/X
f]\t:In
f`3;JF
f`;N#O9aU
face_index < face_valence
factorization - write&read: %d
factorization - write&read: %lli
factorize
failed
failed: cylinder
fast_allocator_regression_test
fastcall
fatbvh
fatbvh accelerator can cause stack overflow for this scene, try using bvh instead
fatbvh accelerator can't allocate enough stack memory, try using bvh instead
fb;<Cu
fbQ|H
fb\b0\aP
fba$@X
fba|H
fba~\b
fd;ۖ4
fdY:\f圻68
fdbBm
fe;+GF
feJ<F
feN>(s[>v
ff9381774dc99fea81a932ad276677aad6a3d4dd
ffalse
fffff
ffffff
fffffff
fg>5Xu
fgƺAyy
fgϻ^9
fic9aaP
file error
file exists
file too large
fileBaseName
filename too long
fill-in parameter is negative
filled
filter functions not supported for this geometry
finished BVH
first <= last
fiԼ<k\t
fj:mgA
fj;`L
fkU:^o
fkg;m
fl;9c
flags
flat_bezier_curve
flat_bspline_curve
flat_catmull_rom_curve
flat_hermite_curve
flat_linear_curve
float expected
float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n
float_exceptions
fmR:\n
fm\v:/t
fn<zɹ;H
fo9@T
fo:GỺl
for BVH4<GridMesh
for BVH4<Object
for BVH4<Quad4i
for BVH4<Quad4iMB
for BVH4<Quad4v
for BVH4<Triangle4
for BVH4<Triangle4i
for BVH4<Triangle4iMB
for BVH4<Triangle4v
for BVH4<Triangle4vMB
for BVH4MB<GridMesh
for BVH4OBB<VirtualCurve4i
for BVH4OBB<VirtualCurve4iMB
for BVH4OBB<VirtualCurve4v
for BVH4OBB<VirtualCurve8i
for BVH4OBB<VirtualCurve8iMB
for BVH8<Object
for BVH8<Quad4i
for BVH8<Quad4v
for BVH8<Triangle4
for BVH8<Triangle4i
for BVH8<Triangle4iMB
for BVH8<Triangle4v
for BVH8<Triangle4vMB
for BVH8MB<GridMesh
for QBVH8<Quad4i
format or the matrix is degenerate with zero row
foȸ%M\v
fp09*$u:\tS
fp\v0\nP
fp\v`\n0
fp\v`\nP
fp\v`\nP\t0
fpx<QFI
fq1<&JF
fq5<1
fq;6nǺg
fq<dm
fqp;E
fq༉匼Cb
fr\bp\a
fr\bp\aP
free blocks
freeAudioBuffer
freeBlocks.load() != nullptr && freeBlocks.load()->getBlockAllocatedBytes() >= bytes
french-belgian
french-canadian
french-luxembourg
french-swiss
frequency_level
fs,:3e
ft==\nT
ft\v;7
fuQ:|vs
fu_E3
function BVH4Curve8iBuilder_OBB_New not supported by your CPU
function BVH4OBBCurve8iMBBuilder_OBB not supported by your CPU
function BVH8BuilderTwoLevelInstanceArraySAH not supported by your CPU
function BVH8BuilderTwoLevelInstanceSAH not supported by your CPU
function BVH8BuilderTwoLevelQuadMeshSAH not supported by your CPU
function BVH8BuilderTwoLevelTriangle4MeshSAH not supported by your CPU
function BVH8BuilderTwoLevelTriangle4iMeshSAH not supported by your CPU
function BVH8BuilderTwoLevelTriangle4vMeshSAH not supported by your CPU
function BVH8Curve8vBuilder_OBB_New not supported by your CPU
function BVH8InstanceArrayMBSceneBuilderSAH not supported by your CPU
function BVH8InstanceArraySceneBuilderSAH not supported by your CPU
function BVH8InstanceMBSceneBuilderSAH not supported by your CPU
function BVH8InstanceSceneBuilderSAH not supported by your CPU
function BVH8OBBCurve8iMBBuilder_OBB not supported by your CPU
function BVH8Quad4iMBSceneBuilderSAH not supported by your CPU
function BVH8Quad4iSceneBuilderSAH not supported by your CPU
function BVH8Quad4vSceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Quad4vSceneBuilderSAH not supported by your CPU
function BVH8QuantizedQuad4iSceneBuilderSAH not supported by your CPU
function BVH8QuantizedTriangle4SceneBuilderSAH not supported by your CPU
function BVH8QuantizedTriangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4SceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4SceneBuilderSAH not supported by your CPU
function BVH8Triangle4iMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderSAH not supported by your CPU
function VirtualCurveIntersector8i not supported by your CPU
function VirtualCurveIntersector8iMB not supported by your CPU
function VirtualCurveIntersector8v not supported by your CPU
function not supported
fv8Dd
fvϽjE
fx:_P2
fxº\fm
fxǾ;X2
fy=p:5
f}ͻB碻lC
f~ֺ\f9M
fÈbQ4
fÜ9- w
fżeqD
fǻ4sJ
fȼf\fj
fɐbq|H
fϹk,e:EG1
fӔ;tpw
fջ\tIz
fռ7`s
fغKd̺oU
fܵ;BA
g!3;Rn8
g!T9"d
g#d<'YC
g%H9V
g'L;kd
g(v;\fA
g*?VO
g*U;t
g*k;8
g+m;sOν[3
g+ѻ2PK
g,;wa 9c
g,<\bp3
g->Ra
g0;TQj
g0ܼe_c
g2=ya=A
g2{:Rn
g3>:2w
g3}>Bi
g4o>e
g4v:E
g5=b\nj
g5RҌ<țu
g6H=Co
g6N:B
g8;;\nk
g8B~0GBf
g8ɊúD
g8мFT
g8߰99g
g9@x!8
g9P0\e
g9P[T<Q
g9ھg9
g: kP;O
g:7`U
g:A\n
g:Hǩ;vHO
g:PZP
g:V6s
g:_lu
g:isr9U
g:qmU
g;2zI
g;>\n49
g;G7p
g;G;kyW
g;hD&;E
g;kuG
g;m{5
g<df\t
g<vm2
g<v«9n
g<z(L
g=+8S
g=K\r
g>>wd\r
g@2:9
gB:cc0
gC`;C
gDﻪY1
gGV=pD
gHH;_P
gLV;I3
gM3<Xs
gO;uIg
gQ;'x
gR9>W8
gRC:h
gS;chc;rx
gS<m\vl
gT\\;QYI
gU(:;47
gUD;ZU
gX<FK
gY(<d
gY^8\a
g\\z>RD
g\a>xh\a5hi\a,4
g\b:CkK
g\e<fB
g\eL>r
g\fD:\n
g\n<K!G<G
g\t;!LM
g\tC;[P
g\v;KZa:6
g^z:h
g_j<H_w
gaP=\rH
ga\b;d
gatherEnergyField
gatherImage
gb6=Md
gbѼzQP
general
generateCameraRays
generateListenerRays
generateProbes
generic
geomID
geomID == geomID0
geomID does not return correct type
geomIDs[i] != -1
geometries[i]->getTypeMask() & Mesh::geom_type
geometry not committed
german-austrian
german-lichtenstein
german-luxembourg
german-swiss
getAABBNodes
getAABBNodesMB
getAABBNodesMB4D
getDataSize
getDeviceDesc
getEnergyField
getGeometryDataDeviceByteSize not implemented for this geometry
getNumBins
getNumChannels
getNumDevices
getNumProbes
getNumSamples
getOutputs
getProbe
getReverb
getinfoaH
gfffffff
gfffffffH
gfffffffI
gfffffffL
gffffffff
gflop   for the numerical factorization: %f
gflop/s for the numerical factorization: %f
gg:C\r4<t
ghL+g`H
ghL+g`I
gj\f>t
go7H=_;K
gp;:nJ
gr9DH7S
gr:-\rY
great britain
grid_accel
grid_accel_mb
grid_u_res >= 1
grid_v_res >= 1
grids
groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    *sum = shmem[groupSize - 1];\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    if (localId == 0){\\ \n    shmem[groupSize - 1] = 0;}\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_PART(type)\\ \n    type group_scan_exclusive_part_##type( int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    type sum = 0;\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (localId == 0)\\ \n    {\\ \n    sum = shmem[groupSize - 1];\\ \n    shmem[groupSize - 1] = 0;\\ \n    }\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    return sum;\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE(type)\\ \n    __kernel void scan_exclusive_##type(__global type const* in_array, __global type* out_array, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    int groupId   = get_group_id(0);\\ \n    shmem[localId] = in_array[2*globalId] + in_array[2*globalId + 1];\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    out_array[2 * globalId + 1] = shmem[localId] + in_array[2*globalId];\\ \n    out_array[2 * globalId] = shmem[localId];\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\\ \n    v2.w += v1.w;\\ \n    shmem[localId] = v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    v2.w = shmem[localId];\\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4_V1(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_##type##4##_v1(__global type##4 const* in_array, __global ty
gu;wI
gvd;>L
gyU:b
g»t\e
gŏ=KG
gŦ:DA
gʼ0;g<o
gͺˇy:2v\n
gκhv付E
gМ;zg
gһuv0
gԺUKL
gۼYVn
h VAVAWH
h VWAVH
h#:yo
h&2;2r
h-Ѽws
h16;|x
h4:IgZ
h5]:i
h5e>v
h60;kG
h6D;2t;<6
h6ٺڿB8
h7꼫a1
h8o\vo
h9 20
h9*yx:UQ
h9<qah
h9>0˺_N
h9^c89
h:)J\t:AY
h:/1E
h:2hH;z
h:Z磺\vO
h:g+f
h:or^9
h:p.Y
h;Adi;rr
h;NDn
h;XtۼK
h;\fZV;7e
h;fKn;06r
h;yjo;K
h;̤d;\tUl
h<A<w\a7
h<I\b6
h=:"OV9
h=;kSp
h=E.2
h=I?F>I
h=\n;pD
h>2ip
h>^ht>0
h?=vxX
h?tFپLJk
hA;μw
hA^A]A
hA_A]A
hA_A^A]A
hB)9Ǯq
hB.<C6F
hB:QN49
hB^T{C
hC:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh4_factory.cpp
hC:\\buildworker\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh8_factory.cpp
hDº\eTr
hEb>0
hHǄ$H
hJ8;zl
hKλyp
hL#=x3
hL;d$p
hL\a;uP
hMK</u
hMK<sJs
hNh4hhh
hN亦Hy
hP:qk
hQƽ2d
hR>\fpm
hU'>k\b
hU<Ǯo
hU\\;CJ{a
hVC;Lo
hW:_z
hX:3jG;F
hX=^y\e
hY%<nO
hYUPŸ\\M
hY\rYk
hY\r{\b
hY]0ŠY
hYȉt$L
h\\E ŀY
h\e;x
h\eH99x\n;1
h\f\f
h\rm<hz
h\v\a
h];sT
h]A_A
h]A_A^A
h_:~xr9b
ha;gRa:r
had the wrong value or the parameter IPAR(6) was altered by mistake outside of
had the wrong value or the parameter ipar[5] was altered by mistake outside of
hair_accel
hair_accel_mb
hair_builder
hair_builder_mb
hair_traverser
hair_traverser_mb
half edge generation
hasLeafSize
hasLeafSize() == false
hasValidPositions
has_back1
has_back1 && has_front2
has_dP || dPdv
has_ddP || (ddPdvdv && ddPdudu
has_front2
hbw_free
hbw_posix_memalign_psize
hc;!UR;8
hdK:3
header crc mismatch
hfalse
hffffff
hfffffff
hhL+h`I
histogram
hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    __global int* numrays,     // Number of rays in the workload \n    int offset,                // Offset in rays array \n    __global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny2L(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n
hivariant == IntersectVariant::FAST
hivariant == IntersectVariant::ROBUST
hk<;n
hl(<2xz
hlbvh accelerator max batch size exceeded
hls:PW4
holland
hong-kong
host unreachable
hpT;U
hrd<O
hreset
hrtfSettings
hrtfSettings->normType
hrtfSettings->sofaData
hrtfSettings->sofaDataSize
hrtfSettings->type
hrtfSettings->volume
hs89r
hs:XO
htl<jt\\<lt4<tt$<wt
http://ocsp.digicert.com0
http://ocsp.digicert.com0A
http://ocsp.digicert.com0C
https://github.com/ValveSoftware/steam-audio/blob/master/LICENSE.md
hu=?lq
hugepages
hvļTAS
hwc;kY
hypot
hypotf
hyz8^7B
hz!>I
hz;Xz
h|S:\fE
h»A,0;J
hÊD$g
hü rj
hŻ\aO
hʼa䯼\bT
h̼wyP
hӻC\fC;}p
hܽe\a
hޯ<WP
hᗻ\vPD
h⡽7-h
i 3\bA(L
i ;\e
i < geometries.size
i < numPrimitives
i < numRanges
i < size_active
i == 0
i B=w5
i!D\r
i!T$P
i!T\v
i"p<F
i# <Q
i#:xYJ
i#F;y
i$baV\bY
i&=tQ\v
i';Ne
i';ecu
i)U;h
i+i<Uj
i, %i } :  Memory overwrite in %s
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %11.4f
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %11.4f + i* %11.4f
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %20.7lf
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %20.7lf + i* %20.7lf
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %i
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %11.4f
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %11.4f + i* %11.4f
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %20.7lf
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %20.7lf + i* %20.7lf
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %i
i,ba~\b
i.;Ws
i.>N5
i0:oȦ9
i1\n;fV8
i3<HO
i4V;\v
i4ۻ?k
i6:\b
i6=uA
i8U,';n
i8g\b2
i8m8@A
i9<S~\r
i9>:\tM
i9B܈9Iw
i9iǋ<Z
i9lzM9
i9v>T\e
i:J+k
i:M)7:^DZ
i:Yoa:\t
i:\bv
i:ik\e
i;LbB
i;Mzu
i;P<5
i;Vv3
i;Zo5
i;\n\fk
i;c+J
i;ku4;iN9
i;l1C
i;oi|:SnO
i;ouJ
i<GeneralCatmullClarkPatch3fa::SIZE
i<MAX_PATCH_VALENCE
i<N && j<N
i<This->N
i<]Cb
i<max_total_elements
i<numArrays
i<tyZ
i=6\nk
i=w?6?T
i>&xO
i>=0 && i<(int)numTimeSteps
i>=0 && i<=(int)totalTimeSegments
i>=q8
i>>yo
i>Bsa
i?0@I
i?<Bu-8
iA<p5
iAU;v
iBo<;T
iD2;v\e
iH<QsO
iHȻDee;5
iI=M\t\v
iI=}9
iIĺ8 Q
iK;n~];qe
iM:_R9\r
iM;$LQ
iOA9\t
iS;U,H
iTa;S1\t
iU;GA
iVr9*bn8
iXh<z
i[0] >= 0 && (size_t)i[0] < num
i[1] >= 0 && (size_t)i[1] < num
i[2] >= 0 && (size_t)i[2] < num
i\a:KIz
i\aļVvB?p
i\bH+)H
i\bba~\b
i\eĻ\b2
i\fźXI
i\n;O
i\nW<6
i\r;2
i\r<e3R
i\v7<\r
i`L+iXL
ia(neqns_in+1)-1: %d nb_in         : %d
ia(neqns_in+1)-1: %lli nb_in         : %lli
ia[neqns_in]-1  : %d nb_in         : %d
ia[neqns_in]-1  : %lli nb_in         : %lli
ib/:u
idata$2
idata$3
idata$4
idata$5
idata$6
identifier
identifier expected
identifier removed
identifier).endpointInfluence.center.x
identifier).endpointInfluence.center.y
identifier).endpointInfluence.center.z
identifier).endpointInfluence.radius
identifier).type
identifier).variation
ido_in          : %d neqns_in      : %d
ido_in          : %lli neqns_in      : %lli
ie <GG
if scene index buffer is set, it has to have the same size as the transform buffer
if;#A
iface%x
iffffff
ifh;#\n
igy;p
iiFi#ii
ii\e?j
iix;Tڈ:w
ikR8qN&9\f
il0<Yl
ilj;S
illegal byte sequence
imb;D
impulseResponse
imŻ\ny
in instability of calculations
in the MXCSR control and status register. This can have a severe
in(:5
in->data
in->data[iChannel][in->numSamples - 1
in->numChannels
in->numSamples
inType
inappropriate io control operation
include "pmmintrin.h
include "xmmintrin.h
incompatible version
incorrect data check
incorrect header check
incorrect length check
incorrect output filename: too long or empty
index < 3
index < 4
index < 8
index0 < edge_valence
index1 < edge_valence
index2 < edge_valence
inflate 1.2.13 Copyright 1995-2022 Mark Adler
inlen == hrtf->N
input matrix size is negative or zero
input value set in DPAR(31) which might result
inputs
inputs are from different devices
inputs->airAbsorptionModel
inputs->airAbsorptionModel)->callback
inputs->airAbsorptionModel)->coefficients
inputs->airAbsorptionModel)->coefficients[iArray
inputs->airAbsorptionModel)->dirty
inputs->airAbsorptionModel)->type
inputs->baked
inputs->bakedDataIdentifier.endpointInfluence.center.x
inputs->bakedDataIdentifier.endpointInfluence.center.y
inputs->bakedDataIdentifier.endpointInfluence.center.z
inputs->bakedDataIdentifier.endpointInfluence.radius
inputs->bakedDataIdentifier.type
inputs->bakedDataIdentifier.variation
inputs->deviationModel
inputs->deviationModel)->callback
inputs->deviationModel)->type
inputs->directFlags
inputs->directivity
inputs->directivity)->dipolePower
inputs->directivity)->dipoleWeight
inputs->distanceAttenuationModel
inputs->distanceAttenuationModel)->callback
inputs->distanceAttenuationModel)->dirty
inputs->distanceAttenuationModel)->minDistance
inputs->distanceAttenuationModel)->type
inputs->enableValidation
inputs->findAlternatePaths
inputs->flags
inputs->hybridReverbOverlapPercent
inputs->hybridReverbTransitionTime
inputs->numOcclusionSamples
inputs->numTransmissionRays
inputs->occlusionRadius
inputs->occlusionType
inputs->pathingOrder
inputs->pathingProbes
inputs->reverbScale[iBand
inputs->source.ahead.x
inputs->source.ahead.y
inputs->source.ahead.z
inputs->source.origin.x
inputs->source.origin.y
inputs->source.origin.z
inputs->source.right.x
inputs->source.right.y
inputs->source.right.z
inputs->source.up.x
inputs->source.up.y
inputs->source.up.z
inputs->visRadius
inputs->visRange
inputs->visThreshold
inputs[i
inputs[i])->energyField
instID
instPrimID
instance
instance has only primitive 0
instance_array
instance_cheap
instance_expensive
instanced scene or scene buffer not set
instancedMesh
instancing_block_size
instancing_open_factor
instancing_open_max
instancing_open_max_depth
instancing_open_min
insufficient memory
int4 bin = (localvals >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        if (localid < NUM_BINS) \n        { \n            scanned_histogram[localid] += sum; \n        } \n    } \n} \n \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid ScatterKeysAndValues(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Input values \n    __global int4 const* restrict in_values, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys, \n    // Output values \n    __global int* restrict  out_values \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localkeys = safe_load_int4_intmax(in_keys, loadidx, numelems); \n        int4 localvals = safe_load_int4_intmax(in_values, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localkeys >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LD
integer expected
interleaveAudioBuffer
internal error in ISA selection for BVH4ColliderUserGeom
internal error in ISA selection for BVH4GridIntersector16HybridMoeller
internal error in ISA selection for BVH4GridIntersector16HybridPluecker
internal error in ISA selection for BVH4GridIntersector1Moeller
internal error in ISA selection for BVH4GridIntersector1Pluecker
internal error in ISA selection for BVH4GridIntersector4HybridMoeller
internal error in ISA selection for BVH4GridIntersector4HybridPluecker
internal error in ISA selection for BVH4GridIntersector8HybridMoeller
internal error in ISA selection for BVH4GridIntersector8HybridPluecker
internal error in ISA selection for BVH4GridMBIntersector16HybridMoeller
internal error in ISA selection for BVH4GridMBIntersector1Moeller
internal error in ISA selection for BVH4GridMBIntersector4HybridMoeller
internal error in ISA selection for BVH4GridMBIntersector8HybridMoeller
internal error in ISA selection for BVH4InstanceArrayIntersector1
internal error in ISA selection for BVH4InstanceArrayIntersector16Chunk
internal error in ISA selection for BVH4InstanceArrayIntersector4Chunk
internal error in ISA selection for BVH4InstanceArrayIntersector8Chunk
internal error in ISA selection for BVH4InstanceArrayMBIntersector1
internal error in ISA selection for BVH4InstanceArrayMBIntersector16Chunk
internal error in ISA selection for BVH4InstanceArrayMBIntersector4Chunk
internal error in ISA selection for BVH4InstanceArrayMBIntersector8Chunk
internal error in ISA selection for BVH4InstanceIntersector1
internal error in ISA selection for BVH4InstanceIntersector16Chunk
internal error in ISA selection for BVH4InstanceIntersector4Chunk
internal error in ISA selection for BVH4InstanceIntersector8Chunk
internal error in ISA selection for BVH4InstanceMBIntersector1
internal error in ISA selection for BVH4InstanceMBIntersector16Chunk
internal error in ISA selection for BVH4InstanceMBIntersector4Chunk
internal error in ISA selection for BVH4InstanceMBIntersector8Chunk
internal error in ISA selection for BVH4OBBVirtualCurveIntersector1
internal error in ISA selection for BVH4OBBVirtualCurveIntersector16Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersector16HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersector1MB
internal error in ISA selection for BVH4OBBVirtualCurveIntersector4Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersector4HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersector8Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersector8HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust1
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust16Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust16HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust1MB
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust4Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust4HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust8Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust8HybridMB
internal error in ISA selection for BVH4Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector1Moeller
internal error in ISA selection for BVH4Quad4iIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH4Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector1Moeller
internal error in ISA selection for BVH4Quad4vIntersector1Pluecker
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH4SubdivPatch1Intersector1
internal error in ISA selection for BVH4SubdivPatch1Intersector16
internal error in ISA selection for BVH4SubdivPatch1Intersector4
internal error in ISA selection for BVH4SubdivPatch1Intersector8
internal error in ISA selection for BVH4SubdivPatch1MBIntersector1
internal error in ISA selection for BVH4SubdivPatch1MBIntersector16
internal error in ISA selection for BVH4SubdivPatch1MBIntersector4
internal error in ISA selection for BVH4SubdivPatch1MBIntersector8
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector1Moeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH4VirtualIntersector1
internal error in ISA selection for BVH4VirtualIntersector16Chunk
internal error in ISA selection for BVH4VirtualIntersector4Chunk
internal error in ISA selection for BVH4VirtualIntersector8Chunk
internal error in ISA selection for BVH4VirtualMBIntersector1
internal error in ISA selection for BVH4VirtualMBIntersector16Chunk
internal error in ISA selection for BVH4VirtualMBIntersector4Chunk
internal error in ISA selection for BVH4VirtualMBIntersector8Chunk
internal error in ISA selection for BVH8ColliderUserGeom
internal error in ISA selection for BVH8GridIntersector16HybridMoeller
internal error in ISA selection for BVH8GridIntersector16HybridPluecker
internal error in ISA selection for BVH8GridIntersector1Moeller
internal error in ISA selection for BVH8GridIntersector1Pluecker
internal error in ISA selection for BVH8GridIntersector4HybridMoeller
internal error in ISA selection for BVH8GridIntersector4HybridPluecker
internal error in ISA selection for BVH8GridIntersector8HybridMoeller
internal error in ISA selection for BVH8GridIntersector8HybridPluecker
internal error in ISA selection for BVH8GridMBIntersector1Moeller
internal error in ISA selection for BVH8InstanceArrayIntersector1
internal error in ISA selection for BVH8InstanceArrayIntersector16Chunk
internal error in ISA selection for BVH8InstanceArrayIntersector4Chunk
internal error in ISA selection for BVH8InstanceArrayIntersector8Chunk
internal error in ISA selection for BVH8InstanceArrayMBIntersector1
internal error in ISA selection for BVH8InstanceArrayMBIntersector16Chunk
internal error in ISA selection for BVH8InstanceArrayMBIntersector4Chunk
internal error in ISA selection for BVH8InstanceArrayMBIntersector8Chunk
internal error in ISA selection for BVH8InstanceIntersector1
internal error in ISA selection for BVH8InstanceIntersector16Chunk
internal error in ISA selection for BVH8InstanceIntersector4Chunk
internal error in ISA selection for BVH8InstanceIntersector8Chunk
internal error in ISA selection for BVH8InstanceMBIntersector1
internal error in ISA selection for BVH8InstanceMBIntersector16Chunk
internal error in ISA selection for BVH8InstanceMBIntersector4Chunk
internal error in ISA selection for BVH8InstanceMBIntersector8Chunk
internal error in ISA selection for BVH8OBBVirtualCurveIntersector1
internal error in ISA selection for BVH8OBBVirtualCurveIntersector16Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersector16HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersector1MB
internal error in ISA selection for BVH8OBBVirtualCurveIntersector4Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersector4HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersector8Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersector8HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust1
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust16Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust16HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust1MB
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust4Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust4HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust8Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust8HybridMB
internal error in ISA selection for BVH8Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector1Moeller
internal error in ISA selection for BVH8Quad4iIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH8Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector1Moeller
internal error in ISA selection for BVH8Quad4vIntersector1Pluecker
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector1Moeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vIntersector1Woop
internal error in ISA selection for BVH8Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH8VirtualIntersector1
internal error in ISA selection for BVH8VirtualIntersector16Chunk
internal error in ISA selection for BVH8VirtualIntersector4Chunk
internal error in ISA selection for BVH8VirtualIntersector8Chunk
internal error in ISA selection for BVH8VirtualMBIntersector1
internal error in ISA selection for BVH8VirtualMBIntersector16Chunk
internal error in ISA selection for BVH8VirtualMBIntersector4Chunk
internal error in ISA selection for BVH8VirtualMBIntersector8Chunk
internal error in ISA selection for QBVH4Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for QBVH8Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH8Triangle4Intersector1Moeller
internal error in ISA selection for QBVH8Triangle4iIntersector1Pluecker
internal_tasking_system
internal_time_splits
interrupted
intersect1
intersect4
intersect8
intersection_filter
intersector1
intersector1.intersect
intersector1.occluded
intersector1.pointQuery
intersector16
intersector16.intersect
intersector16.occluded
intersector4
intersector4.intersect
intersector4.occluded
intersector8
intersector8.intersect
intersector8.occluded
invalid argument
invalid bit length repeat
invalid block type
invalid buffer data pointer type specified
invalid buffer slot
invalid buffer specified
invalid build quality
invalid code -- missing end-of-block
invalid code lengths set
invalid destination pointer
invalid distance code
invalid distance too far back
invalid distances set
invalid edge
invalid edge crease index buffer format
invalid edge crease weight buffer format
invalid face
invalid face buffer format
invalid flag buffer format
invalid geometry
invalid geometry ID
invalid geometry ID provided
invalid geometry type
invalid half edge
invalid hash bucket count
invalid hole buffer format
invalid index buffer format
invalid index buffer format. must be RTC_FORMAT_UINT
invalid index buffer slot
invalid index buffer slot. must be 0
invalid level buffer format
invalid literal/length code
invalid literal/lengths set
invalid map<K, T> key
invalid matrix format
invalid normal buffer format
invalid normal buffer slot
invalid normal derivative buffer format
invalid normal derivative buffer slot
invalid seek
invalid stored block lengths
invalid string character
invalid string position
invalid tangent buffer format
invalid tangent buffer slot
invalid timestep
invalid topology
invalid topology ID
invalid topology specified
invalid transform buffer format
invalid transform buffer slot
invalid vector subscript
invalid vertex attribute buffer format
invalid vertex attribute buffer slot
invalid vertex attribute specified
invalid vertex buffer format
invalid vertex buffer slot
invalid vertex crease index buffer format
invalid vertex crease weight buffer format
invalid window size
io error
ios_base::badbit set
ios_base::eofbit set
ios_base::failbit set
iostream
iostream stream error
ipl::HRTFMap::loadAmbisonicsHRIRs
ipl::HRTFMap::verifyDataHeader
iplAirAbsorptionCalculate
iplAmbisonicsBinauralEffectApply
iplAmbisonicsBinauralEffectCreate
iplAmbisonicsBinauralEffectGetTail
iplAmbisonicsBinauralEffectGetTailSize
iplAmbisonicsBinauralEffectRelease
iplAmbisonicsBinauralEffectReset
iplAmbisonicsBinauralEffectRetain
iplAmbisonicsDecodeEffectApply
iplAmbisonicsDecodeEffectCreate
iplAmbisonicsDecodeEffectGetTail
iplAmbisonicsDecodeEffectGetTailSize
iplAmbisonicsDecodeEffectRelease
iplAmbisonicsDecodeEffectReset
iplAmbisonicsDecodeEffectRetain
iplAmbisonicsEncodeEffectApply
iplAmbisonicsEncodeEffectCreate
iplAmbisonicsEncodeEffectGetTail
iplAmbisonicsEncodeEffectGetTailSize
iplAmbisonicsEncodeEffectRelease
iplAmbisonicsEncodeEffectReset
iplAmbisonicsEncodeEffectRetain
iplAmbisonicsPanningEffectApply
iplAmbisonicsPanningEffectCreate
iplAmbisonicsPanningEffectGetTail
iplAmbisonicsPanningEffectGetTailSize
iplAmbisonicsPanningEffectRelease
iplAmbisonicsPanningEffectReset
iplAmbisonicsPanningEffectRetain
iplAmbisonicsRotationEffectApply
iplAmbisonicsRotationEffectCreate
iplAmbisonicsRotationEffectGetTail
iplAmbisonicsRotationEffectGetTailSize
iplAmbisonicsRotationEffectRelease
iplAmbisonicsRotationEffectReset
iplAmbisonicsRotationEffectRetain
iplAudioBufferAllocate
iplAudioBufferConvertAmbisonics
iplAudioBufferDeinterleave
iplAudioBufferDownmix
iplAudioBufferFree
iplAudioBufferInterleave
iplAudioBufferMix
iplBinauralEffectApply
iplBinauralEffectCreate
iplBinauralEffectGetTail
iplBinauralEffectGetTailSize
iplBinauralEffectRelease
iplBinauralEffectReset
iplBinauralEffectRetain
iplCalculateRelativeDirection
iplCompressedEnergyFieldsBlendAndDecompress
iplCompressedEnergyFieldsCreate
iplCompressedEnergyFieldsCreateEmpty
iplCompressedEnergyFieldsCreateFromProbeBatch
iplCompressedEnergyFieldsGetCompressedData
iplCompressedEnergyFieldsGetDictionary
iplCompressedEnergyFieldsGetNumBands
iplCompressedEnergyFieldsGetNumBins
iplCompressedEnergyFieldsGetNumChannels
iplCompressedEnergyFieldsGetNumProbes
iplCompressedEnergyFieldsGetNumSingularValues
iplCompressedEnergyFieldsRelease
iplCompressedEnergyFieldsRetain
iplCompressedEnergyFieldsSetCompressedData
iplCompressedEnergyFieldsSetDictionary
iplContextCreate
iplContextRelease
iplContextRetain
iplContextSetProfilerContext
iplContextSetVariableBool
iplContextSetVariableFloat32
iplContextSetVariableInt32
iplContextSetVariableString
iplDirectEffectApply
iplDirectEffectCreate
iplDirectEffectGetTail
iplDirectEffectGetTailSize
iplDirectEffectRelease
iplDirectEffectReset
iplDirectEffectRetain
iplDirectivityCalculate
iplDistanceAttenuationCalculate
iplDistanceAttenuationGetCorrectionCurve
iplEmbreeDeviceCreate
iplEmbreeDeviceRelease
iplEmbreeDeviceRetain
iplEnergyFieldAdd
iplEnergyFieldCopy
iplEnergyFieldCreate
iplEnergyFieldGetBand
iplEnergyFieldGetChannel
iplEnergyFieldGetData
iplEnergyFieldGetNumBins
iplEnergyFieldGetNumChannels
iplEnergyFieldRelease
iplEnergyFieldReset
iplEnergyFieldRetain
iplEnergyFieldScale
iplEnergyFieldScaleAccum
iplEnergyFieldSwap
iplHRTFCreate
iplHRTFRelease
iplHRTFRetain
iplHybridReverbEffectApply
iplHybridReverbEffectCreate
iplHybridReverbEffectGetTail
iplHybridReverbEffectGetTailSize
iplHybridReverbEffectRelease
iplHybridReverbEffectReset
iplHybridReverbEffectRetain
iplHybridReverbEstimatorCreate
iplHybridReverbEstimatorEstimate
iplHybridReverbEstimatorRelease
iplHybridReverbEstimatorRetain
iplImpulseResponse2AddChannel
iplImpulseResponse2AddSample
iplImpulseResponse2Create
iplImpulseResponse2GetChannel
iplImpulseResponse2GetNumChannels
iplImpulseResponse2GetNumSamples
iplImpulseResponse2Release
iplImpulseResponse2Reset
iplImpulseResponse2Retain
iplImpulseResponse2SetChannel
iplImpulseResponse2SetChannelDelayed
iplImpulseResponse2SetSample
iplImpulseResponse2Swap
iplImpulseResponse2SwapSource
iplImpulseResponseAdd
iplImpulseResponseCopy
iplImpulseResponseCreate
iplImpulseResponseGetChannel
iplImpulseResponseGetData
iplImpulseResponseGetNumChannels
iplImpulseResponseGetNumSamples
iplImpulseResponseRelease
iplImpulseResponseReset
iplImpulseResponseRetain
iplImpulseResponseScale
iplImpulseResponseScaleAccum
iplImpulseResponseSwap
iplInstancedMeshAdd
iplInstancedMeshCreate
iplInstancedMeshRelease
iplInstancedMeshRemove
iplInstancedMeshRetain
iplInstancedMeshUpdateTransform
iplInterpolatableImpulseResponseBlend
iplInterpolatableImpulseResponseCreate
iplInterpolatableImpulseResponseGetChannel
iplInterpolatableImpulseResponseRelease
iplInterpolatableImpulseResponseReset
iplInterpolatableImpulseResponseRetain
iplInterpolatableImpulseResponseSetChannel
iplOcclusionSimulatorCreate
iplOcclusionSimulatorRelease
iplOcclusionSimulatorRetain
iplOcclusionSimulatorSimulate
iplOpenCLDeviceCreate
iplOpenCLDeviceCreateFromExisting
iplOpenCLDeviceListCreate
iplOpenCLDeviceListGetDeviceDesc
iplOpenCLDeviceListGetNumDevices
iplOpenCLDeviceListRelease
iplOpenCLDeviceListRetain
iplOpenCLDeviceRelease
iplOpenCLDeviceRetain
iplOverlapSaveFIRCopy
iplOverlapSaveFIRCreate
iplOverlapSaveFIRGetBlock
iplOverlapSaveFIRGetChannel
iplOverlapSaveFIRGetData
iplOverlapSaveFIRGetNumBlocks
iplOverlapSaveFIRGetNumChannels
iplOverlapSaveFIRGetNumSpectrumSamples
iplOverlapSaveFIRRelease
iplOverlapSaveFIRReset
iplOverlapSaveFIRRetain
iplOverlapSaveFIRSwap
iplPanningEffectApply
iplPanningEffectCreate
iplPanningEffectGetTail
iplPanningEffectGetTailSize
iplPanningEffectRelease
iplPanningEffectReset
iplPanningEffectRetain
iplPartitionerCreate
iplPartitionerPartition
iplPartitionerRelease
iplPartitionerRetain
iplPathBakerBake
iplPathBakerCancelBake
iplPathEffectApply
iplPathEffectCreate
iplPathEffectGetTail
iplPathEffectGetTailSize
iplPathEffectRelease
iplPathEffectReset
iplPathEffectRetain
iplPathSimulatorCreate
iplPathSimulatorRelease
iplPathSimulatorRetain
iplPathSimulatorSimulate
iplProbeArrayCreate
iplProbeArrayGenerateProbes
iplProbeArrayGetNumProbes
iplProbeArrayGetProbe
iplProbeArrayRelease
iplProbeArrayResize
iplProbeArrayRetain
iplProbeArraySetProbe
iplProbeBatchAddProbe
iplProbeBatchAddProbeArray
iplProbeBatchAddProbeArrayAndCluster
iplProbeBatchCommit
iplProbeBatchCompress
iplProbeBatchCreate
iplProbeBatchCreateCompressed
iplProbeBatchCreateNonUniform
iplProbeBatchGetDataSize
iplProbeBatchGetEnergyField
iplProbeBatchGetInfluencingProbes
iplProbeBatchGetNumProbes
iplProbeBatchGetProbe
iplProbeBatchGetProbeArray
iplProbeBatchGetReverb
iplProbeBatchLoad
iplProbeBatchLoadCompressed
iplProbeBatchLoadNonUniform
iplProbeBatchLookupBakedReflections
iplProbeBatchLookupCreate
iplProbeBatchLookupRelease
iplProbeBatchLookupRetain
iplProbeBatchRelease
iplProbeBatchRemoveData
iplProbeBatchRemoveProbe
iplProbeBatchRetain
iplProbeBatchSave
iplProbeBatchUpdateEndpoint
iplProbeBatchUpdateProbePosition
iplProbeBatchUpdateProbeRadius
iplProbeClusterMapCreate
iplProbeClusterMapGetData
iplProbeClusterMapLookup
iplProbeClusterMapRelease
iplProbeClusterMapRemapNeighborhood
iplProbeClusterMapRetain
iplProbeNeighborhoodCalculateWeights
iplProbeNeighborhoodCheckOcclusion
iplProbeNeighborhoodCreate
iplProbeNeighborhoodFindNearest
iplProbeNeighborhoodGetNumProbes
iplProbeNeighborhoodGetNumValidProbes
iplProbeNeighborhoodGetProbe
iplProbeNeighborhoodGetProbeBatch
iplProbeNeighborhoodGetProbeIndex
iplProbeNeighborhoodRelease
iplProbeNeighborhoodReset
iplProbeNeighborhoodResize
iplProbeNeighborhoodRetain
iplProbeNeighborhoodSetProbeBatch
iplProbeNeighborhoodSetProbeIndex
iplRadeonRaysDeviceCreate
iplRadeonRaysDeviceRelease
iplRadeonRaysDeviceRetain
iplReconstructorCreate
iplReconstructorReconstruct
iplReconstructorRelease
iplReconstructorRetain
iplReflectionEffectApply
iplReflectionEffectCreate
iplReflectionEffectGetTail
iplReflectionEffectGetTailSize
iplReflectionEffectRelease
iplReflectionEffectReset
iplReflectionEffectRetain
iplReflectionMixerApply
iplReflectionMixerCreate
iplReflectionMixerRelease
iplReflectionMixerReset
iplReflectionMixerRetain
iplReflectionSimulatorCreate
iplReflectionSimulatorRelease
iplReflectionSimulatorRetain
iplReflectionSimulatorSimulate
iplReflectionsBakerBake
iplReflectionsBakerCancelBake
iplReflectionsEffect2Apply
iplReflectionsEffect2Create
iplReflectionsEffect2GetFloat
iplReflectionsEffect2GetInt32
iplReflectionsEffect2Release
iplReflectionsEffect2Reset
iplReflectionsEffect2Retain
iplReflectionsEffect2SetBuffer
iplReflectionsEffect2SetFloat
iplReflectionsEffect2SetInt32
iplReflectionsPartitioner2AddTask
iplReflectionsPartitioner2Commit
iplReflectionsPartitioner2Create
iplReflectionsPartitioner2Release
iplReflectionsPartitioner2RemoveTask
iplReflectionsPartitioner2Retain
iplReflectionsPartitioner2RunTasks
iplReverbEstimatorApplyScale
iplReverbEstimatorCreate
iplReverbEstimatorEstimate
iplReverbEstimatorRelease
iplReverbEstimatorRetain
iplSceneCommit
iplSceneCreate
iplSceneLoad
iplSceneRelease
iplSceneRetain
iplSceneSave
iplSceneSaveOBJ
iplSerializedObjectCreate
iplSerializedObjectGetData
iplSerializedObjectGetSize
iplSerializedObjectRelease
iplSerializedObjectRetain
iplSimulatorAddProbeBatch
iplSimulatorCommit
iplSimulatorCreate
iplSimulatorRelease
iplSimulatorRemoveProbeBatch
iplSimulatorRetain
iplSimulatorRunDirect
iplSimulatorRunPathing
iplSimulatorRunPathingForNeighborhoods
iplSimulatorRunPathingPerSource
iplSimulatorRunPathingPerSourceForNeighborhood
iplSimulatorRunReflections
iplSimulatorSetScene
iplSimulatorSetSharedInputs
iplSourceAdd
iplSourceCreate
iplSourceGetOutputs
iplSourceGetOutputsAux
iplSourceRelease
iplSourceRemove
iplSourceRetain
iplSourceSetInputs
iplStaticMeshAdd
iplStaticMeshCreate
iplStaticMeshLoad
iplStaticMeshRelease
iplStaticMeshRemove
iplStaticMeshRetain
iplStaticMeshSave
iplTrueAudioNextDeviceCreate
iplTrueAudioNextDeviceRelease
iplTrueAudioNextDeviceRetain
iplVirtualSurroundEffectApply
iplVirtualSurroundEffectCreate
iplVirtualSurroundEffectGetTail
iplVirtualSurroundEffectGetTailSize
iplVirtualSurroundEffectRelease
iplVirtualSurroundEffectReset
iplVirtualSurroundEffectRetain
ir":r
ir4;D
irUpdateQueue
irish-english
is a directory
is out of admissible interval [0,infinity). Assigning DPAR(8)=%e
isAABBNode
isAABBNodeMB() || isAABBNodeMB4D
isAABBNodeMB4D
isBarrier
isLeaf
isLocked(t_state
isOBBNode
isOBBNodeMB
isQuantizedNode
isSmallGeometry(mesh
isZ;f
is_double
is_finite(bounds
is_finite(bounds.bounds0
is_finite(bounds.bounds1
isa::Cylinder::verify
isrc >= begin && isrc < end
isvalid(dest.ring[i
italian-swiss
items <= 1
items == 1
items == nullptr
items<=4
iterations automatically
itime+1 < numTimeSteps
itime_range.size() == 1
it|<nto<otb<ptU<st
iupperc-ilowerc > 0
ivK;H
ix;h58
ixn<JtA<v
iy0=*{u
iy;\fb
izL;x
i|ŢXY
iȽutv=\tV
iʄ;Et
iͻo\t
i⺵gI;F
i繇ٱ:WF;dF
i軲j̻CF
j ;=M
j ?;k9
j ba|\b
j"=Np\n
j&9|6
j(L=N
j) \n \n// Find span occupied by internal node with index idx \nint2 FindSpan(__global int* mortoncodes, int numprims, int idx) \n{ \n    // Find the direction of the range \n    int d = sign((float)(DELTA(idx, idx+1) - DELTA(idx, idx-1))); \n \n    // Find minimum number of bits for the break on the other side \n    int deltamin = DELTA(idx, idx-d); \n \n    // Search conservative far end \n    int lmax = 2; \n    while (DELTA(idx,idx + lmax * d) > deltamin) \n        lmax *= 2; \n \n    // Search back to find exact bound \n    // with binary search \n    int l = 0; \n    int t = lmax; \n    do \n    { \n        t /= 2; \n        if(DELTA(idx, idx + (l + t)*d) > deltamin) \n        { \n            l = l + t; \n        } \n    } \n    while (t > 1); \n \n    // Pack span  \n    int2 span; \n    span.x = min(idx, idx + l*d); \n    span.y = max(idx, idx + l*d); \n    return span; \n} \n \n// Find split idx within the span \nint FindSplit(__global int* mortoncodes, int numprims, int2 span) \n{ \n    // Fetch codes for both ends \n    int left = span.x; \n    int right = span.y; \n \n    // Calculate the number of identical bits from higher end \n    int numidentical = DELTA(left, right); \n \n    do \n    { \n        // Proposed split \n        int newsplit = (right + left) / 2; \n \n        // If it has more equal leading bits than left and right accept it \n        if (DELTA(left, newsplit) > numidentical) \n        { \n            left = newsplit; \n        } \n        else \n        { \n            right = newsplit; \n        } \n    } \n    while (right > left + 1); \n \n    return left; \n} \n \n// Set parent-child relationship \n__kernel void BuildHierarchy( \n    // Sorted Morton codes of the primitives \n    __global int* mortoncodes, \n    // Bounds \n    __global bbox* bounds, \n    // Primitive indices \n    __global int* indices, \n    // Number of primitives \n    int numprims, \n    // Nodes \n    __global HlbvhNode* nodes, \n    // Leaf bounds \n    __global bbox* boundssorted \n    ) \n{ \n    int globalid = get_global_id(0); \n \n    // Set child \n    if (globalid < numprims) \n    { \n        nodes[LEAFIDX(globalid)].left = nodes[LEAFIDX(globalid)].right = indices[globalid]; \n        boundssorted[LEAFIDX(globalid)] = bounds[indices[globalid]]; \n    } \n     \n    // Set internal nodes \n    if (globalid < numprims - 1) \n    { \n        // Find span occupied by the current node \n        int2 range = FindSpan(mortoncodes, numprims, globalid); \n \n        // Find split position inside the range \n        int  split = FindSplit(mortoncodes, numprims, range); \n \n        // Create child nodes if needed \n        int c1idx = (split == range.x) ? LEAFIDX(split) : NODEIDX(split); \n        int c2idx = (split + 1 == range.y) ? LEAFIDX(split + 1) : NODEIDX(split + 1); \n \n        nodes[NODEIDX(globalid)].left = c1idx; \n        nodes[NODEIDX(globalid)].right = c2idx; \n        //nodes[NODEIDX(globalid)].next = (range.y + 1 < numprims) ? range.y + 1 : -1; \n        nodes[c1idx].parent = NODEIDX(globalid); \n        //nodes[c1idx].next = c2idx; \n        nodes[c2idx].parent = NODEIDX(globalid); \n        //nodes[c2idx].next = nodes[NODEIDX(globalid)].next; \n    } \n} \n \n// Propagate bounds up to the root \n__kernel void RefitBounds(__global bbox* bounds, \n                          int numprims, \n                          __global HlbvhNode* nodes, \n                          __global int* flags \n                          ) \n{ \n    int globalid = get_global_id(0); \n \n    // Start from leaf nodes \n    if (globalid < numprims) \n    { \n        // Get my leaf index \n        int idx = LEAFIDX(globalid); \n \n        do \n        { \n            // Move to parent node \n            idx = nodes[idx].parent; \n \n            // Check node's flag \n            if (atomic_cmpxchg(flags + idx, 0, 1) == 1) \n            { \n                // If the flag was 1 the second child is ready and  \n                // this thread calculates bbox for the node \n \n                // Fetch kids \n                int
j/ʼn4
j1;m\a
j3K:\e
j7w:Y
j7֏L8
j8L;x
j8b3M
j8ba|\b
j9!I4
j9:jId
j9\b|89
j9n.칣J
j9~ry
j: \n\t
j:( K
j:K+9
j:P7\a
j:nsr
j:p\rE:\a0Y:6
j;-v6
j;2<a
j;>N3=B
j;J5\t
j;V^b
j;YSc
j;d<H
j;nYB<D
j<W;a
j<\nQ
j<gOǼh\n
j<hln
j<s@X
j=GǬ9W
j?Q>c
j?\fKk?X
j@p;2
j@w;U
jAE;\n
jB:kZx
jB<\eR
jB\t=!U
jCZ<U\f
jCӻ\f\en
jD5;Hp
jD<3eW
jE3<4
jF;@N
jFb=\fl
jH:<QT
jH<r6v;K
jJ0>o4㽞X
jK<8kc
jL-; H
jO;GA
jPj;Ȥ4
jQ7:5(u
jQ:X&9;\bP
jQ;%8
jS.9eI(:8I
jTK;5ۡ<S
jU)9`9
jU;kD
jW2;5]Q
jX\a<p
jXa ŲXA
jY=\nI
jY>=|ZY
jYD$<H
jYD$<L
jYD$LL
jYT$LH
jYT$LL
jY\e;~7
jYd\aTĢQ
jYd\b\bz
j[;kM
j\a\f
j\aba|H
j\aba|\b
j\aba~\b
j\ah<5p
j\ah<m3
j\b A
j\b\a:Z 6
j\bbA
j\bbA|\b
j\e=lV
j\e\n<h
j\f\n<lN
j\fbA
j\nͼs[c
j\t<B\fy
j\vba|\b
j\vͼgA
j`4<EV
jc<\r
jd\e<օx
jdɼ!j
jf93A5
jffffff
jg<=w
jgE;TY
jgr:g
jh\v<5
jj@0HK4
jm%<nv
joC:H7
joL<ha
jrG;&sV
jt":2
jtm}S
jtۺ\e7\t
juD;BK5
jv: t
jxD<,霼U`E
jy:VK
jy=Hܖ=P
j{E>hI
j˂8>GO:}X
jϼ2Qy<C
jѷ<b3s
jֻOM3
jٚ;n3
jݼfB绪j
jސ;Du
jꅽE-I
jﺜܙ80
k ATAVAWH
k VWAVH
k [:Y
k w:f
k!U<k
k"5:*ub
k"<\f4F
k$l9\\8
k$t.5
k+g:Y6
k,=LAZ
k-z>P\a
k.2:x_O
k.;9p
k0;b8\e
k1;qP6
k1ӽVk
k2=)i
k46:!S
k4ݺiTx
k53<HC
k6A;\\x
k7˼\bQɼK
k80qA
k89;~W
k8=ԈĽ5l
k92JX
k:;3P0
k:=4w
k:Dq\t
k:N=h:3
k:мCz
k;FLO;C
k;K#H
k;Lnm;\\a
k;\n\aۻ8Y
k;\tu7
k;bLŻa
k;tޏ:I0
k;}lU
k;~XO
k<*b2
k<9cXN
k<Z9k
k<\b8\e=C
k=t\b
k>p"Q
k>pzf>M
k@b1|H
kB<qeλ\tt
kC:ll
kE{;Kx
kH\v;A39;BUn:8
kJ\f>V
kL:mw\b9y
kL<9mK
kL@8o(u
kL\f?g
kP<HI <4jv
kPfff
kPffff
kPfffff
kPffffff
kPfffffff
kPջ8u\t
kQQ:I
kQi<\b
kQƼU}S
kQɻ C
kR9;N
kRi;\n
kS;l\a
kT!;>DZ
kT>Lu
kV[8Y
kW\n<|H廀A
kZ;Z}H
kZ<2"N
kZa<jq
k[F<yT
k\bA8m(u\vI
k\bba|H
k\e;wT
k\fb!|HX
k\n;w
k\tbq|H
k]\t;9N
kaw;Ff
kb:cD
kc3:\e
ke@<uM
kernel32
kernel32.dll
keys.size() == values.size
kf<8B
kfH;B]z
kf\e<g
kg;_A
kg=<Zɼy|J
kh;yua;d
kj;\a );K
kl\t<TpC
km\f<O
kok-IN
kok-in
kp漽\f
kq;j\n
krU9\vUy
kt;:\rs
ku;é3:Q
ky\r9E
kyq;]8
k|^Xm
k}<aq
k~*6Q
k~y:K
kļu\r7
kľ<Eg\e
kȻjꦻqkܻFY
kɻ-eQ
kҼf[R
kջWH2<[Q0
kܥ:zfa
l!s;9p
l$ ATAVAWH
l$ H;Y
l$ H;{xr
l$ Hc
l$ L;sxr
l$ UAVAW
l$ UAVAWH
l$ VAVAWH
l$ VWATAVAWH
l$ VWATH
l$ VWAUH
l$ VWAVH
l$ WAVAWH
l$ ba|\b
l$ ba~\b
l$ w\tE
l$ ŠY
l$( b
l$(ba
l$03҉L
l$0D+ D9
l$0E3
l$0H;yxr
l$0L9n
l$0L;sxr
l$0Lcy\f
l$0ba~\b
l$0bb5
l$0fA
l$0fC
l$4bb
l$8D;l$4s\nH
l$8H9~(v
l$8ba~\b
l$8bbE
l$8fff
l$<bb
l$@D8W\buIH
l$@Hc
l$@Ik
l$@LcSl
l$@fA
l$@fD
l$@fff
l$HA_A^A]A
l$HL9a
l$HL9i
l$HL9k
l$HL;h\b
l$LŨYD
l$N=1
l$PD;f
l$PIi
l$Pba
l$Pba~\b
l$PfD
l$PfE
l$Pff
l$XE3\tT$`A
l$XIi
l$Xba
l$Xba~\b
l$X~gL
l$\bba
l$\bba~\b
l$\bbb
l$\f0b
l$\rba~\b
l$`E3
l$`Hc
l$`L;Axr
l$`Lc
l$`ba|H
l$`fA
l$`fD
l$`fE
l$`ffffff
l$fba~\b
l$hAƅX
l$hH;l
l$lH+X`I
l$lH;s
l$pHc
l$pL;l$xL
l$pLc
l$pba~\b
l$pfD
l$pfE
l$pġzY
l$pŠY
l%ݼN8m
l&:GF
l-;eM
l/:09
l0+:z
l0=h{D
l0\aba|H
l15;RJ
l1ú\ad
l598_r
l6w<H
l7<dV
l8%9\tc
l9<RW
l9\t;!\nW
l9u;.L
l:Xj纨E
l:\b\n\t;gr󹙌A;bYi;DQ
l:g\r\t
l:j\aB;r
l:nZ>:JzH
l:~ou
l; le
l;B8a
l;\tyٺtM\f;F
l<X94
l<w5Ž\nL\b
l<ǜu=57
l>a|m
l@3=jX
l@Y\rІw
lBL:pj
lB黻n9
lD;LH\e
lD<dq4<K
lE8o]Q
lGo<`m
lH;QS{9
lHYu\rb
lHY|\a\bb
lHY}\abB
lK=$39
lNs:E7
lO5;"S
lP9[В9
lR);ce
lT0fB
lT5_.E
lU ńX
lV;#f
lW2:8
lW?XҶ<M
lWۻ4\fM9
lX\f"H
lY2;\f
lY5 /i
lY5)Qu
lY5X7j
lY5\nOi
lY5]_i
lY5k`j
lY=Vsq
lY=\e_i
lY=f,p
lY=i;u
lY\r%tV
lY\r.@X
lY\r5s
lY\r7iE
lY\r>U
lY\r?RO
lY\r@-W
lY\rE4P
lY\rFU
lY\rK
lY\rd
lY\rh;A
lY\rn
lY\rn:C
lY\rn\n
lY\rzl
lZ1<x
lZ=Ru\r
lZ=vI
l\a<a8):A
l\aPġBYT\a\\L
l\e;Ko\e:b
l\f5;d'P
l\f<< T
l\f<j
l\fI9
l\fx8Ŕe
l\n\v<2
l\t\abA|H
l\vP:7
l\vS9S7
l\v\abA|H
l]U:j
l_Y<K
l_뻗jK
l`I<\eL
lbS;9bU
lc = nodes[idx].left; \n                int rc = nodes[idx].right; \n \n                // Calculate bounds \n                bbox b = bboxunion(bounds[lc], bounds[rc]); \n \n                // Write bounds \n                bounds[idx] = b; \n            } \n            else \n            { \n                // If the flag was 0 set it to 1 and bail out. \n                // The thread handling the second child will \n                // handle this node. \n                break; \n            } \n        } \n        while (idx != 0); \n    } \n} \n
leaves
left.bounds().empty
lf8<E>6
lfW;I
lfffff
lg;;T
lg\v<DZO
li$<}C0=t
li;4ZD
li=YU˼jn
liF;5F
line segments
line4i
line_accel
line_accel_mb
line_builder
line_builder_mb
line_traverser
line_traverser_mb
list too long
list<T> too long
listTanDevicesAndCaps
listener.x
listener.y
listener.z
listenerAhead.x
listenerAhead.y
listenerAhead.z
listenerPosition.x
listenerPosition.y
listenerPosition.z
listenerUp.x
listenerUp.y
listenerUp.z
ljH;p
lk9(mP
lk;6᤹a\n
llHl$ll
lli, %lli } :  Memory overwrite in %s
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %11.4f
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %11.4f + i* %11.4f
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %20.7lf
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %20.7lf + i* %20.7lf
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %i
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %11.4f
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %11.4f + i* %11.4f
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %20.7lf
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %20.7lf + i* %20.7lf
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %lli
llɻhOx
lm?;DjW
ln;7M\r
loadProbeBatch
loadScene
loadStaticMesh
local static guard
local static thread guard
local vftable
local vftable constructor closure
localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \nvoid group_segmented_scan_exclusive_int_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1
localTimeSegments > 0
log10f
lp:9#\f
lpֹ1yK
lset.geomBounds.empty() && area(lset.geomBounds) >= 0.0f
lu/%s
lv;u\rR
lvӼUf
lxໝi];w
ly\r;^pB
l~;n25
lúL #8
lŽVĖ<mE
lϻg{G
lعIEz
lܼ)8u
lޡ=eo\t
l嫼G+6
l蠼3\v_< ot
m / %d / %y
m L;wxr
m LcT$8I
m b!|\bX
m b1t\b
m!=\n3A
m"2;lxO
m"K;u
m'=YYY
m(8?TT
m(;tU
m);6\nr
m*k<o
m/:RG
m1q;\a
m2<\a'p
m3$;a
m3:@3\n
m5=R.O
m69jlQ9B
m6;]g
m6=FwK
m7;ka
m8(^S80
m8RDu;~d
m8aK:a
m8ԻWw
m9 k;5
m9b25
m9f/\t
m:Dբ9fI
m:cG?;X#W
m:o黹R\n
m;4Ij;qi\a
m;;X4
m;;zmx
m;F|39
m;o1J
m;y\t\a
m<8楼ky
m<>s2
m<[jg
m<\fi
m='\bڽlM8
m=\a9
m>)VF
m?x:o
m@H;{xr
m@L;sxr
m@L;wxr
m@ŠXm0
mAF=:D
mB;G\tH
mD><D
mEA;\a1
mF#ʈb3UF
mH@\rMS
mH@\ra)m
mH@\rhN
mI;g\\U
mJ#;5
mK=lr
mLK:a6t
mLY<F
mOD;7
mPD=I
mPo9"g
mPŠXm
mQ<FYr
mQ<^D
mSV;Ux
mU=#si
mWA9o
mWC:1
mX=9\t)C
mXbaT
mY90W
mY9p>o
m[;1NJ
m\abA|H
m\b!t
m\b;w\f
m\bI+\aA
m\bba}HpձbA,@YU\tb
m\e<r
m\fbA$ X
m\fbQ|H
m\fbr}H
m\nE<v
m\nb1}HpֱbQ,HYU\vb
m\rbA|H
m\tQ9
m\t\v
m\tbQ|H
m\vbA|H
m\vbB
m\vbQ|H
m\v|$dD
m_4:\bN
m`<\au2
m`L;oxr
m`ŠXmP
m`ŨXl
ma;Ⱦ1
madd(decode_scale,float(MAX_QUAN),minF) >= maxF
malloc
managed vector constructor iterator
managed vector copy constructor iterator
managed vector destructor iterator
map/set too long
map/set<T> too long
mask < 16
mask >= 0 && mask < 16
matrix appears to be degenerate. The method probably had to be stopped at the
matrix column indexes are not in increasing order
matrix has no diagonal in CSR format
matrix has zero diagonal
matrix size-1) if IPAR(7)>0, aborting otherwise
matrix size. Proceeding with the parameter equals
matrix_number_in: %d matrix_type_in: %d
matrix_number_in: %i matrix_type_in: %d
matrix_number_in: %lli matrix_type_in: %lli
maxGrowSize
max_builder_isa
max_hrtf_normalization_volume_gain_db
max_isa
max_leaf_size
max_open_size <= MAX_OPENED_CHILD_NODES
max_spatial_split_replications
max_triangles_per_leaf
maximally 256 floating point values can be interpolated per vertex
mb<\e
mc;|c
mc^:H
md:jgt
me;9*7
medium
memcpy_s: dest is NULL
memcpy_s: dmax exceeds max
memcpy_s: dmax is 0
memcpy_s: overlap undefined
memcpy_s: smax exceeds dmax
memcpy_s: smax is 0
memcpy_s: src is NULL
memkind".dll
memkind_get_version
memmove_s: dest is null
memmove_s: dmax is 0
memmove_s: smax exceeds max
memmove_s: smax is 0
memmove_s: src is null
memory for inner temporary integer array of size N
memory monitor forced termination
message size
method may fail to converge
mffffff
mg<;z\b
mge:p
mi<78f
min-width feature is not enabled
min_leaf_size
minkernel\\crts\\ucrt\\inc\\corecrt_internal_strtox.h
mix->data
mix->data[iChannel][mix->numSamples - 1
mix->numChannels
mix->numSamples
mixAudioBuffer
mj9Z[9G
mkX>\r+G
mkl_avx2.2.dll
mkl_avx512.2.dll
mkl_def.2.dll
mkl_mc3.2.dll
mkl_msg.dll
mkl_somatcopy
mkl_vml_avx2.2.dll
mkl_vml_avx512.2.dll
mkl_vml_cmpt.2.dll
mkl_vml_def.2.dll
mkl_vml_mc3.2.dll
mkʻnI\v
ml">Z
mn;$R
mn];A
model->callback
model->coefficients
model->coefficients[iArray
model->dipolePower
model->dipoleWeight
model->dirty
model->minDistance
model->type
morton
morton[j] <= morton[j+1
motion blur grids
motion blur hair
motion blur line segments
motion blur quads
motion blur triangles
movdir64b
movdiri
mp~9GGW
mq:1kA
mq\e:3N
mr;4i
mr=/\b5
mr>\rw
ms:W6x
msM;W
mscoree.dll
msrlist
mt^<E
mtllib %s.mtl\n
must be not bigger than (%i
must be not less than (%i
mv':\eh
mwH9?l\f:@Z`8eTE
mx::dh89mG
myzAn4
m~ҺBT
mÜ8\a
mȣ:ScսEd
mɺDDo;8
m˕9ntH
m˻7\eG;BF
m˻Eg7
mλ8FF
mѸC\e
n            else \n            { \n                lbox = scenedata->bounds[node.left]; \n                rbox = scenedata->bounds[node.right]; \n \n                lefthit = IntersectBoxF(r, invdir, lbox, r->o.w); \n                righthit = IntersectBoxF(r, invdir, rbox, r->o.w); \n \n                if (lefthit > 0.f && righthit > 0.f) \n                { \n                    int deferred = -1; \n                    if (lefthit > righthit) \n                    { \n                        idx = node.right; \n                        deferred = node.left; \n                    } \n                    else \n                    { \n                        idx = node.left; \n                        deferred = node.right; \n                    } \n \n                    if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                    { \n                        for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                        { \n                            gsptr[i] = ldsstack[i * 64]; \n                        } \n \n                        gsptr += SHORT_STACK_SIZE; \n                        lsptr = ldsstack + 64; \n                    } \n \n                    *lsptr = deferred; \n                    lsptr += 64; \n \n                    continue; \n                } \n                else if (lefthit > 0) \n                { \n                    idx = node.left; \n                    continue; \n                } \n                else if (righthit > 0) \n                { \n                    idx = node.right; \n                    continue; \n                } \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return false; \n} \n \n \n#endif \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes, // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef LDS_BUG \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n    // Input \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* ra
n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return false; \n} \n#else \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    if (r->o.w < 0.f) \n        return false; \n     \n    int stack[32]; \n \n    int* sptr = stack; \n    *sptr++ = -1; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    bool found = false; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        leftleaf = LEAFNODE(node.lbound); \n        rightleaf = LEAFNODE(node.rbound); \n \n        lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, r->o.w); \n        righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, r->o.w); \n \n        if (leftleaf) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node.lbound), r)) \n            { \n                found = true; \n                break; \n            } \n        } \n         \n        if (rightleaf) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node.rbound), r)) \n                    { \n                        found = true; \n                        break; \n                    } \n        } \n \n        if (lefthit > 0.f && righthit > 0.f) \n        { \n            int deferred = -1; \n            if (lefthit > righthit) \n            { \n                idx = (int)node.rbound.pmax.w; \n                deferred = (int)node.lbound.pmax.w;; \n            } \n            else \n            { \n                idx = (int)node.lbound.pmax.w; \n                deferred = (int)node.rbound.pmax.w; \n            } \n \n                    *sptr++ = deferred; \n        } \n        else if (lefthit > 0) \n        { \n            idx = (int)node.lbound.pmax.w; \n        } \n        else if (righthit > 0) \n        { \n            idx = (int)node.rbound.pmax.w; \n        } \n \n        if (lefthit <= 0.f && righthit <= 0.f) \n            idx = *--sptr; \n    } \n \n    return found; \n} \n \n#endif \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes, // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n         \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef GLOBAL_STACK  \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData con
n       Lenght: %d   Buffer size: %d\n
n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults,  // Hit results \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    while (ridx < numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[ridx] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRCAMD( \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits, // Hit datas \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    Intersection isect; \n \n    while (ridx < *numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= *numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            IntersectSceneClosest(&scenedata, &r, &isect); \n            // Write data back in case of a hit \n            hits[ridx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRCAMD( \n    // Input \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults,   // Hit results \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    while (ridx < *numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= *numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n
n ;b\e
n <= MAX_RING_FACE_VALENCE
n <gE
n == 0
n M;B"y
n T:C
n }WH
n }ZH
n!r<J{R
n"I\vc
n"a;x
n$ fG
n$v;b
n&ɻwh\b
n'>RR
n(H9n H
n)g;v
n+C;\fK
n,:Ff
n-:LT̹K
n.<Uv
n/ ;l
n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable\n#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n\n// --------------------------------------------------------------------------------------------------------------------\n// Constants\n// --------------------------------------------------------------------------------------------------------------------\n\n#define PI                          3.14159f              // Mathematical constant Pi\n#define SOURCE_RADIUS               0.1f                  // Radius of the sound source sphere (in meters)\n#define LISTENER_RADIUS             0.1f                  // Radius of the listener sphere (in meters)\n#define SPEED_OF_SOUND              340.0f                // Speed of sound in air (in meters per second)\n#define RAY_SURFACE_OFFSET          1e-2f                 // Small offset to prevent ray self-intersection (meters)\n#define SPECULAR_EXPONENT           1e+2f                 // Exponent for specular reflection in Phong shading model (unitless, higher value = more specular)\n#define NUM_BANDS                   3                     // Number of frequency bands (e.g., Low, Mid, High)\n#define NUM_BINS                    256                   // Number of time bins used for energy histograms\n#define BIN_DURATION                0.01f                 // Duration of each time bin (in seconds)\n#define NUM_LOCAL_HISTOGRAMS        2                     // Number of local histograms per workgroup (for atomic contention reduction, tunable)\n\n// --------------------------------------------------------------------------------------------------------------------\n// CoordinateSpace\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) CoordinateSpace_t\n{\n    float3 right;\n    float3 up;\n    float3 ahead;\n    float3 origin;\n} CoordinateSpace;\n\nCoordinateSpace createCoordinateSpace(float3 normal)\n{\n    CoordinateSpace space;\n    space.ahead = normal;\n\n    if (fabs(normal.x) > fabs(normal.z))\n    {\n        float3 right = (float3) (-normal.y, normal.x, 0.0f);\n        space.right = normalize(right);\n    }\n    else\n    {\n        float3 right = (float3) (0.0f, -normal.z, normal.y);\n        space.right = normalize(right);\n    }\n\n    space.up = cross(space.right, space.ahead);\n\n    return space;\n}\n\nfloat3 transformLocalToWorld(CoordinateSpace space,\n                             float3 direction)\n{\n    return direction.x * space.right + direction.y * space.up - direction.z * space.ahead;\n}\n\nfloat3 transformWorldToLocal(CoordinateSpace space,\n                             float3 direction)\n{\n    float3 transformedDirection;\n    transformedDirection.x = dot(direction, space.right);\n    transformedDirection.y = dot(direction, space.up);\n    transformedDirection.z = -dot(direction, space.ahead);\n    return transformedDirection;\n}\n\nfloat3 transformHemisphereSample(float3 direction,\n                                 float3 normal)\n{\n    CoordinateSpace tangentSpace = createCoordinateSpace(normal);\n    return normalize(transformLocalToWorld(tangentSpace, direction));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Random Sampling\n
n/97vO
n/C;7
n0,;P0
n03>Pu
n0<)w
n0A:c
n0\tP\bp\a
n0ƻAsm
n1#<OP8
n1=L88
n1i>u
n2:Nu
n4,;E
n5:\n
n6:!H
n7!;i
n76OL;\nq
n7;XPF
n7T7H
n8=]H
n9%HL
n99%ŻSbǻK
n9FѬ:r
n9\f˜9
n9ofi96
n:/9h
n:/QY
n:3;T
n:3sA
n:VT%;Z
n:\b$o8c
n:\b=5a
n:\bRs
n:\eoe9
n:l)s
n:m~a
n;5Yٺ3w
n;@ d:I
n;A^L
n;C4d<n
n;Ja[;Y
n;Q+f
n;V\fw;\f
n;\r5
n;\v0t;W
n;ai;X
n;b92
n;i|y
n;ku\b;0\nz
n;lvT8\fgM
n;r\b9
n;r\eW9
n;y[f
n<*ki
n</N9
n<4\ro
n<F\rh
n<O}w<p
n<\e4
n<\vzV
n<f8\r
n<s]7
n<uyN
n<vǨ8
n<z4ٻi
n=25b=v
n=4~y
n=9rD
n=TEԼYt
n=e}Q>p
n=fZȼ4u
n=jn\f
n=xnd
n>&CS
n>&S4
n>6<8
n><oF>d
n>Hsk=Q
n>J9H
n>L<Zse
n>Y\n\n>0
n>\e4E
n>\f(FX
n>log2
n>w%n
n>ֻ6zW
n?0ho?s
n?333
n?6\e
n?:Da\t
n?P;H
n?arh
n@ŸYv
nA9Y$vv
nA9y$vv
nA>;b4L
nA>Spz
nB/:m
nBϺُt
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n /************************************************************************* \n  INCLUDES \n  **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable \n#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable \n \n \n// --------------------- HELPERS ------------------------ \n//#define INT_MAX 0x7FFFFFFF \n \n// -------------------- MACRO -------------------------- \n// Apple OCL compiler has this by default,  \n// so embrace with #ifdef in the future \n#define DEFINE_MAKE_4(type)\\ \n    type##4 make_##type##4(type x, type y, type z, type w)\\ \n{\\ \n    type##4 res;\\ \n    res.x = x;\\ \n    res.y = y;\\ \n    res.z = z;\\ \n    res.w = w;\\ \n    return res;\\ \n} \n \n// Multitype macros to handle parallel primitives \n#define DEFINE_SAFE_LOAD_4(type)\\ \n    type##4 safe_load_##type##4(__global type##4* source, uint idx, uint sizeInTypeUnits)\\ \n{\\ \n    type##4 res = make_##type##4(0, 0, 0, 0);\\ \n    if (((idx + 1) << 2)  <= sizeInTypeUnits)\\ \n    res = source[idx];\\ \n    else\\ \n    {\\ \n    if ((idx << 2) < sizeInTypeUnits) res.x = source[idx].x;\\ \n    if ((idx << 2) + 1 < sizeInTypeUnits) res.y = source[idx].y;\\ \n    if ((idx << 2) + 2 < sizeInTypeUnits) res.z = source[idx].z;\\ \n    }\\ \n    return res;\\ \n} \n \n#define DEFINE_SAFE_STORE_4(type)\\ \n    void safe_store_##type##4(type##4 val, __global type##4* dest, uint idx, uint sizeInTypeUnits)\\ \n{\\ \n    if ((idx + 1) * 4  <= sizeInTypeUnits)\\ \n    dest[idx] = val;\\ \n    else\\ \n    {\\ \n    if (idx*4 < sizeInTypeUnits) dest[idx].x = val.x;\\ \n    if (idx*4 + 1 < sizeInTypeUnits) dest[idx].y = val.y;\\ \n    if (idx*4 + 2 < sizeInTypeUnits) dest[idx].z = val.z;\\ \n    }\\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE(type)\\ \n    void group_scan_exclusive_##type(int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (localId == 0)\\ \n    shmem[groupSize - 1] = 0;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_SUM(type)\\ \n    void group_scan_exclusive_sum_##type(int localId, int groupSize, __local type* shmem, type* sum)\\ \n{\\ \n    for (int stride = 1; stride
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \n INCLUDES \n **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_fl
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_floa
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \ntypedef struct \n{ \n    float3 pmin; \n    float3 pmax; \n} bbox; \n \n// The following two functions are from \n// http://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/ \n// Expands a 10-bit integer into 30 bits \n// by inserting 2 zeros after each bit. \nstatic unsigned int ExpandBits(unsigned int v) \n{ \n    v = (v * 0x00010001u) & 0xFF0000FFu; \n    v = (v * 0x00000101u) & 0x0F00F00Fu; \n    v = (v * 0x00000011u) & 0xC30C30C3u; \n    v = (v * 0x00000005u) & 0x49249249u; \n    return v; \n} \n \n// Calculates a 30-bit Morton code for the \n// given 3D point located within the unit cube [0,1]. \nunsigned int CalculateMortonCode(float3 p) \n{ \n    float x = min(max(p.x * 1024.0f, 0.0f), 1023.0f); \n    float y = min(max(p.y * 1024.0f, 0.0f), 1023.0f); \n    float z = min(max(p.z * 1024.0f, 0.0f), 1023.0f); \n    unsigned int xx = ExpandBits((unsigned int)x); \n    unsigned int yy = ExpandBits((unsigned int)y); \n    unsigned int zz = ExpandBits((unsigned int)z); \n    return xx * 4 + yy * 2 + zz; \n} \n \n// Assign Morton codes to each of positions \n__kernel void CalcMortonCode( \n    // Centers of primitive bounding boxes \n    __global bbox const* bounds, \n    // Number of primitives \n    int numpositions, \n    // Morton codes \n    __global int* mortoncodes \n    ) \n{ \n    int globalid = get_global_id(0); \n \n    if (globalid < numpositions) \n    { \n        bbox bound = bounds[globalid]; \n        float3 center = 0.5f * (bound.pmax + bound.pmin); \n        mortoncodes[globalid] = CalculateMortonCode(center); \n    } \n} \n \n \nbbox bboxunion(bbox b1, bbox b2) \n{ \n    bbox res; \n    res.pmin = min(b1.pmin, b2.pmin); \n    res.pmax = max(b1.pmax, b2.pmax); \n    return res; \n} \n \ntypedef struct \n{ \n        int parent; \n        int left; \n        int right; \n        int next; \n} HlbvhNode; \n \n#define LEAFIDX(i) ((numprims-1) + i) \n#define NODEIDX(i) (i) \n \n// Calculates longest common prefix length of bit representations \n// if  representations are equal we consider sucessive indices \nint delta(__global int* mortoncodes, int numprims, int i1, int i2) \n{ \n    // Select left end \n    int left = min(i1, i2); \n    // Select right end \n    int right = max(i1, i2); \n    // This is to ensure the node breaks if the index is out of bounds \n    if (left < 0 || right >= numprims)  \n    { \n        return -1; \n    } \n    // Fetch Morton codes for both ends \n    int leftcode = mortoncodes[left]; \n    int rightcode = mortoncodes[right]; \n \n    // Special handling of duplicated codes: use their indices as a fallback \n    return leftcode != rightcode ? clz(leftcode ^ rightcode) : (32 + clz(left ^ right)); \n} \n \n// Shortcut for delta evaluation \n#define DELTA(i,j) delta(mortoncodes,numprims,i
nD$PfA
nD$TfA
nD8)\bP
nD9Q$t
nEl:c3
nEȾ1l8
nGM;$i
nG۽-F0
nH9G\btsH
nH;A\bu
nH;Q\bu
nH;Q\bu\rL
nHȻ=59
nI7;7W
nIr;15\e<[g
nJ:A+5
nJ|;6v5
nK7:v8
nK\bpRj
nL$DfA
nMKL INTERNAL ERROR: message buffer overflow
nMcL$lM
nNANאB
nNq:RuY
nO;HbK
nO<u\a\e
nO}R7V
nOƼ!b\r
nP-<9
nP_=bw
nQ :oV
nR#;4
nR;SdH
nS:](1;m2
nS;GP
nSa=d
nS|;1
nT9Aq̼H
nThreads
nUp<J
nV5> 8
nV;\e\e
nVl<TJG
nVǺciºD
nW:n$Z;K5J
nW\a;O
nWashington1
nX;O냻R
nXY8Ŋ\\a8łXY
nY<*y1
nYD\alġ*Y
nZ<vSk
nZ`<3g
n[:O9d
n\\8z
n\\q łX
n\a9SB;:9
n\a\a;A\e
n\abA|H
n\ay<{c
n\b:A枻y
n\b=jv8
n\bJ<I
n\bY\f*H
n\bf\fn\n
n\e>BJb
n\e\n=U|O
n\es=]T
n\fּI
n\n// The following code is from the Radeon Rays / Baikal GitHub repository. It can be found at:\n//      https://github.com/GPUOpen-LibrariesAndSDKs/RadeonProRender-Baikal/blob/master/Baikal/Kernels/CL/sampling.cl\n\ntypedef struct RNG_t\n{\n    uint    value;\n} RNG;\n\nuint wangHash(uint seed)\n{\n    seed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nuint randUint(local RNG* rng)\n{\n    rng->value = wangHash(1664525U * rng->value + 1013904223U);\n    return rng->value;\n}\n\nfloat randFloat(local RNG* rng)\n{\n    return ((float)randUint(rng)) / 0xffffffffU;\n}\n\nvoid initRNG(uint seed, local RNG* rng)\n{\n    rng->value = wangHash(seed);\n}\n\nfloat2 uniformRandom2d(local RNG* rng)\n{\n    return (float2) (randFloat(rng), randFloat(rng));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Directivity\n// --------------------------------------------------------------------------------------------------------------------\n\n// NOTE: Custom directivity callbacks are not supported at this time.\ntypedef struct __attribute__((packed)) Directivity_t\n{\n    float dipoleWeight;\n    float dipolePower;\n} Directivity;\n\nfloat evaluateDirectivity(float3 point,\n                          CoordinateSpace coordinates,\n                          Directivity directivity)\n{\n    float3 worldSpaceDirection = normalize(point - coordinates.origin);\n    float3 localSpaceDirection = transformWorldToLocal(coordinates, worldSpaceDirection);\n\n    float cosine = -localSpaceDirection.z;\n    return pow(fabs((1.0f - directivity.dipoleWeight) + directivity.dipoleWeight * cosine), directivity.dipolePower);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Material\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) Material_t\n{\n    float  absorptionLow;\n    float  absorptionMid;\n    float  absorptionHigh;\n    float  scattering;\n    float  transmissionLow;\n    float  transmissionMid;\n    float  transmissionHigh;\n} Material;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Radeon Rays Helpers\n// --------------------------------------------------------------------------------------------------------------------\n\n// This must exactly match the ray data structure (struct ray) used by Radeon Rays.\ntypedef struct Ray_t\n{\n    float4  o;\n    float4  d;\n    int2    extra;\n    int2    padding;\n} Ray;\n\n// This must exactly match the hit data structure (struct Intersection) used by Radeon Rays.\ntypedef struct Hit_t\n{\n    int       shapeid;\n    int       primid;\n    int       padding0;\n    int       padding1;\n    float4    uvwt;\n} Hit;\n\n// --------------------------------------------------------------------------------------------------------------------\n// IIR Filtering\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct IIR_t\n{\n    float a1, a2;\n    float b0, b1, b2;\n} IIR;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void generateCameraRays(global CoordinateSpace* camera,\n                               global Ray* rays)\n{\n    uint width = get_global_size(0);\n    uint height = get_global_size(1);\n    uint u = get_global_id(0);\n    uint v = get_global_id(1);\n    uint index = v * width + u;\n\n    float du = ((u / (float) width) - 0.5f) * 2.0f;\n    float dv = ((v / (float) height) - 0.5f) * 2.0f;\n\n    rays[in
n\n<L6
n\n\f
n\nbq|H
n\nҼR
n\rba|H
n\t$;AW
n\t;ud
n\tbQ|H
n\v>c
n\vR<q
n\vb<c\e
n]8-Qz
n]s9P
n]ͺX0
n^r;R4
n`q<D9Q
na\e>i
nan(ind
nan(snan
naۼyt
nb!\fHY
nb!|H
nb\a<\n
nbaL X
nba~\b
nbb}XB
nbq,HY
nbu;T
nc:\ba
nc<\e"7
ncd>0
ncڼY\a
nd'<T\f
nd1;,A
nd8<D1
ndC;D
ndN9^5
nda:h\b
ne::v
ne;=wgU
need dictionary
network down
network reset
network unreachable
new-zealand
newID+numSubPrims-1 <= numPrimitivesExt
newNumThreads
new_active <= new_alloced
new_root_ref <= (int64_t)REF_TAG_MASK
newmtl material_%d\n
next_half_edge_ofs != 0
nextafter
nfA9\tt\tI
nfA>MI\f
nfe;h
nfffff
ng:2p5
ngN;1
ngf>ZL
ngo<E
nh0;7F
nh;R\b
nh;xl
nh<Spz
nhԼwc
ni#<v\a
ni&<5
ni/=4M
niø>2i
niۺ\e
nj;\rIe9
nj\bT\nf\b
nk;\b$d
nkB;z
nm9C1
nmȻ/n
nn=<AI
nnu;Sl
no buffer space
no child process
no link
no lock available
no message
no message available
no multiple minimum degree on the separator nodes
no protocol option
no space on device
no stream resources
no such device
no such device or address
no such file or directory
no such process
no9yaa
no:%\nO<dA
no;\t
no;o3\e
noJ;1
node.isOBBNodeMB
nodes
norwegian
norwegian-bokmal
norwegian-nynorsk
not a directory
not a socket
not a stream
not be equal to 0.0 at this stage. Either the user had to stop the method as it
not connected
not enough memory
not stopped when it found the solution. The solution may be wrong
not supported
not supported node type in bvh_statistics
not:݊n
npA<0
npJ:4
np\t0\bP
np\t`\b0
np\t`\bP
npɺL+\e
nq:\bx0
nqS<r
nr7;T
nr;r$\a
nr<UV
nre;X,K
ns<\r
nt$\bfG
nt91b\f:뜈94
nt=Ac
ntdll.dll
ntel3L$0\txineI3D$,1
ntel3T$0\t¸ineI3D$,1
nu>mo
num <= maxLeafBlocks
num == 1
num == getNumEagerLeaves(patch.grid_u_res,patch.grid_v_res
num >= 1
numBilinearFaces
numChannels
numComplexFaces
numFaces
numInputs
numIrregularQuadFaces
numMisplacedItemsLeft == numMisplacedItemsRight
numPrimitives+offset <= numPrimitivesExt
numPrimitivesToSplit == (numPrimitives - center
numRegularQuadFaces
numSamples
numSubPrims
numSubPrims < MAX_PRESPLITS_PER_PRIMITIVE
numSubPrims-1 == numSubPrimsExpected
number of columns for each panel: %d
number of columns for each panel: %lli
number of equations:           %d
number of equations:           %lli
number of independent subgraphs:  %d
number of independent subgraphs:  %lli
number of iterations is equal to IPAR(5)-IPAR(4
number of non-zeros in A (%%): %f
number of non-zeros in A:      %d
number of non-zeros in A:      %lli
number of non-zeros in L+U:              %d
number of non-zeros in L+U:              %lli
number of non-zeros in L:                %d
number of non-zeros in L:                %lli
number of non-zeros in U:                %d
number of non-zeros in U:                %lli
number of right-hand sides:    %d
number of right-hand sides:    %lli
number of supernodes:                    %d
number of supernodes:                    %lli
number of time steps is out of range
nv?:Fx
nvdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    float3 invdirtop = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    // We need to keep original ray around for returns from bottom hierarchy \n    ray topray = *r; \n \n    // Fetch top level BVH index \n    int idx = scenedata->rootidx; \n    // -1 indicates we are traversing top level \n    int topidx = -1; \n    // Current shape id \n    int shapeid = -1; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, isect->uvwt.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                // or containing another BVH (top level hierarhcy) \n                if (topidx != -1) \n                { \n                    // This is bottom level, so intersect with a primitives \n                    if (IntersectLeafClosest(scenedata, &node, r, isect)) \n                    { \n                        // Adjust shapeid as it might be instance \n                        isect->shapeid = shapeid; \n                    } \n \n                    // And goto next node \n                    idx = (int)(node.pmax.w); \n                } \n                else \n                { \n                    // This is top level hierarchy leaf \n                    // Save top node index for return \n                    topidx = idx; \n                    // Get shape descrition struct index \n                    int shapeidx = SHAPEIDX(node); \n                    // Get shape mask \n                    int shapemask = scenedata->shapedata[shapeidx].mask; \n                    // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                    // otherwise skip the subtree \n                    if (Ray_GetMask(r) && shapemask) \n                    { \n                        // Fetch bottom level BVH index \n                        idx = scenedata->shapedata[shapeidx].bvhidx; \n                        shapeid = scenedata->shapedata[shapeidx].id; \n \n                        // Fetch BVH transform \n                        float4 wmi0 = scenedata->shapedata[shapeidx].m0; \n                        float4 wmi1 = scenedata->shapedata[shapeidx].m1; \n                        float4 wmi2 = scenedata->shapedata[shapeidx].m2; \n                        float4 wmi3 = scenedata->shapedata[shapeidx].m3; \n \n                        // Apply linear motion blur (world coordinates) \n                        //float4 lmv = scenedata->shapedata[shapeidx].linearvelocity; \n                        //float4 amv = scenedata->shapedata[SHAPEDATAIDX(node)].angularvelocity; \n                        //r->o.xyz -= (lmv.xyz*r->d.w); \n                        // Transfrom the ray \n                        *r = transform_ray(*r, wmi0, wmi1, wmi2, wmi3); \n                        // rotate_ray(r, amv); \n                        // Recalc invdir \n                        invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n                        // And continue traversal of the bottom level BVH \n                        continue; \n                    } \n                    else \n                    { \n                        idx = -1; \n                    } \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                // This is an internal node, proceed to left child (it is at current + 1 index) \n                idx = idx + 1; \n            } \n        } \n        else \n        { \n            // We missed the node, goto next one \n            idx = (int)(node.pmax.w); \n        } \n \n        // Here check if we ended up traversing bottom level BVH \n        // in this case idx = -1 and topidx has valid value \n        if (idx == -1 && topidx != -1) \n        { \n            //  Proceed to next top level node \n            idx = (int)(scenedata->nodes[topi
nv}:gn
nv¼\f6
nx:V"3
nxm;n
nzW;soi
nzԉY9
n{;DX
n|4\bfG
n½<FM
nĻljs9
nƉ;8XB
nɍ\f8fD
nʈL$Wba
n˺Zu3
n̼myƼN
nϬ;DD
nӽoZ\r
nֺ]Gc;oq
nۺc{k
nܺ#9Z8\rx
nߋ:qZk
nDkt
o ;^Y
o!:5V
o"I=q
o"j=9
o#r;5C
o%=Qe
o%BVV
o%Kau
o%L]M
o%ZLM
o%Z\r
o%\tsM
o%tOu
o%w6u
o%z|B
o%{IiO
o&;Ts\n9
o):8tR\e
o-0MP
o-@nO
o-dKE
o-oDM
o-q=3j
o0;\acL;&1
o0H;_8
o1H:\r
o2;ht7
o2R<e
o4;"Q\r
o5$\v7
o5%!O
o5%CG
o5&MD
o5,w5
o53 Q
o5K,O
o5L\fY
o5P{D
o5T+F
o5YTQ
o5[\a8
o5\\hX
o5\aB
o5\bgF
o5\rPX
o5`vQ
o5c-8
o5fZ5
o5ibY
o5o[\n
o5p-L
o5t$V
o5y\bZ
o7:n>L:F
o8%;n
o9?PI
o9JBD
o9YL軧w
o9\nAܹᆆ9
o9vI!9
o:!ＺU5p
o:=ds
o:CD0
o:Md\n:0
o:cPO
o:ˊV9T
o;0>r
o;7 X9
o;A;k
o;So4
o;a\a_:Hrb
o;n2;F2r;P
o;u ѺR
o;xXq
o<D<c
o<g~1
o<m7¼S
o<}ug
o=!LE
o=5Ve
o=W\r
o=\e 2=QO
o=\tVN
o=v\e
o>3j\r?\f
o>p-I
o@e:z4
oAJ;o
oB);B
oB)>z
oB<P\b
oC;@cB
oD$ fD
oD$0fD
oD$PfA
oD$`fA
oD$`fE
oD$pfD
oD>Kg
oEb;CK
oI\\$Hf
oJ;I\am;8
oK.;\vN
oL$ fD
oL$0fD
oL$`fD
oL$pfD
oM̹r0
oO\vbQ
oO{Jw
oQ <]\b
oQ;Bs
oR<X\b
oRۼƿc
oSüoV
oT$ fD
oT$@fD
oT$@fE
oT$PfD
oT$`Hk
oT$`fD
oT$pfD
oT$pŹv
oT<cQ˼Ի\t
oV<o6o
oW\v<kD
oZs=s_d
o\\$PfA
o\\$PfD
o\\$pfD
o\a>xp\a5hq\a,4
o\e;L
o\f;H
o\f;Wtv8
o\r >w
o\r"O
o\r$7J
o\r&9S
o\r)MW
o\r2zz
o\r3s
o\r6NP
o\r8X4
o\r8^9
o\r9qU
o\r;e\a
o\r>I8
o\r?5
o\rARS
o\rA[S
o\rB\bS
o\rD'9
o\rH\\h
o\rNCx
o\rNFi
o\rNPC
o\rOWV
o\rREM
o\rSDn
o\r[u
o\r\\Nn
o\r\v;U
o\ra#X
o\ra;O
o\rd)c
o\rdV
o\rjLE
o\rk-6
o\rn(\b
o\rn}i
o\ro@b
o\rs}B
o\ruXM
o\rwgW
o\rx[R
o\ry8
o\r{qM
o\r}8
o\t>j
o\t\r
o\te:xD
o\tĺ\fZ
o]X:C
o`U<R
oat2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n
ob!?K
object
object_accel
object_accel_max_leaf_size
object_accel_mb
object_accel_mb_max_leaf_size
object_accel_mb_min_leaf_size
object_accel_min_leaf_size
object_builder
object_builder_mb
object_ids[i] < numObjects
objects
obq\fHY
occluded1
occluded4
occluded8
oc̻P[b
od ;S
od$0fD
od$@fD
od$PfD
od$`fD
od$pfD
oe);h
oe;\a{H
of iterations is equal to IPAR(5)-IPAR(4
of the matrix is negative or zero
offset <= 2*N
ofs <= size
ofs == bytes
ofܺ\n
og 9P
ohL+o`L
oiκHT
oj<WD
oj>OP
oj?;78
ol$ fD
ol$0fD
ol$@fE
ol$PfD
ol$`fA
ol$`rD
ol$pfD
ole32.dll
omni callsig
onst float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n \n \n \n#define STARTIDX(x)     (((int)(x->pmin.w))) \n#define SHAPEIDX(x)     (((int)(x.pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n \ntypedef struct \n{ \n    // BVH structure \n    __global BvhNode*       nodes; \n    // Scene positional data \n    __global float3*        vertices; \n    // Scene indices \n    __global Face*          faces; \n    // Transforms \n    __global ShapeData*     shapedata; \n    // Root BVH idx \n    int rootidx; \n} SceneData; \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nbool IntersectLeafClosest( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n    if (IntersectTriangle(r, v1, v2, v3, isect)) \n    { \n        isect->primid = face.id; \n        return true; \n    } \n \n    return false; \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r                      // ray to instersect \n) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n    if (IntersectTriangleP(r, v1, v2, v3)) \n    { \n        return true; \n    } \n \n    return false; \n} \n \n \n// intersect Ray against the whole BVH2L structure \nbool IntersectSceneClosest2L(SceneData* scenedata, ray* r, Intersection* isect) \n{ \n    // Init intersection \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    // Precompute invdir for bbox testing \n    float3 i
onst float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n#define STARTIDX(x)     (((int)((x).pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n#define SHORT_STACK_SIZE 16 \n \n \ntypedef struct \n{ \n    bbox lbound; \n    bbox rbound; \n} FatBvhNode; \n \ntypedef struct \n{ \n    // BVH structure \n    __global FatBvhNode const*     nodes; \n    // Scene positional data \n    __global float3 const*         vertices; \n    // Scene indices \n    __global Face const*         faces; \n    // Shape IDs \n    __global ShapeData const*     shapes; \n    // Extra data \n    __global int const*             extra; \n} SceneData; \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nvoid IntersectLeafClosest( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n        } \n    } \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return f
ooc_cfg_file_name  got by Env=%s
ooc_cfg_path       got by Env=%s
ooc_keep_file      got by Env=%d
ooc_keep_file     got from config file=%d
ooc_max_core_size  got by Env=%d
ooc_max_core_size got from config file=%d
ooc_max_swap_size got by Env=%d
ooc_max_swap_size got by Env=%lli
ooc_max_swap_size got from config file=%d
ooc_path           got by Env=%s
ooc_path          got from config file=%s
ook:e
ooq:w
operation canceled
operation in progress
operation not permitted
operation not supported
operation not supported for this geometry
operation only allowed for user geometries
operation would block
operator
operator co_await
opposite_half_edge_ofs != 0
or criterion is very restrictive. CG method has been stopped
or the parameter DPAR(1) was altered by mistake outside of
or the parameter IPAR(1)=%s was altered by mistake outside of the
or the parameter SPAR(1) was altered by mistake outside of
or the parameter dpar[0] was altered by mistake outside of
or the parameter ipar[0]=%s was altered by mistake outside of the
or the parameter spar[0] was altered by mistake outside of
or>P>M
oriented_bezier_curve
oriented_bspline_curve
oriented_catmull_rom_curve
oriented_disc
oriented_hermite_curve
oriented_linear_curve
os<`M
ot$ fD
ot$@fA
ot$@fD
ot$`fD
ot:Kh
ou;d%w
out of memory
out->data
out->data[iChannel][out->numSamples - 1
out->numChannels
out->numSamples
outType
outlen == newN
outputs
outputs->direct)->airAbsorption[iBand
outputs->direct)->directivity
outputs->direct)->distanceAttenuation
outputs->direct)->flags
outputs->direct)->occlusion
outputs->direct)->transmissionType
outputs->direct)->transmission[iBand
outputs->pathing
outputs->pathing)->binaural
outputs->pathing)->eqCoeffs[iBand
outputs->pathing)->hrtf
outputs->pathing)->listener.ahead.x
outputs->pathing)->listener.ahead.y
outputs->pathing)->listener.ahead.z
outputs->pathing)->listener.origin.x
outputs->pathing)->listener.origin.y
outputs->pathing)->listener.origin.z
outputs->pathing)->listener.right.x
outputs->pathing)->listener.right.y
outputs->pathing)->listener.right.z
outputs->pathing)->listener.up.x
outputs->pathing)->listener.up.y
outputs->pathing)->listener.up.z
outputs->pathing)->order
outputs->pathing)->shCoeffs[iCoeff
outputs->reflections
outputs->reflections)->delay
outputs->reflections)->eq[iBand
outputs->reflections)->ir
outputs->reflections)->irSize
outputs->reflections)->numChannels
outputs->reflections)->reverbTimes[iBand
outputs->reflections)->tanDevice
outputs->reflections)->tanSlot
outputs->reflections)->type
outputs[i
outputs[i])->impulseResponse
outside of the routine, or the wrong value was assigned to the parameter 'np
outside of the routine, or the wrong value was assigned to the parameter 'nt
outside of the routine, or the wrong value was assigned to the parameter 'nx
outside of the routine, or the wrong value was assigned to the parameter 'ny
outside of the routine, or the wrong value was assigned to the parameter 'nz
ov<v\e1
ovһwB
ow\nbQ
owner dead
owq:Bsb
owʹ12
oxp;O
oy[:Q
oz:Ŷ%;nUr
o|$0fD
o|$PfD
o|:zJC
o~7:95\b
oÍ9ChM
oƺ<t\tv
o˼rә=wqb
oߏ;2Wf
p UWATAVAWH
p UWAVH
p WATAUAVAWH
p WAUAWH
p WAVAWH
p }8GQ
p!u;w;K
p"<C1
p%w+q4
p&7]u
p&Ϻz\vƺ5u
p,m;\eQF
p->hasOpposite() || p->edge_crease_weight == float(inf
p/C<Dn
p0R^G
p1.face_valence > 2
p1X>{C
p3L:B
p3ֹVBR
p4+<4
p7M}f
p7N<Bw
p7ǹzRa
p8H:d
p8W+B
p8^|S
p8墀9}\eT8
p9OBc
p9ݘX:2
p:4ߗ8z
p:KF\v
p:\vH\a
p:r\t
p:Ͳ7;9O
p:зٺ]Wr9L
p;5\b6
p;5qm
p;=AH
p;FpR
p;LFS
p;_8C
p;e8i
p<Q=7
p<W:sbI
p<\ba
p<gX\a
p=BAr
p=L\b
p=eaj
p=yO1
p>8MdF
p?<Ap
p?\b\tq?W
p@ݼoI
pA:sE
pA_A^A
pA_A^A]A
pC:\e
pD$@Uf
pD$`DE
pD$`Df
pD$`DfD
pD$pUD
pD;#O
pDf;~I
pE@DfD
pF<h:d
pG9;Dw
pGA:CH
pH+A0L
pH9oHvMI
pHcM@I
pI;\bA
pI;\bH
pK\e;E
pL$PDf
pL$`Nf
pL$pDf
pL;D$8s\aH
pL;D$Xs
pL;L$x
pL;d$xL
pL;t$HH
pL;x\b
pL;{xr
pMٹ2qh
pN;T,8r
pOE=e
pOߺthM
pS;뮀66
pT$@DA
pT$`Df
pT$pDf
pT%95l
pT|\a
pU@DfD
pUPDfD
pU\v;j
pUpDfD
pVֺ\t'F
pW\v=Z
pXD\v
pXd$PŨY
pXd$pŨY
pYD$p
pYE0Š\\MP
p[:I54
p\\$ UA
p\aIB
p\abA
p\aj;{s
p\b<I\v
p\bH+0H
p\bL;Axr
p\f<TyQ
p\r0\fP
p\r6;,E
p\rP\f0!p
p\r`\f0\vP
p\r`\fP
p\r`\fP\v0
p\rk<\t
p\t:lϏ9
p\t<lt)<8
p\tL<dd\a
p\v";LG
p] DfD
p]0DfD
p]:ql
p]@DfD
p]A_A
p]A_A^A
p^<DGn
pa; V
pa;CT
pa;\f\e5
parameter 'BCTYPE' was not in the admissible range {D,N,P} during initialization stage
parameter 'BCtype' was not in the admissible range {D,N,P} during initialization stage
parameter DPAR(1)=%e. The sine transform may be unsuitable for
parameter DPAR(1)=%e. The staggered cosine transform may be
parameter DPAR(1)=%e. The staggered sine transform may be
parameter SPAR(1)=%e. The SINE TRANSFORM may be unsuitable for
parameter SPAR(1)=%e. The sine transform may be unsuitable for
parameter SPAR(1)=%e. The staggered cosine transform may be
parameter SPAR(1)=%e. The staggered sine transform may be
parameter dpar[0]=%e. The sine transform may be unsuitable for
parameter dpar[0]=%e. The staggered cosine transform may be
parameter dpar[0]=%e. The staggered sine transform may be
parameter number %4i had an illegal value
parameter spar[0]=%e. The sine transform may be unsuitable for
parameter spar[0]=%e. The staggered cosine transform may be
parameter spar[0]=%e. The staggered sine transform may be
params
params->airAbsorption[iBand
params->bakeBatchSize
params->bakeFlags
params->binaural
params->delay
params->direction.x
params->direction.y
params->direction.z
params->directivity
params->distanceAttenuation
params->eqCoeffs[iBand
params->eq[iBand
params->flags
params->height
params->hrtf
params->identifier.endpointInfluence.center.x
params->identifier.endpointInfluence.center.y
params->identifier.endpointInfluence.center.z
params->identifier.endpointInfluence.radius
params->identifier.type
params->identifier.variation
params->interpolation
params->ir
params->irSize
params->irradianceMinDistance
params->listener.ahead.x
params->listener.ahead.y
params->listener.ahead.z
params->listener.origin.x
params->listener.origin.y
params->listener.origin.z
params->listener.right.x
params->listener.right.y
params->listener.right.z
params->listener.up.x
params->listener.up.y
params->listener.up.z
params->numBounces
params->numChannels
params->numDiffuseSamples
params->numRays
params->numSamples
params->numThreads
params->occlusion
params->openCLDevice
params->order
params->orientation.ahead.x
params->orientation.ahead.y
params->orientation.ahead.z
params->orientation.origin.x
params->orientation.origin.y
params->orientation.origin.z
params->orientation.right.x
params->orientation.right.y
params->orientation.right.z
params->orientation.up.x
params->orientation.up.y
params->orientation.up.z
params->pathRange
params->probeBatch
params->radeonRaysDevice
params->radius
params->rayBatchSize
params->reverbTimes[iBand
params->savedDuration
params->scene
params->sceneType
params->shCoeffs[iCoeff
params->simulatedDuration
params->spacing
params->spatialBlend
params->tanDevice
params->tanSlot
params->threshold
params->transform.elements[iRow][iColumn
params->transmissionType
params->transmission[iBand
params->type
params->visRange
pardiso_read_ooc_file: Fseek error
pardiso_read_ooc_file: Read error
pardiso_write_ooc_file: Write error
pardiso_write_ooc_file: nfirst is EOF
pascal
patch.ring[0].hasValidPositions
patch.ring[1].hasValidPositions
patch.ring[2].hasValidPositions
patch.ring[3].hasValidPositions
patchIndex < numPrimitives
patch[0].verify
patch[1].verify
patch[2].verify
patch[3].verify
patch[i].ring[0].hasValidPositions
patch[i].ring[1].hasValidPositions
patch[i].ring[2].hasValidPositions
patch[ip1].ring[3].hasValidPositions
paλ-h
pbndkb
pb{>m
pc=i9
pclmul
pconfig
pd$0UD
pd^=R
pdata
pe##4* out_array, uint numElems, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    shmem[localId] = v1.x + v1.y + v1.z + v1.w + v2.x + v2.y + v2.z + v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    type offset = shmem[localId];\\ \n    type t = v1.x; v1.x = offset; offset += t;\\ \n    t = v1.y; v1.y = offset; offset += t;\\ \n    t = v1.z; v1.z = offset; offset += t;\\ \n    t = v1.w; v1.w = offset; offset += t;\\ \n    t = v2.x; v2.x = offset; offset += t;\\ \n    t = v2.y; v2.y = offset; offset += t;\\ \n    t = v2.z; v2.z = offset; offset += t;\\ \n    v2.w = offset;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_PART_4(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_part_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __global type* out_sums, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupId   = get_group_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\\ \n    v2.w += v1.w;\\ \n    shmem[localId] = v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    type sum = group_scan_exclusive_part_##type(localId, groupSize, shmem);\\ \n    if (localId == 0) out_sums[groupId] = sum;\\ \n    v2.w = shmem[localId];\\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_GROUP_REDUCE(type)\\ \n    void group_reduce_##type(int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n#define DEFINE_DISTRIBUTE_PART_SUM_4(type)\\ \n    __kernel void distribute_part_sum_##type##4( __global type* in_sums, __global type##4* inout_array, uint numElems)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int groupId   = get_group_id(0);\\ \n    type##4 v1 = safe_load_##type##4(inout_array, globalId, numElems);\\ \n    type    sum = in_sums[groupId >> 1];\\ \n    v1.xyzw += sum;\\ \n    safe_store_##type##4(v1, inout_array, globalId, numElems);\\ \n} \n \n \n// These are already defined in Apple OCL runtime \n#ifndef APPLE \nDEFINE_MAKE_4(int) \nDEFINE_MAKE_4(float) \n#endif \n \nDEFINE_SAFE_LOAD_4(int) \nDEFINE_SAFE_LOAD_4(float) \n \nDEFINE_SAFE_STORE_4(int) \nDEFINE_SAFE_STORE_4(float) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE(uint) \nDEFINE_GROUP_SCAN_EXCLUSIVE(float) \nDEFINE_GROUP_SCAN_EXCLUSIVE(short) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_SUM(uint) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(float) \n \nDEFINE_SCAN_EXCLUSIVE(int) \nDEFINE_SCAN_EXCLUSIVE(float) \n \nDEFINE_SCAN_EXCLUSIVE_4(int) \nDEFINE_SCAN_EXCLUSIVE_4(float) \n \nDEFINE_SCAN_EXCLUSIVE_PART_4(int) \nDEFINE_SCAN_EXCLU
pej;0
performance impact. Please enable these modes for each application
permission denied
pf:6K
pf<^n
pffffff
pgL:vt
pg\n?pg\n
pgݻDv
ph:t4-;c
phonon.dll
phonon_itest.exe
phonon_perf.exe
phonon_test.exe
pinfo1.size() == numPrimitives
piٻCb\t
pk9e\\V
pk;{ZR
pl$pUD
pl':U!y:JW
placement delete closure
placement delete[] closure
pmg;xz?9}\a
pn9II0:SfR9Z
pn<dó<H
pn>6ނB
poh=qO
popcnt
portuguese-brazilian
pp9* \n
pp;0E
pr china
pr-china
preSplitItem0[center].data >= 1.0f
preSplitItem0[i].data <= MAX_PRESPLITS_PER_PRIMITIVE
prefetchi
preordering failed (matrix types 11, 13 only
presplits
prev_half_edge_ofs != 0
previous iteration. The solution may be wrong
prim.geomID() & SPLITS_MASK) == 0
prim.lower[dim] <= fsplit && prim.upper[dim] >= fsplit
primID
primitives
priority >= 0.0f && priority < FLT_LARGE
probe.center.x
probe.center.y
probe.center.z
probe.radius
probeArray
probeBatch
probeIndex
problems with opening OOC temporary files
profilerContext
program name unknown
progress monitor forced termination
protocol error
protocol not supported
pt$`DA
pt$pUD
ptr64
ptwrite
pu DfA
puPDfA
puerto-rico
pv<gX
pw8;;\v
pw<dqs
pz9<\nT
pz<\ta
p{h2Һi
p}@UfA
pġz\\L7
pƻ8XN
pǄ:5j
p˔;yS
pͼ#BмKg\b
pΥ<03
pф;e6M
pӅ=T\nM
pԉD$ H
pԡ9j3
pؼWl9
q bR%H6
q!:F A:3
q!; s7
q!H  źY
q!I0 H
q!I` H
q!L$0
q!L$P0H
q!L$p
q!P8 H
q!P8 I
q!\f8
q!\f9
q!\f\n0ăQ
q!\f\n0ăY
q!\f\t0ăQ
q!\f\t0ăY
q!`8 I
q!c;BF
q!x8 H
q!x8 I
q#>;Wqc
q'h96
q)9wa
q*;0X
q+:3MyX+z8
q+۽Rzt
q0Ȼi(j
q1<k\r
q2';m26:D2J
q35;bK
q3h;r
q5-;fW
q8,PF
q8\aX
q8ŒXa
q9:w8;;Q
q9<l'\r
q9d>W9
q:5Cߺ\ewt
q:9I\t;8V
q:Rj\r;Gt5
q:Y\f
q:d/κQsW
q;0Tz
q;39\a
q;R>b
q;Tl\f
q;WkE
q;h1v
q;i\eP
q<TJ"=k4
q=.Ca
q=Ҳ9>BF
q?V<b
qB9/^o
qB>kjg
qBǻtOA
qCm=>\av
qGL="l~=M\f3
qGS9w?z
qH=}c
qHH;s0r
qJ;\e
qJ<W%A
qJL$Pp
qJL$`p
qJT$0
qJT$P
qJT$PP
qJT$`P
qJ|$ p
qMX:Jj
qP:eAлz
qQQ:*5ʺa
qRG;Q
qS>g?h3
qTŊ\\I4
qTŢ\\I4
qU~;e
qW$;\eJg
qX=˱j
qX\a;Zu
qZ:aߺ9m
qZ;"9M;l
q[ݹWvɺa
q\a;Le
q\b7;(wV
q\b;6RֺF
q\b;j
q\bL+1H
q\bba~\b
q\e\e
q\nba|H
q\rչt
q\t;e7r
q\t\a=Ezz
q\tba~\b
q\vba~\b
q`k:c
qb!}Hp$ٱbA
qbvh4.quad4i
qbvh4.triangle4i
qbvh8.quad4i
qbvh8.triangle4
qbvh8.triangle4i
qbڻŤl9
qe-<L}g
qeB<FAE
qffff
qg<s%w
qgY=EG
qgw=(\a\t
qiT;B
qiX:S
qj/9;E
qj:axY9l
qjļDw
qot:׀X
qp2:R
qt5<-r
quad4i
quad4v
quad_accel
quad_accel_mb
quad_builder
quad_builder_mb
quad_traverser
quad_traverser_mb
quads
quality
quantizedNodes
quz-BO
quz-EC
quz-PE
quz-bo
quz-ec
quz-pe
qw+=k5R
qxs?qxs
qxs?qxs?qxs?qxs?qxs?qxs
qyb:O2
q{3摻T
qƷ;coM
qǺu!w
qȽJ30
qںOKm:t
r %:Aj
r &\r%Im
r";Xb
r#=lRr
r$>9L
r%:y6
r&fR{a
r'<Ms
r'=dB
r'X9|b
r'j=Zf
r(H=ja
r(T;Fh
r)7<'H9
r);DBX
r*:v5
r+w2L
r,2:n
r.'>Xft
r.9pR\n
r.begin() == 0
r.end() == 1
r.size() == 1
r/d=rH
r0;sƐ9
r0\fP
r0\fp\v`\n
r130801120000Z
r1;D t
r1<%h
r1ֺB :9
r210429000000Z
r220801000000Z
r241012000000Z
r250507000000Z
r250604000000Z
r250728210739Z0
r271008235959Z0a1\v0\t
r2:bO
r2<u4һq
r2=Iz
r311109235959Z0b1\v0\t
r360428235959Z0i1\v0\t
r360903235959Z0c1\v0\t
r380114235959Z0i1\v0\t
r380115120000Z0b1\v0\t
r3>l`ݽK
r3Ӽ_t
r42:n2F
r5:D/z
r5:zp58z\ff
r6ƻ\t\nĻD
r6ǼHY
r7;&v
r7<}ZԼ}8j
r8,;5
r8\\=rd
r8\v:WO
r8q:Q
r9=)K\v
r9=gD2
r9>Hߺ5
r9IT\v
r9N8y9
r9Rǳ:y
r9mpe;Dk":\b
r9obֺޟm
r9z6;\tQg
r:%h4
r:'X̻yn
r:,Ul
r:Q\a89
r:S(ڻlq
r:Yoa
r:\f;L94
r:eSĺ A
r:gom:fp
r;0 h
r;0=MIA
r;81\t=\t
r;9>\t:R6
r;9D2
r;9Tr
r;:CQ
r;;bIE
r;;쇻05r
r;A\vx;w2
r;C"7
r;E%4
r;FG{8
r;GHM
r;I,w:GoQ:W
r;K%n9
r;N2<v
r;Q\e@9
r;XE]:N
r;\n9V
r;`kD
r;`sD
r;d$c
r;d|d
r;pBL
r;q=t:0s
r;q>Q
r;usb;_i
r;wH@<m
r<25A
r<2wg
r<FO.<X
r<T9a
r<Z^6
r<dKļGB
r<v;f
r="rD=bx
r='DN
r=2uz
r=;3Kh
r=O>m
r=\tSD>\t
r=kB\e
r=on5=D
r=u8\b
r>3;caN
r><7ag
r>KQA>x
r>P\n
r>Rq=>2
r>\fB
r>e4F
r>e\n
r?fQ3
r?ѻTS
r@0:WI
rB;ިL
rB\t0\bp\a
rB\v;v
rC<RE
rCCޱb#UCC
rE\b=6yM
rF 9d
rFV:J
rH :P
rH6;3
rH;~r
rHR=w
rH\e;!A
rHź\\Bp
rJ;\e\n
rK<ldC
rLc]lI
rLg<qr
rM?\t7\a
rMI+\nN
rMe;u
rM»\f"W
rN*;D
rO@brMH
rO|:wv
rPܺr嬻y
rR\\;eV
rSಸCd9
rT%>2
rT1<3e
rUC:ºf;a
rW;(F
rX"<6
rX6:;z
rX;pf
rX<)E
rX[;X
rXy`łY
rXypŚXyt
rXϻ(\nF
rY;\tbC
rY<}S
rY>P/1
rYI<\bK
rYL<\fXC
rZ2;nvܺt
rZ8>\v
rZ98r
rZ>"n
rZ\a<Yeûk
rZk;\fj
r[k8B
r\\l$ ŲYM
r\\y4łY
r\a(:Kb
r\abbmH
r\b<5
r\b<gAt
r\bSA|X=G
r\b\a>4hl
r\bb"e@6
r\bbA
r\bba|\b
r\bba~\b
r\br><A
r\e\f
r\ebA|\b
r\f;[w6
r\f<(DF
r\fbA
r\fl<\tFU
r\n$;T4t8
r\n0\tP\bp\a
r\n;r@5
r\n<\eqǻm0
r\r:NB
r\rbA
r\t9,g0
r\tVr.>T
r\ta<1G
r\ta<؆e
r\tbA
r\tba
r\tba|\b
r\v0\np\t`\b
r\vba|H
r\vw<?hG
r`\f0\vP
r`\fP
r`\fP!5
r`\fP!i
r`\fP\v0
r`j9ϹI
rae:m2R;B
range.size() == 1
range.size() > 1
ranspose
raoint
ray.tnear() >= 0.0f
ray.valid
raymasks
rb!4@Yt
rb!\f@Yt
rb,9J
rbA|H
rbQ|H
rb\t0\bp\a
rba$@X
rba~\b
rcalculating laplacian: %.2f
rcp(min_rcp_input)*FLT_LARGE+FLT_LARGE < 0.01f*FLT_MAX
rdata
rdata$T
rdata$r
rdata$voltmd
rdata$zzzdbg
rdseed
re;0w8
reU>\v
read from files: %10.3f Mb
read from files: %d
read from files: %lli
read only file system
read-write problems with the OOC data file
real (including 1 factor): %d
reconstruct
reconstructImpulseResponse
reconstructor
reloc
remove
removeData
removeProbe
removeProbeBatch
reorder
reordering problem
residual stopping test and the stopping test for the maximal number of
resource deadlock would occur
resource unavailable try again
restrict
result
result out of range
result.center.x
result.center.y
result.center.z
result.radius
result.x
result.y
result.z
resulting from this problem
retain_uncompressed_reverb
reverbTimes
reverb_min_absorptive_gain
rf;2Py
rfJBGo
rfffff
rg<<e
rh.;s
rh\t;<Q
ri/=q
ri4<wb
riP<d3
right.bounds().empty
rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, isect->uvwt.w); \n \n        if (leftleaf) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node.lbound), r, isect); \n        } \n \n        if (rightleaf) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node.rbound), r, isect); \n        } \n \n        if (lefthit > 0.f && righthit > 0.f) \n        { \n            int deferred = -1; \n            if (lefthit > righthit) \n            { \n                idx = (int)node.rbound.pmax.w; \n                deferred = (int)node.lbound.pmax.w;; \n            } \n            else \n            { \n                idx = (int)node.lbound.pmax.w; \n                deferred = (int)node.rbound.pmax.w; \n            } \n \n                    *sptr++ = deferred; \n            continue; \n        } \n        else if (lefthit > 0) \n        { \n            idx = (int)node.lbound.pmax.w; \n            continue; \n        } \n        else if (righthit > 0) \n        { \n            idx = (int)node.rbound.pmax.w; \n            continue; \n        } \n \n                idx = *--sptr; \n    } \n \n    return isect->shapeid >= 0; \n} \n#endif \n \n#ifndef GLOBAL_STACK \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    if (r->o.w < 0.f) \n        return false; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            leftleaf = LEAFNODE(node.lbound); \n            rightleaf = LEAFNODE(node.rbound); \n \n            lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, r->o.w); \n            righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, r->o.w); \n \n            if (leftleaf) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node.lbound), r)) \n                                    return true; \n            } \n \n            if (rightleaf) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node.rbound), r)) \n                                return true; \n            } \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = (int)node.rbound.pmax.w; \n                    deferred = (int)node.lbound.pmax.w;; \n \n                } \n                else \n                { \n                    idx = (int)node.lbound.pmax.w; \n                    deferred = (int)node.rbound.pmax.w; \n                } \n \n                if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                { \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        gsptr[i] = ldsstack[i * 64]; \n                    } \n \n                    gsptr += SHORT_STACK_SIZE; \n                    lsptr = ldsstack + 64; \n                } \n \n                *lsptr = deferred; \n                lsptr += 64; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = (int)node.lbound.pmax.w; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = (int)node.rbound.pmax.w; \n                continue; \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n
rj$:o\b
rj9=Q
rjQ9u3
rk9Bi
rk<<p
rkV<M
rk_;bt
rl7=V
rlԻDJ
rm;8m^9
rmarking potentially diffracting voxels: %.2f
ro:?f
ro:xPG
roU;i
robust
round_bezier_curve
round_bspline_curve
round_catmull_rom_curve
round_hermite_curve
round_linear_curve
roup_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n} \n \n__kernel void compact_int_1(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output, \n    __global int* out_size) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_group_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n \n    if (global_id == 0) \n    { \n        *out_size = in_address[in_size - 1] + in_predicate[in_size - 1]; \n    } \n} \n \n__kernel void copy(__global int4* in_input, \n    uint  in_size, \n    __global int4* out_output) \n{ \n    int global_id = get_global_id(0); \n    int4 value = safe_load_int4(in_input, global_id, in_size); \n    safe_store_int4(value, out_output, global_id, in_size); \n} \n \n \n#define FLAG(x) (flags[(x)] & 0x1) \n#define FLAG_COMBINED(x) (flags[(x)]) \n#define FLAG_ORIG(x) ((flags[(x)] >> 1) & 0x1) \n \nvoid group_segmented_scan_exclusive_int( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2
routine to work by setting IPAR(7)=0 before the call to this routine
routine to work by setting ipar[6]=0 before the call to this routine
routine was not called. Computations have stopped. The result may be incorrect
routine, or DFGMRES_CHECK routine was not called. The solution may be wrong
routine, or the user had to stop FGMRES method because it had converged
routine, or the wrong values were assigned to parameters 'ap' and 'bp
routine, or the wrong values were assigned to parameters 'at' and 'bt
routine, or the wrong values were assigned to parameters 'ax' and 'bx
routine, or the wrong values were assigned to parameters 'ay' and 'by
routine, or the wrong values were assigned to parameters 'az' and 'bz
routine, or the wrong values were assigned to the parameters 'ap' and 'bp
routine, or the wrong values were assigned to the parameters 'at' and 'bt
routine, or the wrong values were assigned to the parameters 'ax' and 'bx
routine, or the wrong values were assigned to the parameters 'ay' and 'by
routine, or the wrong values were assigned to the parameters 'az' and 'bz
rp;Kv
rp;bB
rp\f0!1
rp\f0!7
rp\f0\vP
rp\f0\vP!.\b
rp\f0\vP!\b
rp\f0\vP!k
rp\f0\vP!t
rp\f`\v0
rp\f`\v0\nP
rp\f`\vP
rp\f`\vP\n0
rpb<2
rq<NuW
rqp:J
rr:K\r\v
rrA<l
rs\b:B^B;c
rset.ext_end() + left_ext_range_size == set.ext_end
rset.geomBounds.empty() && area(rset.geomBounds) >= 0.0f
rsrc$01
rsrc$02
rt8lS
rt<1k
rtc$IAA
rtc$IZZ
rtc$TAA
rtc$TZZ
rtcIntersect and rtcOccluded not enabled
rtcIntersect16 and rtcOccluded16 not enabled
rtcIntersect4 and rtcOccluded4 not enabled
rtcIntersect8 and rtcOccluded8 not enabled
rtcIntersectN and rtcOccludedN not enabled
ru6:2
rv;Ovg
rw*<y\a
rw5<Rh
rx<]Im
rxt:3
ry \rG
ry6rcI
ry=4Ы=\b7
r}R9N,N
rġzo|0
rġzo|8
rġzo|\b
rĢy!D
rĢy!D2
rĢy#D
rĢy#D0
rĢy#D8
rĢy#D\b
rǼExd
rȺd#4
rȻhf\r
rɋL$PH
rː;Nu
r̻de8;L9\n;U
r̻hiK
rЯ:G8s
rҺEe0
rԼYvI=\f
rػfK\f
rںmY`:ry
rڻX1ĹQ
rݻXt9
rݼ+QӼHh
rދD$0f
rߺF)0
rᇺJ2};S
r辽ICA
r깺\bn
r엺o\b5<\e 8
rY4t
s ;Pr/;G
s WATAUAVAWH
s WAVAWH
s build %s for %s %s
s double precision computation is turned ON
s single precision computation is turned ON
s!< N
s$W<M\b
s%9"Ue
s%O:bLE
s'b;sy
s(D+s0
s)3:l
s,fffff
s0;;O
s0C;yd
s1;ʭ0
s3:?L
s59=p}Խm
s5Ic\aH
s5fE9
s5ͼ\vpi
s6}:g
s6߹PtG
s82٫9v
s: Unsupported HRTF data format version: %d
s: invalid %s: %s = %s
s: solving a Hermitian indefinite system
s: solving a Hermitian positive definite system
s: solving a complex nonsymmetric system
s: solving a complex structurally symmetric system
s: solving a complex symmetric system
s: solving a real nonsymmetric system
s: solving a real structurally symmetric system
s: solving a symmetric indefinite system
s: solving a symmetric positive definite system
s:0xS
s:DYa9
s:Ja)<K
s:qn\r
s:s梺t7
s;3!G
s;7dE
s;8|p
s;^o6
s;rYO<4
s;t\v
s;whk
s<MBs
s<\tk
s<fff
s<pD[<l
s<yln
s<zde
s>P=6z
s>\bE
s@=aa0
s@L;f0r
sBȻQ8
sEӺHMM
sFȺi0
sFҺ\a
sFں2f
sI"9_R\n
sI:59
sI\e;t1
sJ:v6
sJt<9\n
sK:&r
sL:rq
sL;20~<d
sLݺmvH
sM:\e\t
sN:\e
sP=Ywżi+J
sRA; J
sT`>y1
sUN;y
sV< Mp
sVL9F\b
sV\t<Ax㻞j
sXX:*q
sZֻVt
s\a;1i
s\a<Xy
s\bH+t$hH
s\eֺn
s\fbq|H
s\n;E
s\nF;R5
s\t>9
s\v8>\t4
s\v@9
s\vD88w
s\vHcҋD
s\v\r=L
s\vba|H
s_<d2
s_forward_trig_transform/s_backward_trig_transform routine
s`3;Y
sa_<z
sah_fast_spatial
sah_presplit
saveOBJ
sc\r;rά;a
scalar deleting destructor
scaleAccum
scan_exclusive_int4
scan_exclusive_part_int4
scene not committed
scene_flags
scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n
segments
selected scene intersector
sequential
serializedObject
set to default value (%i
set.end()+numExtElements<=set.ext_end
set.ext_range_size() > 0
set.has_ext_range
set.size() > 0
set.size() > 1
setInputs
setProfilerContext
setScene
setSharedInputs
set_affinity
settings
settings->anyHitCallback
settings->closestHitCallback
settings->data
settings->duration
settings->embreeDevice
settings->flags
settings->fractionCUsForIRUpdate
settings->frameSize
settings->freeCallback
settings->irSize
settings->materialIndices
settings->materialIndices[iTriangle
settings->materials
settings->materials[iMaterial].absorption[iBand
settings->materials[iMaterial].scattering
settings->materials[iMaterial].transmission[iBand
settings->maxDuration
settings->maxNumOcclusionSamples
settings->maxNumRays
settings->maxNumSources
settings->maxOrder
settings->maxSources
settings->numCUsToReserve
settings->numDiffuseSamples
settings->numMaterials
settings->numThreads
settings->numTriangles
settings->numVertices
settings->numVisSamples
settings->openCLDevice
settings->order
settings->radeonRaysDevice
settings->rayBatchSize
settings->reflectionType
settings->requiresTAN
settings->samplingRate
settings->sceneType
settings->simdLevel
settings->subScene
settings->tanDevice
settings->transform.elements[iRow][iColumn
settings->triangles
settings->triangles[iTriangle].indices[iTriangleVertex
settings->type
settings->vertices
settings->vertices[iVertex].x
settings->vertices[iVertex].y
settings->vertices[iVertex].z
sf\n>Y0
sffffff
sfree <= end-begin
sg@;m
sh9w3I
sha512
shadeAndBounce
shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n#define LDS_BUG \n \n#ifdef LDS_BUG \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    int stack[STACK_SIZE]; \n    int* ptr = stack; \n \n    *ptr++ = -1; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        if (LEAFNODE(node)) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node), r, isect); \n        } \n        else \n        { \n            lbox = scenedata->bounds[node.left]; \n            rbox = scenedata->bounds[node.right]; \n \n            lefthit = IntersectBoxF(r, invdir, lbox, isect->uvwt.w); \n            righthit = IntersectBoxF(r, invdir, rbox, isect->uvwt.w); \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = node.right; \n                    deferred = node.left; \n                } \n                else \n                { \n                    idx = node.left; \n                    deferred = node.right; \n                } \n \n                *ptr++ = deferred; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = node.left; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = node.right; \n                continue; \n            } \n        } \n \n        idx = *--ptr; \n    } \n \n \n    return isect->shapeid >= 0; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r) \n{ \n    //return false; \n \n    const float3 invdir = native_recip(r->d.xyz); \n \n    //if (get_global_id(0) == 0) \n    //{ \n \n    //} \n \n    int stack[STACK_SIZE]; \n    int* ptr = stack; \n \n    *ptr++ = -1; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    bool hit = false; \n \n    int step = 0; \n    //if (get_global_id(0) == 1) \n        //printf("Starting %d\\n", get_global_id(0) ); \n    while (idx > -1) \n    { \n        //printf("%d", get_global_id(0)); \n        step++; \n        //if (get_global_id(0) == 1) \n        //{ \n            //printf("Node %d %d\\n", idx, step ); \n        //} \n \n        if (step > 10000) \n            return false; \n \n        node = scenedata->nodes[idx]; \n \n        if (LEAFNODE(node)) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node), r)) \n            { \n                hit = true; \n                break; \n            } \n        } \n        else \n        { \n            lbox = scenedata->bounds[node.left]; \n            rbox = scenedata->bounds[node.right]; \n \n            lefthit = IntersectBoxF(r, invdir, lbox, r->o.w); \n            righthit = IntersectBoxF(r, invdir, rbox, r->o.w); \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = node.right; \n                    deferred = node.left; \n                } \n                else \n                { \n                    idx = node.left; \n                    deferred = node.right; \n                } \n \n                *ptr++ = deferred; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = node.left; \n
shared
sharedInputs
sharedInputs->duration
sharedInputs->irradianceMinDistance
sharedInputs->listener.ahead.x
sharedInputs->listener.ahead.y
sharedInputs->listener.ahead.z
sharedInputs->listener.origin.x
sharedInputs->listener.origin.y
sharedInputs->listener.origin.z
sharedInputs->listener.right.x
sharedInputs->listener.right.y
sharedInputs->listener.right.z
sharedInputs->listener.up.x
sharedInputs->listener.up.y
sharedInputs->listener.up.z
sharedInputs->numBounces
sharedInputs->numRays
sharedInputs->order
should be a positive integer. Parameter was probably altered by mistake
should be a positive integer. The parameter was probably altered by mistake
should be an even number. Assign a proper value to parameter 'np
should be an even number. Assign a proper value to parameter 'nt
should be an even number. Assign a proper value to parameter 'nx
should be an even number. Assign a proper value to the parameter 'np
should be an even number. Assign a proper value to the parameter 'nt
should be an even number. Assign a proper value to the parameter 'nx
should be divisible by 4. Assign a proper value to parameter 'nx
should be divisible by 4. Assign a proper value to the parameter 'nx
should be positive. Parameter was probably altered by mistake outside of the
should be positive. The parameter was probably altered by mistake outside of the
should not be equal to 0.0. The FGMRES method may fail to converge
si)<ZO
simd128
simd256
simd512
similarityScale == 0.f
similarityScale == 1.f
similtude && similarityScale > 0) || !similtude
simulator
size <= PrecomputedBSplineBasis::N
size <= PrecomputedBezierBasis::N
size <= PrecomputedCatmullRomBasis::N
size of largest supernode:               %d
size of largest supernode:               %lli
size() == 4
size_active == 0
size_alloced == 0
size_t)&data[0]) & (maxAlignment-1)) == 0
size_t)in) & 0xF) == 0
size_t)node & align_mask
size_t)ptr & align_mask
size_t)this % 64) == 0
size_t)tri & align_mask
si¼|0\r
siںGC
sl;܀F
slot < slots
slotMask
slovak
sma-NO
sma-SE
sma-no
sma-se
smj-NO
smj-SE
smj-no
smj-se
smn-FI
smn-fi
sms-FI
sms-fi
sn$:p
solve - write&read: %d
solve - write&read: %lli
something wrong with diagonal matrix row %d
something wrong with diagonal matrix row %lli
source
source.ahead.x
source.ahead.y
source.ahead.z
source.origin.x
source.origin.y
source.origin.z
source.right.x
source.right.y
source.right.z
source.up.x
source.up.y
source.up.z
source.x
source.y
source.z
sourcePosition.x
sourcePosition.y
sourcePosition.z
south africa
south korea
south-africa
south-korea
spW;w
spaceAvailable
spanish-argentina
spanish-bolivia
spanish-chile
spanish-colombia
spanish-costa rica
spanish-dominican republic
spanish-ecuador
spanish-el salvador
spanish-guatemala
spanish-honduras
spanish-mexican
spanish-modern
spanish-nicaragua
spanish-panama
spanish-paraguay
spanish-peru
spanish-puerto rico
spanish-uruguay
spanish-venezuela
sphere
sphereOcclusion
spherical
splitprims > 0 && splitprims <= MAX_PRESPLITS_PER_PRIMITIVE
splitprims >= 1 && splitprims <= MAX_PRESPLITS_PER_PRIMITIVE
sponse[(batch * numChannels * numBands * numSamples) + (channel * numBands * numSamples) + (band * numSamples)];\n\n\tfloat xm1 = 0.0f;\n\tfloat xm2 = 0.0f;\n\tfloat ym1 = 0.0f;\n\tfloat ym2 = 0.0f;\n\n    global IIR* filter = &filters[band];\n\n    float a1 = filter->a1;\n    float a2 = filter->a2;\n    float b0 = filter->b0;\n    float b1 = filter->b1;\n    float b2 = filter->b2;\n\n\tfor (uint i = 0; i < (numBins * samplesPerBin); i += NUM_WORK_ITEM_SAMPLES)\n    {\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tworkItemSamples[j] = signal[i + j];\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tfloat x = workItemSamples[j];\n\t\t\tfloat y = (b0 * x) + (b1 * xm1) + (b2 * xm2) - (a1 * ym1) - (a2 * ym2);\n\n\t\t\txm2 = xm1;\n\t\t\txm1 = x;\n\t\t\tym2 = ym1;\n\t\t\tym1 = y;\n\n\t\t\tworkItemSamples[j] = y;\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tsignal[i + j] = workItemSamples[j];\n\t\t}\n    }\n}\n\n// todo: linear reconstruction?\nkernel void reconstructImpulseResponse(global int* energy,\n\t\t\t\t\t\t\t\t\t   uint samplingRate,\n                                       uint samplesPerBin,\n\t\t\t\t\t\t\t\t\t   uint numSamples,\n\t\t\t\t\t\t\t\t\t   global float* airAbsorption,\n\t\t\t\t\t\t\t\t\t   global IIR* filters,\n                                       global float* whiteNoise,\n                                       global float* impulseResponse,\n                                       uint offset,\n\t\t\t\t\t\t\t\t\t   float scale)\n{\n    size_t bin = get_global_id(0);\n    size_t band = get_global_id(1);\n    size_t channel = get_global_id(2);\n\tsize_t numBins = get_global_size(0);\n    size_t numBands = get_global_size(1);\n    size_t numChannels = get_global_size(2);\n\n    global float* impulseResponseBin = &impulseResponse[offset + (channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n    global float* whiteNoiseBin = &whiteNoise[(channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n\n    float e0 = (float)energy[0*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n    float e = (float)energy[channel*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n\n    if (fabs(e) < ENERGY_THRESHOLD || fabs(e0) < ENERGY_THRESHOLD)\n    {\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = 0.0f;\n        }\n    }\n    else\n    {\n        float tMean = ((bin + 0.5f) * samplesPerBin) / samplingRate;\n        float tVariance = MIN_VARIANCE;\n\n        int sample = bin * samplesPerBin;\n        float binEnergy = 0.0f;\n\n        float t = sample / (float) samplingRate;\n        float dt = 1.0f / (float) samplingRate;\n\n        float g = exp(-((t - tMean) * (t - tMean)) / (2.0f * tVariance));\n        float dg = exp(-(dt * ((2.0f * (t - tMean)) + dt)) / (2.0f * tVariance));\n        float ddg = exp(-(dt * dt) / tVariance);\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = g * whiteNoiseBin[i];\n            binEnergy += impulseResponseBin[i] * impulseResponseBin[i];\n            g *= dg;\n            dg *= ddg;\n        }\n\n        float normalization = e / sqrt(e0 * sqrt(4.0f * PI));\n\n        normalization *= exp(-0.5f * airAbsorption[band] * SPEED_OF_SOUND * ((bin + 0.5f) * samplesPerBin * (1.0f / samplingRate)));\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] *= normalization;\n        }\n    }\n}\n\nkernel void combineBandpassedImpulseResponse(uint numSamples,\n                                             global float* bandImpulseResponses,\n\t\t\t\t\t\t\t\t\t\t\t global float* impulseResponse)\n{\n    size_t sample = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t batch = get_global_id(2);\n\tsize_t numChannels = get_global_size(1);\n\n\tfloat value = 0.0f;\n\n    for (int i = 0; i < NUM_BANDS; ++i)\n    {\n        value += bandImpulseResponses[(batch * numChannels * NUM_BANDS * numSamples) + (channel * NUM_BAND
sptr < stack_size
sptr_node < stackEnd
sptr_node == stack_node
sptr_node > stack_node
sr-BA-Cyrl
sr-BA-Latn
sr-SP-Cyrl
sr-SP-Latn
sr-ba-cyrl
sr-ba-latn
sr-sp-cyrl
sr-sp-latn
src->data
src->data[iChannel][src->numSamples - 1
src->numChannels
src->numSamples
src[iArray
ssM+\nH
sse2::BVH
sse2::BVH4ColliderUserGeom
sse2::BVH4InstanceArrayIntersector1
sse2::BVH4InstanceArrayIntersector4Chunk
sse2::BVH4InstanceArrayMBIntersector1
sse2::BVH4InstanceArrayMBIntersector4Chunk
sse2::BVH4InstanceIntersector1
sse2::BVH4InstanceIntersector4Chunk
sse2::BVH4InstanceMBIntersector1
sse2::BVH4InstanceMBIntersector4Chunk
sse2::BVH4OBBVirtualCurveIntersector1
sse2::BVH4OBBVirtualCurveIntersector1MB
sse2::BVH4OBBVirtualCurveIntersector4Hybrid
sse2::BVH4OBBVirtualCurveIntersector4HybridMB
sse2::BVH4OBBVirtualCurveIntersectorRobust1
sse2::BVH4OBBVirtualCurveIntersectorRobust1MB
sse2::BVH4OBBVirtualCurveIntersectorRobust4Hybrid
sse2::BVH4OBBVirtualCurveIntersectorRobust4HybridMB
sse2::BVH4Quad4iIntersector1Moeller
sse2::BVH4Quad4iIntersector1Pluecker
sse2::BVH4Quad4iIntersector4HybridMoeller
sse2::BVH4Quad4iIntersector4HybridPluecker
sse2::BVH4Quad4iMBIntersector1Moeller
sse2::BVH4Quad4iMBIntersector1Pluecker
sse2::BVH4Quad4iMBIntersector4HybridMoeller
sse2::BVH4Quad4iMBIntersector4HybridPluecker
sse2::BVH4Quad4vIntersector1Moeller
sse2::BVH4Quad4vIntersector1Pluecker
sse2::BVH4Quad4vIntersector4HybridMoeller
sse2::BVH4Quad4vIntersector4HybridMoellerNoFilter
sse2::BVH4Quad4vIntersector4HybridPluecker
sse2::BVH4SubdivPatch1Intersector1
sse2::BVH4SubdivPatch1Intersector4
sse2::BVH4SubdivPatch1MBIntersector1
sse2::BVH4SubdivPatch1MBIntersector4
sse2::BVH4Triangle4Intersector1Moeller
sse2::BVH4Triangle4Intersector4HybridMoeller
sse2::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse2::BVH4Triangle4iIntersector1Moeller
sse2::BVH4Triangle4iIntersector1Pluecker
sse2::BVH4Triangle4iIntersector4HybridMoeller
sse2::BVH4Triangle4iIntersector4HybridPluecker
sse2::BVH4Triangle4iMBIntersector1Moeller
sse2::BVH4Triangle4iMBIntersector1Pluecker
sse2::BVH4Triangle4iMBIntersector4HybridMoeller
sse2::BVH4Triangle4iMBIntersector4HybridPluecker
sse2::BVH4Triangle4vIntersector1Pluecker
sse2::BVH4Triangle4vIntersector4HybridPluecker
sse2::BVH4Triangle4vMBIntersector1Moeller
sse2::BVH4Triangle4vMBIntersector1Pluecker
sse2::BVH4Triangle4vMBIntersector4HybridMoeller
sse2::BVH4Triangle4vMBIntersector4HybridPluecker
sse2::QBVH
sse2::QBVH4Quad4iIntersector1Pluecker
sse2::QBVH4Triangle4iIntersector1Pluecker
sse4.1
sse4.2
sse42::BVH4InstanceArrayIntersector1
sse42::BVH4InstanceArrayIntersector4Chunk
sse42::BVH4InstanceArrayMBIntersector1
sse42::BVH4InstanceArrayMBIntersector4Chunk
sse42::BVH4InstanceIntersector1
sse42::BVH4InstanceIntersector4Chunk
sse42::BVH4InstanceMBIntersector1
sse42::BVH4InstanceMBIntersector4Chunk
sse42::BVH4OBBVirtualCurveIntersector1
sse42::BVH4OBBVirtualCurveIntersector1MB
sse42::BVH4OBBVirtualCurveIntersector4Hybrid
sse42::BVH4OBBVirtualCurveIntersector4HybridMB
sse42::BVH4OBBVirtualCurveIntersectorRobust1
sse42::BVH4OBBVirtualCurveIntersectorRobust1MB
sse42::BVH4OBBVirtualCurveIntersectorRobust4Hybrid
sse42::BVH4OBBVirtualCurveIntersectorRobust4HybridMB
sse42::BVH4Quad4iIntersector1Moeller
sse42::BVH4Quad4iIntersector1Pluecker
sse42::BVH4Quad4iIntersector4HybridMoeller
sse42::BVH4Quad4iIntersector4HybridPluecker
sse42::BVH4Quad4iMBIntersector1Moeller
sse42::BVH4Quad4iMBIntersector1Pluecker
sse42::BVH4Quad4iMBIntersector4HybridMoeller
sse42::BVH4Quad4iMBIntersector4HybridPluecker
sse42::BVH4Quad4vIntersector1Moeller
sse42::BVH4Quad4vIntersector1Pluecker
sse42::BVH4Quad4vIntersector4HybridMoeller
sse42::BVH4Quad4vIntersector4HybridMoellerNoFilter
sse42::BVH4Quad4vIntersector4HybridPluecker
sse42::BVH4SubdivPatch1Intersector1
sse42::BVH4SubdivPatch1Intersector4
sse42::BVH4SubdivPatch1MBIntersector1
sse42::BVH4SubdivPatch1MBIntersector4
sse42::BVH4Triangle4Intersector1Moeller
sse42::BVH4Triangle4Intersector4HybridMoeller
sse42::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse42::BVH4Triangle4iIntersector1Moeller
sse42::BVH4Triangle4iIntersector1Pluecker
sse42::BVH4Triangle4iIntersector4HybridMoeller
sse42::BVH4Triangle4iIntersector4HybridPluecker
sse42::BVH4Triangle4iMBIntersector1Moeller
sse42::BVH4Triangle4iMBIntersector1Pluecker
sse42::BVH4Triangle4iMBIntersector4HybridMoeller
sse42::BVH4Triangle4iMBIntersector4HybridPluecker
sse42::BVH4Triangle4vIntersector1Pluecker
sse42::BVH4Triangle4vIntersector4HybridPluecker
sse42::BVH4Triangle4vMBIntersector1Moeller
sse42::BVH4Triangle4vMBIntersector1Pluecker
sse42::BVH4Triangle4vMBIntersector4HybridMoeller
sse42::BVH4Triangle4vMBIntersector4HybridPluecker
sse42::QBVH4Quad4iIntersector1Pluecker
sse42::QBVH4Triangle4iIntersector1Pluecker
sso;2b
st* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults  // Hit results \n    , __global int* stack \n    ) \n{ \n \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef GLOBAL_STACK  \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef GLOBAL_STACK  \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults   // Hit results \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef GLOBAL_STACK  \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny
st:PM
st\r<utK
stackPtr < stackEnd
stackSize < RTC_MAX_INSTANCE_LEVEL_COUNT
startTime has to be smaller or equal to the endTime
start_threads
state not recoverable
staticMesh
std::isfinite(b.lower.x
std::isfinite(b.lower.y
std::isfinite(b.lower.z
std::isfinite(b.upper.x
std::isfinite(b.upper.y
std::isfinite(b.upper.z
stdcall
stream buffer empty
stream end
stream error
stream timeout
stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \n__kernel void segmented_scan_exclusive_int_nocut(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_nocut_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n \n__kernel void segmented_distribute_part_sum_int( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    //inout_array[globalId
stride <= unsigned(inf
stride of normal buffers have to be identical for each time step
stride of normal derivative buffers have to be identical for each time step
stride of tangent buffers have to be identical for each time step
stride of vertex buffers have to be identical for each time step
string
string too long
strncat_s: dest is null
strncat_s: dest unterminated
strncat_s: dmax exceeds max
strncat_s: dmax is 0
strncat_s: not enough space for src
strncat_s: overlapping objects
strncat_s: slen exceeds max
strncat_s: src is null
strncpy_s: dest is null
strncpy_s: dmax exceeds max
strncpy_s: dmax is 0
strncpy_s: not enough space for src
strncpy_s: overlapping objects
strncpy_s: slen exceeds max
strncpy_s: slen is zero
strncpy_s: src is null
strnlen_s: dmax exceeds max
strnlen_s: dmax is 0
structure singular or input/parameter problem (matrixtype 11,13
stλ$oZ
subPatch < N
subPatch < patch->N
subPatch == 0
subTrees[subtrees] == ref
subdiv_accel
subdiv_accel_mb
subdivision surfaces
subdivpatch1
subdivs
subgrid
subtrees < MAX_NUM_SUB_TREES
success
sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; in_flags[globalId + i] == 0 && i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                inout_array[globalId + i] += sum; \n            } \n        } \n    } \n} \n \n__kernel void segmented_distribute_part_sum_int_nocut( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    bool stop = false; \n    //inout_array[globalId] += sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                if (in_flags[globalId + i] == 0) \n                { \n                    inout_array[globalId + i] += sum; \n                } \n                else \n                { \n                    if (stop) \n                    { \n                        break; \n                    } \n                    else \n                    { \n                        inout_array[globalId + i] += sum; \n                        stop = true; \n                    } \n                } \n            } \n        } \n    } \n} \n
supported
sused <= end-begin
sw@;E
swedish-finland
swidth < (2<<20) && sheight < (2<<20
swift_1
swift_2
switch_block_threshold <= maxBlocks
sy\v:6
symbolic (max): %d symbolic (permanent): %d
syr-SY
syr-sy
s|@9l
sºJlֺM
s»;6P
sǙ=di
s͛=Ei
sϺu`M9
sݹsQM
s移\erH
s躭\te
t $;c
t ]9p
t!+V\bH
t!1;zP
t!:6C
t!Hc\vH
t" fC
t#B;o
t#k:M
t$ ATAUAVAWE3
t$ ATAVAWH
t$ AUAVAWH
t$ AVH
t$ AWH
t$ H;t$\b
t$ H;yxr
t$ L;p\b
t$ L;r\b
t$ L;sxr
t$ L;t$\b
t$ L;{xr
t$ Lc
t$ N;t
t$ UATAUAVAWH
t$ UWATAVAWH
t$ UWAUAVAWH
t$ UWAVH
t$ WATAUAVAW
t$ WATAUAVAWH
t$ WAVAWH
t$ ba|H
t$ fD
t$ w\tE
t$ ŰXT
t$ ŸT\r
t$(A2
t$(HcE
t$(M#f\bt
t$(ba|H
t$(t\vH
t$(w\tE
t$0H+t$pH
t$0I91
t$0I;p\b
t$0I;|6
t$0L;p\b
t$0N;t
t$0ba~\b
t$0fA
t$0fD
t$0fE
t$0fff
t$48_\bu?H
t$4ba~\b
t$4fff
t$8H;t$0
t$8I;p\b
t$8fff
t$8w\tE
t$@H;sxr
t$@fA
t$@fD
t$@fff
t$Dba~\b
t$Dw\tE
t$HA_A^A]A
t$HHct
t$HL9{0
t$Hffff
t$Lba
t$Lba~\b
t$O7:\a
t$PH;_xr
t$PH;p\b
t$PHǅp
t$PI;p\b
t$Pba~\b
t$PfA
t$PfD
t$PfH
t$Pfff
t$Vba~\b
t$XH;T
t$XIcmlC
t$Xba~\b
t$Xr[H
t$\bI+4$H
t$\bff
t$\ebA~\b
t$\fbq<HY
t$`fA
t$`fB
t$`fD
t$`fD9+t$I
t$`fE
t$`fff
t$`uQ
t$`v&Ncd
t$dba~\b
t$hMc9L
t$hr[H
t$ht\fH
t$lH;s
t$lL;s
t$lbb
t$pD;nD
t$pH;t$0
t$pL;{xr
t$pfD
t$pff
t$pfff
t$pu\bE1
t$x3\tD$HH
t$xE3
t$xHcOH
t$xba~\b
t$xt*3
t$xtPM
t$xu\a1
t$xuyH
t$|Hc
t%TvZ
t%fE9\bt
t&A88t
t&b;Ab
t'HcG
t'L;\raHK
t'j=2\fB
t'ѹm3
t(9Z\ae
t(:dIf
t(c<@_j9aE
t)IcV\bH
t)fffff
t* fC
t+;RU
t+\a\bd2\a\aWT
t+z:X
t,8J;t
t,fffff
t,ŔW\rxRt
t,ŜW\rp
t-Z;anJ
t-s;D
t.;bzZ
t.C<p
t.k:H9
t.ۺubL
t/̺Ttz
t099\t
t0<Yi
t0\bp\a
t0\e:R
t0t1.size() > 0.0f
t0t1i.empty
t1?"t1?"t1?"t1
t1p;ˣ\b
t2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    c
t2V<Ϛ0
t3 b1
t3<S-a
t3ҋ4%8
t3ܻA\a
t4;ExF
t4L;C\bt*L
t4N;V
t4\a*d3\a*42\a
t4\b%d3\b%42\b
t4\b*d3\b*42\b
t4\e;9V
t4z;@;k
t5ƺO/M
t6$:N
t6B<g
t6P=H\f
t6\a+d5\a+44\a
t6p7MOf
t7t9]9m
t7ݹIMj
t8<Q.I
t8=j&꼪o
t8=tD
t8B: \b
t8M<TTs
t8Tڿ:baK
t8\b*d7\b*46\b
t8d<xvt
t8r<G
t95:B
t98_2t
t9Cʈ8
t9Oa0
t9\v*d8\v*47\v
t9q x
t:!xC
t:1iV
t:3]T
t:B0\r
t:DkL
t:\at
t:_Li
t:c\a\e
t:dS\a9
t:lyY
t:o[4
t:uEZ
t;.9t9
t;8F|:G
t;8_2t
t;:ZM
t;A8\bt6
t;GR4;KKY
t;J479
t;O\av
t;TXQ9
t;\aJt
t;\e5f
t;\vw\n:sT\r
t;eAK
t;hR\f
t;ig4
t;pcl:V
t;qs\r
t;y8z
t;ܣɻGcA
t< >M
t<$6C
t<%fH
t<*dK<7
t<:r8
t<;FP
t<@cO
t<Fer
t<J"˻3O
t<R8u
t<\e3
t<\rN\e9
t<\tFU
t<b8o9Hu
t<jeܻ6
t<u<Y
t<u=4<I
t<wTj
t<zTa9b
t=8dE
t=UWټi
t=\aMf>,u
t=\fO
t=cl;=L
t=gW켼\fg
t>&EF
t>QW2
t>Yj >h~5
t>\bU
t>n;r
t>u}9
t>͛g<4F
t?@b1
t?L;YᴻL
t?X5I
t@%s: HRTF data contains Ambisonic HRIRs of unsupported order: %d
t@)fLL
t@HcS\bH
t@REF%08lX
tA8_:t
tA<DF
tAO:q
tA\v9
tB9\a4
tB:,NR
tB<#b
tCI9I
tCU:Y
tD='sC
tDA;m$t>H
tDH9\nu
tD\b%dC\b%4B\b
tD\b*dC\b*4B\b
tDĻ&cS
tE=@8
tED8k2u7H
tF*<ZIj
tF;^d
tF=A䴼th
tG<zmZ
tGѻ.N
tH#:P
tH696d
tHY-ϖx
tHY-чw
tH\b%dG\b%4F\b
tH\b*dG\b*4F\b
tH\t%dG\t%4F\t
tHкKY
tI\n*dH\n*4G\n
tJ:4zs
tJ>\a
tJR>8o
tK9_\bt
tKI=dXW
tL$@fD
tL:\t0
tL;!lD
tL\b%dK\b%4J\b
tLcA\bH
tLg:C
tLջJ0
tM99WC
tM:>V|;mB
tMF<TV
tM\e;>m
tM\n*dL\n*4K\n
tN:;\fP
tO,>f
tO;7Q
tOHcw,H
tP@;r
tP\t*dO\t*4N\t
tPϹƃg
tQ:|nG
tQD8c:u0M
tQX<sF
tQ\n*dP\n*4O\n
tQfD9 tK
tQg;l
tR$;9p
tRV=\v
tR躽1ݹY
tSf91tNH
tT:V05
tT\rJ96
tT\rP}M
tTػRa
tU;\\$0tH
tUbo\bZ
tV9;\v\e
tV;#4
tVݻr\r
tW%1It
tW=1¬=n
tW\r F
tW\r y
tW\r#kR
tW\r&0p
tW\r&\eq
tW\r.WQ
tW\r1\rn
tW\r22k
tW\r2bk
tW\r2x
tW\r3)V
tW\r7Uj
tW\r<%g
tW\r@)c
tW\rB6
tW\rCo
tW\rCwq
tW\rHxK
tW\rJgg
tW\rJkp
tW\rKXG
tW\rLbD
tW\rN?u
tW\rO@d
tW\rR
tW\rR!Y
tW\rR"Q
tW\rR"i
tW\rR[I
tW\rS(F
tW\rSn
tW\rW'K
tW\rX4
tW\rY5Q
tW\r[P
tW\r\a*6
tW\r\eR
tW\r^@F
tW\r_Ug
tW\rb
tW\rcPD
tW\rf}X
tW\rhlj
tW\rl@q
tW\rl\aR
tW\rruk
tW\rsZR
tW\rswY
tW\rx
tWt:ttt
tX+>a
tX-< Gd
tXF:OPͺo
tXe ŬY
tY5me
tY\n*dX\n*4W\n
tZ<eGv<\b4
t\a-<jv
t\a:Z
t\a?GY\r
t\aH9D$PuCH
t\aār^L
t\aġrYL
t\aġzYD
t\e;D
t\f;e
t\fH;Q@s
t\fO;l¯:Y
t\n@88t\bH
t\nF?s
t\nH9P A
t\nH;B\bv
t\nH;C\b
t\nH;C\bv
t\nI9Jhs
t\nL9Qhs
t\nbatH
t\r98t H
t\r; iҼn
t\r;vW
t\rL#\r\vWK
t\rfD9"u\aB\bL
t\t3ҋʋB
t\t\n:9
t\v>\fw
t\vH;B\bv
t\vK9D'\b
t`:MK
t`\bP!w
ta97zX
ta;e,F
ta<pN
tail[BUCKETS-1] == head[BUCKETS-1] + count[BUCKETS-1
tail[BUCKETS-1] == num
task stack overflow
tb!T@Yt\t
tb!|H
tb1>\bY
tbA\\HYe\ab
tbA|H
tbI<XO
tbQ|H
tbad(W
tba|H
tba|\b
tba}Hp
tbb=\b
tbq}HpɱbA
tbq}HpбbA
tc7=P
tc;7!C
tc蹇k9
td\b*dc\b*4b\b
tdm;O1h
te=\tGR
tessellation_cache_size
text file busy
text$di
text$mn
text$mn$00
text$x
text$yd
tf/<LP
tf<KN
tfffff
tfffffff
tg;iY
th*;073
th/;On
th9@p
th<V3̻I
th\b%dg\b%4f\b
th\b*dg\b*4f\b
th\v*dg\v*4f\v
that provides the minimal Euclidean norm of the solution will be computed
that should be discarded according to the threshold
the D_COMMIT_TRIG_TRANSFORM routine
the D_COMMIT_TRIG_TRANSFORM routine. Assigning to DPAR(1) the default value
the S_COMMIT_TRIG_TRANSFORM routine
the S_COMMIT_TRIG_TRANSFORM routine. Assigning to SPAR(1) the default value
the call to D_FORWARD_TRIG_TRANSFORM/D_BACKWARD_TRIG_TRANSFORM routine
the call to S_FORWARD_TRIG_TRANSFORM/S_BACKWARD_TRIG_TRANSFORM routine
the call to d_forward_trig_transform/d_backward_trig_transform routine
the call to s_forward_trig_transform/s_backward_trig_transform routine
the d_commit_trig_transform routine
the d_commit_trig_transform routine. Assigning to dpar[0] the default value
the default value
the first call to DCG routine. Otherwise, the maximal
the parameter 'BCTYPE' were out of admissible range {D,N,P} during initialization stage
the parameter 'BCtype' is not in the admissible range {D,N,P} during the initialization stage
the parameter 'BCtype' was outside of the admissible range {D,N,P} during the initialization stage
the s_commit_trig_transform routine
the s_commit_trig_transform routine. Assigning to spar[0] the default value
this data vector
this problem
thiscall
thread the following way
threadCounter == 0
threadIndex < threadLocal.size
threadLocal[threadIndex].load() == nullptr
threadPool
threads
thy<F
ti;?z$9
ti;ڣ0;M
tiY:SV
ti\e>I
ti\n*dh\n*4g\n
time_range.size() > 0
timed out
tj;+Z
tj;5R
tj<jtV
tjL;@(H
tk<\vD
tkE>fvw
tk\a=W
tl;\bGE
tlT9t
tl\b%dk\b%4j\b
tl\b*dk\b*4j\b
tls$ZZZ
tm\f;q
tm\n*dl\n*4k\n
tn$;Wc
tn)=0O
tn,<w7
tnM;:Lf
tny<l\nB
to provide memory for temporary data structures
to use periodic boundary conditions in x axis direction
to use periodic boundary conditions in y axis direction
to use periodic boundary conditions in z axis direction
to:\taع4
to;6O
tograms to reduce the chance that an atomic_add leads to contention (see below for details).\n    local int localEnergy[NUM_BINS * NUM_LOCAL_HISTOGRAMS];\n\n\t// These base pointers are used in stage 2 of the kernel. See below for details.\n    local int* workItemEnergy = localEnergy + mul24(localIndex, NUM_LOCAL_HISTOGRAMS);\n\n\t// Initialize all local-memory histograms to zero.\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++)\n    {\n        workItemEnergy[i] = 0.0f;\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 1\n\t// Each work-item processes one ray. If it is not occluded (i.e., it carries non-zero energy), the energy is added\n\t// to one of the local-memory histograms for the work-group. These adds need to be atomic, since multiple rays\n\t// being processed in the same work-group may write to the same bin of the same histogram. The contention\n\t// due to atomic_adds can be reduced by increasing NUM_LOCAL_HISTOGRAMS, at the cost of increased local memory\n\t// usage.\n    if (!isOccluded)\n    {\n\t\t// Adjacent work-items in a work-group do not use the same local-memory histogram. A work-item with local\n\t\t// index i writes to local-memory histogram (i % NUM_LOCAL_HISTOGRAMS).\n\t\t// When calculating the bin index, bin index i is mapped to index  NUM_LOCAL_HISTOGRAMS * i in the\n\t\t// local-memory buffer. This is because the histograms are interleaved.\n        local int* shiftedLocalEnergy = localEnergy + localIndex % NUM_LOCAL_HISTOGRAMS;\n\n        global float* rayEnergy = (global float*) (&totalEnergy[offset + rayIndex]);\n\n        float time = totalEnergy[offset + rayIndex].w;\n        uint bin = convert_uint_sat(floor(time / BIN_DURATION)) * NUM_LOCAL_HISTOGRAMS;\n\n        if (bin < NUM_BINS)\n        {\n            float energyValue = scale * rayEnergy[band] * shCoefficients[channel * numRays + rayIndex];\n            int quantizedEnergyValue = convert_int_sat(floor(energyValue));\n            atomic_add(shiftedLocalEnergy + bin, quantizedEnergyValue);\n        }\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 2\n\t// Each work-item processes one bin. The corresponding bins for all local-memory histograms are added, and the\n\t// result is stored in a private variable. No atomic operations or barriers are required here, since each work-item\n\t// operates on independent data.\n    int accumulatedEnergy = 0;\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++)\n    {\n        accumulatedEnergy += workItemEnergy[i];\n    }\n\n\t// Stage 3\n\t// Each work-item processes one bin. The summed values from the local-memory histograms are added to the corresponding\n\t// bin in a global-memory histogram. Here, atomic_adds must be used, because multiple work-groups may be trying to\n\t// write to the same global-memory bin at the same time.\n    atomic_add(energy + channel * NUM_BANDS * NUM_BINS + band * NUM_BINS + localIndex, accumulatedEnergy);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Reconstruction Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\n#define ENERGY_THRESHOLD            1e-7f\n#define MIN_VARIANCE                1e-5f\n#define NUM_WORK_ITEM_SAMPLES       32\n#define WORK_GROUP_SIZE\t\t\t\t64\n\nkernel void applyIIRFilter(global IIR* filters,\n                           global float* impulseResponse,\n\t\t\t\t\t\t   uint numBins,\n\t\t\t\t\t\t   uint samplesPerBin,\n\t\t\t\t\t\t   uint numSamples)\n{\n    size_t band = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t numBands = get_global_size(0);\n    size_t numChannels = get_global_size(1);\n    size_t batch = get_global_id(2);\n\n\tlocal float localSamples[(NUM_WORK_ITEM_SAMPLES * WORK_GROUP_SIZE) + NUM_WORK_ITEM_SAMPLES];\n\n\tconst int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\tlocal float* workItemSamples = &localSamples[localIndex * NUM_WORK_ITEM_SAMPLES];\n\n    global float* signal = &impulseRe
tolerance multiplied by the matrix row L_2 norm
too many files open
too many files open in system
too many geometries inside scene
too many length or distance symbols
too many links
too many symbolic link levels
total
total            : sah
total - write&read: %d
total - write&read: %lli
total memory wanted here: %d kbyte
total memory wanted here: %lli kbyte
tp;GJl
tp;bJ̺j
tp<\nZ3
tpH91uk
tp[9\aO
tp\a%do\a%4n\a
tp\b%do\b%4n\b
tp\b0!(\f
tp\b0!\v
tp\bP!/\f
tp\b`\a0
tp\b`\aP
tpɼy\tw
tq\n*dp\n*4o\n
tr%<.Om
tr:b51
tr\v>l(C
transform.elements[iRow][iColumn
traverser
traverser_mb
tri_accel
tri_accel_mb
tri_builder
tri_builder_mb
tri_traverser
tri_traverser_mb
triangle4
triangle4i
triangle4v
triangle4vmb
triangles
trinidad & tobago
ts,<aM
ts;Hj
tsg:B
tsplit.fpos < set.time_range.upper
tsplit.fpos > set.time_range.lower
tsplit.sah != float(inf
ts̸pv
tt\a%ds\a%4r\a
tt\b%ds\b%4r\b
tt\b*ds\b*4r\b
tv;<D~G
tv>`I6=yW
tvD$ ňW
tvE ňW
tvG ňW
tvL<U
tvûY`ԻA
twx\\w
tx<w]Y
tx\b%dw\b%4v\b
tx\b*dw\b*4v\b
txмkn
ty<Geometry::GTY_END
ty\n*dx\n*4w\n
tyfD9 tsH
typeof
types & BVH_MB) || (query->time >= 0.0f && query->time <= 1.0f
types & BVH_MB) || (ray.time() >= 0.0f && ray.time() <= 1.0f
types & BVH_MB) || all(valid, (ray.time() >= 0.0f) & (ray.time() <= 1.0f
tz/9u1
tz\a>yI5
t{757
t{<j4
t}9;p
t}һO\r0
t~; Q
t~E;C
t»Wv̻Hu
t¼!8W
tƻCrb8"q
tȉD$\f1
tл\tm
tѣ<EW
tӎ;3u
tӺP\e\r
t۹>WJ
tۺ$4f
t⻲x\n
t焹G!y
t蝼^Pf
t뾖2j<C
u 2\tM
u H;_xr
u H;sxr
u HcA<H
u L;sxr
u L;wxr
u L;{xr
u N;t
u ba|H
u }<w88
u!bA|H
u"3\tD$H
u$D8r(t\rH
u%@8j(t
u%A8x,u
u(;3EV
u(A+u0A
u(k:9
u+L=B
u. ;BS0
u.>:wSG
u0N;t
u1!D$0H
u2ffffff
u4\f<$v
u6ɸNGq
u7;otR;U
u7n;w7
u8;-h
u8@8{,u2L
u8D9{\bu2M
u8U\e
u8ffffff
u9<%F
u::wG
u:B\tP
u:R$h
u:h[0:U
u;2*m
u;5tg
u;;UsK
u;H"n
u;Lx9P쉺c
u;UȪ9
u;seؼr
u<>xg
u<K\nQ<f
u<\rDk
u<g~l<it[<ntP<ot,<pt
u<ջiR
u=K,J
u>2jh
u@:SG
u@H;{xr
u@L;wxr
u@N;t
uA8D$`t\bH
uA;=Ne`=aE
uB<_Kt
uBa|)CG
uC<Y3V
uD=W2
uDx;!\e
uE:4Z
uED8r(t\rH
uF<xXߺR
uGL;^PtAL
uJ%lxz
uJ<0uF
uJA:4a
uK8o-\a
uK;xXL
uMcσ~\b
uN:w\n*9T
uN漘\e
uOɼ3\r
uP96K\v9
uPN;t
uQ8G\buAH
uQr;s
uTL9n\bt H
uV;U\n
uWM;q\b
uWM;t$\b
uWh<Z
uX%-z
uX%5,E
uX뼔y\t<\b
uY<opx<c
uY\v:A
uZ;u{\v
uZEeu\b
u\a3\bB
u\a;Y$r
u\a;y$r
u\abA
u\b< t=<\tt9
u\b<oel
u\bbA|H
u\bbA|I
u\bbQ|H
u\bh;I
u\e@8j(t
u\ee<XT
u\f9\r
u\fbQ|H
u\nA8
u\nA84
u\nD8AP
u\nH9]8
u\nL9gP
u\nL9oP
u\nM9UP
u\nM9}H
u\nfA9
u\nfA9\b
u\rb>g
u\rba,HY
u\rba|H
u\rfA9P
u\rfD9d$0
u\rw=Uf
u\t3ҋʋB
u\t<BFb
u\tb"-H
u\tbA
u\tbA4HYM
u\v>W
u\v@8~0tM
u\vM9|$H
u]D8O\buIH
u^8G\buGH
u^H;x(H
u^n=Zn
u_H:dB
u_size >= 1
u`N;t
u`ŨYu
u`ŸT\rJ
ua;'W
uaA8_\buEI
ub'vb'v
ucF:\\T
ucO;oO09
udt returning
ufA8<,u
uf\v:5n
ufffff
ugD;B$t
uh4;E9u
uh{:8
ui="jf
uiA8_\buEI
um;o(k
umber of rays in the workload \n__global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n
umٺ\bC
un;DW
unable to open output file. Print to STDOUT
unaligned
ungetAABBNodes
ungetAABBNodesMB
united-kingdom
united-states
unknown
unknown buffer type
unknown builder
unknown compression method
unknown error
unknown exception caught
unknown hair acceleration structure
unknown header flags set
unknown motion blur hair acceleration structure
unknown motion blur triangle acceleration structure
unknown quad acceleration structure
unknown quad motion blur acceleration structure
unknown readable property
unknown subdiv accel
unknown subdiv mblur accel
unknown traverser
unknown triangle acceleration structure
unknown writable property
unordered_map/set too long
unsigned int)timesegments < max_time_steps
unsigned(morton[j]) >> shift) & (BUCKETS-1)) == i
unsigned(v) >> shift & (BUCKETS-1)) == i
unsuitable for this data vector
uoA8]\buMI
up traversing bottom level BVH \n        // in this case idx = 0xFFFFFFFF and topidx has valid value \n        if (idx == -1 && topidx != -1) \n        { \n            //  Proceed to next top level node \n            idx = (int)(scenedata->nodes[topidx].pmax.w); \n            // Set topidx \n            topidx = -1; \n            // Restore ray here \n            *r = topray; \n            // Restore invdir \n            invdir = invdirtop; \n        } \n    } \n \n    return false; \n} \n \n \n// 2 level variants \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n) \n{ \n \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest2L(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny2L(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    __global int* numrays,     // Number of rays in the workload \n    int offset,                // Offset in rays array \n    __global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest2L(&scenedata, &r, &isect); \n \n
up;Ijf
upH;wxr
upJcL
updateTransform
upŨ_Ep
upƺ%W
uq`:)SK
ur != BVH::emptyNode
us=;aI
usE8E\buQI
use rtcJoinCommitScene to join a build operation
use_single_mode
used blocks
usemtl material_%d\n
user32
user_threads
usergeom
usermsr
using
uuNu'uu
uv+:t
uv\r;DF
uwo;Pw
uxHc\r
uz-UZ-Cyrl
uz-UZ-Latn
uz-uz-cyrl
uz-uz-latn
u~9t$Xt
uƂnA&Q
uɊ9Rbj9
uɺ=z8
uδ;cf
uϋD$$LcL$(Hcl
uԋ<8Q
uݼ,Jn
v %f %f %f\n
v ><W
v Lc\\$8I
v ɺM119
v";jd
v#9Lo_9
v#S;Pe
v$G<@A4
v%m=k
v(A+v0A
v)0;Px
v)9%4o
v)\a=Q2
v*4\e\v
v-;bG6
v-Y:\ev
v-o;~z7
v.<zBA
v0,<\nTF
v0<a_\n
v1d-v0d) != 0.0f
v1ͻ&e
v2!L.2
v2;[8e
v2Z;s\f
v3x(\v*h)\v!tZ
v4#:0
v4.x = v4.y; v4.y += t; \n    t = v4.z; v4.z = v4.w; v4.w += t; \n    *offset3 = v4; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    *histogram = total; \n} \n \n// Calculate bool radix mask \nshort4 radix_mask(int offset, uchar digit, int4 val) \n{ \n    short4 res; \n    res.x = ((val.x >> offset) & 3) == digit ? 1 : 0; \n    res.y = ((val.y >> offset) & 3) == digit ? 1 : 0; \n    res.z = ((val.z >> offset) & 3) == digit ? 1 : 0; \n    res.w = ((val.w >> offset) & 3) == digit ? 1 : 0; \n    return res; \n} \n \n// Choose offset based on radix mask value  \nshort offset_4way(int val, int offset, short offset0, short offset1, short offset2, short offset3, short4 hist) \n{ \n    switch ((val >> offset) & 3) \n    { \n    case 0: \n        return offset0; \n    case 1: \n        return offset1 + hist.x; \n    case 2: \n        return offset2 + hist.x + hist.y; \n    case 3: \n        return offset3 + hist.x + hist.y + hist.z; \n    } \n \n    return 0; \n} \n \n \n \n// Perform group split using 2-bits pass \nvoid group_split_radix_2bits( \n    int localId, \n    int groupSize, \n    int offset, \n    int4 val, \n    __local short* shmem, \n    int4* localOffset, \n    short4* histogram) \n{ \n    /// Pointers to radix flag arrays \n    __local short* shmem0 = shmem; \n    __local short* shmem1 = shmem0 + groupSize; \n    __local short* shmem2 = shmem1 + groupSize; \n    __local short* shmem3 = shmem2 + groupSize; \n \n    /// Radix masks for each digit \n    short4 mask0 = radix_mask(offset, 0, val); \n    short4 mask1 = radix_mask(offset, 1, val); \n    short4 mask2 = radix_mask(offset, 2, val); \n    short4 mask3 = radix_mask(offset, 3, val); \n \n    /// Resulting offsets \n    short4 offset0; \n    short4 offset1; \n    short4 offset2; \n    short4 offset3; \n \n    group_scan_short_4way(localId, groupSize, \n        mask0, mask1, mask2, mask3, \n        shmem0, shmem1, shmem2, shmem3, \n        &offset0, &offset1, &offset2, &offset3, \n        histogram); \n \n    (*localOffset).x = offset_4way(val.x, offset, offset0.x, offset1.x, offset2.x, offset3.x, *histogram); \n    (*localOffset).y = offset_4way(val.y, offset, offset0.y, offset1.y, offset2.y, offset3.y, *histogram); \n    (*localOffset).z = offset_4way(val.z, offset, offset0.z, offset1.z, offset2.z, offset3.z, *histogram); \n    (*localOffset).w = offset_4way(val.w, offset, offset0.w, offset1.w, offset2.w, offset3.w, *histogram); \n} \n \nint4 safe_load_int4_intmax(__global int4* source, uint idx, uint sizeInInts) \n{ \n    int4 res = make_int4(INT_MAX, INT_MAX, INT_MAX, INT_MAX); \n    if (((idx + 1) << 2) <= sizeInInts) \n        res = source[idx]; \n    else \n    { \n        if ((idx << 2) < sizeInInts) res.x = source[idx].x; \n        if ((idx << 2) + 1 < sizeInInts) res.y = source[idx].y; \n        if ((idx << 2) + 2 < sizeInInts) res.z = source[idx].z; \n    } \n    return res; \n} \n \nvoid safe_store_int(int val, __global int* dest, uint idx, uint sizeInInts) \n{ \n    if (idx < sizeInInts) \n        dest[idx] = val; \n} \n \n// Split kernel launcher \n__kernel void split4way(int bitshift, __global int4* in_array, uint numElems, __global int* out_histograms, __global int4* out_array, \n    __global int* out_local_histograms, \n    __global int4* out_debug_offset, \n    __local short* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n    int numGroups = get_global_size(0) / groupSize; \n \n    /// Load single int4 value \n    int4 val = safe_load_int4_intmax(in_array, globalId, numElems); \n \n    int4 localOffset; \n    short4 localHistogram; \n    group_split_radix_2bits(localId, groupSize, bitshift, val, shmem, &localOffset, \n        &localHistogram); \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    __local int* sharedData = (__local int*)shmem; \n    __local int4* sharedData4 = (__local int4*)shmem; \n \n    sharedData[localOffset.x] = val.x; \n    sharedData[localOffset.y] = val.y; \n    sharedData[localOffset.z] = val.z; \n    shar
v4:6ݸ;f
v5?:7IN;\e
v5~:P
v6:Gq\n
v8F9\n
v9&;D
v9+M=9
v9A^5
v9d[z
v9o{W
v:+YC
v:5Il;˅N
v:;C5\n
v:<mF2;T,\b<uNV
v:JzK
v:M:3
v:X$T
v:ZQS
v:\br\t:H
v:kaH:l
v:lP :TFt82
v:պH\aa8
v;)mM9
v;0^8
v;509;4
v;:Pl
v;D\v
v;S\r
v;Us3;G
v;Zy\e
v;\tLr;{tb
v;\tnʺSF
v;`n5
v;dW><K
v;oOc:L
v;reO
v;s}p
v;w0N
v;x;K
v<Aj\n
v<F㴻JV
v<eiƼ1
v<er󻗇\t
v<n$b;L\r
v<~0p
v=#hD
v=Qeh
v=Y]Bv
v=YiZ
v>'5C
v>P9#>nV
v>x掾2
v>yE\v
v>{Ed=o
v>Ĩ\f>JfJ>MM
v?,\tm2
v?PDt?a
v@D8s(t\rH
v@DIMENSION_SCALE
v@L:qY
vA03>A
vA;b\n
vAD8s(t\rH
vBF:\r
vC<RDJ<s
vCք\tes\vC
vD$(A\v
vDN<V
vF;6S8
vF<a5L
vG ŠW
vG|HO
vH9y\bu
vH;A\bu
vH;Q\bu
vH;Q\bu\rL
vHȻd(5
vID$\b
vK;A\fL
vL77㉼Q
vL9u O
vL<2N
vL{j\t\f
vLûbSv:̦I
vM8¶R
vM>TYӾI
vMW;q#6=2
vM~;Av
vN;\fLu
vNcD\b
vNr:oU
vO,;Y2
vO<lCF
vPE;E
vQ;7&N
vQ츟Xc
vR!;0
vRH+D$xH
vSc<bAӽy
vT$9f
vT;nur;W
vT;|j
vTv<F
vU˻=nT
vValve Corp.0
vValve Corp.1
vWf;Ob\e
vX:s,\e
vX廑|Q;K
v[;\r6s
v[GbO\b
v\\8E5
v\a4:n
v\bD;3
v\bYL$ b
v\f(<BI
v\f>GvS
v\f@8k(t
v\f̺e\t
v\n\f;C4
v\nbatH
v\t;~y0
v\t<8Rj
v\t>k
v\tL;Y
v\tbQ|H
v\tcvo
v\tݺEx\v
v\v_;VYf:UPH
v\vɻz
v^>\nhh
v_H+D$hH
v_size >= 1
value has appeared (small with respect to the input
value too large
vaw</i
vaݺ\nkt
vb"5H
vb-;R
vb:<I
vb:o\t
vb<PK
vbA|H
vbA|\b
vbB5H
vbQ|H
vban\bX
vbase destructor
vba|H
vbounds not implemented for this geometry
vbqLHX
vbtable
vc<PM?;l
vcall
vde=s
vd˺;U
ve;;w
veH9[@u
vector constructor iterator
vector copy constructor iterator
vector deleting destructor
vector destructor iterator
vector too long
vector vbase constructor iterator
vector vbase copy constructor iterator
vector<T> too long
vector<bool> too long
vectorcall
verbose
verbosity
verify
vertex buffer can be at most 16GB large
vertices
veɹt쵺5
vf;2yt
vf=;,UG;e
vf?;A@F
vfD9!H
vfffff
vftable
vg\v;.JB;N
vh:L=9
vh;Am
vhH9[@ub
vhT;m$k
virtual displacement map
vj&<SS
vj8jB49
vjH9[@ud
vkH9[@ue
vla;"Y
vlinearBounds not implemented for this geometry
vm:ay
vm:ay̺K\n
vm;9)t
vm<R\b
vmH9[@ug
vn;\b
vnH9[@uh
vo$;E
voH9[@ui
vp$;V/A
vp\nP!\r
vp\n`\t0\bP
vp\n`\tP\b0
vp\n`\tP\b0!\e
vpclmulqdq
vq9xk
vq;?7\t
vq;p\n
vq<<3
vqJ=C
vs:'cl
vsd=\fJ
vt;\vqi
vt\r<x
vt}<x
vu:XXR
vvܻOs
vw9s$vgK
vw˼R識4
vx9s$vhI
vx=-o
vx\r=YG
vy;."w9\b
vy}:\nD
vz̻UWC
vzټw2D
v{;9I&9
v|G9RT
v}8<\bo
v}ŹWl#9!L
v~9;UF
v~:oe
v~o<gS
vä;OH
văa!4\n
vĎ:Hf
vġzoL
vġzoL0
vġzoL8
vġzoL\b
vġzo|2\nĢy!D2
vĢy!D\n
vĢy#D
vĢy#D0
vĢy#D8
vĢy#D\b
v̺B8c
vӽ9NB\n:3
vԥ;aY
vܻh+G;0I
vߔ<Av
v↻vhW
w"ʻvbV
w$j:3\n
w%7;9Q
w':UlO
w+=P8
w+\r<s\no
w,a;Yk
w.:IQ
w/:3\aw
w0<s4
w0<y6\n
w0I;_8
w0\t<3u
w0Ӻo)9
w11:c
w2&:sx
w29iN\t
w4;\tp
w4G;\r\f
w4_;W
w5<;V
w9T\rM
w9\r쭺>zr
w:RΙ;P9
w;"Nd
w;7aٻ7r
w;G9\a
w;W:2
w;\nJ
w;\t㊽xY
w;oC?<4
w;rWz;5
w;sG\n
w;tGB
w;w"L
w;y?J
w<0|H
w<v0c
w<wB\f
w=^eI
w=wSN
w>B7c
w@L;f0r
wA]A\\]_^[ÐSVWUATAUH
wA^A]A
wA_A^A]A
wB;9ٳ;S
wB<1\a
wD:ę\t7
wF7=1D
wF;wk绢J
wF\\:Pjb
wF\e;Vf
wG0:\a
wGB:Jρ:F
wH:|7
wH;\rF
wH;\rG
wH;\rg
wH;\rs
wHH;_P
wHM+w@H
wIz<=Ug
wJ\r9
wJ\v<$p
wLC<ɬ\e
wLcEgI
wM;GI
wNM:>Vk9M
wOb:mj
wQ<:\nT
wQ?;g
wS9Q\fu
wSԼD\n
wT:;dsp
wT:Fv\e
wT\t=\a
wY:%E\n
wZ9Q\fu
wZ:Wv
wZw=www w
w\\K:pz
w\a<I
w\a\t
w\b:E\auj
w\bL+t$hL
w\bUUUU
w\bf;E\auuA
w\eu;\e
w\f;˪k9
w\fS:hC
w\t9\v/};xrb
w]A_A
w]A_A^A
w^;5aD
w_*<GaQ
w_F;P
waitpkg
was altered by mistake outside of the D_COMMIT_TRIG_TRANSFORM routine
was altered by mistake outside of the S_COMMIT_TRIG_TRANSFORM routine
was altered by mistake outside of the d_commit_trig_transform routine
was altered by mistake outside of the s_commit_trig_transform routine
wasted
wb9X-s
wbnoinvd
we;\nS8
weV=Fq
wgQ=]h
wgj;p49
wh?9nMW
whH+w`I
which is equal to %e
which is equal to %s
wi_<a
wide-kl
will always lead to failure in computation of LU factors
with multiple minimum degree on the separator nodes
wiںSys
wl989d
wlY>s
wlԼ\r
wn>Jj
wn_;Ysڻs
wp\b>\tX
wqu:B
write to files : %10.3f Mb
write to files : %d
write to files : %lli
write&read     : %10.3f Mb
wrmsrns
wrong column indexes in CSR format
wrong control step parameter ido %d
wrong control step parameter ido %lli
wrong integer array of row positions in its CSR
wrong protocol type
wrong row indexes in CSR format
wrɼCk
ws1:Mt
ws;PXR
wt4:M
wv;\r\f\r
www.digicert.com1!0
www.digicert.com1$0
wxԺ\r/7
wy:-hs9
wyh;\b
wz@7\n
wzT<\f
wz\n=#qn
w{9YM
w|y<Q
w};b7\f
w¹Sg̺n
wĢ<EC
w˼QPü`V
w̺MK}<6
wξ\fZD>L
wϼ{Tl
wԹ3\aB9
wպOY2
wڗ:GY
w۹qVO
w㔻97\b
w挽\b8
x :\e)K
x ATAVAWH
x AUAVAWH
x AVAW
x AVHcA
x HcD
x UATAUAVAWH
x UAVAWH
x(D$0H
x(L$ L
x(L$0H
x(L$0L
x(L$PH
x(L$PL
x(L$pL
x(T$PI
x(d$0I
x(l$ H
x(t$PL
x(t$pL
x)D$ H
x)L$0
x)L$0L
x)L$PH
x)L$PI
x)L$pM
x)T$0H
x)d$0I
x)d$pH
x)l$ H
x)l$PI
x)l$PL
x)l$p3
x)t$PI
x+9- G8
x+:xb
x+<efI
x-;CT0
x.%\nhv
x.5vZx
x.>5bF
x.S9L
x/%M0w
x/%d\aS
x/%i\f7
x/%jVv
x/5>ud
x/5ur
x/D$ w
x/L\n(v
x/\r=27
x/\rPM\e
x/\rbT1
x/\rq?7
x/e@w\tE
x/e`w\tE
x4:sS
x4D>qI
x8:Sb(8h
x8}0\t9
x9:\nV
x9;Fu
x:;dH\e
x:P5Q:Zx
x:U8ǻi
x:\fd2
x:\rhN
x:f#9
x:ۚ\e9Fl
x;)Li
x;<a 9p
x;CaR
x;Er\v
x;MҠ9
x;R7̻1
x;\eI\a
x;hKR
x;q_x9
x;uLO
x;|8O
x<$OV
x<1f켹c
x<EHv
x<J\r
x<qio
x=&UǽWN4
x>0\n
x>Q<\aQ
x>V6'?C
x?;1BN
x?S;3
x@bB%H6
xA^A]A
xA_A^A
xA_A^A]A
xB-zC\f
xC<@x
xEV<V
xFG;vMV
xG :*魹h
xG)=p
xH9Axs
xH;D$h
xH;}0
xH<jc
xHY9#yn
xJ>Hf
xJF;E6
xM#g\bt
xM;\\YU
xN.<S
xN\v<>,l6
xP:Ed\r
xQ*;A
xQ4:\fF
xR;[SA:L
xRZ;U
xS69:yX
xT\rS
xU";c
xU9:O
xU:b~\a
xU;qGK
xWI96tRI
xWؽX"K
xX%\\yn
xX%g1m
xX'>ubW<]1
xX5|i
xX8:ՄJ
xXG@ŘY
xXI96tSI
xXL# ġ@Y
xXL# ġHY
xXL# ŰY
xXL' ġHY
xXL+ ġ0Y
xXL+ ġ@Y
xXL/ ġHY
xXL1 ġHY
xXL3 ġ@Y
xXL9 ġHY
xXL: ġHY
xXL\a
xXL\a L
xXL\a ġHY
xXL\v
xXO`ŘY
xXW0ŘY
xX\r<Xx
xX_ ŘY
xXs<S
xYT0 H
xZ\n:2
x[9[xE
x[Q:xJx
x\\U ŨY
x\\UPġx
x\\g:cH
x\aH;m
x\bH+8H
x\bntelu
x\f=9Z\a
x\nIcL$l
x\n|\fX\n
x\v;f#C
x\vL;0
x]A_A
x]A_A^A]A
x_x;5
x`D<7J
xa9;EJ
xbػ(Ri
xdata
xdata$x
xdgemm
xdp>n
xe;&j
xeq<H
xf;}ws
xh"9A
xjͻKQs
xk]:45R
xl;!\r5
xn5;|:A
xo78$E
xoM=6
xoؾvK
xr<Ir
xs;6y
xuĻv\fx
xw;^n
xwg=.,f
xwֻ\an
xxJ;*\f
xxJ<&X
xy<Aq9
xǊ:2C
xϻ8go
xؙ9eUl
xݻhṻI
y ba~\b
y º KI
y!D \n
y!D$p b
y!D0\n
y!D1\n
y!D8\n
y!D9\n
y!D\b\n
y!D\t\n
y"=AH
y#D\b
y&:kw
y(J9h1
y+Y<w
y+{YB
y-N:Pv
y.<Hm
y.K91\aZ:-E
y/8Qv
y0G=XM
y1d<0
y2@\e
y2o9,p\b
y2úڪZ
y3H:wO
y4<G3
y5zo1
y63˼}l
y67;\eq
y9.9W
y9<wh
y9\r`y
y9`;S
y9gt\b3
y9k>":0
y9x0C;\n
y:)Jp
y:< 6K
y:@FO
y:Bm(:t
y:\rz
y:gt\t3
y:oSj
y;-y5
y;;vV
y;aAڻeD
y;cev:V
y;ƗJ:Vt
y;ƼPDx
y<;TDf
y<L9{0
y<W%7
y<l:lEV
y=F:LO
y=e;q\t
y=uYX
y=u\n3
y=ľS=jz
y>(0r
y?Nny
yA9TYi
yA<\fM
yEٺn3
yI!<o;P
yJ=0xN>7
yKc:\n
yM:'S`9
yM<pIл[!j
yM>ȞI
yN<qyC
yNӻ!n{bk
yO>;g
yQ&<C7
yTw:Nr
yU;J\vǻty
yXD$DŨY
yY54F
yY;rY8
yZy;ᴀ:t
y\\PD
y\a\b
y\b< Dn9
y\bH+9H
y\bL+9H
y\bL+9I
y\bW;,l
y\bba~\b
y\eq;d
y\fbA~\b
y\fúbM
y\r<o
y\r=5
y\rk;b\b
y\tV<&h
y\v;\vNX
y\v<xz\v3h{\v*t
y^O;T
y_U;O\t
ya=OYY
yb;\rA
ycI<p
ycO:"K
yd=Oi
ygV:J(6
yj';f
yl苼$P\r
yn->l7
yni;t
you have to wait for spawned subtasks
yp; \eA
ypg<9M
ypm;pR
yrL9JT
ys,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults  // Hit results \n    , __global int* stack \n    ) \n{ \n \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef LDS_BUG \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef LDS_BUG \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults   // Hit results \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef LDS_BUG \n            hitresults[global_i
ytV;D
yuϻ%NX
yv;\v
yzC<Z
y~;8J
yȺ\nY
yɻP.K
y̺4\e6
yͺ:rN-7
yϻ/Z0
y耺SC\a
z <tHm
z v"z$e
z!U:I
z";WF
z&:RC
z*Y9Pw
z+R<4T
z,;EAI
z096?\a
z0=|Q
z0U;6x
z0\f>L
z1=<D
z2v;Ns
z4:(lk
z4:NA
z4\f<Elf
z4v?\f\b
z7:hv¹p_v
z7<Gi
z7H<ur
z8J:X
z8W;r=A;ATB
z8\axغB
z8v>\r
z8ڻad
z9>z\rf
z9MdU;\nV
z9ں;u
z: SR
z:2\v
z:3:D8a0
z:3{g:xp
z:> R9f
z:bIm
z:c夺Q
z:jPj
z:o4.;E
z:vhT
z;7WH
z;GRt
z;\tOg<K
z;bhD
z;g<p
z;qbC
z;ѲI;7I
z<62P
z<;<fvu
z<rc+;\al9<gn
z<t\f
z=;NSH
z=T/P=tA
z=l4ݽw
z>W\f
z>h4Ժ/so
z?<5T
z?ƽA\t3
zA*=c
zA7<EU
zF;u+\f
zGf:XV
zH\t=p
zJ6;[O
zJ;߸89
zL<&Cs;2
zL\r;N
zQv<>8
zR>_OB
zRB:5
zRc;>E
zUżL^Q
zWM;L
zX\a;N
zX\f2āz
zXq ŊY
zY$!M
zY,\vĢa
zY0v;C
zY6;j
zY;>u:m\t
zYD(\bL
zYD\v\fġz
zY\\\v\bH
zY\f2K
zY\f2āz
zYt\a
zY͉D$h
z\\T6@3
z\\|Fzn
z\aGl
z\aba|\b
z\b A
z\bH+:H
z\e3<,S
z\fba~\b
z\r=t
z\rba|\b
z\t:|FO
z\tb"u\b
z\tbA
z\tba|\b
z\tba~\b
z\tƼ\a켭 w
z\v2;\a
z\vba~\b
z\vܺ78
z^\r;hU
zb2:E
ze<58\e
zffffff
zg;9_ûc
zh-CHS
zh-CHT
zh-chs
zh-cht
zh:8n
zh\f:\n
zhb>f
zi3==\aR
zi9uMe
zi<g)C
ziS<D
zjS:6>Q:aph
zk3:\t(5
zkD;=N
zm?9CD
zmϼ`8r
zn==bR
znӺWT
zo%7V
zo%FEl
zo%q3l
zo%su
zo%tn
zo%x4
zo%{t\r
zo-'9
zo-*Ok
zo-5a
zo-<rn
zo-P1
zo-ZIk
zo-\ad
zo-\nDk
zo5)Fj
zo51/o
zo51\t8
zo53rt
zo5:Or
zo5\b(j
zo5\vvt
zo5_sl
zo5bP
zo5iFr
zo5p\tr
zo5wGt
zo5w\r
zo=(c
zo=D\\l
zo=Dko
zo=G8
zo=d8Z
zo=q[8
zo=uf8
zo=zO
zo=zP
zoL$pH
zoL$pL
zo\\$pH
zo\r&=o
zo\r.\to
zo\r0F
zo\rH
zo\rQ;k
zo\r\a%k
zo\rh^t
zo\ruM7
zol"\nĢy!D
zol2\nĢy!D0
zol:\nĢy!D8
zolV\nH
zolW\nH
zol\n\n
zol\n\nĂy!L
zou@Hk
zou`Hk
zo|2\n
zo|2\nĢy!D2
zo|\n\n
zq<gCn
zqz:r
zr`:o
zsX<\r
zt;\ar
ztߺv\a4
zut<[H
zx ;ɾn
zx%ܻK
zz1;j1
zzp;lQ
z~4\bġz
z~=gC
z˺jwx:c
z̓;9WG
zͻyp˻\aL
zѻ>\tCp
zּNDf
z߳;Rk
z㹭6/:oĤ6q
