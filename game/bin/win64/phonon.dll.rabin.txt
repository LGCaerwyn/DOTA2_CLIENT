0 ACr
0!\v4f8t4b
0%:I7
0&>\vxe
0(J>a
0(¼2K
0*=tP
0+<5oϻU
0-based array is turned ON
0/8;&jt
00000000@@@@@@@@PPPPPPPP
0000@@@@PPPP
00=Ps
00cfg
0123456789
0123456789-+Ee
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789ABCDEFabcdef-+Xx
0123456789ABCDEFabcdef-+XxPp
0123456789abcdefghijklmnopqrstuvwxyz
02<N`N
03\tD
040904b0
045>,D
06*>L
07T:R
08Y;zQ\n
08ܻM\nB;i
09G|\t;i
09kP\n
09})C
0: =p
0:'E9
0:8\r#8
0:<q6r
0:=Mg
0:HQo
0:Yk\a
0:qg 8
0:zh#;L
0:ďI9
0:ѳn86
0;!AI
0;7zA
0;?aq
0;B1ͺR
0;C8j8
0;Ts#:d
0;Z$D
0;hLw
0;iZ-:X
0;nU\r;f
0;vn2
0;xCg
0< l\f
0<4xS7
0<4~O
0<>2!<kRZ
0<QIx
0<\azJ
0<\boX;z
0<\tw\b
0=!cl
0=>yJ
0=s!N
0=􀒽\ttK
0><[cZUg
0>H8B
0>\bQ
0>\nW4
0>\rg
0?K;1F
0@>1j4
0A^A]A
0A_A]A
0A_A^A
0A_A^A]A
0B:;n
0E|;Ox
0FV:6
0G=·l=G
0H+=i
0H;o\br
0H;w\br
0Hq;qj\v
0II;6
0Ic\aIcW
0JV;\f
0K:y\a
0L9{0
0Lck0I
0Lc{0I
0M#o\bt
0M;x\b
0N;shY
0Pr<o\f
0R:;xW
0S,;iJM
0S;BF
0S;\tw2
0S_;f
0To:@75
0X8b?~\e
0Xh:u95
0YL$0ŨYD
0Yr709
0\aba|H
0\eY8(iA
0\fѸS
0\rD;0
0\rP\fp\v`\n
0\tJ= H
0]A^A
0]A^A]A
0]A_A
0]A_A]A
0]A_A^A
0]A_A^A]A
0^;MzP:Q
0_:7r5
0_L$pI
0b!|H
0b!}Hp4
0b1F\bY
0b1\v0\t
0bA|H
0bC%\b
0bC\r\b
0ba|H
0ba~Ho
0ba~\b
0bc=\b
0bc=\b!d
0bcE\b
0c1\v0\t
0df=Ŗ\n
0e1\v0\t
0e=;a
0e\\9f
0eɺB\v
0ffffff
0fffffff
0gû[x
0h<nBp
0hU<a
0i1\v0\t
0l:<z
0m;YG
0pU;ͲA
0r\a=FF
0r\r<,4
0s; $5
0sh;K
0t\e;U
0u;6B
0u;ȺJ;C
0w0c1\v0\t
0x%I64x
0y<2\r6
0zD;wD
0zj;V
0}0i1\v0\t
0}<LB
0ġz~4
0ŨXU`ŰX
0ŰYUP
0ŻQ!v
0ż\tk
0ȹq!O:B
0Ϭ8Uh
0҇8,q
0ڼvYмr
0ފ;Rj
0籼d#3
1!;5jf
1#QNAN
1#SNAN
1*̽ Z
1+;\tk<Tt
1, 1))) \nvoid ScatterKeys(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localvals = safe_load_int4_intmax(in_keys, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localvals >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LDS \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals.x = keys[localid << 2]; \n            localvals.y = keys[(localid << 2) + 1]; \n            localvals.z = keys[(localid << 2) + 2]; \n            localvals.w = keys[(localid << 2) + 3]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n
1-8=M8I
1-based array indexing is turned ON
1.2.11
1/;Be
1/;hR
100.00
10=`M
119[V
13,<j
14;&Q
15:g7E
18?FMT[bi
18H\núy
19>]4
19eď9 Y
1:3\ae
1:\rh
1:a^l
1:f\tV
1;5`b
1;^u8
1;pOe:f
1<Egd;"m
1<\bL
1<\r2
1<]HB
1<tŨ;wvp
1<樫=H2E
1=hǽW
1=wgֻaQ<O
1=Ϻp\b2
1>:Do
1><pM
1>c\v8>gp
1>vER=\a
1B=!e
1BLQXC?l
1C;pW\n
1C<ID\r
1D8G\buIH
1D8G\buQH
1D<)T
1DZ<jF\n
1F;F碻-i
1FW:C
1G3;yWY
1H;>u?I
1HcD$(L
1I27K
1IL$LD
1IL$TD
1IL$\\D
1IL$lD
1Iw<C3
1J9rt纀T
1L9O7n8
1M;*S
1N;dC
1NI;K
1O);k
1Q:ay
1T'::1q
1T;=}88
1V";Bw
1Wz<cl
1\\>14C
1\\z9
1\a9x2\a0h3\a'4p
1\n9t
1\t:QG3
1\t>\faS
1b!|H
1b!}Hp,ұb
1b1, X
1b1}Hp,бb
1bO;d
1ba4@X\tba|H
1ba\\ X
1ba\f
1bq}HpԱbQ$@Y
1b{9eV
1e;y\aW
1e\a:^M
1ffffff
1gt;O
1h$:\eZy
1hq<Jp\v
1hq<Y
1i]9{K
1j=\n
1jx;5\bλQE
1kG:y5
1l;(8G
1m><uE
1rE;k
1rd>y
1t\t9
1tں&s
1u0;t`b9
1wP=%Id
1wX:<n
1yD{z
1{S;c
1{q;kq
1|U;eG
1ºH=58
1ûZ\a\f
1āzXD
1ģi!l
1żah6
1˻UEV
1ֻ\bC6
1ֻuQ\b
1צ;zoR
1ٗ<V7\f
2 ;k/p
2!:Xs
2"A:j
2+=-tG=br
2,S;TS
2.17.7-alpha.1
2.8OVd
2.=jiD
2/x;Oq
20240722
20:WϽ;3
20H@.B<D>F>H
20l;g
21];ZD
21a;?H8:6
22:RNz
2333333
23=Dͳ=\tJ
26K;$N
27:ȵO
27<AFK
27O;P
29&b\f9
29[yi
2:6W\v:3ľ8
2:F_b
2:L`o9L
2:YFk:k
2:b=m<f
2:gDx
2;*l8
2;0"e
2;7i̻C
2;TiJ83CR
2;Ue绳w
2;\bT
2;\bZ8
2;` w
2;arX
2;s=2
2;sNL
2;vM\v
2;}w5
2<2\tźO
2<6r⼐kz
2<D@L
2<KB\r
2<j)i
2<u\bt
2<vdR
2<۽CK
2=i>3
2>~m6
2>ʚo>J2
2>۽vx
2A;sZ\v
2C\t9U
2DE=au
2DigiCert Trusted G4 RSA4096 SHA256 TimeStamping CA
2DigiCert Trusted G4 RSA4096 SHA256 TimeStamping CA0
2E=82R<d
2Ee<pI8
2Ej;?l3
2F=\f
2FҺ^J
2G8ƶy90
2GG>!B
2I;"bA
2I;\f
2J\f=Ԉ2
2Js;~n
2Jw;r􈺅Tb
2Ky;Un
2M¼\a\e
2Q;rf\r
2R=\fӽ<au
2T*<6
2TK;>nE
2T~:CS\b9
2Tлl8
2U1<J
2V1;(%v
2V:ϥC:M
2Vv=F
2W">`92
2YL\a|Ģa
2Y|2d
2\a<K
2\b:OZ\b
2\e>vc\a
2\e\v
2\f0\vP\np\t`\b
2\f:p4q
2\f<1W
2\n[:S0e
2\nЈEPH
2\rp\f`\v0
2\rp\f`\vP
2\v0\np\t`\b
2\v<X\v9
2\v=\n X
2\vL$PL
2]fQ\t?5
2^˼78
2`ġJYt2d
2a\v:)YD
2b!<HY
2b!|H
2b!}Hp
2b'>Q8
2bF;y
2b\b<Z
2ba}Hp\f
2bq}Hp
2dh=(X
2f<w\r7
2fGHz
2fffff
2g/:G
2h9sp
2http://crl3.digicert.com/DigiCertTrustedRootG4.crl0
2izj|4
2jG:z
2jP;3hN
2p;V+n
2p</MT
2r*9U
2wx:rd
2xk:F
2yY9u&U
2z<#k
2{A\vDcC
2|8Et
2ǼzSO<n
2Ɉ9dcz
2μcRƼc
2҈UHE3ɍA
2ֺ8WG
2ٻZᙻmg
2ݺv>F
2捻rF2<f\v
2蚻ǰV9NJ
3 :\v
3 ;4T
3 H=t
3!y:G
3$m<3
3%0=9
3%I;wDb
3%P;Ul
3)ƼkWy
3*V<gL
3+r:ߨ2;Qq
3- =cO
3-:MPN
3/C>R
30;th
31<(M
32-bit integer overflow problem
32źs౻a
333333
35i<sC
36;3\vR:Y
36A;rn5
36`=s\b
37ܻ4h
38$Dk9
38(3q;τr
38:\vk
38;qwZ
38غ%F
39.6v
396js
39\aq@;4
3:8me
3:JpV;l\v
3:}3w
3;&vh
3;7\bS
3;:HF\a
3;CScs
3;TWɻs
3;\n N
3;\tTʺK
3;atH
3<!lN
3<Cܮ<WP
3<dF\b
3<dU\r
3<y8B
3=:w2
3=N\f
3=h\a\t
3>4A\a
3>N;kU
3A-;w
3A;XI6
3A</a
3A\a;^ᇻ8d1
3BڼlxǼG
3DC@H
3DF@H
3DG@H
3D{7ýt
3E9>l
3E<tF
3F:Nڂ:4m
3G*=1
3GV;VL
3Gܻ\r7
3H=X\e
3Hc\f\bH
3I9)ZZ
3I:OP8
3Jg;d
3L:<h
3L;2V
3LA<n,\e
3O<qoW
3OIX:0w*:\f
3P=\v1`<ci1
3P>=U
3Q;\e/t
3Q\r<n
3Sk>r
3TF<F
3W<HF
3YY:4F
3\f<L
3\fW;T
3\n=Fw\n
3\n\t;Q
3\r<p6L
3\tD$ H
3\tD$0E3
3\tD$0H
3_<2l\r
3a\n<ZB
3b,;V2
3b1|\b
3b:NSm
3bA|H
3bad@X
3batHX
3c*:"u09\n
3c,:KFӺv
3eG<rb
3fffff
3ffffff
3hZ;\aX
3hi:٢b
3iD:P
3jȺ!eX<ܻV
3k;'N4
3k>Sgq
3kg;iX
3mo=EX
3oƻrn
3q;dŦ;E
3r=:WB
3t::T
3tD;\a
3t\b<kg
3v9\\sZ
3vQ:6˿;O
3xźOH4
3y->W
3zϺqh
3z꠩7Z\b
3}b;\nCR;eL
3~:yS
3ģi!T5
3ɉD$8H
3ɉL$HE
3ɋt$P
3ѻNgQ
3ѻadl:e
3҉T$ A
3҉T$ L
3҉T$0A
3ҋD$(Mc
3ۉT$HD
3۸VUUUD
3ۻD\vb<N
3J\n
4 <(Xx
4!<VE
4"T:PD
4%V<2u
4,bR}I
4/bA~\b
4/bbUH
40<k5
40{;N
41<zgE
42:|\fv
42;YAg
42B>F
42ģI!41
43b!|\b
44?:S
45X9.H0
469;}X
46ăI!40
47;0^68r
47\b=x
47bA|J
47bA~\b
47c#\e
49G%\a;bi
49HoKC
49u O
4:HmݼH
4:bFܺ7F
4;,Ip
4;K\v\b
4;Y/l;\n6
4;\nCs
4;bA|H
4;bBu
4;ba$@X
4;mA\n;Q
4;qH+:h
4;t }956
4;ʼuc\f
4</fb
4<4;ZvջA
4<>\v0A
4<G,ӼQkj
4<X8A
4<YP6
4<cZ44<\t
4<k:F
4=7#=5Z
4=D}Q
4=HH3
4=\tJ
4=rUľ}p
4>%4m
4>3RO
4>5IF>_X
4>PQ\a
4>b!L
4>v<r
4@=m0\r
4@bb}H
4A;!q
4B;$y
4Bo;n
4D8l$2u
4G3<%E
4GE:m
4Gbr}H
4Iڻ/A\f
4JB:킩8
4L廉zN
4M*<e
4M8Y?6
4M<D\nL
4N8=C
4N;Y*\r
4NŻ|6\a;s
4Q<\a8Y
4QY=M
4R):wvҺJ
4R9\v]5
4R<K3
4R=i7
4T5Hq
4TԄWak>E
4Uʻa*w
4VR=ޗp
4Vc70d
4Xϻ7cu
4Y,96r
4YL$`ŬYE
4YM`ŬY
4Y\rE
4Y\rzE6
4Ym ŬX
4Y̺Dis
4Z\n;1
4[<WH
4\\i7n
4\abq|H
4\b6\n@\f
4\eģI!t
4\f<z<K
4\f^;mS
4\nbA|H
4\nbA~\b
4\r<0Li
4\r>v
4\t<QU4
4\tbrm
4\tbr}H
4\vb;_Y
4_Q;2
4`q9P\r
4a<S\aF
4b;<l
4bA|H
4bL<dM
4bQ4HX
4df<W_9
4e;[h
4ffffff
4g<k\a5
4h:oW\v
4hG<"0
4hT<\r
4http://crl3.digicert.com/DigiCertAssuredIDRootCA.crl0
4i9CdS
4i;w9
4j;6\t
4j\v:\t{k
4k!:C8
4l;G{f
4l<\nt
4p:jCH;y
4p[7w
4q<+3U
4q<+l
4r<ܽ˽Sx
4s\b>Z4ԽO
4t;3u\n
4u9Ig
4ve;x
4x*9S
4xt;ђ9
4z<4/Q
4|λ8YŻ8
4ӺVڅ;p啻pW
4Թ:Qi
4ػOz\n<rg
4ݯ>28
5 ;=dU
5!D=6
5#:r\eO
5#\b<Yt
5%9ZKK
5&b?B1s
5';Z4\f
5(96N\r
5)m:F^k
5+;ruL
5,O<w
5-;e1
5-C:r
509;k
51+<Y
51:`k\a
51:sk
54;Djp
55M>vG
56*;n0
58\ej
58ٻ\tx
58ᓍ:紻92
59Z;\et
59ZEz
5: ]O
5:'4o
5:/F1
5:PAY
5:\vqY
5;+,v9C\f
5;6\r4:u
5;B\\c9
5;D\e
5;X(o
5;e5X=L
5;f\b
5;kc1<4H
5;n4b:\n
5;om컠\v
5;r\vb8hr
5;}SZ
5<FE.:TP
5<[ E
5<\f>лuxk
5<^ZA
5<e+L=H
5<eB0
5<m(3
5>'MX
5>cQW
5?5=A
5?l 6?#:7
5@D;OJ
5B:\b
5C3=f3
5C;\nN
5D0<dr\f
5Dۺvg
5E>haR
5F=4u
5FB;[Jz
5FM<5tE
5Fj;q i
5GJ:ʍg
5J;҇u
5JO<s
5Lv;E
5M;j2\f
5M\t;O
5N9t.y9
5NC<Dz
5Pһ\eM
5RC9!Ŵ9
5TK;c>d
5U!;Y
5UC7֚A
5Ul<"V
5V9;4
5V;'di
5VӼL\fl
5\aS<c
5\b:yώ9
5\bY:hǱ9P
5\e=lOf
5\f4:T
5\nJ:U
5\nk=e
5\v;hag
5\vʻ_2h
5b691n6
5bt;\n
5cI<S
5e"=k!z=Y
5e:)N6
5e:\t
5fffff
5h5<d
5http://cacerts.digicert.com/DigiCertTrustedRootG4.crt0C
5i,%5i}:  On entry to
5k>\rW\f=v
5l˽F{P
5lԽLX
5m8>8=t
5n:"f8
5n<<99Q
5o< I
5pME:i
5q1;R
5qB=g
5r:Q}4
5rv;S
5s0;B
5t:\\K6:U
5tĻrD
5w<6A
5xA9E
5xF;+gE
5xm?\a
5x¼@E
5{˻kN
5ºs0\t
5Ǻ033
5ʎ:Y5
5ʻG]9;a
5̸n[λNuM:9B
5պ91n;h
5ڹ\nG
5ڽp3Q
5ۺ:Q2
5蝽,4z=Fks
6!x<0R
6!»Br
6$)2Az
6';pIY
6*p;d
6,\f>brg
60u\rA
60ÜZ{i
61f;\tMK
61̼M\n
62F;u
64ι_e\v
666<jHv
68^dh<f\\A<2
68tGS
6:%Q6
6:;Uu
6:C8*;acy
6:CI1
6:\v\ae
6:enZ
6:iSB:V
6:scM9
6;!Iz;p
6;O\f\e
6;\t M
6;hVH
6<'(4;nAK
6<,|n=XQ1=3Y
6</in
6<2wN
6<Pr3
6<\to\e
6<cNx
6<k\rP
6=3D\a
6=4iＨxp
6=K웼S
6=X t
6>D\rF
6>v쓼L
6?<Vj
6@1<8
6A$:r
6C9>L
6D:\a_O
6E:Eo
6F#>\ff
6F;Dd\t
6FQ=47
6F½{o
6Gg;E.C
6Go;\v
6H<=Y
6I;uBV
6Ix=5
6Lc;R
6N<? q
6NK>\e\r
6Rɼ<X
6UļVJǼ1Hۼ42
6W绱}d
6X[;dIR;S
6Z_;4
6\\\e<Va7
6\a ;c
6\b>s
6\e;+C9
6\f9<'L
6\fA=\e
6\fXO>\ntA
6\fw9
6\nR<u
6\nܼt
6\v;r45
6_8<u
6`h;C
6`tl:hO
6a<\erb=6
6aR;5
6aͼ`8F
6b!F\bX
6bB;n
6d;zܩ9j
6d<HMr
6e;vu
6e}:}Ru:t
6f&;Y
6f?;\vu
6ffffff
6g=$Y
6gU9f
6i %-6i %-3i     %-8.4f %-8.4f
6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e
6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e   FAIL
6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e   pass
6iZ<vb
6iӻ`wh
6jG<,Q
6ko;T%;j
6l8\eQ
6m:\e
6mZ<DgJ
6nB;r\v
6nd<f
6oh;\f
6p7MOf
6q;fUR
6qO<F
6r9 5
6rǻ Y
6t:$2t
6t;FY
6tX<\v21
6wo=e
6x<Q\nX
6ys\b$;o
6yк%S
6zz<c
6}3= 5
6Ó;pC
6ăa!\f0
6Ƿ;L\v9
6ͻqy"<3
6κj侺*Es9
6Ҽ46Żvt
6յ;vH
6㔻>SS;9
6璻UAۼU\t
7 :IƝ;du
7#bI;nR
7$\eD:g
7%;+xe9
7&n>h\fn
7'\a7=A
7+G;C
7+u:PH
7,;UX
7-:Zu\n
70:Y@4:I
70?Hz\e
72-<f\e
729:g
72L=L
72r=AY
73<q\f
75AJ9\n
75{V:\n
77;tc
78`_:V\bx9
79$畺3B$;E
7909b
79?G8
79bp\r:(L
7: 6J;@75
7:!8J
7:!X1
7:<7L
7:LRιr4
7:Z-f
7:\nn89
7:qZ9
7:vbA
7:vrt:0
7;%La
7;0\t
7;B|Q;R
7;l\n\t
7;rnպu
7<Q)5
7<RLK
7<dDW=v
7=7gS
7=<\ey7
7=\bK\a
7=dUt
7=wRj>K
7=}Jp
7>HֺBz
7?Լ\a3t
7AP:!o4
7BƼ|o
7BھXSB
7Cu<d
7E>9Lo=d
7F!;E
7H9x\fY
7I3:\b
7K\fk
7Ld:I
7PR;D)k
7Q;E#i
7Q<F[l
7QC;\v5n
7R[<` p
7S>;s
7U:;X
7Uʻ/c
7V;g3
7Vmq:w
7Vӹ'Zt
7Xd<ηz
7YJ;~V
7Z1|9e
7\aǻ0Y
7\aɼ=KC
7\bu;C
7\e:Y
7\e{U;n
7\eջ1
7ae:%z
7b!|H
7bA~\b
7bJ;C7
7ba|H
7e:\f
7fffff
7ffffff
7fi9\aYG
7h[;\e7
7h\e1;V
7http://cacerts.digicert.com/DigiCertAssuredIDRootCA.crt0E
7hz\a
7i:lp
7iݽg\v
7j,<KDa
7jnj;D
7mh:h
7n?ǺM
7ni&9N
7nuH8
7p;f 3;q
7p<<xq
7q:42i;a
7q;8\\y9
7s1<R1\a
7s\t0
7sƜ:\b߉9m
7u<NT\a
7ur;yI
7vf;AJ
7x<\n
7{KV\nU
7~:\nTW
7ƍ;hND
7ơ<AY
7˺8`89\v
7˼*Es<V
7ͷ9kD
7φ:U9ֹa
7л<wH<v
7ӏ<H8Ȼ2z
7Ս<vZ
7ݻJ\e
7ޗ<b\eE=Ys
7릻yFF<m
7뻆\bڻ1V
8 V<bz
8"&08l
8#J\f
8#Po:M
8$ $9D
8$v2;E
8%h&;gn
8&#89K
8&GS9
8(Wһj\e
8(\tC;B
8(e=E0
8)B\a>8B
8)u&I
8,3M:QN
8,\rk;S
8-Z\v:H
8/;in
8/NG8
8/Uĺ2
80d\t
80pR<pIQ
81!;cr
81;*^C9~6B
81Eɻ~\vc
81¼R9？h
82AI9
82˦9R\r\n
83:aN
83;9M
84<HAJ
84XŹ7
85<ιL
85G<r\a\f
86:u6
86;rJ2
86>V9\f0
88/\ve
897}:I3G
89H`fD
89Z6{[u<;w
89\\$Pf
89\\$pf
89\n0w
89t$0fA
89whS<\v
89|$4
89~n0;h
8:1%Z;c
8:6,:5!m96
8:;dd
8:OBc
8:\bc\t;n
8:b\eg
8:dIj
8:q\t\n
8;'qw
8;)xV
8;3)D
8;5G\t
8;Bt::gW
8;PBA
8;W:p
8;XM8
8;e\b:U
8;fy3;r\e
8;jMa:aX
8;mH793
8;o.v
8;q`9:\vT
8;w{s
8;xNw;m
8;yHc
8;zsM
8;zʭ;of
8< .f
8<A?5
8<TYf
8<\f6t;͚T
8<]p3
8<aik
8<f<f9
8=#xѼa4
8=Qsg
8=RY\t
8=XPfA
8=`PfA
8=hPfA
8=pPfA
8=x$5>Y
8>9:k
8>G2\e=mf
8>\ew\t
8>c\eքBC?>6t9^\tc
8>~08
8?oЈ>Vc
8@Hd;L
8A;\b;f0
8A^A]A
8A_A^A
8A_A^A]A
8B"\e<l
8B+59&pt9
8BNK:Z
8BYV;Nٰ8
8B\r=[L
8Bh\e;\eH
8Bko9f
8C0u\tI
8C\buAH
8C\buGH
8Cj;<s
8Csinf
8Cؼ}98
8D$@t\fH
8D$Xt\fH
8D<<2
8D=V;C
8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA1
8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA10
8G\a\e=\r
8G\buAH
8G\buBH
8G\buGH
8GdH;z
8H;E!Q
8H=E;y
8HS2:A
8I*\v
8I?=&UN
8Ia\n;u
8IջO/0
8J\f<qJ
8KyD9
8L$ܹz
8L:{r\f
8L;x\b
8Lck0I
8Lcs0H
8M,;Iw
8M;D$0u
8M;x\b
8M\v;X1
8Ms;\fTf
8N>u\e[>e
8NG1:'}\b
8NS`:iVR
8N\vɻV
8R"L;x
8Sf<\ap
8U)zj
8U;\ncN
8UL<ޭ\v
8UUUUU
8V;ŹR
8Vk;J
8W;2o
8Ww;z
8Xüy\f
8Xċt$x
8Xޠ;VY\e
8Y3<:fc
8Z0Ļu
8Z6\t:m
8Z;y\v
8Z=M1o>C*0
8ZüK|G
8[yǺTq
8\\$PtD
8\\$PtF
8\a;s
8\aj躥$u
8\b\a
8\bg88ew
8\eIN:7
8\eQq7
8\eǻZOp
8\n<[Hm
8\n<_Dp
8\nӺyqg
8\t'0:_sd9
8\t:^9U
8\tpw9q\ee
8\tr]H
8\v$=KO
8\v?m9y
8\vؼ"72
8\vߺ"S6
8]:\vo9
8];f\nB
8]A_A
8]A_A^A
8]A_A^A]A
8]ｾxD
8_9"3a
8_\bu?H
8_\bu@H
8_\buAH
8_\buEH
8`gԸBt
8avu\rA
8avx2u
8avxiu
8b!|H
8b!}Hp
8b!}Hp4
8b2ad69f899ca0710f94d10303a2f02d7426faaf
8b:c{p
8ba~\b
8bf=`a8
8bunz8
8bwE:O
8d;k活^as:L
8d=?9Y
8d>:v㐻Q
8e:u:c
8eY<L
8e\b<kw
8ffff
8fޗ:Gؠ9
8g=ʹi
8gnu;!~N
8h;;R
8hВ82Pa8
8iV=ˣP
8i\a=6x
8kqp;H
8kz[91
8lA99c
8m+:it
8m5йвd
8m:StY
8m=OSb
8n<PnZ
8nݹ>0r9
8o;EIJ
8o_9^Q
8p4[;=0
8p6y:\n
8pb0;S
8q2u}H
8sse3u
8sse4u
8sse4u\aA
8ssseu\rA
8ssu\rA
8t;e13
8tR/;R
8tZJ;P\tV;E
8t\tH
8u\e:tf
8u\nfD9
8u{b;\b
8v?Q:X
8vH<\vPZ
8vL96W
8vL;\bX
8v\tۺZw:J
8w(;s
8w:]C2
8w\bu?H
8w\buAH
8wpv0H
8wع]x
8x;\e
8x?I:z
8y tmH
8zq(;X
8{\bt
8|$Ht\fH
8|$Pu
8~!tKH
8»MHa<L
8ÐATAUAVAWH
8ŻqGx
8ɺUr5
8˺8hC
8˻ë99
8̮e9\tL
8̶9)o
8ʹv72
8֖S:VX
8ֽwSt<R
8ؼI7\r
8ܧ9lM
8ދ\b9
8ျ\vJr8p
8ṉ;4op
9 ;Ԣi;O
9 OҺ]ej
9!6N:q
9!AF:\t
9!r9:U
9"2ԺEH0
9"]Q;tY
9"o&8+Pj:4T
9"ҼrB
9"٘;rBI
9#WùWiC
9$x[<Ac
9%/C9
9%?9j
9%B<2$c
9'I:0F
9(D>O
9(e;aP
9)eA:ڧ2
9)v<z
9*K:r
9*QY:\a
9*|G<uG
9+l\a
9,c :\a
9-W\n:Vk69
9.}c:Mi
9/5i:\a
9/Q 9y
9/x9l
9/}M9u
90-\v8B
90;Hc
90f#<0hm
90|ƺU
90Ì;yK
90ܳ:0?j:Id
91#v:4
91C-:a
92$n9c
929ںOD
92;d\tr
92<T;v
92B;F_k;gl
92B\r;F
92_J8
92i;9d
92ճ:fp
932;A
93;fK
93R;\a
93Y\e;'t
949^;2
94UzPW
94ݻ31
951\t:J
96;MC\e
96<Ns
96K"<i
96VR;v
96qe8
96ލ:ͤa9
9738;L
97\r; AS
97d]:=w
97ڻZB
98/ºza5:B
98VŻ^I
98Wdu
98m:$J
99-9X
991%ڹ\b\n
99\bS;.G
99\fu:U
99fɹmL
99q\a:a
9:R\r?9
9:[i59
9:ck\n
9:rM9vG
9:rл#\tV9
9:x\tK
9;&QH
9;)NN;k
9;3V;\fV\f
9;7Nz
9;\n;jk
9;\va:4K5:`iX
9;_\aS9iY0;0
9;a?9
9;jm7<Cp
9;m_J
9;qtE
9;|P;eW
9;|\nHcC\bH
9<'md
9<)M72
9<1*:F4
9<1;B
9<90o
9<H8d
9=8H;J
9=\tuȼp
9>=N9
9>LXN
9>uQ[;Y
9?]X9\v
9?m8:7
9@@Y9ZS
9@We:>5
9@\nY9
9@мYF
9A';o
9A\b~6Hc
9Ar-:{f;9
9B J:s
9B<\bI5
9B\ef9
9C\b~)D
9C\b~4HcR\bD
9Cu,fD9y
9C빔Zƻm
9D$Pu\tA
9D%W9
9D*\v
9DBu9
9DE\f;aUF
9D\t/9a
9D_\v:G
9DgX;STU
9E,E:G
9E;3r8
9EE.9Y
9ES9\n5c
9E\b=B\t
9F) 90
9F:cJA
9FF>\\d
9FHtJH
9F\bt\fI
9G:P᭺\e
9G:hO
9G\bt\vI
9G\ft!I
9G\vS:$f)9
9Gg:m\e
9H7&;1
9H;CPv
9HPu9*ms
9Hn%:U
9H}\n:5N
9HŻyTw:D
9Idɺu
9Ig:Y
9Iڢ;LN
9J;N3W
9J>t9
9JHi:w
9Jk<jw
9JÊ:j\v
9K :#R
9K%{<0lj
9K-R;ys
9KG?;GD
9K\eg;C
9K\nM
9K\r:a
9K];7
9L>bN2
9L\bF
9Lj\f
9Lڂ;U\ag9
9MI+;{C
9Msd87
9N%|6
9N7w9}G
9NIz:G
9N\rC9
9NeغVb
9O';S
9O5S;q
9ODp;l
9PSc;Y
9Pa]9(,H9
9Pwָ\b
9Pʫ;A
9Q.ȺPE
9Q4:)I6
9Rp:k#\n
9Rͻ:P
9S1ֹAC
9S7]d
9S>K<C
9SP<Q
9Sk\n
9Sz\e9q9
9T$PtJH
9T1[:}LQ
9T9]:x
9TF;loQ
9U9¹eO\e9
9U;6[v
9U;\e
9U[C87
9Udչm\rV
9V<7;Kt
9VBA;2
9VL;W
9W!s;{m
9W6!;x
9WQ;DVԻ\n
9W獷mf\r
9W裺Q>\v
9XEC8Ii
9XbN:9R
9XɹyH
9Y$v:D
9Y(1;bk
9Y_Q8
9Z3ʻeG
9Z47<75C
9Z<;Dp
9ZQK9J
9Zzɷb
9ZӠ9i
9\\\vh94
9\\dk9R
9\a><kY
9\aXN;m
9\az;bpj
9\b4B
9\b\ed;\b
9\b\fT9T
9\bqm:z
9\bwn
9\e:H
9\f;qK\n
9\fyͺR
9\nd7
9\nh_9I
9\r\tp
9\rz^;5
9\tRD
9\tx&;z
9\v j9hKU
9\v.S:V
9\v:x9\b
9\vFz9v
9\vQx
9\vde:U;:t5
9\vhe
9\v~8
9]!/9\txD
9]\am
9]o?9]o
9^ t"H
9_hs'H
9_ns:i3
9`C;No
9a*p:\n
9a,\a;Z
9aw\t;RA
9b!}Hp
9b;nj1
9ba4 Y
9ba|H
9bdt;vCb
9bl-:3l
9br%<7
9c-d:7
9c-m;A
9c\\99E
9csb9w
9d;e4
9e9O:e
9e:\rf\n
9et~;l
9e{\b
9e|I:P
9f.X8\a
9fQT:q
9ffffff
9gN>9N
9gfr9
9hG5:f
9hPJ;4
9hU<?km
9h\\F
9h\b9
9h\r;\alS
9ha\t:j
9i?>H
9iL$:-p
9ia{90
9ih\r:I
9j;i}W
9j<\e;9
9jK;Tl
9j`M;p
9kB\b:F
9kEM;v9
9khO9ad
9kv\b
9kwͺAB
9k{I:c
9kO[x:T
9lDŻط\f
9lt\e6
9m2?<W
9mN캘UQ
9mP/:U
9mRӹ\f
9mXZ:L
9mu8;#q
9n4\t:T
9nD=wD
9nT":B
9oE#9
9oF-:p|V:6
9oF\v:I1
9otx:7
9o|;967
9pS[7z
9p\aJ
9pfM:(\e
9p}\v
9q+B;nn
9q;tx
9q\aڻs:\t
9q\r8;$V
9rcE9V
9r~?9
9rļ8,w
9s\aԻ{O
9s\b~63
9s\vY:n\v8
9s`A;L
9t$Pu\t
9t6%;w
9t:VW
9t:qY\n
9tL)9'e
9tVK9
9t\v96
9uve9
9v J;*0
9v.ƼS%B
9v\te9
9v\vE9M
9v\vz
9v_u;h
9vg@:A
9vů9tH
9vԼR5ȼri
9w3/:ͥs
9w8=H\v\n
9w9\t:lϏ9
9wPA:V
9w\bt'HcW\bH
9w\b~tL
9w\eS
9x,<dy
9x9;P
9x>\f
9xxr9SYo8
9yH9B
9yI?:r-ȹm
9y\b~\\Hc
9z8OH
9z\e5:{K
9z\eպ2
9zmp;oH\t
9{ M9Y
9{6r:u\n
9{\bu\b9
9{\fu\t9
9|7[9Uu
9~0t\vH
9~6ѺJ
9~C:9
9~D1;d
9~\tD
9·L0x:b
9ĉA:q
9Ļ]1q
9Ż;Zb
9ƎD;7\e
9Ƭ49hky
9ǘy9&\rw9
9ȮB80I
9ɖI;gu
9ɫѺ4t
9ɲi:kJW
9ɾCF8
9ʁ:pAv:3
9ʙF;'Aa
9ʚ˺GV|9Q0
9̔E<c
9Ϫλ iX8
9Ͼ1:U\r
9ӽr|ȽT0C
9Ժd=m:r
9դ?89
9ջrF2<J
9اB:J
9طx:9
9ٽ2Va
9ݙ-9X7
9ݶg;H|U
9ߛ?9F
9ߟ=x3
9ờy\e
9鷬9>H
9:Z\tI
9:uXQ
A :\a.L
A ;\f\r
A \\L
A \\g H
A"Yt/4
A# Generated by Steam Audio\n
A$¼1b0
A$ƻP7
A'i:E
A(H+A H
A(L+A H
A*D;iײ9
A*YT3\b
A+=p7
A+]0A
A+^0A
A+}0A
A+~0A
A+ƉD$hD
A,8`e
A,ba~\b
A.5<sx
A2a<\\w
A2ٸcʞ8pm
A5;"f
A5g;e
A8<$u~M
A8@0u\fH
A8@0u\fI
A8@0u\tH
A8@0u\tI
A8A0u\fI
A8A0u\tI
A8G\buBI
A8G\buGI
A8H+A0I
A8H90t
A8L9 t
A8L9(t
A8L90t
A8M(u\rI
A8W\v|$X
A8^8}SD
A8m(u=I
A8z,u\bH
A8{,u\bH
A8}(u\bI
A9(݊9\n
A90~(3
A94$~<E
A96u\bI
A99R\fH
A99~6H
A9<C;\e
A9>u\bI
A9D$\bs
A9F+\e;a
A9P0t\nI
A9\riֻ5
A9_H~6H
A9}H~<H
A:8ucI
A:HBι5
A:\at\vI
A;2#z
A;>M3
A;>VP
A;E8v#A
A;Exsd
A;H7,:x
A;I\b|K9
A;Jk\a
A;W\e
A;\aʆ93
A;\e7F
A;^Pc
A;czC
A;v<s;Kq
A;|$lu4A
A<$90
A<GfS
A<GmO
A<HrH<\a
A<l;5
A=!U༾JL
A=:t9
A=\ews
A=\rw
A=cT9
A=k"N
A>{rS=t
A@K=q6I
A@Yt$P
AAW:uk
ABCDEFGHIJKLMNOPQRSTUVWXYZ
AC\b<\bU\e
ACh B`z
AC˹Y&2;C
AD4<;tH
ADVAPI32.dll
AG:^3
AHH+A@H
AHYl$0
AHԻgɬ;q
AI(9%s
AI99C`N3A
AJ9"ݬ:R
AJC<w
AJL$PP
AJL$`P
AJ_n$ŘT
AK;Hv
AKZ<X
AKi;)lr
AKn:h
AM:am:PM:pm
AMFInit
AMFQueryVersion
AMX-BF16
AMX-COMPLEX
AMX-FP16
AMX-INT8
AMX-TILE
AN;`U
AO library failed to initialize
AOڻUx
AP9\f g:O
APD90
APD9\b
APIName
APIVersion
AP\r;li
APi9+\a
ARI SOFA API for Matlab/Octave
ARY\\/4
ASARAQAPRQAWAVAUATVWUSH
ASONASON
ASONASONASASASASSS
ATAUAVAWH
ATAUAVAWUA
ATAUAVAWUH
ATAUAVH
ATAVAWD
ATAVAWH
ATAVAWUH
ATVU`E
AT}9dI3
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03VAccelSet@embree@@UObject@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAH@$03VAccelSet@embree@@UObject@2@@sse2@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAHQuantized@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UObject@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UObject@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07UObject@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$ClosureTaskFunction@V<lambda_0257928c69f3ca6a7123b06d6f3b7ad5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_02ef727abba9baf050cb44766040526f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_050b646956caed7fdaa67b1d4ef38836>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_05b090693c19e65375dfc04e4614d831>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0770016c8ad601d2b3ee9869de84d45c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0773d8b51a03587d5ebba0f0babe1c61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0810e6a1c682feee9e21662b6d5895fd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0ba0f6951c95034592039939e46e6adc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0bf7e7f8026686a4e169d2a2a3fbc284>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0c8a48911d9bc79b5f63ab68fda175d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0cb4938c3329244fdc7d28e8b68531d8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0d9816577c66ed0e5876af74f65ec1db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0f7d48f0f13c849ea2f5d5d06cc32f61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_103b8eb5296c081133f5f0633a6e0f4c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1070d15b2e0a459f12353442e1087446>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_10bd3097dea0ffc4d7ea5f99aff55ff7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_10edfa8ff134489e84f7d6842fbc9e53>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_111454f9162f4fd44ee79f232ea41ce6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1159125f07c0da4d1ef4a077b779c95d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_123bfa89286d9a69a48a2507fdc91ec5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1393b5adec419286175685534c302c36>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_142286e99081977ea9b431b977dc397b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1465822f4afc21711940feab4a96b609>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_14a2b0a7490cecf62e5c1db7e187e003>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_15c1675cce59426cee48e7d3701830a1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_16bd739913477f65c3b295a4a9a3f780>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1754c6088f7d2e7d8e5d85049ea46eeb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_17d4f0c18989a074d0b73f3e32af3e2d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1880cd30ca9875de576e86fdcbc9aea9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_18b6e499d28522ad747e42f02fe514e1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_19a60362099440456374c87deae05897>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1a2ec9725e19309b34301891f7ef37e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1b881d296a37095bf2ba4916f5766bb9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1b963dc7c01448ed9caf0d427c40482c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c483ea2f1582478c6c36bcdf50a5ac5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c53c660fe2e31e74957829702466677>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c7d7fa76e2ecd4691d00f6774bb98cc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1d3d46b83459c751b5a1d3866bac4d84>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1de437dcfdac90722fd45cb17c885504>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1e4859f33cc101bb139d2d68512ab37f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1efb61c2450c0d64b50121ed4ccf7512>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1ff75bbda1119736a8ea2bffa74f1117>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_203168769a8752ed39c0084eb5e0f86b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_237a8dac36ab9cef0f09490973046d65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2564acea42ca70f5289378535b1a5fda>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_25818e8b46e81478b20a71647dce67b0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_25fa0f05dd69fd0fbb5d98e1b9f22a17>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_277246a1dad0b789de0a5bf300615a69>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2785e509a66b39750953fa2172977bc6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_28ab207b4a4cae8f2a329ddaaa8347ab>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2983dbeae842cbca40c80bf7c793ff50>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2bcfad3a1040075454eb8c492a4817a1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d19c8f57b057314e1eba0879795a2d3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d4f244b7e192fa43e226589d452c701>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d7849d795cecafc716deb9906d0679d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d8b8f927bcf3f56c8e097fe75fb6a9b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2eebba4634f99d4722efcb197e612f81>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2f1a84cd769cdaf119ff64e0db1ac73f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2fd1025fa3c16d025feaa7c82cac6e45>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_30292f8def386cbd3ab393de8852bc8d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_307a912a967dbe18ca3d867cf49db7bf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_30da547d4d136440398053afe6d6df52>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_324f8f85fa5a734b0d69e373a8615fde>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_333cd141d30f0c3d1182719aaba1ca1f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34687d5f8161bf526d0ed813b8bc2956>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34788c56ac2c8d8d43be324f69291a1d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34f6c0c15de95f59ebc592d1a646999f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_35955c6a6d524fbc4260398ea787ea12>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_35aab39df7b5f8da4606f471a502b4b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_364906aee425af1aee8cd5882b619dcc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_36d192ec4c56e9df0060dbd486f9ba7c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3709d78c9da312d1da6a52b8a7ed02eb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_374c4fe9bc8934a13c1dfba0c8a2e3fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_38b497ee7dde3dad4a2bff651d24f01e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_39ae3cd435bbc28b90f1c4fcf8a9f2cb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3bf6dbbfa27fcd585f246e455d9164d3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3c183140e38f6db62b774fd8bd404466>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3d5e40bb487df58a36c0f1bd0972ce5e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3dc49f9a80eb9d6a2ca9dc4b73f6df9d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3e52b8c63300cd110fa13ae0b7c1cd60>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4019ef4b11105db1b5343b7f18c18453>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_402a737f13eafe9fe16d70ff6a894992>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_40845830eed773233b2942955217836c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_46f0b9a674db9f12d178d60ec90bd3b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_470e83d3d8279e1c869990724c4026e1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_48756a50904fde6adffda6e05318fa21>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_48eb3204b05163a7edd86df9082ae2bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_493c4fcd97d59cfa23518cfe7cef909b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49431b271f192c26f3d82d74f978add2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49a55a7560c70477acccc84f560607af>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4af68bccd17ee4982ce6cf6c17df8fb2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4b6cea141daed67a603d8c3129f48861>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4c09c780d1c23c4be6ef9f0906c92c13>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4cf4a25052f797060e3602408b7d83db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4d1d9e37a82f7399d0daf11b0e003fe0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4d860d2828d694467f37646af49512ad>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4dfaeb055a2848a18e1c2a693664e365>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4e9a920d3a0e8077c04dbbeaba34d69b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4f52ac6b547d139d4666992287a1d33e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_508d5c5eae2e09ca974019602570497b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_519d6864de56dd813715a3324da6ab03>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_528c6aeae8d7a6235882068fbe18ba29>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_52e835bfebfdf243c300b842bcfbd693>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_55d7d6d7e9c3cf78dc032fa18e0a1756>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_56228ec77c1bf800c98ea10cf09dbdca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5806bf8c82548594d7b14a6031d3becc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_587c3387fd00b5c47d777280f639ccbb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_58a007f1dcfdcf2842a0651c9cf4fb16>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_596624f597bd50de0edc513e65f10248>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_59708c2094bd10121cdb0d0feee13575>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a4619dfc5b3f52888e410231d1b76c6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5b205f904e6a5e922c78b0780f6595fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5cccc2026c15c9f772dc34068e64dbd3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5ce543f4f6f460823047169427ff959b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5df809d8ba8774c0c3e07d9023dc361f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5e0af431c85d723742ac31139cf4f6cf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5f057fc8dd507ba4420188be12b864a7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5fa18547fd1c49e47f8a1482795f6bfa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5fbae35bffd37dd4454c255c3bfe1423>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5ff1317532aa23eaa4235a4897d071c5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6076a43db63a4a654b76b3906f0fa336>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_612f275e48608a47fe6f208f6f90ef2c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_61a5893ea96d3e3c22460dd21bc6918f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6208554dadd1a347baaf9698a23260b0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_63774194788fd674aeda94589387ad7e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_63f62a6d4554716cd85d4437cc4e8d6b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_642da8bb02350bf3bc1e2d17da1782a2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_658ade971d81b8d2c4aff7e1c8316fd9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6928df31523de1d77177658324507289>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6972a451ddef89ded0359c514c93674c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_69b60174e657725950226c292dfe8810>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6a1d60d8252eb56aa624ccee38aae3f8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6a9765672699b15200b9e625cbe78fe2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6bd70ec753e41fe9ef52ce2294285ffc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6dd588069b0497955952869d46623054>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e12b1e7ea1c3cabb970d9aad37b880e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e1c069ffa23258a04e4132daf8ae5a6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e24166b0a6550ce4ca0fd16b21eaedc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f395463036b9f2ef27cb319ec541679>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6ffea1e26fc61475c82a269c9412ff7c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_701f58262cbf59178d70f368547d4be4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_70adec8fff91ba581942c3e7e58800bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7137bbdf7501823d38edf36447a4c5da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_72eb2d970ec2715c3cb455dc8b65e700>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_73d76564d82f8824c0d011a96892e820>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7447278d269d570e2d5a575a040ac0d5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_761150a6dbf7b3e8e149529b93d7def9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_769b7396f06b114caaad51b6d1c2033a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_76ecf3bf9e9ee6806f09118ecd9063fe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_791ac13d4d779712e0fc089e446ba11d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7926a52cb91716c6e9c7b46e42baf2b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7a3f31a682378d6bb22d8b79968ded5d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7a41611522e2560efa455142ae8ae3f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7b832da9ba6e6ec113b237e338498c20>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d52ab0d031b883d77281a985b5128ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d71192f9be9b7b5111bb3afe6336625>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d7b9a8a8418fcb9f2476126aff61395>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d90ad674d8d89632a4cc3c6a77a230d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7ec6b5632644aa2f0854d1191db4876a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7ec874256f6ac9fb0cb0ccf0b23709fc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f4ecb58a9eca6a896f3913eca50e647>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f688a3c57e8b39313eac45d84608341>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f891e51f0ef2b3b767c0c2ff1810fc9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7fa6182c81737d0353c54febe17bfbe3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7fab0ac51a8990f2a7558b9e7bf9140a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_80bba59ad49d13103ad66077542bc181>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_81325ab80d9ffd100b657d78df5f2705>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8139ebda25fc1cb5d72fb097fc720fb9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_82f44bf085fe83988536c56ffe856489>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83743a4f871b15f1a702394e12997bf4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_84b6c724f2443266e7ce254992f9c5da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_85d19732fb13b56beb1c219db1abe8fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_85d203de33fad9040c2eb1d8e4b12ebc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_85f24a3907079e650ca1db2021e42117>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_866091200b38baa804ebb0acd27cdbe3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_869ce95d276aa5f0e5ad098cae581aed>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_87fc12fb3ccde100f0a609f5c0fd3efe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_881194d5bcdf56d290b5a3890c7a7fd9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_884393cb3e516c3d8a80c164c6933801>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_88815198c2a58dc16ce4c22605b79ab2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_89b1cbae6bac656013c873e1b7d54903>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a022dfc4ff070f70bdf133f193a8ee1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a6f7d40767aad6609d3ca0b66f1dee7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8aac9ef93071c0774417f4dc8397b96c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8b8d7bdc0350d5ca99ff86da49d813c7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8bb36c840ee4e2d1368a0c16750e547c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c0daac60dcd7ba85b78d65683e249cf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c73507aad286028b6059eb192af892d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8cb4b4d8bcabfa96351bf47410136244>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8cc2b536a046cc8ac89776f7a665e528>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8d1805ec003b6fbd327129a9f3a725a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8d2db962c0f243ae1a45e956ee5728d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8f02bd655e3495eac01ecb3adbbea0c0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_90ed84fa9333cdc12bda8b8d14ad8fe0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9152e8397bdc19577a0393abaf1b6dd0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_91742af8957171a092115533b682d41a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9241f93aadcafa7b129d36c659088890>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9249e8aa16a2d29a7983072b56338515>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9385af4936c854d2afe7f028e7e3ee65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_93984adfa5c9e9b7fdebd37ff069f084>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_93e55b2f7065a3bdd2d2b66c9ba2c1da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_943576034df25ad54b025192b8cffb10>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_949501f6172a69753cb894e7be6f4ac7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_94fe20416c45f7915d75432d64d9334d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_952ff9f245e0e20c4f4453f24ba87d85>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_95cc731380b2fab9d8d1b177110fb7f9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_963c47aeb0ddb526503fc0f9cb48533a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9648822dc6f816d0211bfcb8628576f2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_97613cd1c18bf2204ec7d59dd6c2efe6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_980311499bf94cba279fc3e02d6c8e25>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9adfacac89ae04da373bb2c86bf2e785>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9b9375a65e69303d3d685621f3f002df>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9db83e7e70a7c8ba33a06ed4b85b3976>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e1b0c1d4f37825716630f67a2282b86>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9f4ad124d614903c866b98a110355e96>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a1d4ea9e4ba6d18f9801458e384703a3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a23496410d5cc29c9a9a40d5466b2f49>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a3145c4db4c07e91b74a82630ed60970>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a4208c0a8979a608aca52e893a4df9b8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a44afce2e29d983e48149fa0bd663010>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a473ef03c623ac047962bdb06b5479ca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a506632a0478e305a2a9e0fb82c9a6ba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a6934328d76b0f105e91326357ee4397>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a70f7bb15801ea4a0648e665aa087fcb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a7c826f3e82e808a18562b298e752e25>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a7e93f04524f80620b388d6353a1f85f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a8b2023aa1b4d1a7199f8af3bb7763ee>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a8bb5dd076802398bbdb2bb82bb6b808>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a9d22604637b8ab881820f7262f57ddb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aa2b3d86106154a41df4d9e750d27e29>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aa41b87e783e4d6d1cc483279e07b81b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aa649782e95517a76fdb98d192cff8a3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ae88fe0c7f2a852c30e9582f143c23ea>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af2efa9cb3646c20724995a52541df4d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af4af31444d1dcf4037a6119b331bade>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af60c21cc7f286de97aa0bfefd3f4c95>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b02a51061afae8ace83b3547b12602b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b02fd97c6c7c1a650eb55e6ebd421022>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b15e0bf1a6a3756600ce6412ff604756>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b181c1383ded4db84c53e8c5e12f4607>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b293711f313ff97f0acda51fe2f55992>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b399192e05ed586364e549af91af1089>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b45bfaee1b976145c0498b58fdb3a1ea>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b4cd2aca1bbac98ba795a14d230855ce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b589f3793c9428fe1b0321ccee3aad61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b902b2bacef501b1eb21b79562702b69>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ba11a5935e2a0ad0f5b0151297439f49>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bc5e7b60f199be10075f04536edcd8d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bd1501ca16ab979bb9c6a91264c0ef79>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bf88c16418418e9d04f2d0a74994d5bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c0955aedf17321d1ddb93318daf5508e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c0c956f33ac4d840b0f2a78dc9649eec>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c27ccc40853f6653f4126af1f5587982>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c308f3f4f90cb392f9b6a1afdedb8fa7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c5b37c3d4343119f010a70c507f5fa35>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c64ded238af9365da3bb2fb9aa06d2c4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c7a2e929408f0fe05b554ed2e2c60b4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c84049b567c18d000c9f14ffb8574de3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c8c96faa707bef900dff317fab2982f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c8f03e1c48140a7c0a2eb449dd0e1c34>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c9d47d2a6c0ca0586e511764ee2a2660>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_caa044740ccfe4a6927e4afa964b7a53>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cad120d6a3f256d13fe99516a5a33a8c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cb0b673290f3ffb7b0d9066c6ab85b20>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cb2120e9b24416c3e735c0fc7b9a22cb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cbf0e018a22e77e1d8203b6989d4fc50>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cc0550cacd0e26dcbee934735dd7c566>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cd65f27202c6944bcdb92cd324393d2c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cd91ae3365950228a915ee058c35cc6f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cdb8465e765f90309f597d7a8eec059a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cfb4df5bdda74f8f01e37a4dd9fb02fa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d0248521766bdb5cae133d7e4133acef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d14f8e6bb372a4f82c01d529ef8f6797>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d1aa5966c6b0f9baed433e5ae134fd3c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d232ccb9559db976d92b550558ba6081>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d4625f1e524954737e1c304658606ff5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d4f8a24a716d3c865e8f813376763d96>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d583195d41bb96e6e15f56bd9b10e414>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8bf7531551fd906ae24fcffe76011e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d971ad00998fa48a17bd80b22f7660b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d9f5ab55c39609572c638d6b6428a7a3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_da96c3ac85e55a41a8750c63c7ce8537>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_daf5afdcf783a7225068096e149dd869>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dc0fc851e427b8494ef13afc8d0ebad1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_de581c8ebdd980d24c86cbca4215513c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_df9052d790dac606cf5a47c9d876c608>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dfcf2bb000bbe6dd33de7b65de01cf43>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dfe97666f81a8a9621776384ff25b219>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e048fd7cf3385f4678eccd267ef05d8b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e0518c94692270d68a8bc445c176346d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e0cd4179ccb986fe30e51c91dbfaf4d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e0ebd27de42e56945aa333f9c23150fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e150f3251fef807f4cef8bf9b86ebe6a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e16a78992ea44989935f19163566fc39>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e1e7cbf5942d94bfdd4d5b63d6a8b060>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e2be729290318259e0eec8a02cf5019b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e32b4ba674e64610246503fd7a7e2d68>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e3a1910586cc979ff1ab63b3aea48d27>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e5d4ce89eea4f46ccc67ca69aecfa6dc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e5f67dba5eefee75a32542ba3adcee30>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e91231a8a971d33fcce73921f66993f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ea8b8104235951fa3f399193535068d0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eb2429a57718bce23b7d1eac85038a8e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eb55f89d2c339b07a708773692607068>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ebca007067980e8000c5006e83d27415>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ec4c8c147918a8d768009fd5b551b5ed>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ec4d0eb5b6fed30b55121dbb7767792c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ecaf0da6470494d8972033a51ea6668d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_edf43b92f1a50dcb9304df3415c38318>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ee3ef6a9143c2fd26054b2bd0a01c510>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ee5fe37d3e2608b4336ca03267d352be>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f021cdef2cbfe511e6cf411d575df7e0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f035ab843647e98a8c72603effe69b12>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f176e0f30d685b750646c0a2baccf296>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f2bea8a1dee18cc4582d2ef5cb538d0d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f3eb69b11fcd9a25a8f712cf84755c70>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f88672913bccab0428a46555adc85e6e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f88925e772ef98816ab7eb5e40a10a64>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8aed9c70924e61b413f0ef14704f70b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8fa0d76bf6846da50700a400af0a5ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9c9d2e87cd66f42c75f50f430def7f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9f0bab5d448810eee5808d354c2f0f1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fa9ceb962d5423042e9694103eb6e93f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fb819125baff5b558ae74f00dd26ba4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fbb01ee15e5f4b27ee8320fbf60e8e54>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fc0ff580a5b442854e44c3c6deb6a15c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fc19415e17ea706413f0561e2a91e020>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fd6087856a329f8cc019cf1262bdbafe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fda3769582440d59c66ab3ddc3ad5a24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fdbd198e5b4ebd72dcf16140169c88c4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fe6fd13753666c6a6b315fd1a1433b87>@@@TaskScheduler@embree
AU?$deleter@VIScene@ipl@@@ipl
AUAVAWH
AUAVAWUH
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@avx@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@sse2@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$07@avx@embree
AUBuildProgressMonitor@embree
AUBuildProgressMonitorInterface@Scene@embree
AUCalcBufferHolder@RadeonRays
AUCalcEventHolder@RadeonRays
AUGeometryGroup@embree
AUGeometryInstance@embree
AUInstance@embree
AULeafBoundsInterface@?$BVHNRefitter@$03@avx@embree
AULeafBoundsInterface@?$BVHNRefitter@$03@sse2@embree
AULeafBoundsInterface@?$BVHNRefitter@$07@avx@embree
AUMemoryMonitorInterface@embree
AUPrimitiveType@embree
AURegressionTest@embree
AUState@embree
AUTaskFunction@TaskScheduler@embree
AUTaskScheduler@embree
AUTriangleMesh@embree
AUTriangleMeshISA@avx@embree
AUTriangleMeshISA@sse2@embree
AUType@?$LineMi@$03@embree
AUType@?$QuadMi@$03@embree
AUType@?$QuadMv@$03@embree
AUType@?$TriangleM@$03@embree
AUType@?$TriangleMi@$03@embree
AUType@?$TriangleMv@$03@embree
AUType@?$TriangleMvMB@$03@embree
AUType@Bezier1i@embree
AUType@Bezier1v@embree
AUType@Object@embree
AUType@SubdivPatch1Cached@embree
AUTypeCached@SubdivPatch1Cached@embree
AUUUUUU
AUUserGeometry@embree
AU_Crt_new_delete@std
AUbarrier_sys_regression_test@embree
AUctype_base@std
AUfast_allocator_regression_test@embree
AUmessages_base@std
AUmoney_base@std
AUrtcore_error@embree
AUtime_base@std
AV<lambda_0a5eb190081202e0f28c290d3f31c81b
AV<lambda_0cfbd31dcc0320209a6f9675d2dc252f
AV<lambda_498b6f04f2beccab8c714618b3ad669c
AV<lambda_62a9d32afc8d6b63df56e96e440ec261
AV<lambda_845e6907f0dbd1951683b9def278af13
AV<lambda_9aaaaccd033d9521153b989e3b20efb5
AV<lambda_ad5078782d34ed51c56ec29c040ebbb4
AV<lambda_ad81efa77d3f586fae2d16f50912b9cf
AV<lambda_dff3c1b6999eee227e24249907461f6e
AV<lambda_ee6a2105f198a1070623061950e8e630
AV<lambda_f5a6bbee718852bc735793355e363d30
AV?$BVHN@$03@embree
AV?$BVHN@$07@embree
AV?$BVHNBuilderInstancing@$03UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderInstancing@$03UTriangleMesh@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03VAccelSet@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$03VAccelSet@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$07VAccelSet@embree@@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03VAccelSet@embree@@UObject@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07VAccelSet@embree@@UObject@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNRefitT@$03VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNRefitT@$03VAccelSet@embree@@UObject@2@@sse2@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNRefitT@$07VAccelSet@embree@@UObject@2@@avx@embree
AV?$CLWBuffer@D
AV?$CLWBuffer@H
AV?$CLWBuffer@M
AV?$ReferenceCounter@PEAU_cl_command_queue@@$1?clRetainCommandQueue@@YAHPEAU1@@Z$1?clReleaseCommandQueue@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_context@@$1?clRetainContext@@YAHPEAU1@@Z$1?clReleaseContext@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_device_id@@$1?clRetainDevice@@YAHPEAU1@@Z$1?clReleaseDevice@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_event@@$1?clRetainEvent@@YAHPEAU1@@Z$1?clReleaseEvent@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_kernel@@$1?clRetainKernel@@YAHPEAU1@@Z$1?clReleaseKernel@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_mem@@$1?clRetainMemObject@@YAHPEAU1@@Z$1?clReleaseMemObject@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_platform_id@@$0A@$0A
AV?$ReferenceCounter@PEAU_cl_program@@$1?clRetainProgram@@YAHPEAU1@@Z$1?clReleaseProgram@@YAH0@Z
AV?$Stream@H@embree
AV?$Stream@VToken@embree@@@embree
AV?$_Ebco_base@V?$allocator@UImpulseResponse2@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VBinauralEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VBufferedIndirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VCompressedEnergyFields@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VCompressedProbeBatch@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VContext@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VDirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VDirectSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeInstancedMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEnergyField@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHRTFDatabase@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHybridReverbEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHybridReverbEstimator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VImpulseResponse@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectMixer@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectPartitioner@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VInstancedMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VInterpolatableImpulseResponse@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VJobGraph@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VNonUniformProbeBatch@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOpenCLDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOpenCLDeviceList@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOverlapSaveFIR@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOverlapSavePartitioner@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPanningEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPathEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPathSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeArray@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeBatch@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeClusterMap@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeNeighborhood@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VRadeonRaysDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VReconstructor@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VReflectionSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VReverbEstimator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VScene@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSerializedObject@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSimulationData@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSimulationManager@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VTANDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VThreadPool@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VVirtualSurroundEffect@ipl@@@ipl@@$00@std
AV?$_ExceptionPtr_static@Vbad_alloc@std@@@?A0xad5a25bc
AV?$_ExceptionPtr_static@Vbad_exception@std@@@?A0xad5a25bc
AV?$_Func_base@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_base@XPEAVBuffer@Calc@@@std
AV?$_Func_base@XPEAVDevice@Calc@@@std
AV?$_Func_base@XPEAVEvent@Calc@@@std
AV?$_Func_impl@V<lambda_498b6f04f2beccab8c714618b3ad669c>@@V?$allocator@H@std@@XPEAVBuffer@Calc@@@std
AV?$_Func_impl@V<lambda_62a9d32afc8d6b63df56e96e440ec261>@@V?$allocator@H@std@@XPEAVDevice@Calc@@@std
AV?$_Func_impl@V<lambda_dff3c1b6999eee227e24249907461f6e>@@V?$allocator@H@std@@XPEAVEvent@Calc@@@std
AV?$_Func_impl_no_alloc@V<lambda_0a5eb190081202e0f28c290d3f31c81b>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_0cfbd31dcc0320209a6f9675d2dc252f>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_845e6907f0dbd1951683b9def278af13>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_9aaaaccd033d9521153b989e3b20efb5>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_ad5078782d34ed51c56ec29c040ebbb4>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_ad81efa77d3f586fae2d16f50912b9cf>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_ee6a2105f198a1070623061950e8e630>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_f5a6bbee718852bc735793355e363d30>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Iosb@H@std
AV?$_Mpunct@D@std
AV?$_Mpunct@G@std
AV?$_Mpunct@_W@std
AV?$_Ref_count@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std
AV?$_Ref_count_obj_alloc3@UImpulseResponse2@@V?$allocator@UImpulseResponse2@@@ipl@@@std
AV?$_Ref_count_obj_alloc3@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@V?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl@@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsBinauralEffect@ipl@@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsDecodeEffect@ipl@@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsEncodeEffect@ipl@@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsPanningEffect@ipl@@V?$allocator@VAmbisonicsPanningEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsRotateEffect@ipl@@V?$allocator@VAmbisonicsRotateEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VBinauralEffect@ipl@@V?$allocator@VBinauralEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VBufferedIndirectEffect@ipl@@V?$allocator@VBufferedIndirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VCompressedEnergyFields@ipl@@V?$allocator@VCompressedEnergyFields@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VCompressedProbeBatch@ipl@@V?$allocator@VCompressedProbeBatch@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VContext@ipl@@V?$allocator@VContext@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VDirectEffect@ipl@@V?$allocator@VDirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VDirectSimulator@ipl@@V?$allocator@VDirectSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeDevice@ipl@@V?$allocator@VEmbreeDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeInstancedMesh@ipl@@V?$allocator@VEmbreeInstancedMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeStaticMesh@ipl@@V?$allocator@VEmbreeStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEnergyField@ipl@@V?$allocator@VEnergyField@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHRTFDatabase@ipl@@V?$allocator@VHRTFDatabase@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHybridReverbEffect@ipl@@V?$allocator@VHybridReverbEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHybridReverbEstimator@ipl@@V?$allocator@VHybridReverbEstimator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VImpulseResponse@ipl@@V?$allocator@VImpulseResponse@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectEffect@ipl@@V?$allocator@VIndirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectMixer@ipl@@V?$allocator@VIndirectMixer@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectPartitioner@ipl@@V?$allocator@VIndirectPartitioner@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VInstancedMesh@ipl@@V?$allocator@VInstancedMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VInterpolatableImpulseResponse@ipl@@V?$allocator@VInterpolatableImpulseResponse@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VJobGraph@ipl@@V?$allocator@VJobGraph@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VNonUniformProbeBatch@ipl@@V?$allocator@VNonUniformProbeBatch@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOpenCLDevice@ipl@@V?$allocator@VOpenCLDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOpenCLDeviceList@ipl@@V?$allocator@VOpenCLDeviceList@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOverlapSaveFIR@ipl@@V?$allocator@VOverlapSaveFIR@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOverlapSavePartitioner@ipl@@V?$allocator@VOverlapSavePartitioner@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPanningEffect@ipl@@V?$allocator@VPanningEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPathEffect@ipl@@V?$allocator@VPathEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPathSimulator@ipl@@V?$allocator@VPathSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeArray@ipl@@V?$allocator@VProbeArray@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeBatch@ipl@@V?$allocator@VProbeBatch@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeClusterMap@ipl@@V?$allocator@VProbeClusterMap@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeNeighborhood@ipl@@V?$allocator@VProbeNeighborhood@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VRadeonRaysDevice@ipl@@V?$allocator@VRadeonRaysDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VRadeonRaysStaticMesh@ipl@@V?$allocator@VRadeonRaysStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VReconstructor@ipl@@V?$allocator@VReconstructor@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VReflectionSimulator@ipl@@V?$allocator@VReflectionSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VReverbEstimator@ipl@@V?$allocator@VReverbEstimator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VScene@ipl@@V?$allocator@VScene@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSerializedObject@ipl@@V?$allocator@VSerializedObject@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSimulationData@ipl@@V?$allocator@VSimulationData@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSimulationManager@ipl@@V?$allocator@VSimulationManager@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VStaticMesh@ipl@@V?$allocator@VStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VTANDevice@ipl@@V?$allocator@VTANDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VThreadPool@ipl@@V?$allocator@VThreadPool@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VVirtualSurroundEffect@ipl@@V?$allocator@VVirtualSurroundEffect@ipl@@@2@@std
AV?$_Ref_count_resource@PEAVIScene@ipl@@U?$deleter@VIScene@ipl@@@2@@std
AV?$allocator@UImpulseResponse2@@@ipl
AV?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl
AV?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl
AV?$allocator@VBinauralEffect@ipl@@@ipl
AV?$allocator@VBufferedIndirectEffect@ipl@@@ipl
AV?$allocator@VCompressedEnergyFields@ipl@@@ipl
AV?$allocator@VCompressedProbeBatch@ipl@@@ipl
AV?$allocator@VContext@ipl@@@ipl
AV?$allocator@VDirectEffect@ipl@@@ipl
AV?$allocator@VDirectSimulator@ipl@@@ipl
AV?$allocator@VEmbreeDevice@ipl@@@ipl
AV?$allocator@VEmbreeInstancedMesh@ipl@@@ipl
AV?$allocator@VEmbreeStaticMesh@ipl@@@ipl
AV?$allocator@VEnergyField@ipl@@@ipl
AV?$allocator@VHRTFDatabase@ipl@@@ipl
AV?$allocator@VHybridReverbEffect@ipl@@@ipl
AV?$allocator@VHybridReverbEstimator@ipl@@@ipl
AV?$allocator@VImpulseResponse@ipl@@@ipl
AV?$allocator@VIndirectEffect@ipl@@@ipl
AV?$allocator@VIndirectMixer@ipl@@@ipl
AV?$allocator@VIndirectPartitioner@ipl@@@ipl
AV?$allocator@VInstancedMesh@ipl@@@ipl
AV?$allocator@VInterpolatableImpulseResponse@ipl@@@ipl
AV?$allocator@VJobGraph@ipl@@@ipl
AV?$allocator@VNonUniformProbeBatch@ipl@@@ipl
AV?$allocator@VOpenCLDevice@ipl@@@ipl
AV?$allocator@VOpenCLDeviceList@ipl@@@ipl
AV?$allocator@VOverlapSaveFIR@ipl@@@ipl
AV?$allocator@VOverlapSavePartitioner@ipl@@@ipl
AV?$allocator@VPanningEffect@ipl@@@ipl
AV?$allocator@VPathEffect@ipl@@@ipl
AV?$allocator@VPathSimulator@ipl@@@ipl
AV?$allocator@VProbeArray@ipl@@@ipl
AV?$allocator@VProbeBatch@ipl@@@ipl
AV?$allocator@VProbeClusterMap@ipl@@@ipl
AV?$allocator@VProbeNeighborhood@ipl@@@ipl
AV?$allocator@VRadeonRaysDevice@ipl@@@ipl
AV?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl
AV?$allocator@VReconstructor@ipl@@@ipl
AV?$allocator@VReflectionSimulator@ipl@@@ipl
AV?$allocator@VReverbEstimator@ipl@@@ipl
AV?$allocator@VScene@ipl@@@ipl
AV?$allocator@VSerializedObject@ipl@@@ipl
AV?$allocator@VSimulationData@ipl@@@ipl
AV?$allocator@VSimulationManager@ipl@@@ipl
AV?$allocator@VStaticMesh@ipl@@@ipl
AV?$allocator@VTANDevice@ipl@@@ipl
AV?$allocator@VThreadPool@ipl@@@ipl
AV?$allocator@VVirtualSurroundEffect@ipl@@@ipl
AV?$basic_filebuf@DU?$char_traits@D@std@@@std
AV?$basic_ifstream@DU?$char_traits@D@std@@@std
AV?$basic_ios@DU?$char_traits@D@std@@@std
AV?$basic_iostream@DU?$char_traits@D@std@@@std
AV?$basic_istream@DU?$char_traits@D@std@@@std
AV?$basic_ostream@DU?$char_traits@D@std@@@std
AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$basic_streambuf@DU?$char_traits@D@std@@@std
AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$codecvt@DDU_Mbstatet@@@std
AV?$codecvt@GDU_Mbstatet@@@std
AV?$codecvt@_WDU_Mbstatet@@@std
AV?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std
AV?$collate@D@std
AV?$collate@G@std
AV?$collate@_W@std
AV?$ctype@D@std
AV?$ctype@G@std
AV?$ctype@_W@std
AV?$enable_shared_from_this@VIScene@ipl@@@std
AV?$messages@D@std
AV?$messages@G@std
AV?$messages@_W@std
AV?$money_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$money_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$money_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$money_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$money_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$money_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$moneypunct@D$00@std
AV?$moneypunct@D$0A@@std
AV?$moneypunct@G$00@std
AV?$moneypunct@G$0A@@std
AV?$moneypunct@_W$00@std
AV?$moneypunct@_W$0A@@std
AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$num_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$num_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$numpunct@D@std
AV?$numpunct@G@std
AV?$numpunct@_W@std
AV?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$time_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$time_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$time_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$time_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$wstring_convert@V?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std@@_WV?$allocator@_W@2@V?$allocator@D@2@@std
AVAWMcq\bH
AVAWUF
AVAWUH
AVAccel@embree
AVAccelData@embree
AVAccelInstance@embree
AVAccelN@embree
AVAccelSet@embree
AVAllocator@flatbuffers
AVBakedPathData@ipl
AVBakedReflectionsData@ipl
AVBatchedReflectionSimulator@ipl
AVBuffer@Calc
AVBuffer@RadeonRays
AVBufferClw@Calc
AVBuilder@embree
AVBvh2lStrategy@RadeonRays
AVBvh@RadeonRays
AVBvhStrategy@RadeonRays
AVCAmbisonicsBinauralEffect@api
AVCAmbisonicsDecodeEffect@api
AVCAmbisonicsEncodeEffect@api
AVCAmbisonicsPanningEffect@api
AVCAmbisonicsRotationEffect@api
AVCBinauralEffect@api
AVCCompressedProbeBatch@api
AVCContext@api
AVCDirectEffect@api
AVCEmbreeDevice@api
AVCHRTF@api
AVCInstancedMesh@api
AVCLWCommandQueue
AVCLWContext
AVCLWDevice
AVCLWEvent
AVCLWException
AVCLWKernel
AVCLWPlatform
AVCLWProgram
AVCNonUniformProbeBatch@api
AVCOpenCLDevice@api
AVCOpenCLDeviceList@api
AVCPanningEffect@api
AVCPathEffect@api
AVCProbeArray@api
AVCProbeBatch@api
AVCRadeonRaysDevice@api
AVCReflectionEffect@api
AVCReflectionMixer@api
AVCScene@api
AVCSerializedObject@api
AVCSimulator@api
AVCSource@api
AVCStaticMesh@api
AVCTrueAudioNextDevice@api
AVCValidatedAmbisonicsBinauralEffect@api
AVCValidatedAmbisonicsDecodeEffect@api
AVCValidatedAmbisonicsEncodeEffect@api
AVCValidatedAmbisonicsPanningEffect@api
AVCValidatedAmbisonicsRotationEffect@api
AVCValidatedBinauralEffect@api
AVCValidatedContext@api
AVCValidatedDirectEffect@api
AVCValidatedEmbreeDevice@api
AVCValidatedHRTF@api
AVCValidatedInstancedMesh@api
AVCValidatedOpenCLDevice@api
AVCValidatedOpenCLDeviceList@api
AVCValidatedPanningEffect@api
AVCValidatedPathEffect@api
AVCValidatedProbeArray@api
AVCValidatedProbeBatch@api
AVCValidatedRadeonRaysDevice@api
AVCValidatedReflectionEffect@api
AVCValidatedReflectionMixer@api
AVCValidatedScene@api
AVCValidatedSerializedObject@api
AVCValidatedSimulator@api
AVCValidatedSource@api
AVCValidatedStaticMesh@api
AVCValidatedTrueAudioNextDevice@api
AVCValidatedVirtualSurroundEffect@api
AVCVirtualSurroundEffect@api
AVCalc@0
AVCalcClw@Calc
AVCalcIntersectionDevice@RadeonRays
AVCalcIntersectionDeviceCl@RadeonRays
AVCompressedBakedReflections@ipl
AVCompressedProbeBatch@ipl
AVCustomScene@ipl
AVDefaultAllocator@flatbuffers
AVDevice@Calc
AVDevice@embree
AVDeviceCl@Calc
AVDeviceClw@Calc
AVEmbreeInstancedMesh@ipl
AVEmbreeReflectionSimulator@ipl
AVEmbreeScene@ipl
AVEmbreeStaticMesh@ipl
AVEnergyField@ipl
AVEvent@Calc
AVEvent@RadeonRays
AVEventClw@Calc
AVException@Calc
AVException@RadeonRays
AVException@ipl
AVExceptionClw@Calc
AVExceptionImpl@RadeonRays
AVExecutable@Calc
AVExecutableClw@Calc
AVFatBvhStrategy@RadeonRays
AVFileStream@embree
AVFlatBuffersAllocator@ipl
AVFunction@Calc
AVFunctionClw@Calc
AVGeometry@embree
AVHRTFMap@ipl
AVHlbvh@RadeonRays
AVHlbvhStrategy@RadeonRays
AVIAmbisonicsBinauralEffect@api
AVIAmbisonicsDecodeEffect@api
AVIAmbisonicsEncodeEffect@api
AVIAmbisonicsPanningEffect@api
AVIAmbisonicsRotationEffect@api
AVIBakedData@ipl
AVIBakedReflectionsLookup@ipl
AVIBinauralEffect@api
AVIContext@api
AVIDirectEffect@api
AVIEmbreeDevice@api
AVIHRTF@api
AVIHRTFMap@ipl
AVIInstancedMesh@api
AVIInstancedMesh@ipl
AVIOpenCLDevice@api
AVIOpenCLDeviceList@api
AVIPanningEffect@api
AVIPathEffect@api
AVIProbeArray@api
AVIProbeBatch@api
AVIRadeonRaysDevice@api
AVIReconstructor@ipl
AVIReflectionEffect@api
AVIReflectionMixer@api
AVIReflectionSimulator@ipl
AVIScene@api
AVIScene@ipl
AVISerializedObject@api
AVISimulator@api
AVISource@api
AVIStaticMesh@api
AVIStaticMesh@ipl
AVITrueAudioNextDevice@api
AVIVirtualSurroundEffect@api
AVImpulseResponse@ipl
AVInstance@RadeonRays
AVInstancedMesh@ipl
AVIntersectionApi@RadeonRays
AVIntersectionApiImpl@RadeonRays
AVIntersectionDevice@RadeonRays
AVLineCommentFilter@embree
AVMesh@RadeonRays
AVNonUniformProbeBatch@ipl
AVOpenCLEnergyField@ipl
AVOpenCLImpulseResponse@ipl
AVOpenCLReconstructor@ipl
AVPrimitives@Calc
AVPrimitivesClw@Calc
AVProbeBatch@ipl
AVRadeonRaysReflectionSimulator@ipl
AVRadeonRaysScene@ipl
AVRadeonRaysStaticMesh@ipl
AVReconstructor@ipl
AVRefCount@embree
AVReflectionSimulator@ipl
AVSOFAHRTFMap@ipl
AVScene@embree
AVScene@ipl
AVShape@RadeonRays
AVShapeImpl@RadeonRays
AVSplitBvh@RadeonRays
AVStaticMesh@ipl
AVStrStream@embree
AVStrategy@RadeonRays
AVTokenStream@embree
AVVWSH
AVVWSPH
AVVWUSH
AVWorld@RadeonRays
AVX23L
AVX2_E1
AVX512
AVX512BW
AVX512CD
AVX512DQ
AVX512ER
AVX512F
AVX512F H
AVX512IFMA
AVX512IFMA52
AVX512KNL
AVX512PF
AVX512SKX
AVX512VBMI
AVX512VL
AVX512_4FMAPS
AVX512_4VNNIW
AVX512_BF16
AVX512_BITALG
AVX512_E1
AVX512_EH
AVX512_FP16
AVX512_MIC
AVX512_MIC_E1
AVX512_VBMI2
AVX512_VNNI
AVX512_VP2INTERSECT
AVX512_VPOPCNTDQ
AVX53D
AVX_10_1
AVX_10_1_512
AVX_IFMA
AVX_NE_CONVERT
AVX_VNNI
AVX_VNNI_INT16
AVX_VNNI_INT8
AV_ExceptionPtr_normal@?A0xad5a25bc
AV_Facet_base@std
AV_Generic_error_category@std
AV_Iostream_error_category2@std
AV_Iostream_error_category@std
AV_Locimp@locale@std
AV_Ref_count_base@std
AV_System_error@std
AV__non_rtti_object@std
AVbad_alloc@std
AVbad_array_new_length@std
AVbad_cast@std
AVbad_exception@std
AVbad_function_call@std
AVbad_typeid@std
AVbad_weak_ptr@std
AVcodecvt_base@std
AVerror_category@std
AVexception@std
AVfacet@locale@std
AVfailure@ios_base@std
AVios_base@std
AVlength_error@std
AVlogic_error@std
AVout_of_range@std
AVrange_error@std
AVruntime_error@std
AVstl_condition_variable_interface@details@Concurrency
AVstl_condition_variable_vista@details@Concurrency
AVstl_condition_variable_win7@details@Concurrency
AVstl_critical_section_interface@details@Concurrency
AVstl_critical_section_vista@details@Concurrency
AVstl_critical_section_win7@details@Concurrency
AVsystem_error@std
AVtype_info
AW&qB
AWAVATVWSH
AWAVATVWUSH
AWAVAUATVWSH
AWAVAUATVWUS
AWAVAUATVWUSH
AWAVAUATVWUSL
AWAVAUATVWUSPH
AWAVVWS1
AWAVVWSH
AWAVVWUSH
AX:gex:J
AXH+API
AXH+API;D$0
AXH+API;E0
AXH+APL
AYAXZY
A[YƋL$0H
A\\A]A^A_YZAXAYAZA
A\a9Ћi
A\b3Ҋ\bI
A\b>Q^0
A\bA;ŋI\fA
A\bH;\bu
A\bL;\bu
A\bba|\b
A\bi:L
A\eP;g
A\fba~\b
A\nYL
A\nYT
A\nba|\b
A\nba~\b
A\ny:\a
A\rba|H
A\t8;:X\a
A\t;vk
A\t<&a0
A\tB(M
A\tE\a`h
A\v:O)3
A\vE\b`h
A]A\\]_^[ÐSVWUATAUH
A^A]A
A_A]A
A_A^A
A_A^A]A
A_A^A]A\\_^[ÐSVWATAUAVAWUH
A_H<r
A`+AX
AbYd/4
AccelN::intersector1
AccelN::intersector16
AccelN::intersector4
AccelN::intersector8
AccelN::intersectorN
Access violation - no RTTI data
AcquireSRWLockExclusive
Ad\\?HcC
AdjustTokenPrivileges
Advanced Micro Devices
Ady;.s
Af<ZXk
AfC`ěA
Affff
Affffff
Ag5<I
Ah\f;o
Ai<ִv
AjYT3\bz
AjY\\4\fz
Ak==9
Ak\f<\a
Ak»mS
AmQ,BP\a
Am\a9D
An error/warning message cannot be saved in the file
An unclassifiable error occurred
An>uCv
AoҼh9
Ap_p@H
AppPolicyGetProcessTerminationMethod
AppPolicyGetShowDeveloperDiagnostic
AppPolicyGetThreadInitializationType
AppPolicyGetWindowingModel
Aq:UV
Aq:k\n
AreFileApisANSI
As< g
Asg<0gk
Assertion failed
Assertion failed: %Ts, file %Ts, line %d\n
Assigning DPAR(1)=%e
Assigning DPAR(2)=%e
Assigning IPAR(8)=IPAR(9)=1. This means that DFGMRES routine will do the
At least one of parameters IPAR(8), IPAR(9), or IPAR(10) must be equal to 1
At least one of the parameters IPAR(8), IPAR(9), or
August
Auth3D$4
Auu:L
Aw9/1
Awj;:m\e
Ax/t1
Ax5;U
AxXd$0
AxYt$P
AxY|$P
Ax]D$p
Ay<xeV
Aynt\f0
Ayn|\fd
A{A=dg
A{L.B
A|(TD
A|(tE
A|=T2P
A||                                    %f
A}oKL$X
A}oȉL$X
AƼCNϼ\fc
Aʼ;\vdb
A˻bC3<\aHN
A̪;VB
A̻fsv<?c
À:bf
A֟;Sr
A۬\v C
A۬\v0C
A۬\vPC
A۬\vPg
A۬\vpC
A۬\vpg
Aໂi\a
A酼Xto
A튺r*o
B :;NM0
B :UsK
B"B&B*B.B2B6B:B>BBBFBJ
B(<t5A
B(I9A(u\r
B)bA|\b
B+N>ZaS
B+Q4\a
B-H<WP
B0;0=k
B0i9B
B0ɼ"7
B1<J\aJ
B93)\v
B9<ybl
B9dڕ8nO
B9ᑙ:7m
B:BbZ:R
B:\f0u M
B; rs9
B;"3J;g
B;(kW
B;0JH
B;Q医9
B;RbT
B;WO5
B;XNN;$9J;6
B;Y)Y;2N
B;ZwH
B;\bEO
B;jOH
B;peL
B;íc8hxs
B<;YV1
B<\t\r\b8
B<xym<[\nM
B=2}\t=Cٞ=i6h=JC
B=Jk8
B=R67
B>Bh9?\a
B>F\fE
B>\tSԽe
B>zZ\v
B>{Pn
B?d!\vY
B?d"C
B@bQ|\n
BA.L$p
BA.d$p
BB:;o\t
BB<.m
BCŻHl5
BCױbc}IC
BC߱bc}IC
BD>Lɏ<s
BD\v7
BENCHMARK_BUILD
BF8<pjM
BF>XoT
BH;% H
BI.L$p
BI.T$p
BJ8=R
BJƼ{K
BK=\b
BL0<:;H
BM<mcW
BM];Ha
BMa=!9
BMr:Km
BN9"X
BN:;lY
BNe<\v@P
BNi;\b
BOO<̊r
BP<p\r
BQ#"C\n
BQZ:K:G
BRANCH
BSp<fm0;\a
BT{zb
BUY:P
BUμVx
BXHc\bI
BXI+KPI+BPH
BXQ<ŊXy
BXm:|v
BY,T,L
BY\t>w
BYԀB8B
B\\s;Mse<\vu0
B\a8pUx
B\bH9A\bu\rH
B\bHcEgH
B\bbQ
B\bba|\b
B\e>fH\b
B\eCW&qB
B\n:Q+K
B\nba|\b
B\nba~\b
B\r0\fp\v`\n
B\r;Lnm
B\r;oN9
B\rV:9
B\rbA|\b
B\t;n*l
B\t=L\v3
B\vba~\b
B]\n>wZU
B`ěAi\\BB
Bad dynamic_cast
Bad facility code
Bad severity number
Base Class Array
Base Class Descriptor at
Bba~\b
Bd#<miE
Be.V I
Be.o I
Bffff
Bffffff
Bfڻm`3
Bg; T7
Bhba|\b
Bi'LCNאB
Bi.D$p
Bi.L$p
BitHistogram
Bj'?I
Bj:\vB5ڻBI
Bjûoc
Bk(#B3
Bm\b> H
Bm^<C\ef
Bn<pZ
BnB=^D
BnE;UN
BnI<Bb
Bpֹ=7G;Z
Bq.D$p
Bq.L$p
BqȻ"s
Br!<35
Br=/y
Bu<\a|p
Build
BuildHierarchy
BuilderFastSpatialSAH
BuilderInstancing
BuilderMBlurSAH
BuilderSAH
BuilderTwoLevel
Bw:<F
By.L$p
By.T$p
By.l$p
Byź`2
BzŰC*!3B0y
B{t:6
B|nZB\r
B}ļ G
B~0GB
B~Z=Q
Bŕ\rB
BȻoH뻎A
B̻w\fлJ
BϻLd0
BЋA(H
Bґ<mg
BһR1q;\e
Bպ+TO
Bք\tAl1"B
B۸YI>9
B⽦qG;t
C 9t$0
C rWH
C!p;l
C$ɺ12
C&:5Q\f
C(D;i2
C(Hc\f\aH
C(Hc\f\aI
C):4Z\e
C);PNO
C);nnA;p
C*!3B
C+;87
C09p\btU
C0;^F
C0F;<\n
C0H+C(H
C0HcH\bL
C0HcH\fH
C0Hc\tH
C1<tA
C23;}K
C2j:v
C2u<ӐK
C4=mwV
C8;C4s
C8H+C0I;D
C8H+C0I;E
C8O:;Ŵ6
C9JD$p
C9_S8
C9n,.;8j
C:&\fS9
C:,lu)C
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_instancing.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_morton.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_sah.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_twolevel.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_intersector_stream_filters.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_refit.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_statistics.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/geometry/instance_intersector.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/mysofa/install/windows-x64/share/libmysofa/default.sofa
C:70W:ﯸ7sK
C:GpK
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\algorithms\\parallel_for.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\algorithms\\parallel_sort.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\math\\range.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\math\\vec3fa.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vboolf4_sse2.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vboolf8_avx.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vfloat4_sse2.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vfloat8_avx.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint4_sse2.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint8_avx.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint8_avx2.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\alloc.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\alloc.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\sysinfo.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\vector.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\tasking\\taskschedulerinternal.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\tasking\\taskschedulerinternal.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../../common/algorithms/parallel_for_for.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../../common/algorithms/parallel_partition.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../common/primref_mb.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_binning.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_binning_array_aligned.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_openmerge_array.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_spatial.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_spatial_array.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_timesplit_array.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/bvh_builder_msmblur.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/bvh_builder_sah.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/splitter.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../bvh/bvh.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../common/alloc.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/triangle.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglei.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglev.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglev_mb.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh4_factory.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh8_factory.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_instancing.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_instancing.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_morton.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_sah.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_twolevel.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_twolevel.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector1.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_hybrid.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_stream.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_stream.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_stream_filters.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_refit.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_statistics.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_traverser1.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_traverser_stream.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/algorithms/parallel_for.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/simd/simd.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/sys/array.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\accel.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\acceln.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\accelset.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\alloc.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\buffer.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\device.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\rtcore.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_triangle_mesh.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_triangle_mesh.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\state.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\vector.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\../common/primref_mb.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\../common/scene_instance.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\filter.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\instance_intersector.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\intersector_epilog.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\trianglei.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\trianglev_mb.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\mysofa\\src\\mysofa\\src\\hrtf\\easy.c
C:\\buildworker\\phonon_main_win64\\build\\core\\build\\windows-vs2019-x64\\src\\core\\Release\\phonon.pdb
C:oMt
C;%La
C;=Db
C;L\v0
C;Mub
C;S\t
C;XDb;S
C;e৺HB
C;i,N;4
C;i{j
C;t嬺0
C<2sR
C<;C4A
C<CPX7
C<G;g
C<Tzv
C=8,z
C=B \b
C=M5)=7
C=\v8
C=p\eཛྷ6
C=z"d9
C>5x=h4
C>7hk
C>9^a6
C>\b84>eJ
C>t}C
C@H98t$H
C@H9\bt
C@I=5P
C@f91H
C@f99H
CB';t
CC>/b
CD:\nE2
CG<UlX
CGj:zK
CH;\n
CHEGST
CHH+C@I;D
CHٹ`N7
CI9y\bi;)o\a
CJ>sm
CKW;b
CKc=YC
CL interop not supported
CLDEMOTE
CLv\vH
CM:TkJ
CMF}A
CMPCCXADD
CN@=!kC
CNNFTNFNNFTNF
CNR:%s
CO ;qd
CO9`2
COMPATIBLE
CONOUT
CPHcS\bH
CPHc\bI
CPU does not support SSE2
CPU frequency: %8.3f GHz
CQȺ0\\Ǻty
CRT$XCA
CRT$XCC
CRT$XCL
CRT$XCU
CRT$XCZ
CRT$XDA
CRT$XDZ
CRT$XIA
CRT$XIC
CRT$XIZ
CRT$XLA
CRT$XLC
CRT$XLZ
CRT$XPA
CRT$XPX
CRT$XPXA
CRT$XPZ
CRT$XTA
CRT$XTZ
CS;"i
CW&qB쾩C
CWD>~3
CXH+CPH
CXH+CPI;G0
CXH+OPH+CPH
CXHc\bI
CXL+CPH
CYA>HM
CZ滘dٻO
C\\,50J
C\a>8B\a
C\a>8B\r
C\b;e4ƹZ
C\fA]A
C\fHcOLH
C\fbA
C\nżi3
C\r\r;M
C\tJup
C\tJvp
C\tJwp`H
C\v$9!J
C\v;f7
C`H+CX
C`H;CXt"I
C`H;CXt#A
C`N3A
C`N3Gs
Ca;=\nJ
CalcMortonCode
Calculate any intersection \n            hitresults[ridx] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process \n__global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process                     \n__global int* hitresults  // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,      // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \n__global int const* numrays,     // Number of rays in the workload \n__global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest(&scenedata, &r, &isect); \n            // Write data back in case of a hit \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \n__global int const* numrays
Calling r8write without FORTRAN_IO, iparam(9)=0
Cannot create file %s
Cannot create file MKL_Poisson_Library_Log.txt
Cannot proceed as the system failed to provide
Cannot proceed with calculations as
Cannot proceed with calculations as input
Cannot proceed with calculations as input matrix has
Cannot proceed with calculations as input maximum
Cannot proceed with calculations as input size
Cannot proceed with calculations as matrix has either
Cannot proceed with calculations as small diagonal
Cannot proceed with calculations as the system failed
Cannot proceed with computations
Cannot read the contents of a file
Cannot run %s - not enough memory
Caｎ ~=7
CcR;9
Cf;4AC
CfC=&p
Cffff
Cffffff
CfνP\\T
Cg8\t
Ch\n=*S
CiK=>N
Ci^;XW
Cj:\vBs\t
Ck(#B
Ck(#Bsx
Class Hierarchy Descriptor
Class name
CloseHandle
CloseThreadpoolTimer
CloseThreadpoolWait
CloseThreadpoolWork
ClŻBq
Co:}j
CoTaskMemFree
Column-replicated array -- copy in process column: %d
Columnwise
CompanyName
CompareStringEx
CompareStringW
Compiler
Complete Object Locator
Computational layer library for Cluster FFT not loaded
Computations have stopped. The result may be incorrect
Conditional numerical reproducibility mode is turned OFF
Conditional numerical reproducibility mode is turned ON
Config
Conjugate
Conventions
CoordinateSpace* listeners,\n                           global const Directivity* directivities,\n                           uint numRays,\n                           uint numBounces,\n                           float irradianceMinDistance,\n                           global const Ray* rays,\n                           global const Hit* hits,\n                           global const float3* normals,\n                           global const int* materialIndices,\n                           global const Material* materials,\n                           uint numDiffuseSamples,\n                           global const float4* diffuseSamples,\n                           uint randomNumber,\n                           float scalar,\n                           global Ray* shadowRays,\n                           global Ray* reflectedRays,\n                           global float4* energyDelay,\n                           global float4* accumEnergyDelay)\n{\n    size_t numChunks = max(numListeners, numSources);\n    size_t numPrimaryRays = get_global_size(0) / numChunks;\n    size_t numShadowRays = get_global_size(0);\n\n    uint rayIndex = (numListeners > 1) ? get_global_id(0) : (get_global_id(0) % numPrimaryRays);\n    uint chunkIndex = get_global_id(0) / numPrimaryRays;\n    uint listenerIndex = (numListeners > 1) ? chunkIndex : 0;\n    uint sourceIndex = (numSources > 1) ? chunkIndex : 0;\n    uint shadowRayIndex = get_global_id(0);\n\n    // If this ray is disabled, don't do anything.\n    if (rays[rayIndex].extra.y == 0 || hits[rayIndex].primid < 0)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        reflectedRays[rayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n        return;\n    }\n\n    // Random number generation for work group.\n    local RNG rng;\n    local float randomFloat;\n    local uint randomUint;\n    if (get_local_id(0) == 0)\n    {\n        initRNG(randomNumber + rayIndex, &rng);\n        randomFloat = randFloat(&rng);\n        randomUint = randUint(&rng);\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    // Calculate hit point.\n    float3 rayDirection = rays[rayIndex].d.xyz;\n    int triangleIndex = hits[rayIndex].primid;\n    float hitDistance = hits[rayIndex].uvwt.s3;\n    float3 hitPoint = rays[rayIndex].o.xyz + hitDistance * rayDirection;\n\n    // Calculate hit normal.\n    float3 hitNormal = normals[triangleIndex].xyz;\n    if (dot(hitNormal, rayDirection) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    // Calculate hit material.\n    Material hitMaterial = materials[materialIndices[triangleIndex]];\n    float3 hitMaterialAbsorption = (float3) (hitMaterial.absorptionLow, hitMaterial.absorptionMid, hitMaterial.absorptionHigh);\n\n    // Calculate shadow ray direction.\n    float3 source = sources[sourceIndex].origin;\n    float hitToSourceDistance = distance(hitPoint, source);\n    float4 hitToSource = (float4) (normalize(source - hitPoint), 0.0f);\n\n    // Skip the ray if:\n    //  a) the hit point is inside the listener, or\n    //  b) the hit point is too close to the source, or\n    //  c) the ray hit a backfacing triangle.\n    if (hitDistance <= LISTENER_RADIUS ||\n        hitToSourceDistance <= irradianceMinDistance ||\n        dot(hitToSource.xyz, hitNormal) < 0.0f)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n    }\n    else\n    {\n        // Generate the shadow ray.\n        shadowRays[shadowRayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * hitToSource.xyz, hitToSourceDistance);\n        shadowRays[shadowRayIndex].d = hitToSource;\n        shadowRays[shadowRayIndex].extra = (int2) (0xffffffff, 1);\n\n        // Calculate shading values.\n        float3 energy = (1.0f / PI) * hitMaterial.scattering * max(0.0f, dot(hitNormal, hitToSource.xyz));\n        energy += ((SPECULAR_EXPONENT + 2.0f) / (8.0f * PI)) * (1.0f - hitMaterial.scattering) * pow(fabs(dot(normalize(hitToSource.xyz - rayDirection), hitNormal)), SPECULAR_EXPONENT);\n        energy *= scalar;\n        energy
CorExitProcess
Could not open file %s
Could not open file %s, aborted
CoҺcP
CqY:Y
Cr;Npl
Cr;WVz
CreateEventA
CreateEventExW
CreateEventW
CreateFileW
CreateSemaphoreExW
CreateSemaphoreW
CreateSymbolicLinkW
CreateThread
CreateThread failed
CreateThreadpoolTimer
CreateThreadpoolWait
CreateThreadpoolWork
Ct-<D
Ct;ti
CtK<Dv
Current date/time: %s
Cw:\b
Cw;CD:\t
Cy2@K
Cy9LH$9\r
Cylinder test
Cylinder { p0
Cz,;\nfS
Cz\e<L
C|nZB
C}żDiмo
Cú9eo
CŻ9AE
Cȼ=8Q;g
CʺfhƺeY5
C˽YL\e=F
Cӷ;fYt
Cք\tA
Cڳ; \fm<Q
Cߺ\vo0
C㏻|h编ZR
D  fB
D AMD
D AMD_MEDIA_OPS
D W?{W
D WIN32
D!l$xA
D"<k7
D"D&n,n2
D$ 3\tD$,H
D$ 9A
D$ ;D
D$ BǄ\a
D$ D3
D$ H;D
D$ H;D$\bH
D$ H;L
D$ H;L$P
D$ H;Q
D$ H;T$H
D$ H;V
D$ H;\r
D$ H;\rA+S
D$ HcL$8H
D$ I;U
D$ `fD
D$ b!|M
D$ ba
D$ ba|\b
D$ veH
D$ ġzYL
D$$bb}H
D$(H!L$ E3
D$(H9D$H
D$(HcL$4H
D$(fff
D$03ɉL$8L
D$0@8
D$0A;\b
D$0D9P
D$0D;L$(u
D$0H9D$8
D$0H;D
D$0H;D$8
D$0H\vD$(I\v
D$0HcH
D$0HcL
D$0HcL$,H
D$0L+D$ L
D$0L9H s\n
D$0N;l
D$0fE
D$0fffff
D$0tVA
D$0tWA
D$0t]A
D$0t^A
D$0u\f3
D$18F(u\bH
D$2E3
D$4Lc
D$8D8T$1u\f
D$8H;D$0
D$8H;S
D$8HcJ
D$8HcL
D$8L98
D$8fff
D$<0b
D$<HcT$<H
D$@E3
D$@H;D$ H
D$@HcL
D$@HcL$<H
D$@HcL$LH
D$@HcL$PH
D$@HcT$<H
D$@HcT$P1
D$@L;D$Hu
D$@fD
D$DDtRH
D$HD9@$t
D$HD;l$4s\vH
D$HE3
D$HH+D$@H
D$HH;D$8
D$HL9gXt
D$Hr~I
D$HtgH
D$Hx0I
D$H~JN
D$L;D$x
D$PH;D
D$PH;D$ H
D$PHcH
D$PL;D$Xu
D$PL;\r
D$PLcH
D$PfD
D$Ps!f
D$PsOH
D$Pt#A
D$Pt&A
D$XH;D$H
D$XHcE
D$XI+D$PI;E0
D$XI+D$PI;E8v*M
D$Xs!f
D$XsUH
D$XsaH
D$Xt$f
D$\bH;A
D$\bH;D
D$\bHcL
D$\bIcL
D$\bbA|\b
D$\f0bc%\b!l$l
D$\fba|\b
D$\nba~\b
D$`D9;u
D$`E3
D$`H+D$hH
D$`fff
D$`sQH
D$`sWH
D$`tGM
D$`tKM
D$`t\fH
D$d:v
D$h9t$P
D$hH9D$@L
D$hH;C
D$hH;D$pwBH
D$hHcC8H
D$hL;t$0M
D$hLc\t
D$hfffff
D$hs!f
D$hsC
D$ht4A
D$n<od
D$pA;w
D$pD8~ t\fH
D$pD;g
D$pH;V
D$pHcH
D$pHc\bL
D$pLc7L
D$pba|\b
D$pfA
D$pfD
D$pt\nH
D$ptyf
D$pu"H
D$pu\bH
D$t+D
D$t\vD$p
D$w<NL
D$xH;D$pL
D$xHcA
D$xHd
D$xI;V
D$xba
D$xba~\b
D$xteH
D%;m5\r
D%<V7
D%k;w
D&pA;l$l
D';kzT
D(:s8
D(T=FD\n
D)Hv)A
D*0fB
D*Hv\t
D*\r<3y
D+T$Hfff
D+{HD
D.\ab!D
D.ǻJH
D2Hv\fF
D2ٺV\a\v
D2庈-p
D3 b1
D39\aW-;R
D3f\bD3n\fH
D3мuxc
D4S<U
D6\v:߬B
D6r:w`w
D8+t\nD8k
D81uUL9r
D8APttH
D8G\buBH
D8G\buIH
D8G\buOH
D8L$0uP
D8W\buOH
D8Z\bt
D8\\$8uOH
D8]\v
D8g\buAH
D8i2uvH
D8l$<tNI
D8l$@tOI
D8o\bu@H
D8o\buFH
D8o\buHH
D8o\buNH
D8t$ht\nH
D8|$Ht\fH
D8}?t\tH
D9!t\tH
D91AO<zDy;ɛ\r
D92<a
D92~&A
D92~0A
D92~0H
D9I ~wHc
D9J0~<A
D9K0~NA
D9K\b~+A
D9S\f~J
D9\vucL
D9c4t\bH
D9c\f~C
D9g0~xI
D9s\bu\t9k\f
D9} ~t
D:#)g:rEy9
D:E7\n
D:H\b
D:M+B
D:Q<r\t
D:UT\e
D:\b| D8R
D:\b|$D8R
D:\f0u6H
D:\f0u:H
D:vXh:Y6
D;#rg
D;(u\vf9t$bu
D;-Bb
D;H$t\n
D;M<J
D;RN8=0r
D;S\b}8A
D;bY\e
D;iHJ
D;t$4s
D;yLj:Sj
D;}CQ
D<\bW59\n
D=7@U
D=;\axb
D=maQ
D>#U7
D?\f<fVO:5
D?\v9:U
D@Q=s
DA9wX3
DAL_BLAS_COMPUTE_MODE
DAb<eE
DBY^uB
DB]8Ta
DC:th
DC;ӫ7
DCh9js
DDhu"E
DE;lT\fE
DFGMRES routine
DFGMRES routine. Otherwise, the maximal number of iterations is equal to
DFԽNk
DG9:N2
DGл\r}ܻsD
DH>=h
DI;?mQ8
DIMENSION_LIST
DJQ;Bƅ:وn
DJ\b=<a
DK8ɠ\t
DK;n5
DKO;g
DKf:5
DLڻL\f\n
DN];h
DOm;c
DPAR(2)=%e should not be equal to 0.0 simultaneously. The FGMRES
DQa<Ua
DQ»߃ͻKF
DR;97
DRB<b
DS<tl1
DSYGST
DSp;d
DVe@A\v
DWغ*o
DX4"H
DX<"H
DXƻ&1y
D\a\aba|H
D\b;o1o;f
D\eƻp
D\f;rb
D\f<Sa
D\n$ fG
D\n40E
D\n=OQK
D\n\abq|H
D\n\bbA|H
D\n\e;U
D\n\nba|H
D\nt$PL9
D\t<4W6
D\thġx
D\v\nba|H
D\v`r]E
D\vf:%b
D^F<n
D^ӻmq
D_FORWARD_TRIG_TRANSFORM/D_BACKWARD_TRIG_TRANSFORM routine
D_ԼW6q
Da<ll{;d
Data.Delay
Data.IR
Data.SamplingRate
DataType
Dba~\b
December
DecodePointer
DeleteCriticalSection
Dfb:'Q
Dffff
Dfffff
Dgi;d
DigiCert Timestamp 20240
DigiCert Trusted Root G40
DigiCert, Inc.1;09
DigiCert, Inc.1A0
Distributed Matrix Input Format is used for CPARDISO (iparm(40) = %d
Division by 0 occurred
Division by zero occurred. Computations have stopped. The result may be incorrect
Division by zero occurred. The D_COMMIT_TRIG_TRANSFORM routine was not called
Division by zero occurred. The S_COMMIT_TRIG_TRANSFORM routine was not called
Division by zero occurred. The d_commit_trig_transform routine was not called
Division by zero occurred. The s_commit_trig_transform routine was not called
Division by zero occurred: At iteration number %s, the rotated Hessenberg
Division by zero occurred: parameter DPAR(5)=%e should
Division by zero occurred: parameter DPAR(7)=%e should not be equal to 0.0
Division by zero occurred: the new rotation for Hessenberg matrix is degenerate
Dk;hYn
Dm4<x5
DoG;R
DoL9I
DpɹjYj
Dqt=c
Duf<"`4
Dva<R
Dvc:e4
Dvz;N
Dw<\r\a
DyH<B
Dyn:%d
D|;qyf
D|>9f
D~ "H<O
D~9q\n
D¼9\vr
Dƨ:pR1<2
Dƻ0\ae
DɺlNv
D˻mĥ8
DЋ;M4
Dйl\e;b
DҼl9ؼD
Dܼ1x̼2
D眻F뗻4w
E HcT$0H
E fff
E ŜY=\ax
E"(<ZOw
E$G=@Mt=w6
E%9/q3
E'@6?2s
E(E+E0D
E(G<R
E(H;E
E(Lc7L
E);I\ni
E)B:In
E*:Vh
E*ѼL7
E+}0E
E+܉t$ D
E.ѻ2j
E0;E\bstL
E0H;EH
E0HcH\fD
E0IcD
E0Lc`\fI
E0M;p\b
E0fff
E0stL
E1ɀ|$pNI
E1ۀ|$xNI
E2S9>E
E2[<oO
E2\f<@b
E2j:?z
E3\nS\tI
E3\nW\tI
E3\vD$8A
E3\vT$<L
E3ɅɊ\vA
E3ɉl$P
E3ɉl$PL
E3ɉ|$ D
E3҉U(N
E3ۉEDI
E3ۉEHI
E3ۉEPI
E4;"y
E4?;H
E6;Mm
E6x<E\b\a
E80t"A
E8E\buHI
E8E\buLI
E8E\buQI
E8E\buWI
E8]\buXI
E8a(u\fH
E8a>9
E8q(u\bH
E8q(u\rH
E9.u\aA
E91~)3
E92:W
E99~&A
E99~4H
E9<$A
E9N:5\a
E9Q0~GE
E9e\b~p3
E9e\f~i3
E9l$\f~k3
E9|$\f~k3
E9}\b~h3
E9}\b~k3
E9}\f~k3
E9}\f~k3ېE3
E:+cW
E:2dB
E:6QP
E:<2P
E:<9o
E:Zfl
E:\t=680
E:r?ԻXT
E:yu;29Y
E;*dݺx\ny
E;3>F
E;?tv
E;Fh}AO
E;J+x
E;O䴹R
E;P\n
E;S\rһB
E;Wtg
E;X (;+Zy
E;`2Q
E;kW2
E<<uw
E<MF3
E<P\et
E<nZ\r
E<sS;y
E<tdp
E<uZ*<z
E<xQv
E=E*a
E=WIf
E>p;v
E@D9 u
E@D90u
E@stL
EA5;Ɗs
EACǱb#eAC
EBN9[Bo
EBs<YV6
EDw>P
EGԼ)G
EI;zL
EID$ E3
EID$8H
EJ;8N\t;vj<;nN
EJ;D]\f:M
EJ;^i\t
EJӻegk
EKa;q
ELH9dR{9N
EMcɃ~\b
EMcɃ~\f
ENQCMD
EOʼ.s
EP<+t
EP<0u
EP<0u\a
EP<0u\t
EPstL
ERROR
ERV:8DN
ES:2k
ET;#Pz;ѸU
ET;OB7
EU*?N
EU;&C
EU=\ve
EUG;0c
EVٻ4rY
EWb"e
EX"<f&9
EX%%1c
EX3ҋM`D
EX6;RV
EXI+EPI
EXI+EPI;D$0
EXI+EPI;D$8v/H
EXI+EPI;G0w
EXL;E\bu\r
E[;V3
E[S;i
E[\rn?gc
E[b"m
E\abQ|H
E\auNH
E\b:_h6
E\bHcu`M
E\bbA|J
E\bbQ5H
E\bba}Hp
E\bfA9]\n
E\bs|I
E\btGE3
E\bāx/D
E\e<GQպh
E\ebQT
E\fbA|H
E\n::cXG
E\r<j e:Q&F
E\vbA|H
E\vbQ|H
E_<two
E`bbu
Eb>>Hu
Ec:ud9
Ecb>aS
Ed<+8G
Efffff
Effffff
Eg1<rK
Eg\n;a
EhI+V@L
Ei:݈0;x
Either parameter TT_TYPE in the D_INIT_TRIG_TRANSFORM routine
Either parameter TT_TYPE in the S_INIT_TRIG_TRANSFORM routine
Either parameter tt_type in the d_init_trig_transform routine
Either parameter tt_type in the s_init_trig_transform routine
Either the D_INIT_TRIG_TRANSFORM routine was not called
Either the S_INIT_TRIG_TRANSFORM routine was not called
Either the d_init_trig_transform routine was not called
Either the parameters were altered by mistake outside of the DFGMRES
Either the s_init_trig_transform routine was not called
EkZ;Q
Em1>ap
Em\t:f
Embree Ray Tracing Kernels
Embree: Invalid argument
Embree: Invalid error code
Embree: Invalid operation
Embree: No error
Embree: Out of memory
Embree: Unknown error
Embree: Unsupported CPU
EmitterPosition
En[vP
En\b>w
EncodePointer
End of tests
EnterCriticalSection
EnumSystemLocalesEx
EnumSystemLocalesW
Eo;Ki
Eo<\e:3
Ep\a>9
Epsilon
Error (VML_STATUS_BADMEM) in %s: NULL pointer is passed
Error (VML_STATUS_BADSIZE) in %s: array size %d is not positive
Error (VML_STATUS_ERRDOM) in %s: argument is out of domain
Error (VML_STATUS_OVERFLOW) in %s: argument caused overflow
Error (VML_STATUS_SING) in %s: argument caused singularity
Error (VML_STATUS_UNDERFLOW) in %s: argument caused underflow
Error code=%s and/or %s
Error code=%s and/or %s. Computations have stopped
Error code=%s. Computations have stopped
Error in PARDISO  (        reordering_phase) error_num= %d
Error in PARDISO  (        reordering_phase) error_num= %lli
Error in PARDISO  (        reordering_phase) internal error_num= %d
Error in PARDISO  (      open OOC tmp files) error_num= %d
Error in PARDISO  (      open OOC tmp files) error_num= %lli
Error in PARDISO  (      open OOC tmp files) internal error_num= %d
Error in PARDISO  (     insufficient_memory) error_num= %d
Error in PARDISO  (     insufficient_memory) error_num= %lli
Error in PARDISO  (     insufficient_memory) internal error_num= %d
Error in PARDISO  ( internal_error,unclass.) error_num= %d
Error in PARDISO  ( internal_error,unclass.) error_num= %lli
Error in PARDISO  ( internal_error,unclass.) internal error_num= %d
Error in PARDISO  ( not enough mem. for OOC) error_num= %d
Error in PARDISO  ( not enough mem. for OOC) error_num= %lli
Error in PARDISO  ( not enough mem. for OOC) internal error_num= %d
Error in PARDISO  ( numerical_factorization) error_num= %d
Error in PARDISO  ( numerical_factorization) error_num= %lli
Error in PARDISO  ( numerical_factorization) internal error_num= %d
Error in PARDISO  ( sequence_ido,parameters) error_num= %d
Error in PARDISO  ( sequence_ido,parameters) error_num= %lli
Error in PARDISO  ( sequence_ido,parameters) internal error_num= %d
Error in PARDISO  (32-bit overflow problem.) error_num= %d
Error in PARDISO  (32-bit overflow problem.) error_num= %lli
Error in PARDISO  (32-bit overflow problem.) internal error_num= %d
Error in PARDISO  (incorrect input matrix  ) error_num= %d
Error in PARDISO  (incorrect input matrix  ) error_num= %lli
Error in PARDISO  (incorrect input matrix  ) internal error_num= %d
Error in PARDISO  (prereordering_mtype11,13) error_num= %d
Error in PARDISO  (prereordering_mtype11,13) error_num= %lli
Error in PARDISO  (prereordering_mtype11,13) internal error_num= %d
Error in PARDISO  (read/write OOC data file) error_num= %d
Error in PARDISO  (read/write OOC data file) error_num= %lli
Error in PARDISO  (read/write OOC data file) internal error_num= %d
Error in PARDISO memory allocation: AFTER_REORDERING, allocation of %d bytes failed
Error in PARDISO memory allocation: AFTER_REORDERING, allocation of %lli bytes failed
Error in PARDISO memory allocation: ALLOCATE_GLOBAL_STRUCTURE, allocation of %d bytes failed
Error in PARDISO memory allocation: ALLOCATE_GLOBAL_STRUCTURE, allocation of %lli bytes failed
Error in PARDISO memory allocation: BASIC   , size to allocate: %d bytes
Error in PARDISO memory allocation: BEFORE_INIT_PARALLEL_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: BEFORE_INIT_PARALLEL_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: BEFORE_REORDERING, allocation of %d bytes failed
Error in PARDISO memory allocation: BEFORE_REORDERING, allocation of %lli bytes failed
Error in PARDISO memory allocation: BEFORE_SYMBOLIC_FACTORIZATION, allocation of %d bytes failed
Error in PARDISO memory allocation: BEFORE_SYMBOLIC_FACTORIZATION, allocation of %lli bytes failed
Error in PARDISO memory allocation: CGS_ARR , size to allocate: %d bytes
Error in PARDISO memory allocation: FACTORIZE_SOLVING_LU_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: FACTORIZE_SOLVING_LU_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: FACTORIZE_SOLVING_WORK_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: FACTORIZE_SOLVING_WORK_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: FACT_ADR, size to allocate: %d bytes
Error in PARDISO memory allocation: FACT_L&U, size to allocate: %d bytes
Error in PARDISO memory allocation: LOC_INT1, size to allocate: %d bytes
Error in PARDISO memory allocation: LOC_INT2, size to allocate: %d bytes
Error in PARDISO memory allocation: MATCHING_REORDERING_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: MATCHING_REORDERING_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: OOC_TREE_STRUCTURE, allocation of %d bytes failed
Error in PARDISO memory allocation: OOC_TREE_STRUCTURE, allocation of %lli bytes failed
Error in PARDISO memory allocation: REALLOC_OOC_ARRAYS, allocation of %d bytes failed
Error in PARDISO memory allocation: REALLOC_OOC_ARRAYS, allocation of %lli bytes failed
Error in PARDISO memory allocation: SOLVING_ITERREF_WORK_DATA, allocation of %d bytes failed
Error in PARDISO memory allocation: SOLVING_ITERREF_WORK_DATA, allocation of %lli bytes failed
Error in PARDISO memory allocation: STRUC_FI, size to allocate: %d bytes
Error in PARDISO memory allocation: STRUC_S0, size to allocate: %d bytes
Error in PARDISO memory allocation: STRUC_S1, size to allocate: %d bytes
Error in PARDISO memory allocation: STRUC_S2, size to allocate: %d bytes
Error in PARDISO memory allocation: UP_UPLEN, size to allocate: %d bytes
Error in PARDISO memory allocation: WORK_I0 , size to allocate: %d bytes
Error in PARDISO memory allocation: WORK_R0 , size to allocate: %d bytes
Error in PARDISO: cgs error iparam(20) %d
Error in PARDISO: cgs error iparam(20) %lli
Error in PARDISO: cgs error iparam[19] %d
Error in PARDISO: cgs error iparam[19] %lli
Error in PARDISO: clean impossible (ido
Error in PARDISO: ido<-1
Error in PARDISO: ido<1 and initialization
Error in PARDISO: internal error, insufficient memory factorization
Error in PARDISO: minimal memory required by OOC mode (%dMB) is less than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%dMB
Error in PARDISO: minimal memory required by OOC mode (%lliMB) is greater than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%dMB
Error in PARDISO: minimal memory required by OOC mode (%lliMB) is greater than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%lliMB
Error in PARDISO: only symbolic factorization diagonal matrix case %d
Error in PARDISO: only symbolic factorization diagonal matrix case %lli
Error in PARDISO: preordering failed after %d neqns out of %d
Error in PARDISO: preordering failed after %lli neqns out of %lli
Error in PARDISO: unclassified error
Error in PARDISO: wrong matrix number, clean %d
Error in PARDISO: wrong matrix number, clean %lli
Error in PARDISO: zero or negative pivot, A is not SPD-matrix
Error in PARDISO: zero pivot
Error is not in the area of OOC I/O. Check it manually, error=%d, %s
Error is not in the area of OOC I/O. Check it manually, error=%lli, %s
Error message has been written in %s
Error: Intel oneMKL TT backward transform failed with status=%d in FFTW3 interface to Intel oneMKL
Error: Intel oneMKL TT commit step failed with status=%d in FFTW3 interface to Intel oneMKL
Error: Intel oneMKL TT forward transform failed with status=%d in FFTW3 interface to Intel oneMKL
Error: Intel oneMKL TT initialization failed with status=%d in FFTW3 interface to Intel oneMKL
Error: info returned=%i
Et9Z\v
Et;Z( ;x
Et<]0M
Eu+=V
Eu:Ovûv7Y
EvD<l
Ev\a;6;J
Ew8<AF
Ewx:kۜ7
ExitProcess
ExitThread
Export functionality error: CODE PATH = %d not supported
Export functionality error: DATA_NAME = %d not supported
Export functionality error: INVALID DATA_NAME = %d
Export functionality error: INVALID OPERATION = %d
Export functionality error: INVALID handle
Export functionality error: NULL handle
Export functionality error: OPERATION = %d not supported
Export functionality error: distrubution overlap is not supported
Export functionality error: integer overflow, consider using ILP64 interface
Export functionality error: not all required pointers has been provided before calling main export routine
Export functionality error: some of the input pointers are NULL
Export functionality error: unidentified error
Expression
Ez=uB$>0
EzR;Oo
E{:cAq
E|#9A
E|H9q
E|\f;Zr
E»QZ9P
EûmME
EǋD$8
Eǣ=B\v7
EΎ<z6Z
EщT$xD
EӍZ\bD
EԋD$0D
Eٹ\tn0
F A+N0A
F HcT$0H
F LcL$4I
F#<2z|8r0
F%:Xy0
F&p;bH
F'<nBJ
F(,:Ts3
F(9=lt
F(A+F0A
F(D:9
F(I<U
F):o4\e
F)n;rW
F-N;ro
F19:\n
F2BlJ2HnL
F6:LUP:~so8Ì8;\n
F6û\b2
F8}-L
F9!\aֹP
F9N֑:M
F9Z39
F9`;p
F9o<BwV
F: PӺ\nX
F:4Gǻ\f
F:CVH
F:OKzԣW
F:^Gk
F:j\v
F;8;sG
F;D6S
F;Iy(;De
F;Og{9ޞH
F;Psb;j
F;Q\fL
F;YR3
F;gS¼ʤu
F;nL0;-g
F;tZǺt
F;wr\\6
F;~SS
F<B1v
F<ptO
F<x$Y=zI
F=%=034
F=0;1
F=;AkV
F>qUxv
F?b;yU
FATAL ERROR
FB;:L
FBݻ,DE
FC>yR\t
FDƼ\e
FE?>G
FFCCRR
FF\n@acosf
FGMRES method has lost the orthogonality property, or the FGMRES method was
FGMRES method without restarts, set IPAR(15)=IPAR(5)-IPAR(4) which is equal to %s
FH8;xI
FHD:]T
FHI+F@H
FI;d]N8Qo
FIg=k4
FJ ;>'k
FL;D$8
FL_;eS
FMc\bIk
FOϹLC*;rF
FPH+FHH
FPLcN\bI
FT;IXY
FVN;\f
FWӻǎg
FX=rV?=0
FXH+FPH
FXH+FPH+KPH
FXH+FPI
FXI+FPI;E0
FXI+FPI;E8v*M
FXSAVE
FZ$:Ue9
FZ<Th9
FZ_9\a
F[6:f
F\\V9^J
F\a;R\b¹v
F\a<EG
F\a=LH\e
F\b8H0t
F\b9D$(}s
F\bH90u
F\em;Y
F\n:5V
F\n;F
F\t;RwN
F\tl<a
F\v;Dq
F\v;q
F\v=u
Fa;Q}p
Factorization step
Factorization step (100
Factorization: Time for reading from files: %f
Factorization: Time for writing to files  : %f
Factors L and U
FastMM:%d
Fatal error (error message=%s
Fatal error: Division by zero occurred. Computations have stopped
Fatal error: Failed to normalize the right-hand side
Fatal error: Internal memory error. Computations have stopped
Fatal error: Memory cannot be allocated/deallocated
Fatal error: Memory cannot be allocated/deallocated. Computations have stopped
Fatal error: Trigonometric Transform commit step failed to complete
Fatal error: Trigonometric Transform forward/backward step failed to complete
Fatal error: Trigonometric Transform has failed to release the memory
Fatal error: Trigonometric Transform initialization failed to complete
Fbb}H
Fc*99
FdU</3\b
Features
February
Feẜo蹠k
Ff;ivv
Fffffff
Ffջ(zQ;mv
Fg9\bZ
Fh 9e
Fh:O"c<-W
Fh<9̓=w
FhY<\nKX
FileDescription
FileVersion
FindClose
FindFirstFileExW
FindNextFileW
Fj!;o5F
Fj9lmc
FjB:C2
Fk.9db
FlsAlloc
FlsFree
FlsGetValue
FlsSetValue
FlushFileBuffers
FlushProcessWriteBuffers
Flz5u3
Flº\t
FoO;pb
Foj;w
For information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts
FormatMessageA
Forward
Fpbal
Fq;_S
FreeEnvironmentStringsW
FreeLibrary
FreeLibraryAndExitThread
FreeLibraryWhenCallbackReturns
Friday
Fseek failed
Ftz(u
Fu:.T
Fv;T\f
F{$gT
F|w;b\a
F};AS5
FȈD$HH
FͼV\t
FкZ"G
FջN(J=S
FֻK^N
Fܺ#3R<co
Fݻ3kU;L
Fޘ;Ftf;rJ
G A+G0A
G"e;D
G(A+O0A
G(H+G H
G-;wX
G0HcH\bL
G1m:4I
G20=l
G4l;9k
G6<3yp
G6<ʺL
G7:B6
G7;TO
G8);M
G8;XW
G8z:qW
G9Z!¹p
G9zn7<T
G:$eC
G:UL0
G:j-۸kQ
G:ncG
G:~lD
G:~mQ:U
G:՚ϺZJ6;q
G;0=x
G;M1s
G;Shd
G;brD
G;j,S
G<)mk
G<1\a
G<P\b\f
G<VO+<K
G<\aVлd
G<`Q0
G=0~K
G>l\f
GB:h38
GC;.X\b:3
GEG;\rs
GENERIC_IA32
GFw<5W
GG=2{ĽV
GG??L
GGHRD
GGR8|Q
GH;#H
GH='l
GI\a<s
GJ:F\b
GJ繭?G
GJ켟u!=8
GL9\rXѹcv
GL;M\e,;L
GLUHBQZS
GM;\vL
GNp:W
GPH+GHH
GPUUtilities.dll
GRC<r
GSλiPg
GU\r=L
GX$8aQ
GXH+GPI
GXH+GPL
GX˻.zֻXJ
GYd;em
GZu<M
G[<Ax
G[I;y"g
G\a:Hd
G\aO;\ehs
G\bH+\aH
G\bH+\aI
G\bba|H
G\bāx/D
G\bġx/D
G\n;[wD
G\nf;E\ttT
G\nf;E\ttW
G\r<i
G\r=t|s
G\ri;0
G\t4;H
G\t:E\btK
G\t:E\btO
G\t:E\ftO
G\t:E\ntO
G\t:E\nu`H
G\t:E\nubA
G\t<I
G]H;I
G_ rr\e
G_a=6
Gbb}H
GdͽUW\n
Generated by Steam Audio\n
Genu3D$4
GenuineIH9
GenuineIntel
Genuu\aH
GetACP
GetActiveProcessorCount
GetActiveProcessorGroupCount
GetActiveWindow
GetCPInfo
GetCommandLineA
GetCommandLineW
GetConsoleMode
GetConsoleOutputCP
GetCurrentPackageId
GetCurrentProcess
GetCurrentProcessId
GetCurrentProcessorNumber
GetCurrentThreadId
GetDateFormatEx
GetDateFormatW
GetEnvironmentStringsW
GetEnvironmentVariableA
GetExitCodeThread
GetFileInformationByHandleEx
GetFileSizeEx
GetFileType
GetLargePageMinimum
GetLastActivePopup
GetLastError
GetLocaleInfoEx
GetLocaleInfoW
GetLogicalProcessorInformationEx
GetModuleFileNameA
GetModuleFileNameW
GetModuleHandleExW
GetModuleHandleW
GetOEMCP
GetProcAddress
GetProcessHeap
GetProcessWindowStation
GetStartupInfoW
GetStdHandle
GetStringTypeW
GetSystemInfo
GetSystemTimeAsFileTime
GetSystemTimePreciseAsFileTime
GetThreadLocale
GetTickCount64
GetTimeFormatEx
GetTimeFormatW
GetTimeZoneInformation
GetUserDefaultLCID
GetUserDefaultLocaleName
GetUserObjectInformationW
Gez\es$;J
Gf<@s
Gffffff
Gg;Ӎo
Giy:S
Gj;Wk0
Gk:cd
Gk<D\eS
GkӼ\bHN
Gl;h3
Glu?A
GlubA
Gm轜ls
GnC<O
Gn\t>\b
Gr@;vA
GrJoq
Gr\r<G
Gs:97
Gs;k~\a
Gv;|J1
Gv<3;N
Gvκ6d
Gx9]uP
Gyƻq5
G|b=52
G}F92wu
G}G;S
GĒ:WL
Gɹq@a:t
Gݾ\bWB
GᅻD\e
H 9Y\b
H : %M
H : %M : %S
H A;\bt
H SVWH
H UATAUAVAWH
H UVWATAUAVAWH
H WATAUAVAWH
H!D$ I
H!K=eC
H!L$ D
H!T$0D
H"<jV\t
H#L$0H
H#ƈbc}H
H#ƈbs}H
H#؉M\bH
H#߈bs}H
H%B;IM4:G
H(%wr
H(-3W
H(-5U
H(-BV
H(-JY
H(-LK
H(-Za
H(-fD
H(-hZ
H(-rl
H(-tF
H(-tj
H(\r4b
H(\rWE
H(۸33
H)G0E3
H*:IE
H*=I8
H+D$0H
H+D$8H
H+D$HH
H+D$PH
H+D$pH
H+D$xH
H+D$xL
H+E\bH
H+E\bI
H+HXH+P
H+HhH+P
H+L$ xFH
H+L$0L
H+L$\bH
H+L$\bL
H+OPH
H+Q\bI
H+SPH
H+T$pH
H+T$xH
H+r;pq
H+t$hH
H+ÉM\bH
H+ЋG0
H0:~bV
H1<sF\b
H1ʻ;9
H2\t;c44
H30;t
H39dYk
H3E H3E
H3̋D$ H;\r
H3ۉl$P
H5<M\bv
H5<mN
H5ڻ>1M
H7;5Ӫ:Z\n
H7\r?U
H7\r\rH
H8DQ7;s
H8|UT
H9'wٻP
H9/t\fH
H91vAH
H91vCH
H91v[H
H92t\tH
H92t\tI
H97u+A
H99v$H
H99v/H
H99v2H
H99v;H
H9:t\fH
H9>&X
H9A u\bH
H9A\btgH
H9C s(H
H9D$@t;A
H9D$Ht;A
H9D$Pt
H9D$Xt
H9D$`H
H9D$`t
H9D$pt
H9E\bt>A
H9H s
H9L$Ht?H
H9L$pI
H9L$xu
H9S\buKH
H9S\bu\fH
H9T$ v2f
H9\at\tH
H9c(8
H9i\bujH
H9i\bvZD
H9k\bt\vH;C\bv
H9t$0H
H9t$@t\f
H9{\bt\nH;C\b
H9|$8H
H9|$xt
H9溅s
H:7-9
H:<qkv
H:H=I
H:y\n\t
H;0c4
H;3u-I
H;3u0I
H;3u7H
H;3u:H
H;5\bB:\eL
H;A w7A
H;A w9
H;B0s M
H;B\bw\e
H;CXt\e
H;C\bv\f2
H;C\bw
H;C\bw H
H;C\bw!H
H;C\bw"H
H;C\bw"L
H;C\bw#A
H;C\bw#H
H;C\bw*H
H;C\bw\e
H;C\bw_L
H;C\bwiH
H;D$ r
H;D$0H
H;D$8u"H
H;D$8u"L
H;D$PH
H;D$Pu\bM
H;D$Pv\r
H;D$\bH
H;D$hs
H;D$hv
H;D$pH
H;E@t
H;F w%H
H;G w%H
H;G(sXH
H;H s\bH
H;H\bu\rL
H;H\bv\a
H;K w\t
H;K\bt\bH
H;L$0u H
H;L$PH
H;NPt
H;NPt)A
H;O\bt/H
H;P\bu\fL
H;P\bu\rL
H;Qz";R
H;S8v\bH
H;W t\t
H;XXs\v
H;\at$H
H;\n8
H;\r!BA
H;\r)TC
H;\r)VI
H;\r,yC
H;\r1\t
H;\r3=D
H;\r8*S
H;\r9;C
H;\r?j5
H;\r@1D
H;\rAlC
H;\rCh
H;\rD
H;\rD^C
H;\rHtB
H;\rKN
H;\rM`h
H;\rNKO
H;\rP
H;\rRYe
H;\rUvL
H;\rUxQ
H;\rUyC
H;\rX9h
H;\r\ebg
H;\r\f3C
H;\r\fuB
H;\r\nQC
H;\r\t\nC
H;\rf^C
H;\rgx
H;\rkK
H;\rmN
H;\rn
H;\rqtB
H;\rrCg
H;\ry
H;l$0u'L
H;l$8
H;l$H
H;l$PH
H;l$\bH
H;m(0
H;o`r
H;t$ H
H;t$0L
H;t$0t
H;t$8M
H;t$8u'L
H;t$PH
H;tjy
H;xXu5
H;yNa
H;|80u\nK
H<(i1
H<8La
H<9&l
H<=wU9ܾc
H<Z깻L4
H<cmV
H=e<Ui
H=hSm
H=pd\b
H>*OA
H>7T켆F
H>hl\f
H>́h?5u
H@-7J
H@-OT
H@-f5
H@\rNs
H@\rPT
HA=\f/A
HA^A]A
HA_A]A
HA_A^A]A
HB廨}ȻA\bx
HC<VX
HCL;o
HFX=ej
HG<?wQ
HGݻsp
HH:mm:ss
HH;^Hs
HH;{Hs
HHH+H
HI96v
HIԼ\nK\f
HJ\n?J
HL:Ƅp
HLc@\fIc
HM9\bJJ;(\f
HMcɃ~\b
HMcɃ~\f
HO<A!R
HPH+HHH
HR;xu
HR><y5
HRESET
HS伳q\r=0
HT9)\a
HT\a;H
HV:N<H
HV^<1
HW:m,ݻ6
HWҼ6j
HX%#c
HX%.Q
HX'bQ|H
HX-)l
HX-3d
HX-Br
HX-Vs
HX/bQ|H
HX==i
HX=\fd
HX=\nj
HX?bQ|H
HX?bq<XYE
HX\rti
HX|$R
HY&:g
HY,+bA
HY,\ebA
HY1:Q
HY:.G
HYFpŠY
HYM\nbQtHY
HYe\fbAT@Ye
HYt\a\fb
HYu\fbA
HZ%\b6
HZ\rlq
HZh<s
H\\M ŨY
H\\M0ňY
H\\MpňY
H\a\b;u
H\b9b\f
H\b:Z
H\bAUAVAWH
H\bL9I\bu\bD9
H\bSUVWATAUAVAWH
H\bSVWATAUAVAWH
H\bUATAUAVAWH
H\bUATAUAWH
H\bUATAVAWH
H\bUAUAVAWH
H\bUSVWATAUAVAWH
H\bUVWATAUAVAWH
H\bUVWAWH
H\bUWATAWH
H\bUWATH
H\bUWAUAWH
H\bVWATAUAVAWL
H\bVWATAVAWH
H\bVWAVH
H\bWATAUAVAWH
H\bWAVAWH
H\e/=n9
H\f;xz6
H\f<C|8
H\r4:k
H\r<w*f
H\t#;8A
H\t<gT\t
H\tt\f8C2u\aH
H\vT$PH
H\vT$PH3
H\vl$@H\v
H]A]A
H]A^A
H]A_A
H]A_A^A
H]A_A^A]A
H^=NTm
H^T<u
H_D8f
H`3\bD$8H
Ha=RjR
HaL;K
Haswell
Hba~\b
HcAHH
HcB0M
HcC(HcK,E
HcD$ L
HcD$(H
HcD$(I
HcD$(Mc
HcD$,H
HcD$0LcL$(H
HcD$0LcT$(H
HcD$8LcT$0Lc\\$(H
HcD$<H
HcD$\\H
HcD$xLi
HcD$xM
HcF(Hk
HcF(Lk
HcG(HcO,E
HcH\bH
HcI\bLk
HcL$ B
HcL$p3
HcL$pL
HcS\bHc
HcS\bIc
HcS\bNcD
HcS\fHcK
HcT$$H
HcT$<H
HcT$`H
HcU\bHcM\fK
Hc\\$4H
Hc\\$8H
Hc\\$DH
Hc\\$HH
Hc\\$TH
Hc\\$XH
Hc\\$pA
Hc\\$pE3
Hc\\= H
Hc\\= I
Hc\aHcW(HcO$LcG
Hc\tt$H
HciHH
Hcl$`LcT$pLc|$h
Hcp8Lcx\bD
Hcq;:&g
Hct$pD
Hc{\bIc*H
Hc|$hH
Hc|$xH
Hc} Hc]$LcU(LcE,I
HcȉD$0
HcȋB\bA
HcˉD$P
HcҋE0H
HcҋEHH
Hcҋl$`M
Hc߉M H
Hc߉T$0H
Hc߉T$PH
Hc߉U H
Hc߉U(H
Hc߉U\bH
Hd<BZ\n
Hd<g{7
Hd\e:hE
Hdͻ\rr
Hdлp/\r
He3<9
HeapAlloc
HeapFree
HeapReAlloc
HeapSize
Helmholtz coefficient ?PAR(4)=%e should be non-negative
Helmholtz coefficient ?par[3]=%e should be non-negative
HfD9#A
Hfǹ4IX
Hg%;e5
Hi1:I
Hjֻ*Jn
HkT$HpH
HkT$`pA
HkT$xpH
Hkv=k_E
Hm<x\vw
Hmm>\r
Hn\v:v
Hnռ\ajX
Ho%1P
Ho%1j
Ho%:G
Ho%J9
Ho%TF
Ho%VD
Ho%YY
Ho-@z
Ho-Cl
Ho-OP
Ho-hF
Ho5_\e\e
Ho5_o
Ho;lJ5
Ho=N(\e
Ho=vy
Ho@;i
HoD:\ab
HoK=eM
Ho\rA2
Ho\rG6
Ho\rJM
Ho\rNz
Ho\rO7
Ho\rX
Ho\rzB
Hp$1b
Hp$qH
Hp$qb!}Hp\f
Hp$±b
Hp$±b!4HY
Hp$±b!D@Y
Hp$ñb
Hp$ȱb
Hp$ȱb!4HY
Hp$ʱL
Hp$ʱbq\\H
Hp$˱H
Hp$˱b
Hp$رb
Hp$ٱb
Hp$ڱH
Hp$ڱb
Hp$ܱbQ}Hp\fԱbR\r
Hp,qb
Hp,qba}Hp
Hp,ñb
Hp,ȱb
Hp,ɱb
Hp,ʱb
Hp,ʱbAT@YU
Hp,˱b
Hp,˱ba<@Y
Hp,бI
Hp,бb
Hp,бb"E
Hp,бba4@Y
Hp,ұb
Hp,ԱbA}Hp
Hp,رb
Hp,رb!}Hp4бb!tHY
Hp,ڱb"5H
Hp,۱I
Hp,۱ba|H
Hp1b!}HpԱb
Hp1b!}Hpرb
Hp1b2M
Hp1bA|H
Hp1bA}Hpձbq|H
Hp1ba|H
Hp1ba}Hpʱbr}H
Hp1bq|H
Hp4±bQL@Yu\nb
Hp4ñbq
Hp4ıbQ}Hp\fܱb
Hp4ȱb
Hp4ʱL
Hp4ʱb
Hp4ԱbQ}Hp<ܱb
Hp4ֱI
Hp4ֱbQ}Hp<ƱbA}Hp
Hp4رb
Hp4رbq
Hp4ڱL
Hp4ڱb
Hp4ޱb
Hp<1b
Hp<1bq$HY
Hp<qb
Hp<±b
Hp<ñbq$HY
Hp<ıb
Hp<ƱbA}Hp\f
Hp<ȱb
Hp<ʱb
Hp<ʱbQDHYM\fb
Hp<ʱba}Hp,ڱbQDHYM\fbA
Hp<̱bA}Hp
Hp<бb
Hp<ұb!}Hp
Hp<ұbQ|H
Hp<ֱbq,HY
Hp<ױb
Hp<ڱL
Hp<ڱb
Hp<ڱb!}Hp
Hp<ܱb
Hp<ޱb
Hp<߱b
HpDܫH
Hp\f1L
Hp\f1b
Hp\f±b
Hp\fƱbQDHY
Hp\fȱb
Hp\fʱb
Hp\fʱb!}Hp
Hp\fʱbAtHYE
Hp\fϱbQDHY
Hp\fбbat@Y
Hp\fұb
Hp\fұb"EH
Hp\fرb
Hp\fڱf
Hp\fܱb
Hpqb!D@Y
HpqbA|H
Hp±b!}Hp
Hp±bA|H
Hp±ba}Hp
Hpñb2
Hpñba|I
Hpñbqt@Y
HpıbA|I
Hpűb!L@Y
HpűbQ}Hp
Hpűba|H
HpƱb2E
HpƱbA
HpƱbQ}Hp
HpƱba|H
HpǱb1}Hpӱb
HpǱbA
HpǱbQ}Hp
HpǱba}Hp
HpǱba}Hpѱb
Hpȱb!|H
Hpȱba\f@Y
Hpɱb!|H
Hpɱb!}Hp1b
HpɱbQ|H
HpɱbQ}Hp
Hpɱba
Hpɱba|H
Hpɱbb
Hpɱbq}Hp̱b1}Hp߱b1}Hp
Hpɱbr}H
Hpʱb"U
HpʱbA|H
Hpʱba|H
Hpʱbr}H
Hp˱bA|H
Hp̱bA4H
Hp̱ba|H
HpͱbAD@Y
Hpͱbq}Hp1b
Hpαb!}Hpбb
Hpϱb!L@X
Hpϱb!|H
Hpϱb!}Hp1batH
Hpϱba}Hp
Hpбb!|H
Hpбb1
Hpбba|H
Hpѱb!TH
HpѱbA,@YU
HpѱbAD@Y
HpѱbQ}Hp
Hpѱba
Hpұb!|H
Hpұb!}Hp
Hpұb2UH
HpұbA|H
HpұbQ,HYU
HpұbQ}Hp
Hpұba|H
Hpұbr
Hpӱb!|H
HpӱbA}Hp
HpӱbQ\\HY
HpӱbQ}Hpݱb
Hpӱba}Hp
Hpӱbq|H
HpԱbA,@YU\vbB
HpԱbQ,HYU\rbB-H
HpԱbr
Hpձb"=H
HpձbA,@YU\abB
HpձbQ,HYU\tbB-H
Hpձba|H
HpֱbA}Hp
HpֱbQ,HYU
Hpֱbr}H
Hpױb!|H
Hpױb1|H
HpױbA,@YU\rbB
HpױbQ
HpױbQd@Y
Hpرb!}Hp
HpرbA}Hp
HpرbaD@X
HpرbaL@X
Hpٱb!|H
Hpٱb1,HY
Hpڱb!\fHY
Hpڱb!}HpԱbrM
Hpڱb1
Hpڱb1|H
Hpڱba}Hp
Hp۱b!|H
Hp۱bA|H
Hp۱bBUH
Hp۱bQ}Hp
Hp۱ba
Hp۱ba|H
Hp۱bbE
HpܱbAl@Yu\bb
HpܱbQ,@Y
Hpܱba|H
Hpܱba}Hp
Hpݱb1,HY
Hpݱb1|H
Hpݱba|H
Hpݱba}Hp
HpޱbQ}Hp
Hpޱba4@Y
Hp߱bAd@Y
Hp߱ba|H
HqP:\ai
Hq\e9\a
Ht:;HA
Hu;`4F
HvvGa
Hybrid Solver PARDISO with CGS/CG Iteration
HyͻKR
H{<no6
H{\f<OUv<8Ra
H|m;J
H~S=ita
Hǽ:pJe
H͛:pL
HлLj\t9j
Hա:Fo
Hܐ> 8o>d
H廼 \a
H쐼l6ϼD
I : %M : %S %p
I ;64
I I;U8r
I I;V8r
I \v; x1:H
I brMH
I!>HuR
I"9U/x
I#<ILK
I#=fW
I%7M\f\r7
I'9J\r
I(<4K
I(H+H H
I(L+I H
I+3;c
I+A0I+K
I,<zuH
I.Q;<ZI9Q
I/:6BB
I0T<UO
I0ŪXi
I2ּak
I3=8I
I3?;1
I3s:Ɂ\f:5u
I6<3b
I7,QG9d
I7v9#rX=O
I87:F:G:s
I98t\fL
I98u*A
I99C\eG
I9U0v
I9U8v+I
I9kj^;b
I9q sEI
I9}(tiH
I:'kh
I:2T\r9
I:5r:q
I:U+i
I:c:3ޙ9
I:k\f69c)4;x
I:ýND\v
I;1~NH
I;6\nw;uL
I;:\vje
I;;DC
I;A s>I
I;A`s?I
I;D$ w%H
I;D$Pt
I;E vBH
I;E vEH
I;E veH
I;E w%H
I;EPt+A
I;FPt
I;L$ w\n
I;L$ w\t
I;M w;I
I;M w\n
I;M w\t
I;MPt
I;NPt
I;O w\n
I;O w\t
I;U w\tI
I;U8r
I;V8r
I;\bA
I;\bt\aH
I;is\n
I;pf7
I;q s?I
I;s8A
I<$wh
I<N:8
I<RRĻ8
I=0\aW
I=Xwm
I=jm\b
I=xvW
I=|WZ
I>TtɾI
I>[eL>G
I?N;j
I@L9{8u\vH
I@ipl::HRTFMap::verifyDataHeader
IA:)Nx
IC;Z{k
ICMF}A
ICμyj
ICܱb!}Lp
ID + n-1 <= set.ext_range_size
ID$@H
ID$TL
ID<d-\n
IG4=>V
IH9;MK\r
IH9B\ftEHcR\fI
IHHcB\fJcL\b
IHŪ\\yP
IIݻEQ
IJL$PP
IJL$`P
IKD:fx
IKg<k
IM1:MT
IM<\e%2
IND)ind
IND)ind)SNAN
INFO code =: %d
INTEL oneMKL ERROR: %s
INTEL_ISA_DISABLE
IP<ga
IP<qN
IPAR(10) must have the value 1
IPAR(15)=%s. Parameters IPAR(14) and/or IPAR(15) were probably
IPAR(4) is greater than or equal to IPAR(5
IPAR(5)-IPAR(4)=%s
IPAR(5)=%s is less or equal to the current value of the iteration
IPL;N0
IPLAirAbsorptionModelType
IPLAmbisonicsType
IPLAudioEffectState
IPLBakedDataType
IPLBakedDataVariation
IPLDirectEffectFlags
IPLDirectSimulationFlags
IPLDistanceAttenuationModelType
IPLHRTFInterpolation
IPLHRTFNormType
IPLHRTFType
IPLOcclusionType
IPLOpenCLDeviceType
IPLProbeGenerationType
IPLReflectionEffectType
IPLReflectionsBakeFlags
IPLSIMDLevel
IPLSceneType
IPLSimulationFlags
IPLSpeakerLayoutType
IPLTransmissionType
IPLbool
IPLbyte
IPLfloat32
IPLint32
IPPCODE
IPPDATA
IQj=n
IS8Lpn:\nb
ISӻ\e\t
IXH;J(H
IXI;HXI
IZ;gFE
I\\\e;VYJ
I\aba|H
I\aba|\b
I\aba~\b
I\bI+\tH
I\bL+\vI
I\bba~\b
I\f@;z0u
I\nba^\bX
I\nкH
I\rba~\b
I\v<K6M
I\vڻXa
I_MPI_NUMBER_OF_MPI_PROCESSES_PER_NODE
I_MPI_PIN_MAPPING
I_MPI_THREAD_LEVEL
I`W<b
Ia<\t
Ib&:0\b
Ib:2\vP
Ib\t<2
Ic;HcS\bH
IcD$ A
IcD$$D
IcD$(IcL$,E
IcD$\bA
IcD$\bIcL
IcD$\bIcT$ McT$,H
IcD$\f
IcD$\fD
IcD$\fIcL
IcD$lL
IcElL
IcF\bIcN
IcF\bIcV McF$McV
IcF\fIcN
IcG\bIcW McW,H
IcL$lF
IcT$ McT
IcT$$McL
IcT$(IcL$$McD
IcT$8H
IcT$<H
IcV McV
IcV$McN
IcV(IcN$McF
IcY\fIcI
Ic}\bIcu
Ic̉U0H
Ic̉U`H
Ic͉T$0H
Ic͉U H
Ic͉U0H
Ic͉U\bH
IcԉL$HH
IcԉM H
IcԉM(H
IcԉM0H
IcԉM\bH
IcԉMpH
IcՉL$@H
IcՉM H
IcՉM0H
IcՉM@H
IcՉMPH
IcՉM\bH
Ic։M\bH
Id7;9O
IdP=s
If you are sure that everything is correct, you may force the
Iffffff
Ig8-QʹD19
Ihttp://crl3.digicert.com/DigiCertTrustedG4RSA4096SHA256TimeStampingCA.crl0
Ij$>P
Ij;#mD:K
IjL;C
Ik?<g
Iks:og
Il(;R
Il?333333c
Il\n;x
Ilu;Q
Index is out of bounds
Infinite loop
Infinite loop. At least one of parameters IPAR(8), IPAR(9), or IPAR(10) must be equal to 1
InitOnceExecuteOnce
Initialization failed to complete, or the parameter IPAR(7)=%s
Initialization failed to complete, or the parameter ipar[6]=%s
InitializeConditionVariable
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
InitializeCriticalSectionEx
InitializeSListHead
InitializeSRWLock
Initialized AMD Advanced Media Framework v%d.%d.%d.%d
Initialized Embree v%lld.%02lld.%02lld
Initialized OpenCL device: %s %s (%s
Initialized OpenCL platform: %s %s (%s
Initialized Radeon Rays v%.2f
Input absolute value of tolerance is greater than
Input check: Sequential OOC mode of factorization is incompatible with sequential IC mode of reordering
Input check: Two-level factorization algorithm does not work in OOC mode
Input check: empty input arrays ia and/or ja
Input check: i=%d, ia(i)=%d, ia(i+1)=%d are incompatible
Input check: i=%d, ia[i]=%d, ia[i+1]=%d are incompatible
Input check: i=%d, j=ia(i)=%d, ja(j)=%d are incompatible
Input check: i=%d, j=ia[i]=%d, ja[j]=%d are incompatible
Input check: i=%d, ja(i)=%d, neqns=%d are incompatible
Input check: i=%d, ja[i]=%d, neqns=%d are incompatible
Input check: i=%lli, ia(i)=%lli, ia(i+1)=%lli are incompatible
Input check: i=%lli, ia[i]=%lli, ia[i+1]=%lli are incompatible
Input check: i=%lli, j=ia(i)=%lli, ja(j)=%lli are incompatible
Input check: i=%lli, j=ia[i]=%lli, ja[j]=%lli are incompatible
Input check: i=%lli, ja(i)=%lli, neqns=%lli are incompatible
Input check: i=%lli, ja[i]=%lli, neqns=%lli are incompatible
Input check: ia(neqns+1)_new %d _old %d are incompatible
Input check: ia(neqns+1)_new %lli _old %lli are incompatible
Input check: ia[neqns]_new %d _old %d are incompatible
Input check: ia[neqns]_new %lli _old %lli are incompatible
Input check: ido_new %d (out of bounds
Input check: ido_new %lli (out of bounds
Input check: internal error, counted number of threads %d
Input check: internal error, counted number of threads %lli
Input check: iparam(6) %d (out of bounds
Input check: iparam(6) %lli (out of bounds
Input check: iparam[5] %d (out of bounds
Input check: iparam[5] %lli (out of bounds
Input check: j=%d, ja(j)=%d, ja(j+1)=%d are incompatible
Input check: j=%d, ja[j]=%d, ja[j+1]=%d are incompatible
Input check: j=%lli, ja(j)=%lli, ja(j+1)=%lli are incompatible
Input check: j=%lli, ja[j]=%lli, ja[j+1]=%lli are incompatible
Input check: matrix_number_new %d ido %d are incompatible
Input check: matrix_number_new %lli ido %lli are incompatible
Input check: matrix_type_new %d (out of bounds
Input check: matrix_type_new %d _old %d are incompatible
Input check: matrix_type_new %lli (out of bounds
Input check: matrix_type_new %lli _old %lli are incompatible
Input check: max_fac_store_in %d matrix_number_in %d
Input check: max_fac_store_in %lli matrix_number_in %lli
Input check: max_fac_store_new %d _old %d are incompatible
Input check: max_fac_store_new %lli _old %lli are incompatible
Input check: nb_new %d ido %d are incompatible
Input check: nb_new %lli ido %lli are incompatible
Input check: neqns %d or ia[neqns_in] %d are invalid
Input check: neqns %lli or ia[neqns_in] %lli are invalid
Input check: neqns_new %d
Input check: neqns_new %d _old %d are incompatible
Input check: neqns_new %lli
Input check: neqns_new %lli _old %lli are incompatible
Input check: nproc %d is not equal to counted number of threads %d
Input check: nproc %lli is not equal to counted number of threads %lli
Input check: preprocessing %d (out of bounds
Input check: preprocessing %lli (out of bounds
Input check: unexpected error with working arrays ia and/or ja
Input data or print help ? Type [data]/help
Input error is not equal to ZERO, error=%d
Input error is not equal to ZERO, error=%lli
Input parameters: inconsistent error= %d max_fac_store_in: %d
Input parameters: inconsistent error= %lli max_fac_store_in: %lli
Input value of DPAR(31) equals zero
Intel oneMKL BLACS fatal error: cannot allocate memory, aborted
Intel oneMKL DCSRILU0 ERROR
Intel oneMKL DCSRILU0 WARNING
Intel oneMKL DCSRILUT ERROR
Intel oneMKL DCSRILUT WARNING
Intel oneMKL DFTI ERROR: Configuration parameter DFTI_NUMBER_OF_USER_THREADS is not set
Intel oneMKL DFTI ERROR: Descriptor is uncommitted or corrupted
Intel oneMKL DFTI ERROR: Error in OpenMP
Intel oneMKL DFTI ERROR: Functionality is not implemented
Intel oneMKL DFTI ERROR: Inconsistent configuration parameters
Intel oneMKL DFTI ERROR: Incorrect status
Intel oneMKL DFTI ERROR: Internal error
Intel oneMKL DFTI ERROR: Invalid configuration parameters
Intel oneMKL DFTI ERROR: Not enough memory to allocate
Intel oneMKL DFTI ERROR: Transforms with number of points N of a non-unit stride dimension exceeding 2^(27-p) - 1 for N a power-of-two, or 2^(23-p) - 1 for N not a power-of-two, are currently not supported, where p=0 for single precision and p=1 for double precision
Intel oneMKL DFTI SUCCESS: No error
Intel oneMKL ERROR: CPU %d is not supported
Intel oneMKL ERROR: Incompatible optional parameters on entry to %s
Intel oneMKL ERROR: Parameter %d was incorrect on entry to %s
Intel oneMKL Extended Eigensolvers ERROR: Problem from Inner Linear System Solver
Intel oneMKL Extended Eigensolvers ERROR: Problem with array parameters
Intel oneMKL Extended Eigensolvers ERROR: Problem with input parameters
Intel oneMKL Extended Eigensolvers ERROR: Problem with internal memory allocation
Intel oneMKL Extended Eigensolvers ERROR: Problem with reduced system
Intel oneMKL Extended Eigensolvers Error: Matrix B is not positive definite
Intel oneMKL Extended Eigensolvers WARNING: No eigenvalue has been found in the proposed search interval
Intel oneMKL Extended Eigensolvers WARNING: Only the subspace has been returned
Intel oneMKL Extended Eigensolvers WARNING: Size subspace M0 too small
Intel oneMKL Extended Eigensolvers WARNING: Solver did not converge (number of loops reached maximum allowed
Intel oneMKL Extended Eigensolvers have successfully converged (to desired tolerance
Intel oneMKL Extended Eigensolvers: List of input parameters fpm(1:64)-- if different from default
Intel oneMKL Extended Eigensolvers: Resize subspace %d
Intel oneMKL Extended Eigensolvers: Size subspace %d
Intel oneMKL Extended Eigensolvers: complex double precision driver
Intel oneMKL Extended Eigensolvers: complex single precision driver
Intel oneMKL Extended Eigensolvers: double precision driver
Intel oneMKL Extended Eigensolvers: fpm(%d)=%d
Intel oneMKL Extended Eigensolvers: single precision driver
Intel oneMKL FATAL ERROR: Cannot load %s
Intel oneMKL FATAL ERROR: Cannot load %s or %s
Intel oneMKL FATAL ERROR: Error on loading function %s
Intel oneMKL FATAL ERROR: MKLMPI wrappers are NULL
Intel oneMKL FATAL ERROR: This system does not meet the minimum requirements for use of the Intel(R) Math Kernel Library
Intel oneMKL FATAL ERROR: cannot load %s
Intel oneMKL FATAL ERROR: cannot load %s or %s
Intel oneMKL FATAL ERROR: dynamic library %s is not convenient for this processor
Intel oneMKL FATAL ERROR: memory allocation error
Intel oneMKL INTERNAL ERROR: Condition %d detected in function %s
Intel oneMKL INTERNAL ERROR: Insufficient workspace available in function %s
Intel oneMKL INTERNAL ERROR: Issue accessing coprocessor %s
Intel oneMKL INTERNAL ERROR: Not enough work memory in function %s
Intel oneMKL INTERNAL ERROR: Optimization cache's size limit exceeded
Intel oneMKL POISSON SOLVER ERROR
Intel oneMKL POISSON SOLVER WARNING
Intel oneMKL RCI CG ERROR
Intel oneMKL RCI CG WARNING
Intel oneMKL RCI FGMRES ERROR
Intel oneMKL RCI FGMRES WARNING
Intel oneMKL ScaLAPACK fatal error: cannot allocate memory, aborted
Intel oneMKL TRIG TRANSFORMS ERROR
Intel oneMKL TRIG TRANSFORMS WARNING
Intel oneMKL WARNING: %s function associated with Intel(R) Xeon Phi(TM) x100 Product Family has been deprecated. Intel(R) Parallel Studio XE 2017 is the last supported version for this function
Intel oneMKL WARNING: CPU type %d is not suitable for this processor
Intel oneMKL WARNING: Library %s (oneMKL type %d) is not suitable for this processor (oneMKL type %d
Intel oneMKL WARNING: PGI support is deprecated and will be removed in the Intel oneAPI Math Kernel Library 2025.0 release
Intel oneMKL WARNING: Support of Intel(R) Advanced Vector Extensions (Intel(R) AVX) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library will use Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) instructions instead
Intel oneMKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions
Intel oneMKL WARNING: Support of Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library will use Intel(R) Streaming SIMD 2 Extensions (Intel(R) SSE2) instructions instead
Intel oneMKL WARNING: incorrect conditional numerical reproducibility mode, MKL_CBWR_AUTO is set
Intel oneMKL function load error: %s
Intel oneMKL function load error: cpu specific dynamic library is not loaded
Intel(R) 64 architecture
Intel(R) Advanced Vector Extensions (Intel(R) AVX) enabled processors
Intel(R) Advanced Vector Extensions (Intel(R) AVX) with F16C instructions support
Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX-2) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost
Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2) enabled processors
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) enabled processors
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, FP16 (limited) instructions, and Intel(R) Advanced Matrix Extensions (Intel(R) AMX) with INT8 and BF16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, FP16 (limited) instructions, and Intel(R) Advanced Matrix Extensions (Intel(R) AMX) with INT8, BF16, and FP16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, and FP16 (limited) instructions
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost) and bfloat16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost), EVEX-encoded AES and Carry-Less Multiplication Quadword instructions
Intel(R) Architecture processors
Intel(R) Streaming SIMD Extensions 2 (Intel(R) SSE2) enabled processors
Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled processors
Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) enabled processors
Intel(R) oneAPI Math Kernel Library Version
InterlockedFlushSList
Internal error
Internal error in %s: memory leak
InternalName
IntersectAny
IntersectAny2L
IntersectAnyRC
IntersectAnyRC2L
IntersectClosest
IntersectClosest2L
IntersectClosestRC
IntersectClosestRC2L
Invalid call sequence
Invalid error number
Invalid factor option
Invalid message argument descriptor
Invalid message level
Invalid message request. This should never happen in a normal situation
Invalid message request. This should not happen under normal circumstances
Invalid option
Invalid reorder option
Invalid string descriptor
Invalid structure option
Invalid termination level
Io;<W
Io;mS
IpŢ\\i0
IpƱba}Jpqb
Ipɱba}Jpڱb
Ip˱bA|H
Ip̱bA|H
Ip̱ba|H
Ipͱba|H
Ipαba}Jp±b
Ipѱba}Jp۱b
IpԱbA|H
IpݱbA|H
Ipݱba|H
Iq~;Y
Ir==s
IsDebuggerPresent
IsProcessorFeaturePresent
IsValidCodePage
IsValidLocale
IsValidLocaleName
Is\t;n
It is also possible that parameter IPAR(1) was altered by mistake outside of the routine
It is also possible that parameter ipar[0] was altered by mistake outside of the routine
It is possible that future usage for replacement of small diagonal values
It may be an error in one of the parameters
It may be an error in one of the parameters. The method may fail to proceed
It was probably altered by mistake outside of DFGMRES routine. The solution may be wrong
It was probably altered by mistake outside of the routine, or some characters in
It was probably altered by mistake outside of the routine, or the fifth character in the
It was probably altered by mistake outside of the routine, or the first character in the
It was probably altered by mistake outside of the routine, or the fourth character in the
It was probably altered by mistake outside of the routine, or the second character in the
It was probably altered by mistake outside of the routine, or the sixth character in the
It was probably altered by mistake outside of the routine, or the third character in the
Iv*;zy
Iz!4\a
Iz&94Z
Iz\t;OJ
I}ļm\vs
IƟ;Zo
Iɾy?ԽDC
I˔;\agi
I̺\epF
Iͤ:oq\t
Iιy9o
IϼX>R
Iм)lv
Iػ3ld;R79
IⱾ" V
J"bA|\b
J%:9J
J(=Y\tu
J(ba|\b
J):\bzs
J)\r;xhX
J,ba~\b
J-;kUQ
J-;mhۻg
J.i:_TC
J0:LN
J0:fQ
J0W;%\t
J0úJM
J2<2h
J4ba~\b
J5<#h\a
J5ջ\rFz
J79 X
J93ζ9
J9\re+:\e
J9`?Y
J:;5W;dw
J:@ž7v6z
J:B9\t
J:`\nx9
J;8n9d
J;K[U9ly
J;Lk5;9
J;Un#;J
J<0"0i3
J<Q2F
J<UP6
J<X[A
J<Ӻju
J=<qX
J>F*j=s
J?:RFk
J?\v<Xb
J@1;C
J@>HBh
JAKgdB
JAj;P
JBԓpBXchB
JCmQ,B
JG1>jY
JG<zf
JIU<:O
JJ:2uQ
JK\t;H
JL\v;C㍻qB\a;m\b5
JLνn;\b
JO2<i7y
JS9\fuq
JSv:J
JT:wx\t
JTxV`TXX
JU/9F=3
JVC;fN
JVͻM(1
JW,:IYK
JW,:k
JWP:>О7t
JWP;\a
JWĻCb
JX.<C
JXI źXy
JY;.iF;\rl
JYk;\n
JYl\al
JZ;pm
J\a;rd\v
J\ab!|H
J\abA|\b
J\aba|\b
J\b3\tB\f
J\b?ZU1
J\bba|\b
J\bba~\b
J\f=d3a
J\f\b
J\fba~\b
J\nbA
J\nba|\b
J\nba~\b
J\r9<c
J\rbA|\b
J\t:4
J]f=Dh
J`;3j
Ja':q
Ja8N؍:\vn
Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December
January
JbT:;ZB
Jbk9f
Jc,;_Yc;Gd6
JcD0\fI
Jgv<p
Jgн˜3=F\a
JhȽ|z
JkS>1C
Jl<MnA
Jnj:.N
Jo;ZQK
Jpαba}Ip
Jq<ٴN
Jq=\bt
JqӽoA
Jr5<P
Js\e;$E
Js~<b\t
JtC=L
Jv,=H5
JwH;k5
JxѻPK
Jy:<P
J|iNd
J~A<q\vi
Jž1k\t
Jƞ;\v6T
JʻamȻf
Jώ;M7
Jј<z1
JӰ9+Y9;4
Jӻv}i
Jԋ>I0
JֺVT98
Jٹ?Zi:7
JڹF\v
K H+ЋD
K SUVWAVH
K ġz^L
K"ԺWT
K#̈bS-J
K#͈bC\rL
K%2;V
K%Z;h
K(3\tD$4H
K(3\tD$4I
K(y:j
K)=2m
K*;1r\b
K*w;B
K+U<_jr
K-;EzY
K-k<C$C
K.Z9R
K.Ϻ5 ݻJe
K0H;\rr\\I
K0HcQ\f
K0HcQ\fD
K4:{e
K4w;E
K7r:3`9:%0
K8:˾Q
K8H;\rh\\I
K90;\f
K9Hu^9
K9Tљ9n
K9Y3u
K9k_(;mA4
K9v4%;Fu&:G
K;"bH
K;7`8
K;A\a@9
K;GqY
K;Nٰ8S"5;N=6
K;T3L
K;j2ļyP8
K;zj\r
K<V=s
K<aXG;0
K<gOo;k
K=9ev
K=o64=y\bc
K={wl>r1
K>H(L>Sg
K>exU?3
K>g'9
KAF:0
KB;1R\v
KD$ E3
KD=;k
KD?;h
KE; H
KERNEL32.DLL
KERNEL32.dll
KEѻSN
KF:)uV
KG\n;I
KHH;\rT\\I
KHf9}rx9
KHi;\\h
KI;)hR
KIڽ02
KJ;7-\a
KJ;?U
KJj;Z
KJn>EN
KM:\r
KM:^C\b
KN;\eN
KT,>w
KTW;Xr
KW;0'\t:T
KW;wy
KW\r;Υu;i
KWc;jۛ;a
KXH;\r_VI
KXM+KPI
KZI:5\t
KZ[:i!N
K[:cc
K\aU:3Of
K\abr}X
K\b;b
K\b<ic
K\b=CŹ=Yg
K\bATAUAVH
K\bH;\r3VI
K\bLc@\b
K\bSUVWATAUAVAWH
K\bSUVWH
K\bSVWAVAWH
K\bUATAUH
K\bUAVH
K\bUSAVAWI
K\bUSVWATAUAVI
K\bUSWATAVI
K\bUVWATAUAVAWH
K\bUVWATAUAVI
K\bUVWAUAVAWI
K\bUVWAVAWH
K\bUWAUAVAWI
K\bVWATAVAWH
K\bVWAVH
K\bWATAUAVAWH
K\bWAVAWH
K\bbA|H
K\fġz^L
K\n9[M
K\r<3S\a
K\r?z
K\v\tr\r0n
K]F;^3O
K]o9\v4
K]taM
K^a9ma
K`H;\rUVI
Ka=tCP
Ka|ptt
KbP9v
Kd %f %f %f\n
Kd:>J
Kernel32
KhH;\rb\\I
Kj:\f[H
Kk;\\S39
Klh:Rw
Klɻ22\r
KmV<3
Km|;jV7
Knights Landing
Knջdx
Ko\v=Y
KpH;\rX\\I
KpI;J
Kq6:_\r
Ks %f %f %f\n
Ks9\n
Kt@<TN
Kw!=>h8
KxH;\rN\\I
KxS:HQ
Kxɻ.U17n
Kz<1fS
Kz_;Zk
K{J9y
KŻ9\vo;\f
K˼g%7
KѼ\vC
Kѽ8:t
KԻY{G
KֻO\eͻz
Kּ]bK
KݻbW9
Kޢ;FM
L  fB
L 0fC
L <gtȻl
L v"X
L" fC
L#\r(N4
L#\r^d5
L#܈bs]I
L$ E3
L$ E3\v1
L$ H+L
L$ H;H\b
L$ H;T$P
L$ HcT$ H
L$ L;L$\b
L$ SUVWH
L$ SVWH
L$ SWAT
L$ SWAW
L$ SWH
L$ UATAUAVAW
L$ USATAVAWH
L$ USVATAWH
L$ USVAUAVAWH
L$ USVWATH
L$ USVWAVAWH
L$ USVWAWH
L$ USWATAWH
L$ USWAUAVH
L$ USWAUAWH
L$ UVWATAUAVAWH
L$ UVWH
L$ VWAVH
L$ bA~\b
L$ ba~\b
L$ fA
L$ fD
L$ fff
L$ t!A
L$(3ɉD$ D
L$(A2
L$(HcT$4H
L$(bb
L$,fD
L$0H+L$ H
L$0H+L$8H
L$0H;K\bt
L$0H;u
L$0HcD
L$0IcD
L$0IcL
L$0Lc@\b
L$0bA~\b
L$0ba~\b
L$0fA
L$0t!A
L$0t\rA
L$0ŘYD
L$0ŘYD$P
L$0ŘYE
L$0ŸX
L$4+L$8
L$4+L$H
L$89L
L$8E18
L$8HcI\fH9
L$8bb
L$8fffff
L$8t2H
L$<bb
L$@A9MP
L$@E)uP
L$@HcD
L$@HcT$PH
L$@HcT$dH;D
L$@IcD
L$@tBH
L$Bba~\b
L$HH;\rq
L$HL+L
L$HL;T
L$Hb!|H
L$Hfff
L$Hs!E
L$Lfff
L$P+M0D
L$P1ɺN
L$P1ɺ\b
L$P1ɺ\t
L$P3\tD$8H
L$PD9v
L$PH;L
L$PIcD
L$PbA~\b
L$Pba~\b
L$PfC
L$PfE
L$Pfff
L$PŰTE@H
L$PŰT\f
L$THc
L$Vba~\b
L$X+M0D
L$XI+L$PI;M
L$Xu3H
L$Xu<H
L$\bATAVAWH
L$\bAVH
L$\bE
L$\bL;L
L$\bSAUAWH
L$\bSUVWATAUAVAWH
L$\bSUVWATAUAVAWL
L$\bSUVWAUH
L$\bSUVWH
L$\bSVWATAUAVAW
L$\bSVWATAUAVAWH
L$\bSVWAVAWH
L$\bSVWAVH
L$\bSVWH
L$\bSWAUH
L$\bUATAUAVAWH
L$\bUH
L$\bUSATAVH
L$\bUSVAVH
L$\bUSVWATAUAVAW
L$\bUSVWATAUAVAWH
L$\bUSVWATAUAVH
L$\bUSVWATAVAWH
L$\bUSVWAVAWH
L$\bUSWATAUH
L$\bUSWH
L$\bUVWATAUAVAW
L$\bUVWATAUAVAWH
L$\bUVWAVAWH
L$\bUVWH
L$\bUWATAVAWH
L$\bUWAVH
L$\bVWATAVAWH
L$\bVWAUAWH
L$\bVWAVH
L$\bWATAUAVAWH
L$\bWATAUAVH
L$\bWAVAWH
L$\bba
L$\bba~\b
L$\bffff
L$\f b
L$\tba~\b
L$`H+t$PH
L$`HcD
L$`IcD
L$`L;d$PM
L$`fD
L$`fff
L$fba
L$fba~\b
L$hH+t$PH
L$hL9t$pu\bL
L$hba6
L$pH;D$h
L$pH;L$P
L$pbA~\b
L$pba~\b
L$pfA
L$pfB
L$pfff
L$pŰXMp
L$x3ۉT$XD
L$xH;t$h
L$xL;T
L$xba~\b
L&U for matrix number %d deleted
L&U for matrix number %lli deleted
L'3>7
L( fB
L* fC
L+L$8L
L+L$PL
L+L$xL
L+T$0H
L+T$hI
L+d$8H
L+d$8I
L+d$PL
L+d$XL
L+e E3
L+l$\bJ
L+l$pH
L+t$ O
L+w>p{B
L. >Y
L0;CV\b
L3 b1
L38;<d
L3:\a
L3;Kp
L3=,J
L3\bJ+\f3H
L5#;48
L5;Wp
L5<4끼<o
L6<v|Q
L7=Vo
L7A@V
L8<wNb
L9"t\rH
L90u H
L9;0ʍ:Y
L9;<T
L9@JL;4w
L9B\bt\vH;B\bv
L9D$`L
L9[\bt\vH;C\bv
L9d$(s
L9h\bu\bD
L9hc\n
L9l$xt
L9p s\nD
L9s.λJ
L9{\bt\vH;C\bv
L9|$PA
L9~Xv=I
L9~XvCI
L:%kM
L:Bx\f
L:E\bC:Tv
L:Zfc
L:nl~:85\f
L:x\e
L:{Lr9
L; u9H
L;3u3I
L;3u7H
L;3u;H
L;3u>H
L;9Bl;.u
L;;u6I
L;<\r9j
L;D$0r
L;D$0u#H
L;D$0u8H
L;D$8L
L;D$8u
L;D$8u H
L;D$HM
L;D$hM
L;L$8M
L;L$8u H
L;L$HM
L;L$XM
L;L$pt=I
L;PPZ
L;Q0s M
L;T$8M
L;X-x
L;\buFI
L;\r!g5
L;\r2e5
L;\rB[5
L;\rGd5
L;\rT(6
L;\r\aZ5
L;\r_d5
L;\roZ5
L;\t8g
L;\tM&9
L;a\ac:C
L;d$HH
L;d$X
L;d$\bM
L;d$pM
L;i%R
L;l$0H
L;l$PM
L;sMi9䳮8
L;t$pM
L;u}W
L;x\b
L<%OW
L<iWj
L<j_J
L<pAͺNt
L<q\fs<8
L<tsF
L=C\e
L?UUUUUUU
L?n(Zy
L@Y<9b
L@YA\vbaL@Yi
L@YI\fb
L@YQ\bb
L@Ya\tbaL@Ya\rbaL@Yq\nb
LA;$H
LAPACKE_NANCHECK
LAPACKE_sgesvd
LAPACKE_sgesvd_work
LAѼ\tx
LB 9J\bMc
LB89J\bMc
LBʺ,1
LCIDToLocaleName
LCMapStringEx
LCMapStringW
LCW&qB
LC_ALL
LC_COLLATE
LC_CTYPE
LC_MONETARY
LC_NUMERIC
LC_TIME
LCr;xp
LD_LIBRARY_PATH
LEv;B
LGλߞ4:nF
LHYu\bb
LHYu\fbBMH
LHYu\nb
LJ;t*6;\r
LL(;sd
LLS;D\n
LM 9U\bL
LM>:Gs
LNNLNNUNNLNN
LNNRNNUNNRNN
LNUNN
LNUNNN
LO=IKR=i
LP A9x\b
LQ::3F;U
LQ<\fm
LR;xP
LRVTBFBLVFBTFBBFBRVFBTFBBFB
LT fC
LT$0A9L
LTW;zh
LTϻpz
LU fC
LV{;z
LX<"H
LXֻK\t
LYN`ŔY
LY\e<<A
LZ6;Dc
LZ><5
LZCNT
L[:u5
L\a;h
L\a\nbQ|H
L\af;w
L\b;J\aU
L\bt;n
L\e:\ep\b
L\n  fG
L\n00
L\n\\;oPZ:rq
L\n\vba|H
L\r+;22
L\r<oK8
L\t<c(Y
L\t>J沾fQ
L\vN;Ye39
L\v\ryc5
L\v\r|X5
L`;wm
La9;F
Lba~\b
Lc@\bIc
Lc@\bJcT
LcA<E3
LcB\fHcJ
LcD$(I
LcD$4I
LcD$xH
LcI\bLc
LcL$ Ic
LcL$,L
LcL$<HcT$<H
LcL$<L
LcSlI
LcT$(Mc
LcT$4L
LcT$`Lc\\$pLc|$h
LcU\bLcE\fI
Lc]0LcM4HcU8
Lc]lI
Lcc0I
Lcd$tH
Lcd$xH
Lcg0āz
LcmwHc
Lco0āz
Lcs8L
Lcs<L
Lct$(M
Lct$DI
Lcǉt$8
Lcʍ\fRL
LcщL$HI
Lc҉T$4I
Ld;6,R
Ldy<x4
LeaveCriticalSection
LegalCopyright
Leպj'g
Lf ;1
LfH;xR
Lffff
Lffffff
LgQ<R
Lgk<pMm
Lhttp://cacerts.digicert.com/DigiCertTrustedG4RSA4096SHA256TimeStampingCA.crt0\r
Linear system Ax = b
Linear system Ax = b > < transpose
ListenerPosition
ListenerUp
ListenerView
LjȼF0
Lk6;S
LkڻA\n
Ll;=Z
LoadLibraryA
LoadLibraryExA
LoadLibraryExW
LoadLibraryW
LocalFree
LocaleNameToLCID
LookupPrivilegeValueW
Loop | #Eig  |    Trace     | Error-Trace |  Max-Residual
Lpd9\b
LsY;w
Lt:-q
Lu*E;t
Lu:/vR
Lu;4\a
LuȻS!T
Lw#;aR
LwCԓpB
LwZ:\aa
Lx4;V
LxZnf
LzdA9
L{;JlA
L{=R7
L}7;R
L~Z<9
Lú,vE
LǼhE強U
LȺ`FU
L۾=kmT
Lܟ<Fi
Lܻ/h0<S
L毺#$p9M
L溬U2<2
L뢺HCA;(sպ\tG
M &\r\t
M HcD
M HcE\b
M ŀYM0
M#g\bt
M#l$\bt
M#o\bt
M%;3J}6i
M&t:Z
M'y>0y
M(A+M0
M)\r=Dk
M+1 < max_size
M+2;5V
M+D$PI
M09L8\bu
M0HcE\b
M0L;x\b
M0ȹ6,h
M19uA
M1ػ\r
M2\e>(G0
M5D:\t
M6%:V\b
M8J<^N
M8L+M0L
M9,<o
M9e t4L
M9n t4L
M9n8v,I
M9~Xv=I
M9~XvAI
M9~XvCI
M9~XvDI
M9~XvEI
M::\fR6=F0
M:FWC9\a
M:F\t
M:F]T;i
M:i\r
M:mZI
M:~\aO9
M; Tz
M;=0c
M;Cis
M;D$0u
M;FXr
M;Iq
M;O w\n
M;O w\t
M;\vC
M;\vu.H
M;_\n0<d7
M;a)Y:cWa
M;gzѻj
M;oH|\nM;GP
M;uZ)9
M;x\b
M;yKL
M<Z⣼je
M<g-7
M<okk
M<u\a
M<v4S=dp
M<|nZ
M=F\rp
M>9rT
M>N:hO
M>jYX
M?H;MGs H
M?ؼ5T
M@9GlL
M@;\buA
M@ŔYq
MA!;b
MAh9k
MB (100.00
MC'<x
MC|D\t
MD#Έb3}D
METIS algorithm at reorder step is turned ON
ME\r<*j
MFغBV
MHLcC\bI
MIC_LD_LIBRARY_PATH
MK&;A
MKLROOT
MKL] [MIC %02d] [AO %s %s Time] %f seconds
MKL] [MIC %02d] [AO %s %s->%s Data] %llu bytes
MKL] [MIC --]   [AO %s Workdivision] %s
MKL] [MIC --]   [AO Function] %s
MKL_CBWR
MKL_DISABLE_FAST_MM
MKL_DOMAIN_ALL
MKL_DOMAIN_BLAS
MKL_DOMAIN_FFT
MKL_DOMAIN_NUM_THREADS
MKL_DOMAIN_PARDISO
MKL_DOMAIN_VML
MKL_DYNAMIC
MKL_ENABLE_INSTRUCTIONS
MKL_FAST_MEMORY_LIMIT
MKL_MPI_PPN
MKL_NUM_STRIPES
MKL_NUM_THREADS
MKL_SOMATCOPY(%c, %c, %zu, %zu, %f, %p, %zu, %p, %zu
MKL_VERBOSE
MKL_VERBOSE %s %s\n
MKL_VERBOSE WARNING: %s\n
MKL_VERBOSE oneMKL %d.%d
MKL_VERBOSE_OUTPUT_FILE
ML<\aur
MM/dd/yy
MM<-r
MM[<\fb
MM\v;S
MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON
MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON
MO=#II
MOVDIR64B
MOVDIRI
MOy:O
MP9'/r
MP;4nf
MP;H(s\bD
MP;H8s\bD
MP>9(4
MPH;w
MPI_LOCALNRANKS
MQ8;q\b
MQO;AG
MR:}U8
MS:DP
MSRLIST
MVC9bj
MW(;a\v
MW\\;yP
MXCSR
MXI+MPI;L
MYZ=t
MZC;\b\n
M\\Z:Zc
M\a>LmB
M\abQ|H
M\bbA|H
M\e"<Pp
M\e;C3B:r
M\fC:E
M\fbA|H
M\nbQ4HV
M\nbQ|H
M\r=e
M\rb"eH
M\rbQ|H
M\t<T3
M\t\f
M\tbA\\@YE\fbbu
M\tbA|H
M\tbb
M\vb"5H
M\vbQ|H
M]k9đ9;,h
M`I;4
Ma%=sQ
Making IPARM(16) comply with IPAR(1) and IPAR(15
Making IPARM(17) comply with IPAR(1) and IPAR(15
Making IPARM(18) comply with IPAR(1) and IPAR(15
Making IPARM(19) comply with IPAR(1) and IPAR(15
Making IPARM(20) comply with IPAR(1) and IPAR(15
Making IPARM(21) comply with IPAR(1) and IPAR(15
Matching is turned ON
Matrix checker is turned ON
Max split depth
MaxRealTimeComputeUnits
MaxRealTimeComputeUnits2
Maximum fill-in input parameter is greater than or equals
Maximum memory requested that can be used=%llu, at the size=%u
Mc,$H
McA\bHc
McD$lL
McL$l3
McL$lI
McL$lL
McU\fMc
Mc\rL
Mcl$0āz
Mcl$0ġz
Mcl$4H
Mcl$8H
Mcl$<H
Mco0ġz
MessageBoxA
MessageBoxW
Mf:\nVD:1
Mfffff
Mh<<l
Mhttp://crl3.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0S
Mhttp://crl4.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0
Microsoft Visual C++ Runtime Library
Min node overlap
Minimal supported version of the memkind library is 1.1.0
Minimum degree algorithm at reorder step is turned ON
Mi̻OT
Mj: <;e
Mkd;`8
Mkλ\f
Ml><\rm
MlJ;DhE
MmE;=\t
Mn,<e
MnY>g
Mnݺ?K
Monday
Mp\e<I⩼K
Mpqba}Npɱb
Mprim/s
Mp±ba}Npѱb
Mpȱb!}Np1b
Mpбb!}Npqb
Mpܱb!}Np
Mpݱb!}Np
Mpޱb!}Np
Mp߱b!}Np
MtR:gTK9
MultiByteToWideChar
Mw黋hºY
Mx=;81
MzE @t
M{<g5\b
M~ӻeD\r
MÅ9bs
M˻Voû9B
Mѻf'N
MԺXH:U
Mވ;TI
N 6:f
N 9M L
N ňYEp
N"7<aX3
N()8Ix
N(+N0
N(+N0A
N(A+N0
N*;eaL;A
N+h:J\t
N-<odm
N.9c\fu
N0l;g\a\n
N0ŨYE
N12:T\rz
N2Lɭ3
N3;:qV
N5:<3
N7w:\a
N8=?3w
N9Ɏm;q
N9ꚨ9*x
N:"l9;H0
N:&kK
N:,ZX
N:6hҺI
N:@ok
N:Bnz:l
N:I\n
N:\fJ
N:d$p9
N:xV 9lwm:L
N;2]P
N;:3S
N;EN\f<Wm
N;\eu\t;oV
N;yF(;d
N<<O0
N<R*NbJ*HI
N>?mt
N>O=I9
N?6;\t9
N?m;WN\n
NA;Re0
NAN(IND
NAN(SNAN
NB;9*\e
NC<\r&O
NCŻrB
NEչ;F9
NF-;FE
NGV:ps
NHv<\b4
NK"<4
NK=XiG
NLv!H
NLv"H
NNLUNNLNNLNN
NNNNLNNLNN
NNNNLNNRNN
NNNNLUNNNN
NNNNNLNLNN
NNNNRLNNNN
NNNNRUNNNN
NNNNUNNLNN
NNNNUNNRNN
NO+;p
NP:DJt
NPH;I|$p
NRNLLU
NS[;\br
NU:tv
NUֺRv
NVG<j
NW;Jʘ:I
NWW=D
NXI+NPI;M
NZt>R
N\a7>YP
N\bL91u
N\bYL$\\b
N\bYt
N\bYt$ b
N\eh;nD
N\f(8*h
N\f<5\e
N\n<6,u
N\n<g蚻=sM;Ez
N\n>m
N\v;S
N\vk;d5
N\vxV
N`LcF M
Nb!L@X
Nb!|H
Nb!}Hp
Nb!}HpǱb
Nb!}Ip
Nb!}Jp
Nb!}Kp
Nb!}Lp
Nb!}Mp
Nb!}Np
Nb!}Op
Nb"5@6
Nb"5Ce
Nb"]Oe
Nb"uMe
Nb1|H
Nb1}Hp
Nb1}Jp
Nb1}Kp
Nb2\rOe
Nb;f4
Nb<]f
NbA|H
NbA}Hp
NbA}Jp
NbA}Kp
NbA}Lp
NbA}Mp
NbA}Np
NbA}Op
NbB-Be
NbB-Ce
NbBMKe
NbBUCe
NbB]Me
NbBeDe
NbBmDe
NbB}Me
NbQ|H
NbQ}Jp
NbQ}Kp
NbQ}Lp
NbQ}Mp
NbQ}Np
NbQ}Op
NbR5Ce
NbRMKe
NbR]Me
NbR}Me
Nba|H
Nba}Hp
Nba}HpP
Nba}Jp
Nba}Kp
Nba}Lp
Nba}Mp
Nba}Np
Nbb5@6
NbbE@6
NbbUMe
Nbb}Me
Nbq\\HX
NbqdHX
Nbq|H
Nbq}Hp
Nbq}Jp
Nbq}Kp
Nbq}Lp
Nbq}Mp
Nbq}Np
Nbr%Le
Nbr%Ne
Nbr\rMe
Nbr]Me
Nbr}Me
Nc\\\b\fF
Nc|0\fA
Nehalem
NfD9d$pu
Nf\a<@\n1
Nfffff
Nffffff
Ng;a7a
Ni)9sW3
Nj7<h
Nl/7D\e
Nm,:p3
No (P)CG iterations will be performed as parameter
No FGMRES iterations will be performed as the limit for the iteration counter
No such kernel in program
No transpose
Node overhead
Non-unit
Not a square matrix
Not enough memory for OOC mode
Not enough memory to allocate work array in %s\n
Not enough memory to transpose matrix in %s\n
November
Npqba}Mpɱb
Np±ba}Mpѱb
Npȱb!}Mp1b
Npбb!}Mpqb
Npܱb!}Mp
Npݱb!}Mp
Npޱb!}Mp
Np߱b!}Mp
Nq);p
Nr维iT
Nso<Uh <[EF
Number of CPUs: %i
Number of columns less than one
Number of cores: %i
Number of items read=%d
Number of items read=%lli
Number of nodes
Number of nodes in corresponding non-split BVH
Number of non-zeros greater than nRows*nCols
Number of non-zeros less than nRows
Number of rays in the workload \n__global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n
Number of rows less than one
Number of tests: %i
Number of threads: %i
Number of triangle refs
Number of triangles
Number of unknowns computed in backward solving step
Number of unknowns computed in forward solving step
Nv<v\b
Nwܻ[Q
Nxr;z}C
NzQ759
NÒ9a/ֺG
NʹKwR
Nʼ8\r
NʽqQ;<b
Nйh4L
Nѫ8F k
NӹE0ٺ[YF
N֖<Hj
NֻM?c
Nސ:aG
N߈<7m\e
N꺑了9w
O +O0
O 9M A
O <6qﻁ?8
O ŰYL
O!9u\tr
O"<Fox
O%<bZ7
O&G=GM
O(+O0
O(+O0+M
O(D;O,L
O*u;C
O+ԻFcU
O,;42
O/;2R
O/M:Yj
O0L;`\b
O0S:#Q
O0ŨYEp
O2\r:T
O3 <9
O34<u
O3<\rL
O7;CN\a
O8eq۹9
O9:\e
O9>g+̾F~C
O9k\eL;7
O:L`z;6G
O:OI\t
O:XZ0
O:\rI
O:j\vκ\f6
O:n%I
O:n&c
O;)Kh97H
O;0JV
O;3eu
O;>Kf
O;EMX:L1
O;Q;0S
O;xY~:3
O;ʊZ9I
O<+Ch
O<I8r<55
O<PTS
O<RoL
O<\nm\a;U
O<o|x
O=Эl=rf
O>'Nz
O>A\v
O>a4\e
O@H+GHH
OB9>&L
OC;Ox
OE:;Cmɺn
OF<;AX
OFȻQ=\n
OI2;#C#8T9
OI>4v
OK;)n
OMPI_COMM_WORLD_LOCAL_SIZE
OMP_NUM_THREADS
OMs9Gr
OP4=q
OPH;It
OR<nNE
OS<\eoS
OT9IGU9
OU=\t9
OUA:\v
OXH+OPI
OXH;OPt
OXL+OPI
OY;;T
O\b&tN\b&dM\b&4L\b
O\bH99u
O\e{dP\r<u
O\r?e
O\ru>O\r
O\v⼋G
Obk:nz
OcE9H
Oci;60
October
Od:KF
Of ;EKr
Offffff
Oh6>I
Oh:t84;˴A
Oh;1O
Oi;Ǒs
Ok˻\n}4
Ol\f>k
Ol{gN
Om;Fq29"U
Oo<C`2
Oos<"m
Ooy:G9c
OpenCL.dll
OpenProcessToken
OriginalFilename
Osq<%\e
Otherwise, set the 1st and the 2nd character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, set the 3rd and the 4th character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, set the 5th and the 6th character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, the Poisson solver may fail to proceed
Ou:|J\a
Ou=g[P
Out of core Mb
Out of core time (in percent
Out of memory
OutputDebugStringA
OutputDebugStringW
Overflow
OwR<H
Oxb;V
Oy;_R\n
OyR=MI
OyT]Z
Oz;80\b
O}'<soV
O}Q;\ec
O}|8x
OŸdxp
Oȹa5\a
OȺaOι/x7
Oɻ\fS
Oλh%S
Oμ\btF
OϺ+i1
Oջ\fN
OܼRZȼS:S
OܼYGƼ9
O춻_xB;d
P#8\bUo
P$;5vc
P%8=R
P%;7vy
P&u:.Qs
P':Udo
P)e:J
P*;0pz
P+z;%\nP9
P,9E5
P.<dcm
P.T:X
P2<C.s
P4Ի.Co
P5=BM
P7%Cs
P7*;Y
P7g<hVB
P88EB8j
P90p»N2
P9ue!9
P9v_W
P9vۊ:y
P:;VNZ
P:KH2;v`\n
P:PYi
P:bB|:N^i
P:c!F
P:glm9
P:o!w
P:o/9
P;-sp;Q
P;2p-:cY
P;5\t
P;9G\b
P;:u6
P;;%z9P
P;;uD
P;HSr=P65
P;\eZ
P;nRǻ\b
P;ތh9
P<6{e
P<;pVq;y
P<_zûx8
P<x:C
P<zZ\t
P=X&a
P=id1=u
P> {r
P>FDO=mJg
P>q_Y
PARDISO Internationalization error. Message %d is unknown
PARDISO Internationalization error. Message %lli is unknown
PARDISO PERFORMANCE WARNING: Insufficient memory to obtain solution with %d nrhs in single step.\n    RHS will be split in %d parts with %d columns maximum.\n    To optimize performance increase MKL_PARDISO_OOC_MAX_CORE_SIZE (now: %dMB, should be %dMB
PARDISO PERFORMANCE WARNING: Insufficient memory to obtain solution with %lli nrhs in single step.\n    RHS will be split in %lli parts with %lli columns maximum.\n    To optimize performance increase MKL_PARDISO_OOC_MAX_CORE_SIZE (now: %lliMB, should be %lliMB
PARDISO error: internal error
PARDISO error: unknown bit size of pint
PARDISO is running in In-Core mode, because iparam(60)=0
PARDISO is running in In-Core mode, because iparam(60)=1 and there is enough RAM for In-Core
PARDISO is running in Out-Of-Core mode, because iparam(60)=1 and there is not enough RAM for In-Core
PARDISO is running in Out-Of-Core mode, because iparam(60)=2
PARDISO message: Interrupted by the mkl_progress function
PARDISO_OOC_CLOSE_FILE_ERROR occurred: %s
PARDISO_OOC_DELETE_FILE_ERROR occurred: %s
PARDISO_OOC_NUMBER_OF_READ_EQUAL_ZERO occurred: %s
PARDISO_OOC_NUMBER_OF_READ_NOT_EQUAL_COUNT occurred: %s
PARDISO_OOC_NUMBER_OF_WRITE_EQUAL_ZERO occurred: %s
PARDISO_OOC_NUMBER_OF_WRITE_NOT_EQUAL_COUNT occurred: %s
PARDISO_OOC_OPEN_FILE_ERROR occurred: %s
PARDISO_OOC_OPEN_MODE_FILE_ERROR occurred: %s
PARDISO_OOC_READ_EOF_ERROR occurred: %s
PARDISO_OOC_READ_INPUT_PARAMETERS_INCORRECT occurred: %s
PARDISO_OOC_READ_SEEK_ERROR occurred: %s
PARDISO_OOC_WRITE_EOF_ERROR occurred: %s
PARDISO_OOC_WRITE_INPUT_PARAMETERS_INCORRECT occurred: %s
PARDISO_OOC_WRITE_SEEK_ERROR occurred: %s
PA^A]A
PA_A^A
PA_A^A]A
PAq=?Mp
PBNDKB
PC6>g
PC<C\r
PCLMULQDQ
PCONFIG
PCż<0
PD9H t
PD@?h
PE:WGO
PE:[U
PE:ߴf
PG;82
PHH+P
PHH+P@3
PJ;I:qE
PJ;ug5;mɤ:|\r6
PJ<\f>ʻTH0
PKS;L
PL>\e7J
PLci\fM
PM<H\eW
PME<NT
POPCNT
PO˴@N
PPPPPPP
PQLNQQPQPP
PQN;n
PREFETCHI
PS;RG
PSMGGLNNPUFULQUNNFQUULLQPUNNFULQRNPUULQUFFLNLLQRNUULUQPUFFLNFLLQRNPUULUQPUFFLNLULQRNPULULQUNNFLLQRNULULUQPUNNFFLLQRNPULULUQPUNNFLULQRNPUULQUPQPUUUUNNQUFLUPUNNFPLLUUPQUNNFLUPLTQULUPUNNUUPLTULULPQUNNFUUPLTQULULPQUNNULUPLTQUULUPUNNFUUPLTUULULPQUNNFFUUPLTQUULULPQUNNFULUPLTQULLQUPQPLLLGGGG
PS~;ok
PT%&l
PT:\bnL
PTWRITE
PUUUUU
PV:R3\f
PX2?q\v
PYGpňY
PZ)>0X\b
P\aX=db
P\bG<A\f2
P\bJ<"ac
P\eR;g
P\rT91
P\rbA
P\t:YN9
P\tt\f8C:u\aH
P\v;I7\f
P\vT8D5
P\v˻b
P]A_A
P]A_A^A
P]DSH
P`H+PXH
P`m8ս\t
Parallel Direct Factorization is running on %d MPI and %d OpenMP per MPI process
Parallel Direct Factorization is running on %d OpenMP
Parallel Direct Factorization is running on %lli OpenMP
Parallel Direct Factorization with number of processors: > %d
Parallel METIS algorithm at reorder step is turned ON
Parameter ?PAR(1)=%e (the size of the domain along x-direction
Parameter ?PAR(2) was probably altered by mistake outside of the routine
Parameter ?PAR(2)=%e (the size of the domain along y-direction
Parameter ?PAR(3)=%e (the size of the domain along phi-direction
Parameter ?PAR(3)=%e (the size of the domain along z-direction
Parameter ?PAR(4)=%e (the size of the domain along theta-direction
Parameter ?par[0]=%e (the size of the domain along phi-direction
Parameter ?par[0]=%e (the size of the domain along x-direction
Parameter ?par[1] was probably altered by mistake outside of the routine
Parameter ?par[1]=%e (the size of the domain along theta-direction
Parameter ?par[1]=%e (the size of the domain along y-direction
Parameter ?par[2]=%e (the size of the domain along z-direction
Parameter DPAR(5)=%e should be positive
Parameter DPAR(7) was probably altered by mistake outside of the DFGMRES
Parameter DPAR(7) was probably altered by mistake outside of the DFGMRES routine
Parameter DPAR(7)=%e should not be negative
Parameter IPAR(1) is not equal to the parameter N
Parameter IPAR(1) must be a positive integer
Parameter IPAR(1) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(1)=%s is not equal to the parameter N=%s
Parameter IPAR(1)=%s must be a positive integer
Parameter IPAR(10)=%s is not in the admissible range {0,1,2
Parameter IPAR(11)=%s (the number of intervals in phi-direction
Parameter IPAR(11)=%s (the number of intervals in x-direction
Parameter IPAR(12)=%s (the number of intervals in theta-direction
Parameter IPAR(12)=%s (the number of intervals in y-direction
Parameter IPAR(13)=%s (the number of intervals in z-direction
Parameter IPAR(14)=%s is not in the admissible range from 1 to
Parameter IPAR(14)=%s should be equal to 0 before the first call to
Parameter IPAR(15)=%s should be positive
Parameter IPAR(15)=%s should be positive. If you wish to run the
Parameter IPAR(16) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(16)=%s must be a positive integer
Parameter IPAR(17) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(17)=%s must be a positive integer
Parameter IPAR(18) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(18)=%s must be a positive integer
Parameter IPAR(19) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(19)=%s must be a positive integer
Parameter IPAR(20) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(20)=%s must be a positive integer
Parameter IPAR(21) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(21)=%s must be a positive integer
Parameter IPAR(23) was probably altered by mistake outside of DFGMRES routine
Parameter IPAR(23)=%s must be a positive integer
Parameter IPAR(3) must be equal to 1 before the first
Parameter IPAR(3)=%s is not in the admissible range {0,1,2
Parameter IPAR(3)=%s should be equal to 1 before the first call to
Parameter IPAR(4) must be equal to 0 before the first
Parameter IPAR(4)=%s is not in the admissible range {0,...,15
Parameter IPAR(4)=%s is not in the admissible range {0,...,63
Parameter IPAR(4)=%s should be equal to 0 before the first call to
Parameter IPAR(4)=%s was altered outside of the routine or commit
Parameter IPAR(5) must be greater than or equal to 0 before
Parameter IPAR(5)=%s is not in the admissible range {0,1,2
Parameter IPAR(5)=%s should be greater than or equal to 0 before the first
Parameter IPAR(6)=%s is not in the admissible range {0,1,2
Parameter IPAR(7)=%s is not in the admissible range {0,1,2
Parameter IPAR(8)=%s is not in the admissible range {0,1,2
Parameter IPAR(9)=%s is not in the admissible range {0,1,2
Parameter ipar[10]=%s (the number of intervals in phi-direction
Parameter ipar[10]=%s (the number of intervals in x-direction
Parameter ipar[11]=%s (the number of intervals in the y-direction
Parameter ipar[11]=%s (the number of intervals in theta-direction
Parameter ipar[12]=%s (the number of intervals in z-direction
Parameter ipar[2]=%s is not in the admissible range {0,1,2
Parameter ipar[3]=%s is not in the admissible range {0,...,15
Parameter ipar[3]=%s is not in the admissible range {0,...,63
Parameter ipar[3]=%s was altered outside of the routine or commit
Parameter ipar[4]=%s is not in the admissible range {0,1,2
Parameter ipar[5]=%s is not in the admissible range {0,1,2
Parameter ipar[6]=%s is not in the admissible range {0,1,2
Parameter ipar[7]=%s is not in the admissible range {0,1,2
Parameter ipar[8]=%s is not in the admissible range {0,1,2
Parameter ipar[9]=%s is not in the admissible range {0,1,2
Parameters IPAR(1), IPAR(15) and IPAR(16) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(17) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(18) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(19) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(20) have incompatible values
Parameters IPAR(1), IPAR(15) and IPAR(21) have incompatible values
Parameters IPAR(4)=%s and from IPAR(5) to IPAR(10) equal %s, %s, %s, %s, %s, %s do not agree
Parameters IPAR(4)=%s and from IPAR(5) to IPAR(8) equal %s, %s, %s, %s do not agree
Parameters IPAR(5)=%s and IPAR(6)=%s do not correspond to each other
Parameters IPAR(7)=%s and IPAR(8)=%s do not correspond to each other
Parameters IPAR(9)=%s and IPAR(10)=%s do not correspond to each other
Parameters are set to
Parameters ipar[3]=%s and from ipar[4] to ipar[7] equal %s, %s, %s, %s do not agree
Parameters ipar[3]=%s and from ipar[4] to ipar[9] equal %s, %s, %s, %s, %s, %s do not agree
Parameters ipar[4]=%s and ipar[5]=%s do not correspond to each other
Parameters ipar[6]=%s and ipar[7]=%s do not correspond to each other
Parameters ipar[8]=%s and ipar[9]=%s do not correspond to each other
Patch %d
Pb!|H
Pb3]A
PbQ;y
PbQ}Hp
Pba~\b
Pbb=\b
Pc;J,Z
Pc<mf\t
Pd=J=j
Pe?9ȭ9
Percentage of computed non-zeros for LL^T factorization
Performance Summary (GFlops
Periodic boundary conditions can be used only for a pair of boundaries simultaneously
Permutation contains %d multiple element pairs (first: %d -> %d
Permutation contains %d multiple element pairs (first: %d -> %ld
Permutation contains %d out-of-range elements (first:  %d -> %d
Permutation contains %d out-of-range elements (first:  %d -> %ld
Permutation contains %lli multiple element pairs (first: %lli -> %lli
Permutation contains %lli out-of-range elements (first:  %lli -> %lli
Permutation is inconsistent
Pffff
Pfffff
Pffffff
Ph=\tcw
Phttp://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt0\t
Pl;=r
Pl>FE\e
Platform
Please contact Intel oneMKL Technical Support and provide as many details as possible
Pm<̱g
Pn_;A\fݺ9
PoԻ\b
PpH;G\btpH
Pr3<1
Precision
Preprocessing with input permutation
Preprocessing with multiple minimum degree with constraints
Preprocessing with multiple minimum degree, tree height
Preprocessing with state of the art partitioning metis
Press Retry to debug the application - JIT must be enabled
Probably the data were altered by mistake outside of DCG routine
Probe clustering complete. (%lld probes, %lld clusters
Proceed with (-value) if IPAR(7)>0, aborting otherwise
Product
ProductName
ProductVersion
Program
Ps >O2
PsӼ{Q
Pt*9Z
Pt\n<et
Pt\v<et\fA
Pv\f;n
Pw;D\a
PwK:7
Px$9ϧH;[Fs;M:B;6
Px:1IN
Px\e=5
Pxm=b
Pz}b!\n
P{;tiO
P{\b80\r
P}W9c\n
P~|94
Pũ;jR
Pƹ:HV9b/x
PʽJX@=1\b
Pꁺz1\r
Pﺜkn;TB
Q ba|\b
Q g;#a39e
Q)9&T
Q)G>v
Q*;9fͻ5
Q*\n8
Q,9mv
Q.>39
Q09ز1
Q0\n;Q
Q2;Wg
Q2\v>r
Q5rHg
Q6:%E
Q6:jkf
Q8+<\rp
Q8:@uZ9
Q8Kڐ:s
Q9-LM
Q99Ȋ9o
Q: 䙻l^K;v
Q:(ky
Q:@8R
Q:D=J
Q:Xji
Q:nDa
Q:|mH9
Q;3ң9
Q;9\e
Q;i\t4;8
Q;k$K
Q;rP,;9
Q;v#N
Q<6;˹hs
Q<Ee5
Q<LL㻷M
Q>)Hu
Q>.3Z
Q>9;D
Q?;4v
QA;ll
QC<CL\a
QCN:J
QC{;b
QDI:w
QF<k\nϻ,O
QF<wt9
QGջ}7;T
QH;Af;=jlG
QI);mF
QJI?me
QJr<h$4
QJ ~;F$I
QK[;pe
QL"<z
QLNPRT
QM:&WJ
QO<^UC
QQH:Nj
QRAPAQ
QRU=$m
QS:o|2
QT;3RB
QUٻtv
QW1<|KؼY
QXX9l
QXz<%V
Q\a:RM6
Q\aba~\b
Q\bI9Q\bu
Q\bba~\b
Q\f:z
Q\fba|\b
Q\fba~\b
Q\v=\tx\a
Q\v>'QP
Q\vb!f\bX
Q\vbaN
Q\vba~\b
Q]2<4
Q`1<l3
Q`H+QXH
Q`O;F
Qa;\rE
Qa湥\fY
Qc<rGP
Qd~;lM
Qffffff
Qg;]bĺn
Qg\t;\b
Qg󻤍f<P
Qh٢%v
Qi9<`N
Qi<;qӼf
Qj2<2
Qkkbal
Qk}9UHĻP
Qlp9iFٺ[Uk
QlغT7G
Qm9\b
QoF9vG
Qp:P3W
Qp;4^B
Qp\v;\f
Qq@<k`9
Qt"=3
Qu;|k99
QueryPerformanceCounter
QueryPerformanceFrequency
QwI;2
Qx$=nE
Qx:+BF
QzhÐ;3
Q{:re
Q~N;I
QĹh1F96(6
QŌ=ZF\a
QȻP1L
Qɼf+l
Qѻ6,L
Qڊ;\e 8
Qܼg1Z
Q於o~t<z
R!;6K
R$ba|\b
R$p;K
R&:1L
R&ٺrO
R(ȻTL
R+<cD
R-;\rqE
R-L;4
R-b:Z
R0<^2
R0<`6
R2<S1r
R3#;q
R3:#6
R4.:;bF
R6;:E膺8
R6;S+O
R8?Bh9
R8bXźN
R8sjz9
R8|=r
R9.vӹ\a
R9=Io9<}D5
R9A\f\f
R9D:U
R9NPh
R9Wd9
R9m>,P
R:7=K
R:=uo
R:o1j
R;F\n
R;JIG
R;[x~9\fA
R;g\eN
R;zY<h
R;ĹmS
R<jeźO%4
R<l6y=E`0
R<omۻ@} :zhg
R=xRl
R>B/e
R>z☿i
R@L;FXr
R@M;FXr
R@M;FXrϿ\b
RA4;9
RAA;z\b
RAO_INT
RC=hb
RCF;Z
RD=6>k
RDATA
RDRAND
RDSEED
RE\n;zD
RF:9RL
RFVLFV
RH<PX\e<ڀ=2Bk
RHлBnk
RIQ:az
RK>VWI=N
RM:PS
RN;Q5u
RNP=eN
RO;Uk
RPܻ=K
RRG<F0
RRX8Cv
RX;u1n
R[<bRl<v`p=4
R[N;n
R\aba|\b
R\b+z\bA
R\bba|\b
R\bbb
R\ebA|\b
R\fba~\b
R\fӻA@\t8
R\nK9r#M
R\nba|\b
R\r4:BF
R\r;C
R\rp\f`\v0
R\rp\f`\vP
R\rϺi\aC
R\t:f3
R\tba|\b
R\v:V
R\vۊk
R`Q<l\r
R`bA|\b
Ra;-jf
Ra\e:dB
RaiseException
Rb=ib>>s
Read failed
Read type=%d
Read type=%lli
ReadConsoleW
ReadFile
Reb;,9
ReceiverPosition
Reduction for efficient parallel factorization
Ref duplication
RefitBounds
Release
ReleaseSRWLockExclusive
Replicated array -- copy in process (%d,%d
Requested options conflict
ResetEvent
ResetEvent failed
Residual checks FAILED
Residual checks PASSED
RhbR%H6
RiF7B4
RjԻ6bM
Rk/<r
Rn黵_s9
RoInitialize
RoUninitialize
Row-replicated array -- copy in process row: %d
Rowwise
Rp3\tD$4I
Rs\e>$i
Rt>Y\v
RtlCaptureContext
RtlGetVersion
RtlLookupFunctionEntry
RtlPcToFileHeader
RtlUnwind
RtlUnwindEx
RtlVirtualUnwind
Rx.:M
RxL;l$P
RyV;I7
Rzh;~օ9%SP;iO
R~R;o
RĢ: x
RźE_M:j
RƺZWg
R˷cu*:Q
R֞:PC
Rݻ\eYP
R􂻬9ɻ1
S * numSamples) + (i * numSamples) + sample];\n    }\n\n\timpulseResponse[(batch * numChannels * numSamples) + (channel * numSamples) + sample] = value;\n}\n
S \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localkeys.x; \n            keys[newoffset.y] = localkeys.y; \n            keys[newoffset.z] = localkeys.z; \n            keys[newoffset.w] = localkeys.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localkeys = ((__local int4*)keys)[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals = ((__local int4*)keys)[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n        int4 bin = (localkeys >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.x; \n            out_values[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.y; \n            out_values[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.z; \n            out_values[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.w; \n            out_values[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        scanned_histogram[localid] += sum; \n    } \n} \n \n \n__kernel void compact_int(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_g
S$\r;ua
S%2;n
S%R;1mi
S(H+S0H
S)<:GO;4W
S,f<Ma
S-K=5
S0<CwS
S19=-o
S1<H6Y
S2<!fE
S2D<U
S38u\f
S76ƛ:G
S7;31
S8-pԺ7g
S8pŕ:r3\t
S8}!H
S8}$H
S9US}9Do
S9\e1ƺx_u;d
S9b,T:G
S9bmD:M
S:5\fI
S:RRݻʇE
S:^6O
S:a5B
S:jg.;O
S:nHJ
S:orA
S:tJ\a
S:u{q
S;AT5
S;ThM
S;XUѺ\r
S;\nKa
S;\vK
S;p\eg:ya
S<0M\e
S<;NI
S<DQӽ?\aQ
S<dl\f
S<dxU
S=E砽\f4\v
S>$hkDh$h>[2
S>ɽ\v5R
S?ۺuj
S@I;p\b
S@bR5@6
S@bR=@6
SATAUAVAWH
SATAUAVAWUH
SATAUAVH
SATAUAVUH
SATAWUH
SAVAWH
SAVAWUH
SAVAWUI
SBDSQR
SBx;L
SD<\fs6
SE,<1x
SELLLFFRNNULUUFFLNNU
SELLLRUNNAARLNN
SE˻E\f
SG;t'\e
SGEBD2
SGEBRD
SGELQ2
SGELQF
SGEMMT
SGEMQR
SGEQR
SGEQR2
SGEQRF
SGESVD
SGETSQR
SHA512
SIVE_PART_4(float) \n \nDEFINE_DISTRIBUTE_PART_SUM_4(int) \nDEFINE_DISTRIBUTE_PART_SUM_4(float) \n \n/// Specific function for radix-sort needs \n/// Group exclusive add multiscan on 4 arrays of shorts in parallel \n/// with 4x reduction in registers \nvoid group_scan_short_4way(int localId, int groupSize, \n    short4 mask0, \n    short4 mask1, \n    short4 mask2, \n    short4 mask3, \n    __local short* shmem0, \n    __local short* shmem1, \n    __local short* shmem2, \n    __local short* shmem3, \n    short4* offset0, \n    short4* offset1, \n    short4* offset2, \n    short4* offset3, \n    short4* histogram) \n{ \n    short4 v1 = mask0; \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y; \n    shmem0[localId] = v1.w; \n \n    short4 v2 = mask1; \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y; \n    shmem1[localId] = v2.w; \n \n    short4 v3 = mask2; \n    v3.y += v3.x; v3.w += v3.z; v3.w += v3.y; \n    shmem2[localId] = v3.w; \n \n    short4 v4 = mask3; \n    v4.y += v4.x; v4.w += v4.z; v4.w += v4.y; \n    shmem3[localId] = v4.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + shmem0[(2 * localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + shmem1[(2 * localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + shmem2[(2 * localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + shmem3[(2 * localId + 1)*stride - 1]; \n        } \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    short4 total; \n    total.s0 = shmem0[groupSize - 1]; \n    total.s1 = shmem1[groupSize - 1]; \n    total.s2 = shmem2[groupSize - 1]; \n    total.s3 = shmem3[groupSize - 1]; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    if (localId == 0) \n    { \n        shmem0[groupSize - 1] = 0; \n        shmem1[groupSize - 1] = 0; \n        shmem2[groupSize - 1] = 0; \n        shmem3[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem0[(2 * localId + 1)*stride - 1]; \n            shmem0[(2 * localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1]; \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem1[(2 * localId + 1)*stride - 1]; \n            shmem1[(2 * localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem2[(2 * localId + 1)*stride - 1]; \n            shmem2[(2 * localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem3[(2 * localId + 1)*stride - 1]; \n            shmem3[(2 * localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + temp; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    v1.w = shmem0[localId]; \n \n    short t = v1.y; v1.y = v1.w; v1.w += t; \n    t = v1.x; v1.x = v1.y; v1.y += t; \n    t = v1.z; v1.z = v1.w; v1.w += t; \n    *offset0 = v1; \n \n    v2.w = shmem1[localId]; \n \n    t = v2.y; v2.y = v2.w; v2.w += t; \n    t = v2.x; v2.x = v2.y; v2.y += t; \n    t = v2.z; v2.z = v2.w; v2.w += t; \n    *offset1 = v2; \n \n    v3.w = shmem2[localId]; \n \n    t = v3.y; v3.y = v3.w; v3.w += t; \n    t = v3.x; v3.x = v3.y; v3.y += t; \n    t = v3.z; v3.z = v3.w; v3.w += t; \n    *offset2 = v3; \n \n    v4.w = shmem3[localId]; \n \n    t = v4.y; v4.y = v4.w; v4.w += t; \n    t = v4.x
SJ:U]\r
SJ;uK0
SL:o\vu
SLAQRF
SLARFT
SLASQ2
SLASRT
SLD<;d
SLY:Ca
SMٻEG
SOFA file %s contains non-zero values for Data.Delay; this is not currently supported
SOFAConventions
SORG2R
SORGBR
SORGL2
SORGLQ
SORGQR
SORMBR
SORMLQ
SORMQR
SQ@>X
SR=:\bB
SS<J\f
SSE4.1
SSE4.2
SSE43D
SSE4_1
SSE4_2
SSSE3
SSTEQR
SSYGST
SSYR2K
STJ>T
STRICT
SU;CB
SUATAVAWH
SUATH
SUAUAVAWH
SUAWH
SUVATAUAVAWH
SUVATAUAVH
SUVATAUH
SUVATAVAWH
SUVATH
SUVAVAWH
SUVWATAUAVAW
SUVWATAUAVAWH
SUVWATAUAVH
SUVWATAUAWH
SUVWATAVAWH
SUVWATAWH
SUVWATH
SUVWAUAVAWH
SUVWAV
SUVWAVAWH
SUVWAVH
SUVWAWH
SUVWH
SUWATAUAVAWH
SUWATAUH
SUWAUH
SVATAUAVAWUH
SVATAUAVH
SVATAVAWUH
SVATAVH
SVATAWUH
SVAUAVAWH
SVAUAVH
SVAUAWH
SVAVAWH
SVAVAWU
SVAVAWUH
SVAVH
SVAWH
SVWATAUAVAWH
SVWATAUAVAWU
SVWATAUAVAWUH
SVWATAUAVH
SVWATAUAVUH
SVWATAUAWH
SVWATAUAWUH
SVWATAUH
SVWATAVAW
SVWATAVAWH
SVWATAVAWU
SVWATAVAWUE
SVWATAVAWUH
SVWATAVH
SVWATAWH
SVWATH
SVWATUH
SVWAUAV
SVWAUAVAWH
SVWAUAVAWUH
SVWAUAVUH
SVWAUAWUH
SVWAVAW
SVWAVAWH
SVWAVAWUH
SVWAVH
SVWAWH
SVWAWUH
SVWUATAUAVAWH
SVWUATAUAVH
SVWUATAUH
SV{TIJ
SV|;Th
SVۺcj
SWATAUAVAWUH
SWATAVAWUH
SWATAVUH
SWATAWH
SWATAWUH
SWATH
SWAUAWH
SWVUATAUAVAWH
SX<ZoG
SX<eTk
SX=fmZ
SXH+SPH
S\a>1J
S\aN>pl
S\aba
S\b&tR\b&dQ\b&4P\b
S\fbr}X
S\n99\f6
S\n\e;V@3
S\t=Bo
S\tbr}X
S\vl<\b
S\v˻3X
S_FORWARD_TRIG_TRANSFORM/S_BACKWARD_TRIG_TRANSFORM routine
S`H+SXH
S`Q;Udc
Safe minimum
SandyBridge
Saturday
Sb<DPL
Sc\\9Y
Scaling is turned ON
ScatterKeysAndValues
Scene is empty
SeLockMemoryPrivilege
Search interval [%.15e;%.15e
Search interval [%.7e;%.7e
September
SetEndOfFile
SetEnvironmentVariableW
SetEvent
SetEvent failed
SetFileInformationByHandle
SetFilePointerEx
SetLastError
SetStdHandle
SetThreadAffinityMask
SetThreadAffinityMask failed
SetThreadGroupAffinity
SetThreadGroupAffinity failed
SetThreadIdealProcessor
SetThreadIdealProcessor failed
SetThreadIdealProcessorEx
SetThreadIdealProcessorEx failed
SetThreadpoolTimer
SetThreadpoolWait
SetUnhandledExceptionFilter
Sffff
SimpleFreeFieldHRIR
Simulating reflections for %d sources, which is more than the max (%d). Some sources will be ignored
Single-level factorization algorithm is turned ON
Size   LDA    Align.  Average  Maximal
Size   LDA    Align. Time(s)    GFlops   Residual     Residual(norm
Size   LDA    Align. Time(s)    GFlops   Residual     Residual(norm) Check
Sj-;16\r9
Sj<#1\e
Sk0;1Z
Sk;|2M
Skylake Server
SleepConditionVariableCS
SleepConditionVariableSRW
Sls<69
Sm<HF
Smc:[oT
Sn8:\bn
Sn;-\fO
Sn;\t
Solution step
Solution step (100
Solution:      Time for reading from files: %f
Some of the parameters were probably altered by mistake outside of the routine
Some of these parameters were probably altered after DFGMRES init routine
Some parameters were probably altered by mistake outside of the DFGMRES routine
Some values from IPAR(11) to IPAR(21) were probably altered by mistake outside of the routine
Some values from ipar[10] to ipar[20] were probably altered by mistake outside of the routine
Sorry, no statistics for %s in case of a diagonal matrix
SourcePosition
Sp>g8d
SplitBvh\n
Sp커斻K
Ss=pM
Ss\b>(a
St;c|B
StJ:z7
StO9>T
Statistics
Steam Audio
Steam Audio Core
Stopping parameters DPAR(1) and DPAR(2) should not be
StringFileInfo
SubmitThreadpoolWork
Success
Summary PARDISO
Summary: ( cleaning phase
Summary: ( factorization phase
Summary: ( reordering phase
Summary: ( solution phase
Summary: ( starting phase is factorization, ending phase is solution
Summary: ( starting phase is reordering, ending phase is factorization
Summary: ( starting phase is reordering, ending phase is solution
Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday
Sunday
Sv\a>6
Svڻ%W
SwitchToThread
Sy*>TE
System error in PARDISO
SzԺ`3
S{h;R
S~:\bz,9F
SŴ:p1i
Sƒ6jp
Sʅ;QV
SӀ:FfZ91
SӋ>x0
SӺWs\f
SԹk@Y
Sռk\r콆1
SܹS0-;\aX
S߹\rX6
S溝OƻlU
T  fB
T 6<.è7k
T :H]Z
T!;\fAI=HH
T!<qf
T" fC
T"9xh
T$ :T$0uj
T$ :T$pu2
T$ D)s
T$ H;D
T$ IcG
T$ bA~\b
T$ fA
T$ fff
T$ t!A
T$ u?H
T$":T$RuV
T$#:T$cuL3
T$(ba
T$01\t
T$09t
T$0H;T
T$0Hc\aE
T$0IcG
T$0Lcd
T$0fA
T$83ЉT$8I
T$89T
T$8E+T$\bE
T$8H;T$P
T$8fffff
T$8ffffff
T$8t8E
T$8ġzYl
T$<9T$D
T$@HcElH
T$@fA
T$@uVH
T$Dba6
T$Dba~\b
T$H3\tD$8
T$H3ۉL$P
T$H9SD
T$HH+T$@H
T$HL9
T$Hb!|H
T$PHcL$LH+L$0A
T$PIcG
T$Pb!|H
T$PbA~\b
T$Pfff
T$Pffff
T$Pr%H
T$PŀW%!g6
T$PŀW%a
T$PŨTE
T$XH;T$P
T$XH;t$0
T$XI+T$PI;U0w\tI
T$XL;T$ps-I
T$XL;T$ps.I
T$Xfff
T$Xt!A
T$\bvpA
T$\fba6
T$\fba~\b
T$\fuPH
T$`A9r\b
T$`HcۉD$XHc
T$`IcD
T$`IcG
T$`Mcd
T$`fA
T$db!6
T$dba~\b
T$fb!6
T$fba~\b
T$hH;t$h
T$hL;T$h
T$hu1H
T$pIcG
T$pfA
T$pfD
T$pfffff
T$t<tA
T$xba
T$xbb
T$xffffff
T$xuMA
T$xuQ
T%O;J
T%a\f2
T%~Bl
T( fB
T* fC
T*\abA|H
T+=\elA
T+\aba|H
T,7#1T:g
T,Z=T
T-2>A
T-z*A
T.;WLY
T/;ivJ
T1R:3
T1X;2\v
T1\\;kO
T2E:m
T2]:v
T2xġjYT2
T3:.a19
T3:\rc`:0
T4;r~c<v2
T8*NR:5
T8-9D
T8^<r
T8e;!RT
T8Ǽ6뽣s
T9E)y; 9o
T9Q=C
T9i5Z:\tH
T:/Iu:0
T:7*h
T:9(j9
T:I:Z
T:ZXW;10
T:\aEe
T:\ts
T:r~s8
T;9?N
T;\nb
T;f%g;An ;6
T;hD\e
T;s@K
T;лIB
T<@zɽA\fC
T<gLk:F\fX
T<p;ol
T<q\tӼ\tI
T=?uB
T=G\n
T=Pms
T=fQμ\n
T=f]1
T=s\tP
T=|ZB
T>G'i>s;I
T?E;EAf
T?j?Y
T@YU\bb
T@Ym\nb
TANCreateContext
TANCreateConvolution
TAz<)o
TBgvlC~0GB
TC:i5
TC>0L
TCg:G
TD;J t
TEP:$q
THYT\a\fb
THYɍT
TIf:'XȻz
TJ;Z6
TKS;X
TKS< R
TL¼\vR
TM@ŰTE
TMd;g
TN;?l
TNǻo\f
TO@ŀTG
TO@ŐTG
TO@ŠTG
TQ\v;K
TS;0C
TT fC
TT.:77
TTRVLVRVVRLVRVLVRVVRLVRVLVRVRVLVTTRBVLBVRBVRBVBLVRVLVRVRVLVRFVFLVRFVRFVLFVRBVLBVRBVRBVBLVRFVFLVRFVRFVLFVRVLVRVRVLV
TTo;\t
TU fC
TV;<\fd
TV;l>n9
TV@ŨT
TX,"H
TX\f1L
TY,>5
TY-BK6
TY5%G
TYO`ŤX
T[9d%D
T\a<Vn4<rD
T\a\bba|H
T\a\bbq|H
T\a\tbQ|H
T\a\v:8
T\a\vba|H
T\b<J
T\fU;Sm
T\n( fG
T\n(v5B
T\n00N
T\n80E
T\n<a5
T\nM90A
T\n\bba|H
T\n{O<W
T\nŀTB
T\nňTB
T\nŐTB
T\nŘTB
T\tƻZ
T\v!hn7
T\v8=\vO
T\v<a\a
T^9;qA
T_:4Y
Targets
Task does not fit RAM, OOC LU factorization algorithm is turned ON
Task does not fit RAM, OOC NLL factorization algorithm is turned ON
Task fits RAM, OOC NLL factorization algorithm is turned ON
Tasking
Tba:Wi
Tbߺ1h
Te;hQG
TerminateProcess
Teջ\rKD
Tf %f %f %f\n\n
Tffff
Tffffff
Tf黌:7
Th'= s\r
The CPU is not supported in this Intel oneMKL version
The absolute and relative stopping parameters DPAR(1)=%e and
The absolute stopping parameter (zero norm tolerance) DPAR(8)=%e
The absolute stopping parameter DPAR(2) is out of
The absolute stopping parameter DPAR(2)=%e is out of admissible interval [0,infinity
The computations may fail to proceed and/or The result may be incorrect
The computations may fail to proceed and/or the result may be incorrect
The data in parameter DPAR were probably altered by mistake before
The data in parameter SPAR were probably altered by mistake before
The data in parameter dpar were probably altered by mistake before
The data in parameter spar were probably altered by mistake before
The dimension of the trigonometric transform %s should be
The file %s was not opened
The file was not closed
The input vector value |F(1)|=%s is bigger than the tolerance
The input vector value |F(IPAR(1)+1)|=%s is bigger than the tolerance
The input vector value |f[0]|=%s is bigger than the tolerance
The input vector value |f[ipar[0]]|=%s is bigger than the tolerance
The local (internal) PARDISO version is                          : %d
The local (internal) PARDISO version is                          : %lli
The matrix is probably (almost) non-positive definite
The maximum number of elements for scan exceeded\n
The mesh size in the direction theta, ?PAR(2)=%e, must be positive
The mesh size in the direction theta, ?par[1]=%e, must be positive
The mesh size in the direction y, ?PAR(2)=%e, must be positive
The mesh size in the direction y, ?par[1]=%e, must be positive
The method may fail to converge
The method may fail to proceed
The number of OMP threads defined by parameter IPAR(10)=%s should be
The number of OMP threads defined by parameter ipar[9]=%s should be
The parameter IPAR(15) was probably altered by mistake outside of DFGMRES routine
The parameters were probably altered by mistake outside of the routine
The previous call to a Intel oneMKL Trigonometric Transform routine produced an error
The previous call to a Poisson solver routine has failed or has not been made
The previous call to a Trigonometric Transform routine produced an error
The problem is degenerate due to rounding errors. The approximate solution
The processor must support the Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions
The processor must support the Intel(R) Streaming SIMD 2 Extensions (Intel(R) SSE2) instructions
The processor must support the Intel(R) Streaming SIMD 3 Extensions (Intel(R) SSE3) instructions
The processor must support the Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) instructions
The processor must support the Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) instructions
The relative stopping parameter DPAR(1) is out of
The relative stopping parameter DPAR(1)=%e is out of admissible interval [0,1
The result may be inaccurate
The result may be incorrect
The solution may be wrong
The solvers_ee interval generator has failed to find the requested number of eigenvalues. Try\n increasing the number of requested eigenvalues, as this can increase likelihood of success
The tolerance parameter DPAR(1)=%e is not in the admissible range [0,infinity
The tolerance parameter SPAR(1)=%e is not in the admissible range [0,infinity
The tolerance parameter dpar[0]=%e is not in the admissible range [0,infinity
The tolerance parameter spar[0]=%e is not in the admissible range [0,infinity
The type of the trigonometric transform %s is not in the admissible range {0,...,5
The value of input tolerance parameter is negative
This binary version of the SMP LINPACK benchmark is optimized for and runs on only genuine Intel processors
This device does not support HLBVH construction\n
This is a netCDF dimension but not a netCDF variable
This message reserved for future use and should not be displayed
Threads
Thursday
Time A to LU
Time cgs
Time fulladj
Time malloc
Time numfct
Time parlist
Time reorder
Time solve
Time spent in additional calculations
Time spent in additional calculations                            : %f s
Time spent in additional calculations                            : %f s total - sum: %f s
Time spent in allocation of internal data structures (malloc
Time spent in allocation of internal data structures (malloc)    : %f s
Time spent in allocation of internal data structures (malloc)    : %f s total - sum: %f s
Time spent in calculations of symmetric matrix portrait (fulladj
Time spent in calculations of symmetric matrix portrait (fulladj): %f s
Time spent in calculations of symmetric matrix portrait (fulladj): %f s total - sum: %f s
Time spent in copying matrix to internal data structure (A to LU
Time spent in copying matrix to internal data structure (A to LU): %f s
Time spent in copying matrix to internal data structure (A to LU): %f s total - sum: %f s
Time spent in data preparations for factorization (parlist
Time spent in data preparations for factorization (parlist)      : %f s
Time spent in data preparations for factorization (parlist)      : %f s total - sum: %f s
Time spent in direct solver at solve step (solve
Time spent in direct solver at solve step (solve)                : %f s
Time spent in direct solver at solve step (solve)                : %f s total - sum: %f s
Time spent in factorization step (numfct
Time spent in factorization step (numfct)                        : %f s
Time spent in factorization step (numfct)                        : %f s total - sum: %f s
Time spent in iterative solver at solve step (cgs
Time spent in iterative solver at solve step (cgs)               : %f s
Time spent in iterative solver at solve step (cgs)               : %f s total - sum: %f s
Time spent in matching/scaling
Time spent in matching/scaling                                   : %f s
Time spent in matching/scaling                                   : %f s total - sum: %f s
Time spent in reordering of the initial matrix (reorder
Time spent in reordering of the initial matrix (reorder)         : %f s
Time spent in reordering of the initial matrix (reorder)         : %f s total - sum: %f s
Time spent in symbolic factorization (symbfct
Time spent in symbolic factorization (symbfct)                   : %f s
Time spent in symbolic factorization (symbfct)                   : %f s total - sum: %f s
Time symbfct
Time total
Times
Timing linear equation system solver
Tj(<1Q
TjO;]eD;W
TjQ>g
Tl<W*G
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
Tn":xH\r
To;d|\v
Total size of data transferred
Total time (100
Total time spent
Total time spent                                                 : %f s
Total time spent                                                 : %f s total - sum: %f s
Translation
Transpose
Tree height
TrueAudioNext.dll
TryAcquireSRWLockExclusive
TryEnterCriticalSection
Trying to free NULL matrix
Tts;1
TtƼ_T
Tu;S{A
Tuesday
Two-level factorization algorithm is turned ON
Type Descriptor
T~780
T~=\rwZ
T~żpA
TúfW5
Tü\tFF
Tƻj\rŻZ
Tʃ;zN
TҨ>6y
TӨ\bt\v
Tָ/7^94LȻ5
Tٽlh\b
Tۥ<zo
Tݓ>Hmg
T㈼y2G
T溚0c;Uw
T󶹡xȺ30
U 5<'\aZ
U bA, X
U t\tAk
U";<1dP
U%bRE
U(A+U0A
U(t2E1
U)x;TJ
U*=\vPe
U,9Sn
U.2<TNM
U09\f
U0;9iS:\\K
U0A9T$0A
U27<S
U2弇:l
U5<\aB
U6+;b
U6<F4̻K
U6w<N
U7>\nt\e
U7y;O
U8LOR9Y
U:$I=9ZLo
U:)MK
U:,D6
U:,VO9
U:6<r
U:93w
U:\eje;F7
U:\rCV
U:\vgR
U:oF,;i
U;'97
U;)f7
U;6<QY
U;A\vu
U;Bu=;7o\a
U;ES-9b
U;L]@9XbE
U;\egr
U;\tpZ
U;mRj
U<&e0
U<Os:TP
U<g<4.n
U=.m0
U=9xk
U=dh!?K
U>s82
U?q:dq
U@M;p\b
UA>N0Wl
UAH:dxe
UATAUAVAW
UATAUAVAWH
UATAUAWH
UATAUH
UATAVAWH
UATAVAWI
UATAVH
UATAWH
UAUAVH
UAUAWH
UAVAWH
UAVVWSH
UAWAVAUATVWS
UAWAVAUATVWSH
UAԻV1
UAݽ{FO
UBdn~C
UD$pfA
UD$pfD
UDm;hʤ<o'Z
UDݺ\f\b
UEͻv{\v
UF,:fAG
UF>yd
UFLUNNUF
UGݼ|Gӻc
UH#ψbc}H
UH#ψbs}H
UHG;8X
UHM<g
UJ%:R\v
UJ\rka
UNKNOWN
UNNRNNLNNRNN
UNNTTNT
UO <\n
UOW9\b
UP;;c
UQq;"O
URn<t
US;z\tP
USATAUAVAWH
USATAUAWH
USAUAVH
USAUAWH
USAVAWH
USER_MSR
USVATAUAWI
USVATAWH
USVAUAVAWH
USVAUI
USVAVAWH
USVWATAUAVAWH
USVWATAUAVH
USVWATAUAWH
USVWATAUH
USVWATAUI
USVWATAVAW
USVWATAVAWH
USVWATAVH
USVWATH
USVWAUAVAWH
USVWAUAVH
USVWAUAWH
USVWAUH
USVWAV
USVWAVAWH
USVWAVAWI
USVWAVH
USVWAWH
USVWH
USWATAUAVH
USWATAWH
USWATAWI
USWAUAVAWH
USWAUAWH
USWAWH
UT:N%\n
UTF-16LEUNICODE
UTc;֛b:su
UTu;HX\n;L
UU;"V
UUUUUU
UUUUUUU
UV;ab
UVATAUAVH
UVATAVAWH
UVATAVH
UVATH
UVAVAWH
UVAVH
UVAWH
UVWATAUAVAW
UVWATAUAVAWH
UVWATAUH
UVWATAVAWH
UVWATAVH
UVWATAWH
UVWAUAVH
UVWAUAWH
UVWAUH
UVWAVAWH
UVWAVAWI
UVWAVH
UVWAWH
UV\e=o
UWATAUAWH
UWATAVAWH
UWATAVH
UWAUAVAWH
UWAUH
UWAVAWH
UWAWH
UXI+UPH
UXI+UPH;S8w\tH
UXI+UPI;T$0w\nI
UXI;UPt
UZ%;w
UZ;\f{D
UZ?5t,?G
U\\:s&c9e
U\aI>^v
U\abA|H
U\af;b
U\b4>L
U\b<x/2
U\bbA|H
U\bt;X
U\nbQ|H
U\r;Z
U\t<Gd
U\t>u
U\tbA|H
U\vbA|H
U_;F6
U_d:Fd!;q
Ua;pr
Ua=Wf
UaK<N36
Uba4AY
Uba4BY
Uba|XZ
Ubq4IY
Ubq4JY
Ubq4XYK
Ubq<XYC
UcY:(3\b;3B
UdǺ8I
Ufj:0
Uft;]a
Ug)<pD
Ug;B"a
Ujn;Lr\b
Ul;uN\\8
Um<bn
Unable to create OpenCL kernel %s. [%d
Unable to load SOFA data. [%d
Unable to load SOFA file: %s. [%d
Unable to open verbose output file
UnhandledExceptionFilter
Unknown CPU
Unknown error in %s
Unknown exception
Unknown matrix type
Unĺ\r
Uo:DR
Up;LG\t
Update %d
Urp;kv6
User provided fill-in reducing permutation is turned ON
UserProfile
Using %d CUs for convolution, %d CUs for IR update
Using OpenCL device: %s %s (%s
Using OpenCL platform: %s %s (%s
Ut\b<u
Uu;)L
UuL;Cb
UvW;aRr
Ux;=k
Uzz:C\b
U{pNo
U|j;c
UĻ@LS
UƹS9B9
Uɹjbs
Uк0\a
Uټo 3
U܄;r\nD
Uܹ8Q˺ז8
Uܺp(D
Uݺ;y71
U㽼T_D
V!;i5
V&ͽRU
V'Z<_2P
V(A+V0A
V)< R
V-s=Qj
V.;Yw麑\rG
V/f9% 1
V/ҺKc\v
V0z\vx
V0};ur
V38sHR
V5=os
V7:ZC
V8<W&B
V9#EM:z
V:<kv:i
V:Lj\v:9
V:bsr;\b
V:dX;:o
V:dz8
V:nfP:{&z
V:s.q
V:w1f
V;-IM:Z
V;0Lq
V;3{59
V;=dY
V;Bx\r;w
V;Gw\t
V;LwR<0
V;WU3;N
V;gs\f
V;h=vCN
V;j5X
V;wR\a
V;͞j;mm19h2u;z
V<<f06
V<D~j<s\v
V<GZs
V<`gg
V<l;Bk
V=/6R
V=2KN
V=ʸ\rAf;d
V>\aV
V>h:w
V>o6A
V?&pW?SHX?j
V?:wF
VA';e
VA7<5
VATAUAVAWUH
VATAVAWH
VATAVH
VATAWUH
VAUAVH
VAVAWH
VAVAWUH
VAVAWUI
VCϺNp
VEa9Sk
VFổfa;'W
VKV:E
VL;B?3
VOȽGd :v
VPCLMULQDQ
VPH;VXw
VQ[;Ba
VQߺ2z
VR0;X
VS<kS
VS_VERSION_INFO
VUUUA
VUUUUUUUH
VV}:j
VWATAUAVAWH
VWATAUAVAWU
VWATAUAVAWUH
VWATAUAVH
VWATAUAWH
VWATAUH
VWATAVAW
VWATAVAWH
VWATAVAWUH
VWATAVAWUL
VWATAVH
VWATUH
VWAUAVAWH
VWAUAWUH
VWAVH
VWAWH
VWUSATAUAVAWH
VXH+VPH
VXH+VPI;U0w\tI
VXH+VPI;W0w\tI
VXI+VPI;U0w\tI
VXI+VPI;W8w\tI
VXS;\n\t
V\\:SUn
V\\t;aFe
V\a=F@Y<N
V\bF\nV\f
V\bN\f"\n
V\bXy\bb
V\b\\a\vb
V\b\\i\bb
V\fffffff
V\fлZj
V\r9>Q
V\rO8M\n
V\tT;5
V\ta<Y
V\v6I]Dc
V\v;N
V]8iMĺÇI
V]ügHS
Valve Corporation
Vam;9lE
Vba~\b
Vc=N-\t
Vc>L\bH
Vd;kT
VeO<Qm
VeU:Z
Vg}9OE
Vh>6Q&?f
VirtualAlloc
VirtualFree
VirtualProtect
VirtualQuery
Visual C++ Compiler
Vlۼd\e
Vr<NfݼA9k
Vs:=2
Vs^<WV
Vu;ӿl
VuK<y
Vv;JQf
Vv;LL4
Vw:;u\f
VzO:ӪO
V{N;jyr
V|3<K\f9
V|;6fb
V}0<NTq:Q
Vƺ60N
Vƻ_ZV
VǽHc7
Vȼ5D<p
Vμ4R»Z
VϺBh6
Vӻ8%t;y
VԹBQZ
W A+W0A
W \aae
W%.;JtS
W%3<Wx
W%\t=DX
W%t<l#s
W%ҼMN
W&b<O3
W)9\a
W+A>zgD
W,;Yb
W,<fr
W,=gzq
W.s;j
W1a>C
W2:L3
W2ʺ`m
W2ؼFl
W35;|p
W5L:q6
W6;s6
W6\tf
W8<UW
W8WAD
W8m;A
W9>58l
W9BHA9Y
W9j^!;U
W9u#3
W9}0Y
W9ЪG:D
W:'Bl;A
W:7CW
W:7eO95
W:KwӺd
W:L~V9
W:R㸹s
W:j)b;N
W:uls
W:xs`9
W;&wS
W;'8J
W;*I6
W;JJD
W;\bj\a
W;\fVA;av
W;d A
W;j\vl;A
W;ԼJ9
W<96裻\e
W<>Sa
W<XrR
W=*zd=z
W=UՒ>Sb
W>EWC
W>P$D
W@ӻhK
WAITPKG
WARNING: "Flush to Zero" or "Denormals are Zero" mode not enabled
WARNING: AdjustTokenPrivileges failed to enable SeLockMemoryPrivilege: Add SeLockMemoryPrivilege for current user and run process in elevated mode (Run as administrator
WARNING: AdjustTokenPrivileges failed while trying to enable SeLockMemoryPrivilege
WARNING: LookupPrivilegeValue failed while trying to enable SeLockMemoryPrivilege
WARNING: OpenProcessToken failed while trying to enable SeLockMemoryPrivilege
WATAUAVAWH
WATAUAVAWL
WATAUAVAWUH
WATAUAVH
WATAUAVUH
WATAUAWH
WATAUAWUH
WATAUH
WATAUUH
WATAVAWUH
WATAVH
WATAWH
WAUAWH
WAVAWH
WAVAWUI
WAֹDl
WBNOINVD
WC<p\f
WCQ;ǡA
WCv;Щ29D
WD$PL
WD$`I
WD$`M
WD$pI
WD$pL
WD2:o
WD;N \b9f
WD<Ig
WG$85d
WIDE-KL
WJ=Q$a
WK?;7zx:i4
WLcT$PLc\\$HHc\\$@Hc|$8Hct$0L
WN;Z2
WNd;S
WPB:YQ
WQ-<P
WR-:L
WR2;D
WR;RmA
WRMSRNS
WS<_Z
WSVATH
WT=lY
WU(;O
WU3:\n
WU;t9d
WUUUUU
WVSATAUH
WXH+WPH
WXH+WPI;T$0w\nI
WX½\bT6
WXмhcO
WYֽ]a
WZp:h9!<B
W[k;W
W\b:vC0:J
W\bM;P\b
W\bfD9g\n
W\bʼ9c
W\bʼN
W\ns;.X
W\r3;I
W\r>0쏽W
W\rz=pc
W\t=T\b\n
W\t˺l8
W_2;1\a
Wa:wvf
WaitForSingleObject
WaitForSingleObjectEx
WaitForSingleObjects failed
WaitForThreadpoolTimerCallbacks
WakeAllConditionVariable
WakeConditionVariable
Warning
Warning message has been written in %s
Warning: Consider use of MKL_RODFT00 instead of FFTW_RODFT00 in planning r2r transforms with FFTW3 interface to Intel oneMKL (see Intel oneMKL Reference Manual
Warning: incorrect parameter %s (%i
Wc;!42
Wd>;5\b
We appreciate your assistance and apologize for any inconvenience
We appreciate your assistance and apologize for any inconvenience resulting from
We)=D
We9 =N
Wednesday
Wg;;n
Wg~;R
Wh9<.WC
WhƹcJ\n
WideCharToMultiByte
Windows (64bit
Wj;Z;x9
Wk%;t
Wk̼;l3
WkֻTdp
Wl*<0`w
Wl;eEH
Wm:\b`a9
WnȼPQ
Woy:\v\a
Wp>;vi
Wqݻ)D
Wr95B
WrM<dr
Write type=%d
Write type=%lli
WriteConsoleW
WriteFile
Wrong number of vertices per face
Wrong parameter %d in %s\n
Wrote %d items
Wrote %lli items
Ws,<WrQ
Wv:u5B
WvQ;:Mj
WwN<&yx
Wx;GoI
Wz+9Sx
Wz{:u
W|F<u
W}U:8h
W}u;C\v7
Wí9QcW9q
WƼqѼV
WȮ9WH\r
WɄ:AaI
W̼\raq
Wκ[5J
WӚ>n2
W⊼ \t
X 843"8
X @8u/t
X UVWATAUAVAWH
X UVWAVAWH
X UVWH
X VWAVH
X rwI
X"<Ikd
X%VJ2
X%^n2
X&:9G
X)9/j
X,;dJ
X,;s 5;xA
X-J}1
X-Z\a2
X-\tz
X-i|2
X2ԺK\r6
X3g=Xx
X3ۉT$HD
X4:[447)9
X5w9}^O;}C
X69}%r
X6;H3\e
X7f:\e\r\r
X9=\f
X9\bY
X9iAy:g
X9}ٓ8e
X9ܰt:4
X:9.08
X:=Ic
X:AuI<WBV
X:\e8\a
X:\et0
X;%Cu
X;\v$p;C2
X;yb!<v
X< w\eI
X<\e1M
X<\evx
X<f<2
X<f\vw
X<o`5
X<t\eu
X=[g8>t
X=t\vu<E
X>7iad8
X>\ek
X?bq<XYE
X@I;XH
XA(źXy
XA_A^A]A
XC\b;R_\b
XF:g.A
XG.:n8
XG;uٯ9p
XG\a<\\ 3
XHսi7
XI+@PH
XI+@PI+JPH
XI@źXy
XI\tba
XIm< A
XKO<#B
XL#@L
XL&@ġLY
XL6@ġLY
XL>@ġLY
XLc_lA
XOK;gL
XOK;t
XP\e9
XQ\fŢXi
XR?9Dz
XRe76o
XS&=0
XSh;Yq
XT,9Иk:0
XT-5ho
XT<ZO
XTR;|b
XT\r,+r
XT\r8@r
XV27U
XW;\a
XW<\tv
XY$ŢXi
XY<Dm
XYFpŀY
XY\nba^\bXI\tb
X\\tH$5
X\a;yh
X\bUVWATAUAVAWH
X\bUVWAVAWH
X\bm;5
X\r;3
X] ŸXU
X]A_A
X]A_A^A
X]A_A^A]A
X]pĂy
X]pŸX
X`n:a
Xa:vE>;t
Xa\vbaN
XbS;~Y
XbbE\b
Xbt<f
Xc;FKu
Xc=+Xc=+Xc=+Xc
Xe ŬX
Xe=kme
Xe@żX
XeL;'2
Xe`ŬX
Xfffff
Xfy9q
Xhl:(D
Xi Ś\\I
Xi\fbaF
Xj:Gnw
Xl$\bba
Xl:n")9
Xl;\a\a
Xl<-W
Xm.=o9R
Xm0ŘX
Xm@ŘX
XmPŸ\\MP
Xm\b?#8
Xob:ͪ\v
Xp:IH
Xq3;f\e
Xq4Ś\\aT
XqLł\\iL
Xq\fba
Xs.<(1V
Xt$PĂy
Xt$pĢy
Xu`Ăy
XupĂy
Xvϻqz
Xw>YZ
Xwj:β;9
Xwǽ5c
Xx;YmƽϺ\t
X}PŐY
X~úY9
X~ʼcg
Xʒ:5d
Xʻ6M3
X̼Y漼yh
Xͻ\t2
XӺ+5q
XԻk%v
Xⷸ%PZ
Y F;R
Y a:j
Y ba|\b
Y ŢXY
Y!;yU
Y!\f8
Y!\f9
Y$:7l
Y%2;+5n9
Y%:nFh
Y%CL6
Y&:hj
Y&<b2B
Y'̺3T
Y*<5Y
Y+9)K
Y-C~1
Y-D<G
Y-w;W\rA
Y/o<Ww
Y/Ļoon
Y0<9m
Y4+bA|@Yt
Y4>M&\f
Y4ba~\b
Y76<(\v
Y83hѺF
Y8ba~\b
Y8~\t
Y9;H&E
Y9Q\b_9
Y9\rHN9
Y:ZhJ;*Xߺ4h
Y:aB3;Y
Y:dKb
Y:vg~9D
Y:~fw
Y;%ki
Y;/Bg
Y;9b\t;s
Y;<t2
Y;\f g
Y;\r3e
Y;\tw\f;M
Y;gk2>xQ
Y;p9f;Ԡf
Y;xbV
Y;z)k
Y<\v8X<Vh
Y<_B6
Y<ba~\b
Y=\f\eI
Y=u:2
Y=u<R
Y=v6L9
Y=}4A
Y>eu>>S
Y>kX>M\e
Y?;oB
Y@[9ϩs9L
YBT>x
YD$ H;\r
YD$ H;\rv+S
YD$ ŀY
YD$@ŠXt$pŨXl
YD$PM
YD$PŘY
YD$PŠXt$pŨXm
YD$PŠY
YD$`ŰXT$0
YD$pI
YD$pŠXt
YD$pŠY
YD$pŨY
YDؼ4g
YE(<e
YE0ŠXupŨXm
YE0ŨXm
YE0ŰX
YE@ňY
YE@ŤX
YE@ŨXm0ŠX
YE@ŨXm0ŠXu
YE@ŰX
YE\vbQ
YE`ŔY
YE`ŰXUP
YEpŀY
YEpŠXu`ŨXm
YEpŨXm@ŠXu
YEpŸYM
YF\n<Z
YF`ńY
YGpŀYO
YHS;rM
YHa>K]I
YHb=0
YJ1:u
YL!<h5
YL$ ŐYD
YL$ ŘYD$0
YL$ ŘYE
YL$0ŠYE
YL$0ŨY
YL$Lbb\r
YL$Pt=fD
YL$Ptef
YL$PŰYD
YL$`ŨYE
YL$pňY
YL$pŐX
YL;Sw
YM ŘYE0
YM0ŠYE
YM0ŸYD
YM@ŘYEP
YMPŘY
YMPŘYE
YMPŠYE
YM\a:'Y
YM\rbA|H
YM`ńY
YM`ŘYE
YM`ŘYEp
YM`ŠYE
YM`ŨX
YM`ŬY
YM`ŸYE
YMpŀY
YMpňY
YMpŘY
YMpŘYE0
YN`ńY
YN`ŰY
YNb=#uA
YO0ŠYE
YO;ΝA
YO@:h
YO`ŔY
YO`ŤYE
YOz;7\b
YO캨9P
YPŊ\\I0
YQ<We9
YQȼzN
YR<U깺!aS
YT$@fA
YT;7]A
YU;5Z\a<7
YU\tbAD@Y}\vbBmH
YV;H]\b
YV;y]j;LkZ
YWw;j'w
YW˹l\b
Y[L;w
Y\a=l
Y\aba|\b
Y\b<VS
Y\b>H
Y\b>p
Y\bba~\b
Y\e<V l
Y\f+Z\fA
Y\f.9\nX
Y\f1ġzY
Y\f>b
Y\fba|H
Y\fba~\b
Y\nbA~\b
Y\nba~\b
Y\r1=.e
Y\r9&0
Y\rB82
Y\rXE6
Y\r\tL6
Y\r\v82
Y\rbav\bX
Y\rd{2
Y\rs[2
Y\t;4$n
Y\t;gdӻu
Y\t\b
Y\tba~\b
Y\vba~\b
Y\vl\rm p
Y]PŠXt$PĢy
Y]PŠXu0
Y`>0\nS
Y`O:@8j
Yb :3:W
Ybo;`Ox
Yc;,6f
Yd$@ŐYU
Yd$`ňYU0
Yd$pŀY
Yd$pŘY
Yd$pŘYU
Yd\a\nb
Yd绝oۻ4
Ye0ňY
Ye@ŀY
YePġHY
Ye\nbA|H
Yffff
Yh\a=V
Yi;PC
YiN<hA
Yk'>X
YkƻҳJ
Yl\atĢY
Ym Ÿ\\M
Ym0Ÿ\\M
Ym\bb!4HY
Ym\bb"EH
Ym\bbbM
Ym\rbA\\@Y
Ymں\tJ
Yn;ư*9E
Yn\v<fD
YnպյL;K
Yqz>~/k
Yr@;7
Ys\f;,F
Yu9l]A:5
YuPŰ\\E
Yu\fb
Yu\nbA|H
Yu\vbA|H
Yvc;cT
Yw;\b0c
YwǼ)汼MTi
Ywۼ;Q
Yx:\n
YxԻwJo;{Q
Y}N:Mb
Y}\bbA4HYe
Y}\nbA<@Ym\fbA|@YE
Y~ügN\v
YĻyj
YƉD$hB
Yͼiuм5
Yև>0g
YۻK[W
YbѼYZ̼r
Z <"F
Z ba~\b
Z!0;1
Z"R&f
Z#;Go8
Z':cn
Z'M;c
Z(8;H\b
Z(R&f
Z(\a<bt
Z)8E/W9
Z)bA|\b
Z+5<1
Z,R&8 `2
Z,ba~\b
Z0=M,N
Z0[<E
Z0bA|\b
Z2:Bm
Z2b:y Y9
Z30:Bq
Z3@<s
Z3m<B\t
Z3Խ3-d>R
Z4g<Vh
Z5-;iK
Z6=r^9
Z7s:9
Z8\e0
Z95~j
Z9F<rti;Q
Z:4\e
Z::Mt:t
Z:=QtS
Z:Glj8
Z:T4c:J
Z:d?p9
Z;"X4
Z;/aC;M
Z;K*c
Z;MUh
Z;\es
Z;b\v:b
Z;e3мU
Z<2b1
Z<N$O
Z<S;\rl
Z<cDݼ\b
Z<riw
Z=1ችDP
Z=\rIn=U
Z=qh\n>5
Z>6E\v
Z>M#O
Z?<Gsg
Z?ǻUa
Z@t<3y
ZC=\rg
ZCr;B
ZE:Ik1
ZE\t:l\f
ZFa=b
ZFλgX\e
ZGϺqFx
ZH<\f1
ZHEGST
ZI{;Ct
ZM:iR\a
ZN;\e
ZO:"k
ZR<)dl
ZRU=3e
ZS\b;EN\r
ZT;kJ
ZU<\v
ZWz;nc
ZX ;|i
ZX<xۣ;X
ZXXPHP
ZXǼDSC
Z\\Q4ŊXY0
Z\aba|\b
Z\b;\e4
Z\bba|\b
Z\e{&1q
Z\eŻle
Z\f:Md
Z\fbA
Z\n(~Zh
Z\rbA|\b
Z\rκ9;9
Z\t1<Ⱦ9
Z\tbA
Z\tba|\b
Z\vbA
Z\vo>8
Z]輴dY
Z^<C9
Za;\a
Zb(<N\vG
Zci:eF
Zd;،g;s
Ze+:g
Zero pivot detected
ZgC;d
Zj9dtK
Zk;k袻K
Zk\r9
ZlͻZm\v
Zrk;D
Zu1;At
Zw:3>f
Zy9\b
Zy;R齺ݺE
ZzS;\t
Z{Etm;,M
Z{L:J
Z}F7Q;l
Z~@f#aCW
Z¼n4\b=v
ZȺ2AE
Z̻y\rR
ZЕ;Jcm
ZԻEs3
ZԻ[S2
ZոV\b6
Z㻩t:r2
a >= 0 && a <= 255
a D=Q
a e=^v
a non-negative integer. Assigning to the parameter IPAR(10) the default value
a non-negative integer. Assigning to the parameter ipar[9] the default value
a!4\n
a";gn
a"C<EV
a#Ib?AG
a$9\n
a$ba~\b
a%;vGj
a';N8
a*c:n
a-2<H8
a/1<MX
a/ݻi\ne
a09;z
a0;JJs
a0;u8
a1R;\t
a1\t9(f
a2;%\bn
a32:1
a3<U2
a3F:γ4
a3ɉt$(H
a4-;Z
a5::I
a5;hE
a5ӻ\n@Y
a8ܻA_軙14
a9,_W8
a9;E\e :2
a9<4Lṻ1
a9=2ں|Q
a9F$ 9
a9\bfr
a9k}\f
a9t;2
a9x"\a0h#\a'4P
a9x&\a0h'\a'4X
a9z9|v
a:&Ex
a:0)b8
a::\amٺUI
a:;Pi
a:?h\nx
a:IrQ:q
a:VHZ
a:ZlH:co
a:\eEF
a:\rnߺi
a:mᗼN
a:oF\n
a:r?a8
a:wݑ9
a:䋆:RGI
a;"jf
a;/kY
a;GI\b
a;HJ\n9
a;ScֺM
a;W9滻b
a;WHj
a;Wvp
a;\f\rh
a;\te7;a
a;\vUe
a;\vis:3
a;djE;AXO
a;hzx
a;ja».E
a;mG\r
a;o\n
a;o}K
a;qϠ6/do
a;rX\n
a;v&G
a<#o9
a<%hf
a<)pL
a<)q2
a<CuRH
a<KN\n9
a<K嘻sk\b
a<SXԼ2
a<V"a9
a<XBF
a<\au`I
a<\aufH
a<\aujH
a<\tWZ<omJ
a<a櫼\fy
a=#qn
a=,ücAv
a=FA8
a=X5i
a=b4D
a=bV\n
a=fiJ
a=lHe>z
a=lV\e
a=o=1
a=v_g
a>2MR
a><gAd
a>B}h
a>Q>TQ
a>Ud6>O7n
a>uZ>2
a?;RFe
a?a:s
a@;C3
a@b;zO
aAͽ:\f5
aAݻis
aB=i\n\r
aCo7"L
aE3\nS\tI
aE3\nW\tI
aE<zQ
aEh;VB
aF\r:0i
aH9D$8t
aH9D$8t0
aH9G\btkH
aHcwHB
aHc|$dH
aHc|$tH
aHc|$xH
aHc}$H
aHh:P
aIcp\bH
aJ:TRH
aJn?L
aKi;E훺b
aL;<V
aL<Z\f
aL=T\a8
aM+\vE+C\bL
aM5;k
aNX<C
aO=W"L
aP3:GG
aP5<L1Q
aP<ut
aQ8=S
aQ;l&\n
aQ<6`d
aQ<=u
aQżqK3
aR=?3
aS;_a\b9
aSU:LD
aT0:b
aT4;#L
aT4>m
aTI=\f
aU_=d
aV\n;gt
aX:8m
aY>7%Z
aYw;e
aYỒ;C
a\a<\a0
a\aba|H
a\aba~\b
a\abq|H
a\b<z
a\bL+!I
a\bL\ne\v
a\bbQ|H
a\bba~\b
a\bd&\a D
a\bf=\a
a\e<\va
a\f$9
a\fba|\b
a\n8_F
a\n;V
a\n;x3
a\n<ps\b
a\n^=ci
a\nba~\b
a\r9l}M
a\rm;\fS#:xx
a\rx:T\f
a\rӺE
a\tD;A
a\tba~\b
a\v:6
a\v:x
a\vba~\b
a]:MyH
a_\r;wVD
a`h;ziV
a`ۼRZ
aa\b;t
ab!|H
ab!}Hp
ab5;a
ab<0\ba
abA|H
abA~\b
aba|H
abcdefghijklmnopqrstuvwxyz
abq}Hp\f
acc.type
accel
accel_mb
accels
activeTimeSegments > 0
acۺT?I
add@ThreadPool@TaskScheduler@embree@@QEAAXAEBV?$Ref@UTaskScheduler@embree@@@3@@Z
addProbe
addProbeArray
addProbeBatch
addScheduler@TaskScheduler@embree@@CAXAEBV?$Ref@UTaskScheduler@embree@@@2@@Z
address family not supported
address in use
address not available
admissible interval [0,1]. Assigning DPAR(1) to
admissible interval [0,infinity). Assigning DPAR(2) to
advapi32
ae<~Q
aeD<]\f
aeG<L
ae\r=W
af7<\af
af\n=X
affinity
ag=<zM
agH;\tD
ah9{SR
aho9K>\t
ai9\aiI:bq
ai;"q
ai\n;qGV
airAbsorption
airAbsorption[iArray
aiܻbiE<j
aj;P\vB;L
ajq;U
ak:Pq
ak˺<lQ
align & (align-1)) == 0
align <= maxAlignment
alignedNodes
alignedNodesMB
alignedNodesMB4D
all(valid, ray.tnear >= 0.0f
all(valid, ray.valid
alloc
allocSize >= bytes
allocThreadIndex@TaskScheduler@embree@@QEAA_JXZ
alloc_i
alloc_main_block_size
alloc_num_main_slots
alloc_single_thread_alloc
alloc_thread_block_size
allocate enough memory for TMP array
allocateAudioBuffer
allocation is too large
already connected
already initialized
alse; \n} \n \n#ifndef GLOBAL_STACK \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    if (r->o.w < 0.f) \n        return false; \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            leftleaf = LEAFNODE(node.lbound); \n            rightleaf = LEAFNODE(node.rbound); \n \n            lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, isect->uvwt.w); \n            righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, isect->uvwt.w); \n \n            if (leftleaf) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node.lbound), r, isect); \n            } \n \n            if (rightleaf) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node.rbound), r, isect); \n            } \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = (int)node.rbound.pmax.w; \n                    deferred = (int)node.lbound.pmax.w;; \n                } \n                else \n                { \n                    idx = (int)node.lbound.pmax.w; \n                    deferred = (int)node.rbound.pmax.w; \n                } \n \n                if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                { \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        gsptr[i] = ldsstack[i * 64]; \n                    } \n \n                    gsptr += SHORT_STACK_SIZE; \n                    lsptr = ldsstack + 64; \n                } \n \n                *lsptr = deferred; \n                lsptr += 64; \n \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = (int)node.lbound.pmax.w; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = (int)node.rbound.pmax.w; \n                continue; \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return isect->shapeid >= 0; \n} \n#else \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    if (r->o.w < 0.f) \n        return false; \n     \n    int stack[32]; \n \n    int* sptr = stack; \n    *sptr++ = -1; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        leftleaf = LEAFNODE(node.lbound); \n        rightleaf = LEAFNODE(node.rbound); \n \n        lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, isect->uvwt.w); \n        righthit
altered by mistake outside of the DFGMRES routine. The solution may be wrong
am\r<R
america
american
american english
american-english
amfrt64.dll
amx-bf16
amx-complex
amx-fp16
amx-int8
amx-tile
an integer number greater than or equal to 2
an;̴Q
anVZ$k
and/or The result may be incorrect
and/or the result may be incorrect
anonymous namespace
anx;[I
any(valid
aoإ\afȦ\a
apU;\v
api-ms
api-ms-win-appmodel-runtime-l1-1-2
api-ms-win-core-datetime-l1-1-1
api-ms-win-core-fibers-l1-1-1
api-ms-win-core-file-l1-2-2
api-ms-win-core-localization-l1-2-1
api-ms-win-core-localization-obsolete-l1-2-0
api-ms-win-core-processthreads-l1-1-2
api-ms-win-core-string-l1-1-0
api-ms-win-core-synch-l1-2-0
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-2-1
api-ms-win-core-winrt-l1-1-0
api-ms-win-core-xstate-l2-1-0
api-ms-win-rtcore-ntuser-window-l1-1-0
api-ms-win-security-systemfunctions-l1-1-0
applications
applyIIRFilter
apy<S@n
aq6;~t
aq=)R
ar:X}E7
ar;\aR4
arFileInfo
area(left.geomBounds) >= 0.0f
area(lset.geomBounds) >= 0.0f
area(right.geomBounds) >= 0.0f
area(rset.geomBounds) >= 0.0f
argument list too long
argument out of bounds
argument out of domain
as:7Ձ9
asQ=1wU
as|:p\a
at=L;\r
at\n:g<F
atp:T~P
au\b=0
audioBuffer
audioSettings
audioSettings->frameSize
audioSettings->samplingRate
australian
aut;\eF
av/;J
av;\v
av\v=H7
avf;wOu
avx10.1-256
avx10.1-512
avx2::BVH4IntersectorStreamPacketFallback
avx2::BVH4Triangle4Intersector1Moeller
avx2::BVH4Triangle4Intersector4HybridMoeller
avx2::BVH4Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH4Triangle4Intersector8HybridMoeller
avx2::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH4Triangle4IntersectorStreamMoeller
avx2::BVH4Triangle4IntersectorStreamMoellerNoFilter
avx2::BVH4Triangle4iIntersector1Moeller
avx2::BVH4Triangle4iIntersector1Pluecker
avx2::BVH4Triangle4iIntersector4HybridMoeller
avx2::BVH4Triangle4iIntersector4HybridPluecker
avx2::BVH4Triangle4iIntersector8HybridMoeller
avx2::BVH4Triangle4iIntersector8HybridPluecker
avx2::BVH4Triangle4iIntersectorStreamMoeller
avx2::BVH4Triangle4iIntersectorStreamPluecker
avx2::BVH4Triangle4iMBIntersector1Moeller
avx2::BVH4Triangle4iMBIntersector1Pluecker
avx2::BVH4Triangle4iMBIntersector4HybridMoeller
avx2::BVH4Triangle4iMBIntersector4HybridPluecker
avx2::BVH4Triangle4iMBIntersector8HybridMoeller
avx2::BVH4Triangle4iMBIntersector8HybridPluecker
avx2::BVH4Triangle4vIntersector1Pluecker
avx2::BVH4Triangle4vIntersector4HybridPluecker
avx2::BVH4Triangle4vIntersector8HybridPluecker
avx2::BVH4Triangle4vIntersectorStreamPluecker
avx2::BVH4Triangle4vMBIntersector1Moeller
avx2::BVH4Triangle4vMBIntersector1Pluecker
avx2::BVH4Triangle4vMBIntersector4HybridMoeller
avx2::BVH4Triangle4vMBIntersector4HybridPluecker
avx2::BVH4Triangle4vMBIntersector8HybridMoeller
avx2::BVH4Triangle4vMBIntersector8HybridPluecker
avx2::BVH4VirtualIntersector1
avx2::BVH4VirtualIntersector4Chunk
avx2::BVH4VirtualIntersector8Chunk
avx2::BVH4VirtualIntersectorStream
avx2::BVH4VirtualMBIntersector1
avx2::BVH4VirtualMBIntersector4Chunk
avx2::BVH4VirtualMBIntersector8Chunk
avx2::BVH4XfmTriangle4Intersector1Moeller
avx2::BVH8IntersectorStreamPacketFallback
avx2::BVH8Triangle4Intersector1Moeller
avx2::BVH8Triangle4Intersector4HybridMoeller
avx2::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH8Triangle4Intersector8HybridMoeller
avx2::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH8Triangle4IntersectorStreamMoeller
avx2::BVH8Triangle4IntersectorStreamMoellerNoFilter
avx2::BVH8Triangle4iIntersector1Moeller
avx2::BVH8Triangle4iIntersector1Pluecker
avx2::BVH8Triangle4iIntersector4HybridMoeller
avx2::BVH8Triangle4iIntersector4HybridPluecker
avx2::BVH8Triangle4iIntersector8HybridMoeller
avx2::BVH8Triangle4iIntersector8HybridPluecker
avx2::BVH8Triangle4iIntersectorStreamMoeller
avx2::BVH8Triangle4iIntersectorStreamPluecker
avx2::BVH8Triangle4iMBIntersector1Moeller
avx2::BVH8Triangle4iMBIntersector1Pluecker
avx2::BVH8Triangle4iMBIntersector4HybridMoeller
avx2::BVH8Triangle4iMBIntersector4HybridPluecker
avx2::BVH8Triangle4iMBIntersector8HybridMoeller
avx2::BVH8Triangle4iMBIntersector8HybridPluecker
avx2::BVH8Triangle4vIntersector1Pluecker
avx2::BVH8Triangle4vIntersector4HybridPluecker
avx2::BVH8Triangle4vIntersector8HybridPluecker
avx2::BVH8Triangle4vIntersectorStreamPluecker
avx2::BVH8Triangle4vMBIntersector1Moeller
avx2::BVH8Triangle4vMBIntersector1Pluecker
avx2::BVH8Triangle4vMBIntersector4HybridMoeller
avx2::BVH8Triangle4vMBIntersector4HybridPluecker
avx2::BVH8Triangle4vMBIntersector8HybridMoeller
avx2::BVH8Triangle4vMBIntersector8HybridPluecker
avx2::BVH8VirtualIntersector1
avx2::BVH8VirtualIntersector4Chunk
avx2::BVH8VirtualIntersector8Chunk
avx2::BVH8VirtualIntersectorStream
avx2::BVH8VirtualMBIntersector1
avx2::BVH8VirtualMBIntersector4Chunk
avx2::BVH8VirtualMBIntersector8Chunk
avx2::InstanceIntersectorN
avx2::QBVH4Triangle4iIntersector1Pluecker
avx2::QBVH8Triangle4Intersector1Moeller
avx2::QBVH8Triangle4iIntersector1Pluecker
avx5124fmaps
avx5124vnniw
avx512bf16
avx512bitalg
avx512bw
avx512cd
avx512dq
avx512er
avx512f
avx512fp16
avx512ifma
avx512knM9\bu\rA
avx512knl
avx512pf
avx512skH9
avx512skx
avx512vbmi
avx512vbmi2
avx512vl
avx512vnni
avx512vp2intersect
avx512vpopcntdq
avx::BVH
avx::BVH4IntersectorStreamPacketFallback
avx::BVH4Triangle4Intersector1Moeller
avx::BVH4Triangle4Intersector4HybridMoeller
avx::BVH4Triangle4Intersector4HybridMoellerNoFilter
avx::BVH4Triangle4Intersector8HybridMoeller
avx::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx::BVH4Triangle4IntersectorStreamMoeller
avx::BVH4Triangle4IntersectorStreamMoellerNoFilter
avx::BVH4Triangle4iIntersector1Moeller
avx::BVH4Triangle4iIntersector1Pluecker
avx::BVH4Triangle4iIntersector4HybridMoeller
avx::BVH4Triangle4iIntersector4HybridPluecker
avx::BVH4Triangle4iIntersector8HybridMoeller
avx::BVH4Triangle4iIntersector8HybridPluecker
avx::BVH4Triangle4iIntersectorStreamMoeller
avx::BVH4Triangle4iIntersectorStreamPluecker
avx::BVH4Triangle4iMBIntersector1Moeller
avx::BVH4Triangle4iMBIntersector1Pluecker
avx::BVH4Triangle4iMBIntersector4HybridMoeller
avx::BVH4Triangle4iMBIntersector4HybridPluecker
avx::BVH4Triangle4iMBIntersector8HybridMoeller
avx::BVH4Triangle4iMBIntersector8HybridPluecker
avx::BVH4Triangle4vIntersector1Pluecker
avx::BVH4Triangle4vIntersector4HybridPluecker
avx::BVH4Triangle4vIntersector8HybridPluecker
avx::BVH4Triangle4vIntersectorStreamPluecker
avx::BVH4Triangle4vMBIntersector1Moeller
avx::BVH4Triangle4vMBIntersector1Pluecker
avx::BVH4Triangle4vMBIntersector4HybridMoeller
avx::BVH4Triangle4vMBIntersector4HybridPluecker
avx::BVH4Triangle4vMBIntersector8HybridMoeller
avx::BVH4Triangle4vMBIntersector8HybridPluecker
avx::BVH4VirtualIntersector1
avx::BVH4VirtualIntersector4Chunk
avx::BVH4VirtualIntersector8Chunk
avx::BVH4VirtualIntersectorStream
avx::BVH4VirtualMBIntersector1
avx::BVH4VirtualMBIntersector4Chunk
avx::BVH4VirtualMBIntersector8Chunk
avx::BVH4XfmTriangle4Intersector1Moeller
avx::BVH8IntersectorStreamPacketFallback
avx::BVH8Triangle4Intersector1Moeller
avx::BVH8Triangle4Intersector4HybridMoeller
avx::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx::BVH8Triangle4Intersector8HybridMoeller
avx::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx::BVH8Triangle4IntersectorStreamMoeller
avx::BVH8Triangle4IntersectorStreamMoellerNoFilter
avx::BVH8Triangle4iIntersector1Moeller
avx::BVH8Triangle4iIntersector1Pluecker
avx::BVH8Triangle4iIntersector4HybridMoeller
avx::BVH8Triangle4iIntersector4HybridPluecker
avx::BVH8Triangle4iIntersector8HybridMoeller
avx::BVH8Triangle4iIntersector8HybridPluecker
avx::BVH8Triangle4iIntersectorStreamMoeller
avx::BVH8Triangle4iIntersectorStreamPluecker
avx::BVH8Triangle4iMBIntersector1Moeller
avx::BVH8Triangle4iMBIntersector1Pluecker
avx::BVH8Triangle4iMBIntersector4HybridMoeller
avx::BVH8Triangle4iMBIntersector4HybridPluecker
avx::BVH8Triangle4iMBIntersector8HybridMoeller
avx::BVH8Triangle4iMBIntersector8HybridPluecker
avx::BVH8Triangle4vIntersector1Pluecker
avx::BVH8Triangle4vIntersector4HybridPluecker
avx::BVH8Triangle4vIntersector8HybridPluecker
avx::BVH8Triangle4vIntersectorStreamPluecker
avx::BVH8Triangle4vMBIntersector1Moeller
avx::BVH8Triangle4vMBIntersector1Pluecker
avx::BVH8Triangle4vMBIntersector4HybridMoeller
avx::BVH8Triangle4vMBIntersector4HybridPluecker
avx::BVH8Triangle4vMBIntersector8HybridMoeller
avx::BVH8Triangle4vMBIntersector8HybridPluecker
avx::BVH8VirtualIntersector1
avx::BVH8VirtualIntersector4Chunk
avx::BVH8VirtualIntersector8Chunk
avx::BVH8VirtualIntersectorStream
avx::BVH8VirtualMBIntersector1
avx::BVH8VirtualMBIntersector4Chunk
avx::BVH8VirtualMBIntersector8Chunk
avx::InstanceIntersectorN
avx::QBVH
avx::QBVH4Triangle4iIntersector1Pluecker
avx::QBVH8Triangle4Intersector1Moeller
avx::QBVH8Triangle4iIntersector1Pluecker
avxifma
avxneconvert
avxvnni
avxvnniint16
avxvnniint8
aw:R)z8f0
aw];C
ax5;T
ax仡iٻ0
ay57u
az-AZ-Cyrl
az-AZ-Latn
az-az-cyrl
az-az-latn
az<hf
az=\t4d
azE:Ty
a{P;u
a}<7v
a~C<7P
aġynD
aĻs=8
aͼE\nȼL
aμ?sX=IV
aѻ44{0
aѻR\f
aѼV4M
aҹOTO
aּ%7F
aڛ;9k
aܼw-A
aݓ9EЕ9w
aᚼD-D
a㱼ڪL>ti
a꼍Cռs
a빺d`;ZQ
a캅4B:)L
aQzɻ\a
a8\t
b %d %H : %M : %S %Y
b 4;=\tQ
b \b=Uvc
b bB%H6
b ba|\b
b!,HY
b!4HY
b!4HYL
b!L@X
b!N\bY
b!T$h
b!T@YD
b!THYT
b!THYd
b!V\bY
b!W<2
b!\\HYt
b!d$L0b
b!d(Y
b!d@Y
b!dHYT
b!dHY\f
b!lHYt
b!l\bY
b!t@Y
b!t@Yd
b!v\b
b!|HY
b!}Hp
b!}Hp$1b
b!}Hp$±bA
b!}Hp$ڱbA
b!}Hp,1b
b!}Hp,ȱb2MH
b!}Hp,ʱb1LHY
b!}Hp,αb2MH
b!}Hp1b
b!}Hp1batH
b!}Hp4
b!}Hp41
b!}Hp4ȱL
b!}Hp4ȱb
b!}Hp4бb
b!}Hp4ұL
b!}Hp4ұb1}Hp\f
b!}Hp4ڱb
b!}Hp4ڱba}Hp\f
b!}Hp<رba}Hp
b!}Hp\f
b!}Hp\f±b
b!}Hp\fȱb
b!}Hp\fɱb
b!}Hp\fʱb
b!}Hp\fرb
b!}Hp±b
b!}Hpñb
b!}HpǱb
b!}HpǱb1|H
b!}HpǱbA|H
b!}HpǱbq|H
b!}Hpɱb
b!}Hpʱb
b!}Hp˱b
b!}Hp̱ba|H
b!}Hpαb
b!}Hpϱb
b!}HpϱbA|H
b!}HpϱbA|L
b!}Hpбb
b!}Hpұba}Hp
b!}Hpӱb
b!}HpԱb
b!}Hpձb
b!}HpձbA,@YU
b!}HpֱbA,@YU
b!}Hpֱbb}H
b!}HpױbA,@YU
b!}HpٱbQ}Hp
b!}Hpܱb
b!}Hpݱb
b!}Hp߱b
b!}Hp߱bA}HpƱb
b!}Jpбb
b!}Jpұb
b"=Ae
b"UH6
b"V<i
b"]Ae
b"]H6
b"eAe
b"mAe4
b#0<w
b#MBCƱb
b#UBCűb
b#a=TO
b#m\b!4
b#uCCqb
b#}BCбb
b#}BCرb
b%2<7
b&D<q
b&o<9
b';fN
b(V:W
b(l8X
b)A<2
b)A<6fg
b*<4S
b,;wEv
b-;jE
b-;oh
b-R>L1
b.%Ds
b09;\v
b0bA|\b
b1,@Y
b1,@YT
b14@Y
b14@YT
b1:2U\t
b1;:wM
b1<;p
b1D@Y
b1LHT
b1dHY
b1dHYt
b1|H+D
b1|H+L
b1|H+T
b1|H+d
b1|H+l
b1|H+t
b1|\bY
b1}Hp
b1}Hp$ɱba}Hp4
b1}Hp,1bQ,HY
b1}Hp,ƱbQ4@Y
b1}Hp,ڱb
b1}Hp4
b1}Hp4ȱb
b1}Hp4رbQ\\@Y
b1}Hp<1bA
b1}Hp<ڱb1}Hp\f
b1}Hp\f
b1}Hp\fȱbQ,HY
b1}Hp\fʱba}Hp$ڱbQ4HYU\fH
b1}Hp\fʱba}Hp$ڱbQ4HYU\fbq}Hp\f
b1}Hp±bA$@Y
b1}HpǱba}HpǱb
b1}Hp˱ba}Hp˱b
b1}HpӱbQ,HYU
b1}HpԱbQ,HYU\ab
b1}HpٱB
b1}Hp߱b
b2:ve2
b2=@6
b2MʘT
b3D<B\t
b3i>N
b3}C#Јb3uC#وb
b4;hK
b4=YTl
b4źꗢ9P
b58<A
b5K;n
b5\b`h
b6\t;s
b7;6\f
b7<i7a
b8:X*r
b8\a/U:he\v
b8\nR\f
b8\nT\f
b8w7F
b92|뻮0
b989d
b9G;9
b9I"\b
b9M7Ϲr
b9W8@:\\R
b9i0x
b9p3 :t
b9üCZ<3QC
b: Vw:M
b:!3D
b:6?1
b:Dř8'yr
b:E\tuZH
b:KBV9
b:P628>4
b:U;7
b:V\to
b:WlH:l
b:\f4i:褃:t02
b:\vg
b:p\bP
b;'mj
b;'mt
b;0\nN
b;21\r
b;7c\e
b;@Fb;P
b;@Qx
b;@xS
b;CӺ9Y
b;V3Ժk
b;VR\t
b;W\n
b;\nt
b;h68
b;n"V
b;w$t
b;y]L
b;z9\a
b;ռej
b<&vq
b<Iᙼf
b<c3j
b<c\r
b<pgW
b<w$\r=hR
b<z3?9
b<פQ;NX
b=4%1
b=6鏽uJ
b=8Sc
b=?wOj>\e
b=M\tR>08N>Hb
b=\rDU
b=e;\fS
b=z%7
b=zd1
b>,j1
b>9<mI
b>[rC
b>y<K
b?<of
b?Z<c?s
b?\bt\r
b?^Cy\r
b?xCz
b@ :i
b@>ca
bA$@X
bA$@Y
bA$@Yu
bA$HY,\vb
bA,@XW
bA,@YM
bA,@YT
bA,HY
bA,HYu\nbQ|H
bA4@XO
bA4@YL
bA4@Yu
bA4@Yu\b
bA4@Yu\bb"MH
bA4HY
bA4HYM
bA;oH
bA;uH
bA<@XF
bA<@YE
bA<@Ym\fL
bA<HYT
bA<HY\f
bA<HYm
bA>\b
bA@:r
bAD@Y
bAD@YE\fL
bAD@YE\fbA|H
bAD@YU
bAD@Ym\nb
bADHYL
bADHYm
bALHX
bAT@YU
bA\\(XM
bA\\@YE\fb"u
bA\\@YU
bA\\HY
bA\\HYe
bA\\HYe\bb
bA\\HYe\fb
bA\\HYe\nb
bA\\HYe\vb
bA\f@Xw
bA\f@Y
bA\f@YU
bA\v?C
bAd@Y
bAl X
bAl@YM\nb
bAl@Ym\bL
bAl@Ym\bb
bAl@Yu
bAl@Yu\fb
bAt(YU
bAt@YM
bAtHYE
bA|@YE\bbA
bA|@Ym
bA|@Yt
bA}Hp
bA}Hp,ܱbA}Hp
bA}Hp1b
bA}HpT
bA}Hpl
bA}Hpqb
bA}Hp±b
bA}Hpñb
bA}Hpűb
bA}HpǱbB-H
bA}Hpɱb
bA}Hpʱb
bA}Hpϱb
bA}HpѱbA,@YU
bA}Hpұb
bA}HpӱbA,@YU
bA}HpԱb
bA}Hpձb
bA}Hpֱb
bA}Hpױb
bA}HpױbQ}Hp
bA}HpرbQ|H
bA}Hp۱b
bA}Hpݱb
bA}Hpޱb
bA}Hp߱b
bA~(o
bA~(ou
bA~\b
bA~\bYy
bAջ]ux
bB5@6
bBO:N
bBellevue1
bB~H5
bBƼj\vt
bC 9,o
bC:9Y;Nu
bCM\b
bCP=֙Q
bCZ;=O\n
bD =v
bD8T$1u
bD91t
bD9}\bLc
bD;S\f
bD;\n|Q
bD;\n|U
bD;d$P
bD;l$P
bD;t$P
bD\n>\f
bDigiCert1 0
bDɹmt绨b
bE;e\b
bE;e\f
bE;l$\f
bE;wH
bEu:VQ
bEӻ=lv
bF'<s
bF:hʼ9x*%:MAB
bFEMh\f
bFl:z
bG<\ty\v<v
bH"9JJ\n
bH+]\bH
bH9(u
bH;P A
bH;P\b
bH;l$`H
bHN&n
bHbQ|H
bI;D$\b
bIcI8
bJ7>]b
bJ^<t
bJɻ1P
bK*:dj
bL';m
bL+;I
bL+t$PD
bLcl$pM
bM;x\rx
bMcH03
bO>BfL
bP";T
bP:\ehG
bQ$@YM
bQ$@Ye
bQ4HY
bQ;mRA;T\n
bQ<@Yu
bQ<HY
bQ<HYu
bQLHY
bQLHYm
bQT@Ym\bb
bQ\fHX7M
bQ\fHX7b
bQ\fHX7bQ|H
bQ|\n
bQ}Hp
bQ}Hp1b
bQ}Hp1b"eH
bQ}Hp1bq}Hp
bQ}Hp4ƱI
bQ}Hp4ǱL
bQ}Hp\f
bQ}Hp\fıb
bQ}Hp\fԱbR\r
bQ}Hp\fرbQ
bQ}Hpqb
bQ}HpƱb
bQ}HpɱbA}Hp
bQ}HpɱbQ}Hp
bQ}HpɱbQ}Hp۱b
bQ}Hpʱbq}Hpױba|H
bQ}Hp˱b1|H
bQ}Hp˱bq|H
bQ}Hpͱb
bQ}HpϱbA$@Y
bQ}HpϱbA}HpޱbQTHY
bQ}HpбbQ$HY
bQ}HpбbQ,HYU
bQ}HpшbQ}Hp
bQ}HpѱbQ
bQ}HpѱbQ,HYU
bQ}Hpұb
bQ}HpұbbU
bQ}Hpұbr%H
bQ}HpԱb
bQ}HpֱbA}Hpرb
bQ}Hpڱbr}H
bQ}Hp۱b
bQ}Hp۱b2
bQ}Hp۱b25H
bQ}Hp۱b2M
bQ}Hp۱bq}Hp
bQ}Hp۱brM
bQ}HpޱbA}Hp
bQ}Hp߱b
bR%H6
bREH6
bRF=in
bS;oh
bS;µźxs
bSM>X
bSUH%̖b
bSUH%̖bre
bSܻKP\r
bT:(j6:2\a
bU<.O
bUVWATAUAVAW
bUVWATAUAVAWH
bUVWAVAWH
bUVWH
bUú+eH
bVWAVH
bWD;q
bWڻufa
bX*9>K4
bX6ba.\bX
bX<$bA
bXD$\tb
bXY@ŪXi
bXY\fŪY
bXa\ab
bXba|\b
bXf:R
bY$9L
bY%Ey
bY%ef
bY1:to
bYD;\aH
bY\\\ad
bY\t;q
bZ <lP
bZ-;H
bZ<tq3
bZR;v
bZW<{c
b[ <A8\a
b\\<LXJ
b\\A\aba
b\\I\abqf
b\a;i
b\a<Q
b\b8FF
b\b<VlE
b\bF\n5\v
b\b\b
b\b\b\b
b\b\e9u
b\e<L2A
b\f0\vP\np\t`\b
b\fU;1
b\n8t\t\n
b\n:S4o
b\n;11
b\n;6
b\n\b
b\nba|\b
b\nba~\b
b\r?z]D
b\rb!d(Y
b\rbA
b\t7<j
b\t?s
b\tq?\b\tq
b\v\a9
b\vbb-@6
b\vbb]H6
b]x;I
b`:nA
b`?<0HH
ba$ Y
ba$PY
ba,AY
ba,BY
ba,PYU
ba4 Y
ba4@X
ba4PYM
ba;\vc1
ba<@Y\f;ba<@YD
ba<PYE
baL X
baL@Yt
baLHYِH
baT(W
baT@X
baTHY<9b
baTHYd
baT\bY\r
baV\bY5\a
ba\\H
ba\f Y
ba\f Y=B
ba\fAY
ba\fBY
ba\fPY5
ba\fPYu
bad address
bad allocation
bad array new length
bad cast
bad conversion
bad exception
bad file descriptor
bad function call
bad locale name
bad message
bad(W=D
bad@Y
bad@Y%r
bad@Y%t
bad@Y\r
bad@Y\rq
bad@Y\ru
bad_weak_ptr
bakePaths
bakeReflections
bal(W-N
bal@X
bal@Y,/b
balHYA
balHYy\aba|H
barrier_sys_regression_test
based
bat(W
bat(Y
bat@Y
bat@Y-\a
bav\bY
ba|@Y<7b
ba|@Yd
ba|HY
ba|HY=7
ba|\b
ba|\b.=4g
ba|\b.\rDb
ba|\b.\rfn
ba|\b.\ru
ba|\bW=uD
ba}Hp
ba}Hp$±b
ba}Hp$ȱb
ba}Hp$رb
ba}Hp$رbb]H
ba}Hp,ȱb!}Hp
ba}Hp,ڱb
ba}Hp1b
ba}Hp4
ba}Hp4±b
ba}Hp4ȱb
ba}Hp4ʱbA\f@Ye
ba}Hp4бL
ba}Hp<ȱI
ba}Hp<ʱb
ba}Hp<ʱbA
ba}Hp<ٱb
ba}Hp<ٱb"uH
ba}HpY
ba}Hp\f
ba}Hp\fڱb
ba}Hp\fڱbq}Hp
ba}Hpqb
ba}HpqbA}Hp
ba}Hp±b
ba}Hpñb
ba}Hpıb
ba}Hpűb
ba}HpűbQ|H
ba}HpƱb"M
ba}HpǱb
ba}Hpȱb
ba}Hpɱb!|H
ba}Hpʱb
ba}HpʱbA}Hpݱbq|H
ba}Hp˱b
ba}Hp̱b
ba}Hpͱb
ba}Hpбb
ba}Hpѱb
ba}Hpұb
ba}HpұbA,@YU
ba}Hpӱb
ba}HpԱb
ba}HpԱbA,@YU
ba}Hpձb
ba}Hpֱb
ba}Hpױb
ba}HpرL
ba}Hpرb
ba}Hpٱba}Hp
ba}Hpڱb
ba}HpڱbQ
ba}HpڱbQt
ba}Hpݱb
ba}Hpޱbq|H
ba}Jpűb
ba}Jpͱb
ba}Jpбb
ba}Jpѱb
ba}Jpұb
ba}Jp۱b
ba}Mp
ba~(o
ba~Ho
ba~Ho%:Z
ba~Ho%n
ba~Ho-\aZ
ba~Ho0bq~HoH
ba~Ho5
ba~Ho=N
ba~Ho=T
ba~HoI
ba~Ho\r
ba~Hoa
ba~Hoi
ba~Hoq
ba~\b
ba~\bYD
ba~\bYL
ba~\bYT
ba~\bYa
ba~\bo5
bb!|H
bb!|IY
bb!}Hp
bb!}Hpٱb
bb1}Hp
bb1}HpױbQt@Y
bb5Hw
bb5Hwh
bbA4\bX
bbA|H
bbEAe
bbMAe
bbMAe4
bbQ|H
bbQ}Hp
bbUAe
bb\r@w
bb\v<D[c
bbaf\bX
bbal@Y
bba|\b
bba|\b.=d
bba}Hpұb
bbeH@%P
bbq}HpɱbA$@Y
bbq}Hp۱bQ\fHY
bbuAe\f
bbuH6
bb}HX
bb}HX%d
bb}HX\r
bb}HZ
bb}HZ5
bb}HZ5\r
bbպ'\as
bc=\b
bcu@%ږbQd
bd',0F
bd',P
bd;vK3
be9Pl
before the call to the DFGMRES_CHECK routine. Make sure to
beginID < BINS
belgian
benchmark
bestSAH != float(inf
bestSAH >= 0.0f
bezier1i
bezier1iH
bezier1v
bezier1vH
bf-;ytZ;\a
bf;E\a
bfA\v
bfB9<A}1L
bfD94Q}\bI
bfE\v
bffffff
bg*;s31
bh;nݰ8\a
bh<<WDD
bh<V@z
bhP:sQ
bhk;D
binID < BINS
bj=UWi
bjn;\ez
bjӹaE
bjԽXG
bk;S8N
bk]<0
blockSize > 0
bmd;Z
bmt<\e
bmȺLE
bn~<xk
bo:JZ
bo=}qL
boxID < N
bp*<SZ
bpY>GTr
bp\a;u
bp\n:\fi
bq$XY
bq, Y\r
bq,IY
bq,JY
bq,XYS
bq,XYU
bq4XYK
bq4XYM
bq<@Y
bq<XYC
bq<XYE
bq\\HY
bq\\HYt
bq\fIY
bq\fJY
bq\fXYs
bq\fXYu
bqd@Y
bqlHY
bq}Hp
bq}Hp$ʱH
bq}Hp$ʱbQ
bq}Hp$رbQ4@Y
bq}Hp,αbA
bq}Hp,رbA
bq}Hp1bA
bq}Hp4±b
bq}Hp<ڱb
bq}Hp\f
bq}Hp\fȱbQ$@Y
bq}Hp\fӱbrEH
bq}Hp±b
bq}Hpñbr}H
bq}Hpűb
bq}HpɱbA$@Y
bq}Hpαb
bq}HpαbQ}Hp
bq}Hpϱb
bq}HpбbQ4@Y
bq}Hpѱb
bq}HpѱbQ,HYU
bq}HpұbQ
bq}HpӱbQ,HYU
bq}HpӱbQD@Y
bq}HpձbQ
bq}HpձbQ,HYU
bq}HpֱbQT@Y
bq}HpױbQ,HYU
bq}HpױbQt@Y
bq}Hpޱb
bq}HpޱbA}Hp
bq}Hp߱bQ
bq}Hp߱bqTHX
bq~Ho
br<=q
brE@@\r
brR;$j
br\eL
br\t:H
bref.node.isAlignedNode
britain
broken pipe
br}HX
br}HX5
br}HX5_b
br}HX5k
br}HX\r
br}HX\rE
br}HwX
br}\bwL
bs-BA-Latn
bs-P%\r
bs-P%\rF
bs-ba-latn
bsN:7
bs]L#ԈbS
bs|;m\ar
bsܙ_>jj
bt:ۼF
bt\f;cfQ
bu&L;c
bu6t<f
bu;z9L
buSt[A
bu_tef
buffer >= RTC_VERTEX_BUFFER0 && buffer < RTCBufferType(RTC_VERTEX_BUFFER0 + numTimeSteps)) || (buffer >= RTC_USER_VERTEX_BUFFER0 && buffer <= RTC_USER_VERTEX_BUFFER1
buffer error
buffer is already mapped
buffer is not mapped
build threads
builder
builder_mb
building BVH
buildslave\\phonon_main_win64\\build\\core\\deps-build\\mysofa\\src\\mysofa\\src\\hrtf\\resample.c
buӻ=h\f
bv:C/A
bvh.builder
bvh.force2level
bvh.forceflat
bvh.sah.extra_node_budget
bvh.sah.max_split_depth
bvh.sah.min_overlap
bvh.sah.traversal_cost
bvh.sah.use_splits
bvh.usesplits
bvh4.object
bvh4.triangle4
bvh4.triangle4i
bvh4.triangle4imb
bvh4.triangle4v
bvh4.triangle4vmb
bvh8.object
bvh8.triangle4
bvh8.triangle4i
bvh8.triangle4imb
bvh8.triangle4v
bvh8.triangle4vmb
bvh_builder: branching factor too large
bvĻ\r
bw ;2
bw!;O
bw#bR}H
bw$bR}H
bw$br}H
bw:/Q
bw;:6
bw<?ZB
bw}:Lb
bx;ąJ
by.<u
bytes
bytes/prim
bz2u0M
bz\b:I\r
b|\vD8C
b}Z8 \t
b~3;lI
b»rZͻ\f
bġ*Yt2t
bō;U2
bŻxo%;c
bſ<Z1
bǺ6sZ
bȻT88
bɅ:ITP
bкLNM
bл9JY
bҰ=tH
bԐ9mu89
bںE8ۻM
bھ:\rJ6
bڿ;Rb
bެ;BC
b鍸h+ȸ2D
b벺)ff;5A
c != BVH::emptyNode
c [1>H
c \v=H
c$;dq
c%;j51:l
c)\f=iw
c-;aB
c0 != BVH::emptyNode
c0S<I2
c1 != BVH::emptyNode
c1!T$P
c39f욻Sr
c4:|Wz
c5J\r3P1
c5ŽDH
c8YxT9hJA
c8]vo:1
c8z;)D
c9K#\r
c9f癹Y
c:;hz
c:LW99
c;7wR
c;9\ei
c;LL6;N
c;Stz
c;UUUUUU
c;Y[n;C
c;\br
c;b3s
c;nNl
c<CBX
c<\eX
c=Q53
c=iX<\r2
c=u)Q
c>T;4\t
c>uo¾L
c?FA@s
c@S;w\t
cA$;Y
cA$;d
cA;o|q:VC
cAMD3L$0\tzenti3T$,1
cC<G读y
cC<j6W
cC}=Hu
cEP=>L
cF+;UH
cG95_E
cG<AE\f
cGy;\r
cIûL\e
cIͺ@09
cK;b=U
cK\a;C
cL;D$0
cLk>M\r
cN\ewun
cP7;b"R
cR=flT
cRH;4FQ;\e\r1;d2
cRü'8
cSպD<P
cU>an~o
cUI:ݙy
cV\n;mg
cW+;Ah
cX<8yQ
c\\R<1b
c\bH:TSk
c\b\r;6
c\bba
c\e>Gn
c\eպL\b
c\r;j
c\tr;\n
c];T3
c^;0\vQ
c^ٻVg
ca!A8
ca!T$P
ca>:C
cache_size
calculateAirAbsorption
calculateDirectivity
calculateDistanceAttenuation
calculateRelativeDirection
call to DCG routine
call to DCG routine. Otherwise, the maximal number
call to DFGMRES routine. Otherwise, the maximal number of iterations is equal to
canadian
cannot instantiate this geometry
cannot unget that many items
cartesian
cas:0
cblas_sgemv
cb漰"6<w
cd4;]㖺IyF;2\t
cd>,DZ
cdecl
cdֻ+mw
ce$=B
ceS:b
ce\n;K
character
child != BVH::emptyNode
chinese
chinese-hongkong
chinese-simplified
chinese-singapore
chinese-traditional
ciM;D
ci\f;n'O:A
ck:Ug
cl-mad-enable -cl-fast-relaxed-math -cl-std=CL1.2 -I
clBuildProgram
clCompileProgram
clCreateBuffer
clCreateBuffer failed
clCreateCommandQueue
clCreateCommandQueue failed
clCreateContext
clCreateContext failed
clCreateKernel
clCreateKernelsInProgram
clCreateKernelsInProgram failed
clCreateKernelsInProgram return 0 kernels
clCreateProgramWithSource
clCreateProgramWithSource failed
clCreateSubBuffer
clEnqueueCopyBuffer
clEnqueueFillBuffer
clEnqueueMapBuffer
clEnqueueMapBuffer failed
clEnqueueNDRangeKernel
clEnqueueNDRangeKernel failed
clEnqueueReadBuffer
clEnqueueReadBuffer failed
clEnqueueUnmapMemObject
clEnqueueUnmapMemObject failed
clEnqueueWriteBuffer
clEnqueueWriteBuffer failed
clFinish
clFinish failed
clFlush
clFlush failed
clGetCommandQueueInfo
clGetDeviceIDs
clGetDeviceIDs failed
clGetDeviceInfo
clGetDeviceInfo failed
clGetEventInfo
clGetEventInfo failed
clGetKernelInfo
clGetKernelInfo failed
clGetMemObjectInfo
clGetMemObjectInfo failed
clGetPlatformIDs
clGetPlatformIDs failed
clGetPlatformInfo
clGetPlatformInfo failed
clGetProgramBuildInfo
clReleaseCommandQueue
clReleaseContext
clReleaseDevice
clReleaseEvent
clReleaseKernel
clReleaseMemObject
clReleaseProgram
clRetainCommandQueue
clRetainContext
clRetainDevice
clRetainEvent
clRetainKernel
clRetainMemObject
clRetainProgram
clSetKernelArg
clSetKernelArg failed
clWaitForEvents
clWaitForEvents failed
cl_amd_media_ops2
cldemote
cleaned memory, deleted number of L&U-factorizations: %d
cleaned memory, deleted number of L&U-factorizations: %lli
closure stack overflow
clrcall
cmpccxadd
cmѼ7-\a
co%;hxۻk
code, or the parameter IPAR(7)=%s was altered by mistake outside of the routine
code, or the parameter ipar[6]=%s was altered by mistake outside of the routine
coherent
collapsing from
combineBandpassedImpulseResponse
compact
compile time enabled
connection aborted
connection already in progress
connection refused
connection reset
const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n /************************************************************************* \n   EXTENSIONS \n   **************************************************************************/ \n \n \n \n   /************************************************************************* \n    TYPE DEFINITIONS \n    **************************************************************************/ \n#define STARTIDX(x)     (((int)((x).left))) \n#define LEAFNODE(x)     (((x).left) == ((x).right)) \n#define STACK_SIZE 64 \n#define SHORT_STACK_SIZE 16 \n \n \ntypedef struct \n{ \n    int parent; \n    int left; \n    int right; \n    int next; \n} HlbvhNode; \n \ntypedef struct \n{ \n    // BVH structure \n    __global HlbvhNode const* nodes; \n    // Scene bounds \n    __global bbox const* bounds; \n    // Scene positional data \n    __global float3 const* vertices; \n    // Scene indices \n    __global Face const* faces; \n    // Shape IDs \n    __global ShapeData const* shapes; \n    // Extra data \n    __global int const* extra; \n} SceneData; \n \n/************************************************************************* \n HELPER FUNCTIONS \n **************************************************************************/ \n \n \n \n /************************************************************************* \n  BVH FUNCTIONS \n  **************************************************************************/ \n  //  intersect a ray with leaf BVH node \nbool IntersectLeafClosest( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n            return true; \n        } \n    } \n \n    return false; \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r
const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \n/************************************************************************* \n TYPE DEFINITIONS \n **************************************************************************/ \n#define STARTIDX(x)     (((int)(x->pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n \ntypedef struct  \n{ \n    // BVH structure \n    __global BvhNode const*       nodes; \n    // Scene positional data \n    __global float3 const*        vertices; \n    // Scene indices \n    __global Face const*          faces; \n    // Shape data \n    __global ShapeData const*     shapes; \n    // Extra data \n    __global int const*           extra; \n} SceneData; \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nvoid IntersectLeafClosest( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n        } \n    } \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n
context
continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = node.right; \n                continue; \n            } \n        } \n \n        idx = *--ptr; \n    } \n \n    //if (get_global_id(0) == 1) \n    //printf("Exiting %d\\n", get_global_id(0) ); \n \n    return hit; \n} \n \n#else \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            if (LEAFNODE(node)) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node), r, isect); \n            } \n            else \n            { \n                lbox = scenedata->bounds[node.left]; \n                rbox = scenedata->bounds[node.right]; \n \n                lefthit = IntersectBoxF(r, invdir, lbox, isect->uvwt.w); \n                righthit = IntersectBoxF(r, invdir, rbox, isect->uvwt.w); \n \n                if (lefthit > 0.f && righthit > 0.f) \n                { \n                    int deferred = -1; \n                    if (lefthit > righthit) \n                    { \n                        idx = node.right; \n                        deferred = node.left; \n                    } \n                    else \n                    { \n                        idx = node.left; \n                        deferred = node.right; \n                    } \n \n                    if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                    { \n                        for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                        { \n                            gsptr[i] = ldsstack[i * 64]; \n                        } \n \n                        gsptr += SHORT_STACK_SIZE; \n                        lsptr = ldsstack + 64; \n                    } \n \n                    *lsptr = deferred; \n                    lsptr += 64; \n \n                    continue; \n                } \n                else if (lefthit > 0) \n                { \n                    idx = node.left; \n                    continue; \n                } \n                else if (righthit > 0) \n                { \n                    idx = node.right; \n                    continue; \n                } \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n \n    return isect->shapeid >= 0; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            if (LEAFNODE(node)) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node), r)) \n                    return true; \n
contraction rate is greater than 0.9, interrupt
contradiction (set ido>0) %d
contradiction (set ido>0) %lli
converged, or parameter DPAR(5) was altered by mistake outside of the DFGMRES routine
convertAmbisonicAudioBuffer
convolutionQueue
copy constructor closure
counter IPAR(4)=%s
cr=>U
createAmbisonicsBinauralEffect
createAmbisonicsDecodeEffect
createAmbisonicsEncodeEffect
createAmbisonicsPanningEffect
createAmbisonicsRotationEffect
createBinauralEffect
createContext
createDirectEffect
createEmbreeDevice
createHRTF
createInstancedMesh
createOpenCLDevice
createOpenCLDeviceFromExisting
createOpenCLDeviceList
createPanningEffect
createPathEffect
createProbeArray
createProbeBatch
createRadeonRaysDevice
createReflectionEffect
createReflectionMixer
createScene
createSerializedObject
createSimulator
createSource
createStaticMesh
createTrueAudioNextDevice
createVirtualSurroundEffect
created scene intersector
criterion, but it cannot be replaced as IPAR(31)=0
cross device link
crt_strtox::floating_point_value::as_double
crt_strtox::floating_point_value::as_float
cu0Ǆ$\b
cu:'r\e=BL3
cur != BVH::emptyNode
cur != BVH::invalidNode
cur == node->child(boxID
current.prims.size() == 0) || ((leafSAH >= 0) && (splitSAH >= 0
current.size() == 0) || ((leafSAH >= 0) && (splitSAH >= 0
curves
cuռ]m\r
cvC=Z
cx!:A
cy:1V\b
c~<H5Z
c~ǻkY
cŘ"rY
cƽ\bS
cѕ:Ix
cՄ;1s
cպF2R
d / %m / %y
d"9d l
d$ E3
d$ H;T$8
d$ HcG
d$ UAVAW
d$ UAVAWH
d$ bb
d$ bq|H
d$ fff
d$$bb
d$$bbE
d$( bc
d$(bb
d$(r3H
d$00b
d$0A_A^A]A
d$0Hc
d$0]A^A]A
d$0ba~\b
d$0r5L
d$4D8l$1u
d$8A_A^A]A
d$8L;x\b
d$8]A
d$8ba~\b
d$;j7\b
d$@D9fD
d$@D;fD
d$@Lc]l
d$@fD
d$@fff
d$@u\vA
d$Dbb5
d$HL;x\b
d$HM#l$\bt
d$Hba
d$Hba~\b
d$Hbb
d$Hfff
d$Hffff
d$PHc
d$PLcSl
d$PM#l$\bt
d$PM#l$\btѐA
d$PfD
d$XA8_\t
d$XH;T
d$XbbM\b
d$\bbb
d$\f0b
d$\fba|\b
d$\fbb
d$`Ii
d$dD;d$ltY
d$dba~\b
d$hH;w
d$pH;w
d$pHc
d$pfff
d$pr;H
d$xE3
d$x]A
d$xbb5
d$xff
d$xr-H
d$xr6L
d$xtWI
d';aV@9
d'ûdE
d+<0B
d,ܺLMb
d2^2\\HJ2H2<:f
d3;H*k
d3K;:[B
d5\bb"m\b
d5e<^L
d5ƺsD
d6:yi\a
d79Y\r-8
d84<5k
d8s;i
d93PM
d9<kQ
d9r<A
d:75S
d:Cva;z
d:Ei\b
d:b<K
d:b\a
d:hPG
d:o1g<W
d:pǭ;Sr
d;)惼w3f
d;*Zi
d;@AQ
d;_}T9eq2;yX
d;b3ԺS
d;qs5
d;wsj
d<(1T
d<9W\a
d<\bO
d<a<v
d<w|h
d=*X6
d>U"D=z
d?000000
d@Y]\bb
d@Y]\bbBe
d@Y]\fb
d@Y]\fb1DHY
d@Y]\nbBe
dC>@5X
dCºEp
dD:Ckl
dE;iyn
dFb:\n
dG\e:q
dGk<US
dH+X@I
dHY,$I
dHY4\ab
dHYU\ab
dIɻDv
dK;qSH
dL=ܭ7=L
dMڼʥ4
dN:{2N
dP;4e
dP?=MQ
dQH;fdo
dRD;X
dS;Jo3
dS;\v
dS\r<nT
dT fC
dTq<*A
dUK:6
dX4"H
dX\f"H
dX\f<Uy
dY&:k
dYv ŔY
d\aPġRYl\aTĢi
d\a\abQ|H
d\b$;ol
d\b;UḺ4
d\b\f;Oi
d\bʸY0
d\fn:r
d\n  fC
d\n00M
d\n9<[yP
d\nO;SO
d\n\abA|H
d\n\fba|H
d\nջM
d\v3=D
d\v;W1*9
d\v\abA|H
d] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n
d^\n<lQ
d_O;.Cz;Z
d_forward_trig_transform/d_backward_trig_transform routine
data error
data must be 4 bytes aligned
data$r
data$rs
db:;9P;H
dba~\b
dbf:CK\t
db};c$v
dc\a;\vn\f
dc_\bA
dd+;P
ddPdudu
ddPdudv
ddPdvdv
dddd, MMMM dd, yyyy
de5:e
de<2f
debug
default
default constructor closure
defaultBlockSize
deinterleaveAudioBuffer
delete
depth
depth limit reached
deque<T> too long
destination address required
device
device or resource busy
deviceDesc
deviceList
dex].o = (float4) (camera->origin, FLT_MAX);\n    rays[index].d = (float4) (normalize(du * camera->right + dv * camera->up - camera->ahead), 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\nkernel void generateListenerRays(global CoordinateSpace* listeners,\n                                 global float4* sphereSamples,\n                                 global Ray* rays)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t listenerIndex = get_global_id(1);\n    size_t index = listenerIndex * get_global_size(0) + rayIndex;\n\n    rays[index].o = (float4) (listeners[listenerIndex].origin, FLT_MAX);\n    rays[index].d = (float4) (sphereSamples[rayIndex].xyz, 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Sphere Occlusion Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat raySphereIntersect(global const Ray* ray,\n                         float3 center,\n                         float radius)\n{\n    float3 origin = ray->o.xyz;\n    float3 direction = ray->d.xyz;\n\n    float3 v = origin - center;\n    float r = radius;\n\n    float B = 2.0f * dot(v, direction);\n    float C = dot(v, v) - (r * r);\n    float D = (B * B) - (4.0f * C);\n\n    if (D < 0.0f)\n        return FLT_MAX;\n\n    float t = -0.5f * (B + sqrt(D));\n    return t;\n}\n\nkernel void sphereOcclusion(uint numSources,\n                            global const CoordinateSpace* sources,\n                            uint numListeners,\n                            global const CoordinateSpace* listeners,\n                            global Ray* rays,\n                            global Hit* hits)\n{\n    uint numRays = get_global_size(0);\n    uint rayIndex = get_global_id(0);\n\n    for (int i = 0; i < numListeners; ++i)\n    {\n        uint index = i * numRays + rayIndex;\n\n        float listenerSphereHitDistance = raySphereIntersect(&rays[index], listeners[i].origin, LISTENER_RADIUS);\n        if (0.0f <= listenerSphereHitDistance && listenerSphereHitDistance < hits[index].uvwt.s3)\n        {\n            rays[index].extra.y = 0;\n            hits[index].primid = -1;\n            return;\n        }\n\n        for (int j = 0; j < numSources; ++j)\n        {\n            float sourceSphereHitDistance = raySphereIntersect(&rays[index], sources[j].origin, SOURCE_RADIUS);\n            if (0.0f <= sourceSphereHitDistance && sourceSphereHitDistance < hits[index].uvwt.s3)\n            {\n                rays[index].extra.y = 0;\n                hits[index].primid = -1;\n                return;\n            }\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Shading + Shadow/Bounced Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat3 calculateHitPoint(Ray ray,\n                         Hit hit)\n{\n    return ray.o.xyz + hit.uvwt.s3 * ray.d.xyz;\n}\n\nfloat3 calculateHitNormal(Ray ray,\n                          Hit hit,\n                          global float4* normals)\n{\n    float3 hitNormal = normals[hit.primid].xyz;\n    if (dot(hitNormal, ray.d.xyz) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    return hitNormal;\n}\n\nfloat pointSourceIrradiance(float distance,\n                            float minDistance)\n{\n    float attenuation = 1.0f / max(distance, minDistance);\n    float irradiance = (1.0f / (4.0f * PI)) * (attenuation * attenuation);\n    return irradiance;\n}\n\nfloat3 reflect(float3 incident,\n               float3 normal)\n{\n    return normalize(incident - (2.0f * dot(incident, normal) * normal));\n}\n\nkernel void shadeAndBounce(uint numSources,\n                           global const CoordinateSpace* sources,\n                           uint numListeners,\n                           global const
df;qye
dg27\f%8
dhr;w
di.<GZ
diag[dim] > 0.0f
diagonal matrix problem
didat$2
didat$3
didat$4
didat$5
didat$6
didat$7
directory not empty
disabled
disabled\n
distribute_part_sum_int4
div-MV
div-mv
division by a small diagonal value will happen
dk:l]k
dk;qǇ9
dkU<U
dm9\e
dm{>b\bw?q
dm|9xu
do;P-X
downmixAudioBuffer
dq\vF6
dst->data
dst->data[iChannel][dst->numSamples - 1
dst->numChannels
dst->numSamples
dst[iArray
dummy_rtcore_ispc___avx
dummy_rtcore_ispc___avx2
dummy_rtcore_ispc___sse2
dummy_rtcore_ispc___sse4
during initialization stage. Computations have stopped
during the initialization stage. Computations have stopped
dut;tE
dutch-belgian
dv);P7
dx].pmax.w); \n            // Set topidx \n            topidx = -1; \n            // Restore ray here \n            r->o = topray.o; \n            r->d = topray.d; \n            // Restore invdir \n            invdir = invdirtop; \n        } \n    } \n \n    return isect->shapeid >= 0; \n} \n \n// intersect Ray against the whole BVH2L structure \nbool IntersectSceneAny2L(SceneData* scenedata, ray* r) \n{ \n    // Precompute invdir for bbox testing \n    float3 invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    float3 invdirtop = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    // We need to keep original ray around for returns from bottom hierarchy \n    ray topray = *r; \n \n    // Fetch top level BVH index \n    int idx = scenedata->rootidx; \n    // -1 indicates we are traversing top level \n    int topidx = -1; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, r->o.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                // or containing another BVH (top level hierarhcy) \n                if (topidx != -1) \n                { \n                    // This is bottom level, so intersect with a primitives \n                    if (IntersectLeafAny(scenedata, &node, r)) \n                        return true; \n                    // And goto next node \n                    idx = (int)(node.pmax.w); \n                } \n                else \n                { \n                    // This is top level hierarchy leaf \n                    // Save top node index for return \n                    topidx = idx; \n                    // Get shape descrition struct index \n                    int shapeidx = SHAPEIDX(node); \n \n                    // Get shape mask \n                    int shapemask = scenedata->shapedata[shapeidx].mask; \n                    // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                    // otherwise skip the subtree \n                    if (Ray_GetMask(r) && shapemask) \n                    { \n                        // Fetch bottom level BVH index \n                        idx = scenedata->shapedata[shapeidx].bvhidx; \n \n                        // Fetch BVH transform \n                        float4 wmi0 = scenedata->shapedata[shapeidx].m0; \n                        float4 wmi1 = scenedata->shapedata[shapeidx].m1; \n                        float4 wmi2 = scenedata->shapedata[shapeidx].m2; \n                        float4 wmi3 = scenedata->shapedata[shapeidx].m3; \n \n                        // Apply linear motion blur (world coordinates) \n                        //float4 lmv = scenedata->shapedata[shapeidx].linearvelocity; \n                        //float4 amv = scenedata->shapedata[SHAPEDATAIDX(node)].angularvelocity; \n                        //r->o.xyz -= (lmv.xyz*r->d.w); \n                        // Transfrom the ray \n                        *r = transform_ray(*r, wmi0, wmi1, wmi2, wmi3); \n                        //rotate_ray(r, amv); \n                        // Recalc invdir \n                        invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n                        // And continue traversal of the bottom level BVH \n                        continue; \n                    } \n                    else \n                    { \n                        // Skip the subtree \n                        idx = -1; \n                    } \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                // This is an internal node, proceed to left child (it is at current + 1 index) \n                idx = idx + 1; \n            } \n        } \n        else \n        { \n            // We missed the node, goto next one \n            idx = (int)(node.pmax.w); \n        } \n \n        // Here check if we ended
dynamic
dynamic atexit destructor for
dynamic initializer for
dŮ=AI
dż;4i
dƼCQۼ89
dǘ:44
dʯ;Dz
d̺\vOM
dλQf'<u
dս\nw1=jj\t
dغ\vL
dܺQ#f
d䨹j6D
d濻Euz
e =pKH
e =Ӳf
e ๏4\f
e!<fp
e"2<Z
e"?Dg
e$; \tB;1
e%89z
e%I<\n3
e%c<S1
e&<Nf
e&=4o\t
e'9\t5G;Y
e';YKY
e';gu
e'<lH
e(M#l$\bt
e)X;r
e)e>u
e*;=uo9\n
e*<0b\r
e*k:n
e+:EQ
e+W:F
e,I=waK
e-ǻcZ
e.4nI
e.5;+oB
e.dn I
e.t/ I
e.|o I
e/;\vca
e/g<b
e/¼fr
e/ʺHo
e0<dV
e0A_A^A]A
e0M#l$\bt
e0ban\bY1ŊXA
e0ŘY]p
e1>:L
e1G;J{f
e1^;8K\t
e1y;6
e1Ӻoq
e3:gN
e3;Tu
e4,;Tf
e4;Lv
e4="Q
e5;cw3
e5<7 &;z
e5S;T>g:0
e69\r:l
e6:&x
e6;G~G
e7#<X
e7.? bz
e7;B\te
e7;CE
e7<!\v0
e7t;@n3
e8G;]5
e99<9I
e9;N^J
e9^ä9
e: 涻G
e:Rfx
e:Z/8
e:\n l
e:rM\a9
e:uW{9
e:vCw
e:ΊzWd
e;( O
e;(UI
e;0an
e;YM]9J
e;YY\e
e;\aI
e;`Q5
e;d&i
e;fzp
e;g%H
e;g+C:9
e;oAV
e;ykv
e;ԃV=1Z
e;ޖd;W9
e< t ;C
e<!96
e<[P09o
e<\bl
e<`nH
e<eT\n<HY
e<hq\r
e<k8k
e=-Ke
e=Q0F
e=Q蒽I
e=rAe>U:f
e>+8j
e>K7\a
e>q<0H
e>uik
e>uu=Rp
e? =\rUֽb
e?5t,?d
e@A_A^A
eA1:HYS
eB@=HRS>vR
eBZ>̣m
eBٺ>Aj
eC2<Z
eC<$o
eCNאBO:#Cl
eCŻDX
eD?}\eD
eDigiCert Assured ID Root CA0
eEr;db
eF=9Aټp\f9>s
eFڻXvU
eG<!0
eG\v<}R
eGʻ2l
eH@%2p
eH@%U
eH@%UU
eH@%\rZ
eH@%b4
eH@%eN
eH@%fW
eH@%jX
eH@%m
eH@%oY
eH@-yd
eHA_A^A]A
eHH:)Z
eH\t=ME
eI ;1
eI<UGW
eI};giW
eIٺb8z
eJ.85
eJ5;WN\b;y5C
eL;6E
eL;swg
eL<<g8G
eN9=3W
eO9ۻ\r
eO;JP\a
eO<dH
eOP9f
eP%;0
eP8RG:\t
ePw:1
ePŰXE0
eQ(>1
eQ*=O
eQD;Q"*;tnt
eQۼ\fT
eR7<g
eRS:T
eS;{HA
eU<Dh
eVW=z
eV˻j6
eW=88z
eX;!7I
eXd;fs
eXܻ"U
eY=ht1=M\f
eYO9m
eY̼Xh
eZn:0
e[;4OV
e\a>8Na
e\abA|H
e\aͻ\bt
e\b+;NG
e\bX=Tĭ>6
e\bb;x
e\e;脫98tt
e\ebA,(X
e\f:k~z
e\nb1d@T
e\r;eL
e\r>7
e\rbA|H
e\t;Q
e\tz:s
e\v5=%䥾VMx
e\vbA|H
e\vn?c
e^;iRe
e`:G\fb
easy->fir
eaܺͥ6
eb!|H
eb1t Y
ebA}Hpɱb
eba|H
ec;Wa
ec<\r
ed:"e
ed;\fO
ed;\t
ed<9i2
edData[localOffset.w] = val.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    // Now store to memory \n    if (((globalId + 1) << 2) <= numElems) \n    { \n        out_array[globalId] = sharedData4[localId]; \n        out_debug_offset[globalId] = localOffset; \n    } \n    else \n    { \n        if ((globalId << 2) < numElems) out_array[globalId].x = sharedData4[localId].x; \n        if ((globalId << 2) + 1 < numElems) out_array[globalId].y = sharedData4[localId].y; \n        if ((globalId << 2) + 2 < numElems) out_array[globalId].z = sharedData4[localId].z; \n    } \n \n    if (localId == 0) \n    { \n        out_histograms[groupId] = localHistogram.x; \n        out_histograms[groupId + numGroups] = localHistogram.y; \n        out_histograms[groupId + 2 * numGroups] = localHistogram.z; \n        out_histograms[groupId + 3 * numGroups] = localHistogram.w; \n \n        out_local_histograms[groupId] = 0; \n        out_local_histograms[groupId + numGroups] = localHistogram.x; \n        out_local_histograms[groupId + 2 * numGroups] = localHistogram.x + localHistogram.y; \n        out_local_histograms[groupId + 3 * numGroups] = localHistogram.x + localHistogram.y + localHistogram.z; \n    } \n} \n \n#define GROUP_SIZE 64 \n#define NUMBER_OF_BLOCKS_PER_GROUP 8 \n#define NUM_BINS 16 \n \n// The kernel computes 16 bins histogram of the 256 input elements. \n// The bin is determined by (in_array[tid] >> bitshift) & 0xF \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid BitHistogram( \n    // Number of bits to shift \n    int bitshift, \n    // Input array \n    __global int const* restrict in_array, \n    // Number of elements in input array \n    uint numelems, \n    // Output histograms in column layout \n    // [bin0_group0, bin0_group1, ... bin0_groupN, bin1_group0, bin1_group1, ... bin1_groupN, ...] \n    __global int* restrict out_histogram \n    ) \n{ \n    // Histogram storage \n    __local int histogram[NUM_BINS * GROUP_SIZE]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    /// Clear local histogram \n    for (int i = 0; i < NUM_BINS; ++i) \n    { \n        histogram[i*GROUP_SIZE + localid] = 0; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    const int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    const int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        /// Load single int4 value \n        int4 value = safe_load_int4_intmax(in_array, loadidx, numelems); \n \n        /// Handle value adding histogram bins \n        /// for all 4 elements \n        int4 bin = ((value >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.x*GROUP_SIZE + localid]); \n        //bin = ((value.y >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.y*GROUP_SIZE + localid]); \n        //bin = ((value.z >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.z*GROUP_SIZE + localid]); \n        //bin = ((value.w >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.w*GROUP_SIZE + localid]); \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int sum = 0; \n    if (localid < NUM_BINS) \n    { \n        for (int i = 0; i < GROUP_SIZE; ++i) \n        { \n            sum += histogram[localid * GROUP_SIZE + i]; \n        } \n \n        out_histogram[numgroups*localid + groupid] = sum; \n    } \n} \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE
edata
ee2:w
ee:lYF
ef$;TE
ef;|jY
efG;R
effect
effectSettings
effectSettings->hrtf
effectSettings->irSize
effectSettings->maxOrder
effectSettings->numChannels
effectSettings->spatialize
effectSettings->speakerLayout.numSpeakers
effectSettings->speakerLayout.speakers
effectSettings->speakerLayout.speakers[iSpeaker].x
effectSettings->speakerLayout.speakers[iSpeaker].y
effectSettings->speakerLayout.speakers[iSpeaker].z
effectSettings->speakerLayout.type
effectSettings->type
effffff
eg<@s
eh vector constructor iterator
eh vector copy constructor iterator
eh vector destructor iterator
eh vector vbase constructor iterator
eh vector vbase copy constructor iterator
eh:N]\a
eh\f::t
ehttp://www.digicert.com/CPS0
eiX9t
ej;!Lx
el\f;n
el{n0t:e
em,=l
embree2
en097
enable_compressed_reverb_lookup
enable_dc_correction_for_phase_interpolation
enable_hybrid_eq_from_ir
enable_iir_order_8
enable_iir_order_switching
enable_paths_from_all_source_probes
enable_reverb_probe_caching_for_missing_probes
enable_selockmemoryprivilege
enabled
enabled (forced)\n
enabled\n
endID < BINS
england
english-american
english-aus
english-belize
english-can
english-caribbean
english-ire
english-jamaica
english-nz
english-south africa
english-trinidad y tobago
english-uk
english-us
english-usa
enn:u
enqcmd
eo/<c
eoI;ef
ep:i9B;4
ep;VX
ep;ak
eph<'c
equal to 0 simultaneously
er*:r
er\a<s
erd:*7W
erp:0
error PARDISO: iterative refinement
error PARDISO: reordering, symbolic factorization
er~;1
es1;<7
estimatedSize
es{9Zu
et:5J\t9
et<3lA=M
euCȭU
euJ:52
evC=Eu
evaluateDirectivity(hitPoint, sources[sourceIndex], directivities[sourceIndex]);\n        energy *= pointSourceIrradiance(hitToSourceDistance, irradianceMinDistance);\n        energy *= accumEnergyDelay[rayIndex].xyz * ((float3) 1.0f - hitMaterialAbsorption);\n\n        float delay = (hitDistance + hitToSourceDistance) / SPEED_OF_SOUND;\n        delay += accumEnergyDelay[rayIndex].w - (distance(source, listeners[listenerIndex].origin) / SPEED_OF_SOUND);\n\n        energyDelay[shadowRayIndex] = (float4) (energy, delay);\n    }\n\n    barrier(CLK_GLOBAL_MEM_FENCE);\n\n    // Generate the bounced ray.\n    if (numListeners > 1 || sourceIndex == 0)\n    {\n        accumEnergyDelay[rayIndex].xyz *= ((float3) 1.0f - hitMaterialAbsorption);\n        accumEnergyDelay[rayIndex].w += hitDistance / SPEED_OF_SOUND;\n\n        float4 reflectedDirection = (float4) 0.0f;\n        if (randomFloat < hitMaterial.scattering)\n        {\n            uint sampleIndex = randomUint % numDiffuseSamples;\n            float3 transformedDiffuseSample = transformHemisphereSample(diffuseSamples[sampleIndex].xyz, hitNormal);\n            reflectedDirection = (float4) (transformedDiffuseSample, 0.0f);\n        }\n        else\n        {\n            reflectedDirection = (float4) (reflect(rayDirection, hitNormal), 0.0f);\n        }\n\n        reflectedRays[rayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * reflectedDirection.xyz, FLT_MAX);\n        reflectedRays[rayIndex].d = reflectedDirection;\n        reflectedRays[rayIndex].extra = (int2) (0xffffffff, 1);\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Image Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherImage(uint numSources,\n                        global const int* occluded,\n                        global const float4* totalEnergy,\n                        global float4* image)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t numRays = get_global_size(0);\n\n    for (uint i = 0; i < numSources; ++i)\n    {\n        if (occluded[i * numRays + rayIndex] < 0)\n        {\n            image[rayIndex] += totalEnergy[i * numRays + rayIndex];\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Energy Field Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherEnergyField(float scale,\n                              global const float4* totalEnergy,\n                              uint offset,\n                              global const int* occluded,\n                              global const float* shCoefficients,\n                              global int* energy)\n{\n\t// The number of global work-items for this kernel is #rays * #bands * #channels.\n\t// The number of local work-items for this kernel is #bins * 1 * 1. Here, #bins is a compile-time constant.\n\t// This kernel runs in three stages:\n\t//\t1.\tEach work-group operates on a subset of rays, and accumulates their energy into one of multiple\n\t//\t\tlocal-memory histograms.\n\t//\t2.\tEach work-group adds all of its local-memory histograms together.\n\t//\t3.\tThe work-groups cooperate and combine their local-memory histograms into a global-memory histogram.\n\n    uint rayIndex = get_global_id(0);\n    uint band = get_global_id(1);\n    uint channel = get_global_id(2);\n\n    size_t numRays = get_global_size(0);\n\n    bool isOccluded = (occluded[offset + rayIndex] >= 0);\n\n\t// FIXME: shouldn't this be just get_local_id(0)?\n    const int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\n\t// Each work-group stores NUM_LOCAL_HISTOGRAMS histograms in local memory. These are interleaved, i.e.,\n\t// bin i of histogram j is at index (NUM_LOCAL_HISTOGRAMS * i + j) in the buffer. We use multiple local-memory\n\t// his
evϼg%a
ew:ki6
ew;:x
ewM;3
ex;<d
exceeds maximum iteration number %d
exceeds maximum iteration number %lli
executable format error
execute_local@TaskQueue@TaskScheduler@embree@@QEAA_NAEAUThread@23@PEAUTask@23@@Z
ext-ms
ext-ms-win-ntuser-dialogbox-l1-1-0
ext-ms-win-ntuser-windowstation-l1-1-0
ext_elements.load() <= set.ext_range_size
ext_end >= range<Ty>::_end
exȺ3 c
ey:HBp
ez<8w
e|ѽ\fEH
e}4=Z
e}<LN3
e~8;o
e»vhq
e¼\vOǼJk
e¼t麼O
eġz^L\e
eǑ<qg
eɼ8%Y\r
eʻ"A0
e̽NOj>x
eЉD$0tVA
eҔ;b7d
eҢ9nuo
eӖ:s80
eԻqvϺTj
eؼCO\r=|a
eٻ#ur;9
eߨ;KS
e쫼F_G
f %d %d %d\n
f :F'\n
f s cgx iterations %d
f s cgx iterations %lli
f s total - sum: %f s
f u:gw
f"<dZ
f#b"eH
f$H9L
f$\e>zI
f$bA~\b
f$ba~\b
f&ba}Hp<ѱK
f':6J
f';KjX
f(-8y
f(k:0dR
f(ȹvǮ9B
f)\n;tq
f)\r<Gi
f*F,v
f+:qdA
f+bQ|H
f,6:N
f.bQ|H
f/8o J;;b
f0-<K
f0:;l
f0U808
f0\vP
f0\vP!h
f0\vP!s
f0\vP\np\t`\b
f0\vp\n`\t
f0b!L@X
f0u'H
f1.=y\e
f1L<ͅǻM
f1tlārY$\nJ
f2:!I4
f2\bp\a
f2\bp\aP
f2\n9I
f2b1|H
f2bA|H
f3bBm
f5\f`h
f65;܂G
f6b:s
f8>1x:N
f8?ls7
f8ba\\H
f8ݗV:\fl
f9(t\eL
f9(t\fH
f9)u4H9j
f9)u:H
f9,P9
f9.9r
f9/t\tH
f94748
f9<H}\r
f9GGd9
f9\a=s:bcB
f9\bt\rH
f9\bt\tH
f9\bu3HcH<H
f9\nt\tH
f9b!lH
f9b1|H
f9i@w
f9w=`p
f9wZ~9
f9£i8
f:"Yv:d
f:'SK
f::OS
f:Sw$9
f:WV*;Td
f:YXn9
f:\fe
f:f6x8>4
f:fQ\f
f:iby
f:itd:\t
f:ki{9
f:p\t
f:q;Q
f;)ax;K
f;*Ns
f;.tS
f;0H1
f;2Y}>k
f;8\rH9W
f;<wL
f;>YE
f;H9n
f;O^0
f;S;y
f;X\rM
f;X`e
f;Yt˹3
f;\bd
f;\n@a<RI
f;\nDf;VH
f;\tq1<[4I
f;\vuS
f;bA|H
f;k\nF:j
f;r4U
f;t'4<u
f;v\a
f;x)6
f;{\vq; E
f;~gF
f;Ä\b9 \rA
f<IR\t
f<Ol4
f<[6I
f<\fr6
f<\vzμs
f<]V̹AHP
f<f'f<I
f<mT\nE
f<s42
f=B^l=;or
f=G(H
f=HQ\v
f=dS\v>\n
f=j63
f>0Wy
f>>FN
f>Jd\b
f>\bAV>\f
f>\ncL
f?0UE
f?@9ke
f?R(1
f?T;p
f?br}H
f@A:2
f@HcC(H
f@Ye\nH
f@Ye\nb14HY
f@br}H
fA9,@u
fA9,Au
fA9,Qu
fA9,vu
fA91t A
fA;(t(fA98t
fA;8unI
fA;\at\rI
fB9,$O
fB9,Nu
fB94Ou
fB94ht\tH
fB9<@u
fB9<Bu
fB9<Hu
fB9<{u
fB9\fht
fB:)Tf
fC94wu
fC\a>8B
fC\r8\e
fD#\vD$\b
fD+c\bD
fD9 t\a
fD9 t\fH
fD9 t\vH
fD9!u\b
fD9$Hu
fD9$Ou
fD9$wu
fD9,Au
fD9,pu
fD91uTL9r
fD91u\r
fD94Au
fD94Cu
fD94H}aD
fD94Ku
fD94Pu
fD94iu
fD98u\fA
fD9;u\a3
fD9<Gu
fD9<Hu
fD9\bt\rH
fD9\tt(L
fD9d$pt+fD
fD9t$b
fD9|Dhu
fD9|Dhu1
fD9|DhuA
fD9|DhuO
fDigiCert Inc1
fE2;B
fE9!fA
fE9,Fu
fE94Gu
fE94wu
fE98t
fE9<Au
fE:k\f
fES:헏:D
fE\n;T Z
fE\v\bfA
fEo;N
fF"=\rX5
fF<Muq
fFs;\e\em
fG9$Ou
fG;PB
fH:!H
fHL+f@H
fHY4\ebA\fHY\\\e
fH}aB
fHǄ$H\b
fI;n1
fI;tJ\b
fJ;I@a
fJāzY\f
fJԻyrg
fM7<Io
fNֺl/b:\v
fO*>V
fO;Qm
fP:zV
fP;?C";UI
fPҺ/X
fQѻ;q
fR <4c\f
fR\bp\a
fR\bp\aP
fRռhg
fRؽ$C\t
fS>p%C
fSԻvyc
fT=O&n=V
fT\r<Zf2
fU\t=c
fV2:i
fV:Rǭ9
fV<\nL
fV=۠Q
fVE`A\v
fVM@A\v
fW;-I
fW=}b
fWo:Js
fX!t5
fXT=Dq
fXڻOa
fY)9I
fY;7a
fYٻw\e
fZ;6=u
fZK;r
fZy=kJA
f[#9a'g
f[D;\nD
f\a96
f\a<Vhn
f\b!9D
f\b!<8M
f\b;"ep
f\bL:T\tn
f\b\\Q\nb
f\e0B
f\eba~Ho
f\f:|Zk
f\fv:m
f\n0A
f\n=@Z9
f\n>J0
f\nW;`wv
f\n\n;k
f\nba|H
f\nr8J
f\nāzY\f
f\r:D
f\r<\eV
f\r=j}5
f\tn:l
f\v<\tL
f\vT<ӸG
f\vb!|H
f\vba|H
f\vba~\b
f]<o\af
f]P>uep
f]R=r/X
f]\t:In
f`3;JF
f`;N#O9aU
factorization - write&read: %d
factorization - write&read: %lli
factorize
failed
failed: cylinder
fast_allocator_regression_test
fastcall
fatbvh
fatbvh accelerator can cause stack overflow for this scene, try using bvh instead
fatbvh accelerator can't allocate enough stack memory, try using bvh instead
fb;<Cu
fbQ|H
fb\b0\aP
fba$@X
fba|H
fba~\b
fd;ۖ4
fdY:\f圻68
fdbBm
fe;+GF
feJ<F
feN>(s[>v
ffalse
fffff
ffffff
ffffffJ
fffffff
fg>5Xu
fgƺAyy
fgϻ^9
fic9aaP
file error
file exists
file too large
fileBaseName
filename too long
fill-in parameter is negative
filled
filter functions not supported for this geometry
finished BVH
first <= last
fiԼ<k\t
fj:mgA
fj;`L
fkU:^o
fkg;m
fl;9c
float expected
float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n
float_exceptions
fmR:\n
fm\v:/t
fn<zɹ;H
fo9@T
fo:GỺl
for BVH4<Bezier1i
for BVH4<Bezier1v
for BVH4<Line4i
for BVH4<Line4iMB
for BVH4<Object
for BVH4<Quad4i
for BVH4<Quad4iMB
for BVH4<Quad4v
for BVH4<Triangle4
for BVH4<Triangle4i
for BVH4<Triangle4iMB
for BVH4<Triangle4v
for BVH4<Triangle4vMB
for BVH4OBB<Bezier1i
for BVH4OBB<Bezier1iMB
for BVH4OBB<Bezier1v
for BVH8<Line4i
for BVH8<Object
for BVH8<Quad4i
for BVH8<Quad4v
for BVH8<Triangle4
for BVH8<Triangle4i
for BVH8<Triangle4iMB
for BVH8<Triangle4v
for BVH8<Triangle4vMB
for BVH8MBOBB<Bezier1iMB
for QBVH8<Quad4i
format or the matrix is degenerate with zero row
foȸ%M\v
fp09*$u:\tS
fp\v`\n0
fp\v`\nP
fp\v`\nP\t0
fp\v`d\e
fpx<QFI
fq1<&JF
fq5<1
fq;6nǺg
fq<dm
fqp;E
fq༉匼Cb
fr\bp\a
fr\bp\aP
free blocks
freeAudioBuffer
freeBlocks.load() != nullptr && freeBlocks.load()->getBlockAllocatedBytes() >= bytes
french-belgian
french-canadian
french-luxembourg
french-swiss
fs,:3e
ft==\nT
ft\v;7
fuQ:|vs
fu_E3
function BVH8BuilderTwoLevelTriangleMeshSAH not supported by your CPU
function BVH8BuilderTwoLevelVirtualSAH not supported by your CPU
function BVH8QuantizedTriangle4SceneBuilderSAH not supported by your CPU
function BVH8QuantizedTriangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4MeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4MeshBuilderSAH not supported by your CPU
function BVH8Triangle4MeshRefitSAH not supported by your CPU
function BVH8Triangle4SceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4SceneBuilderSAH not supported by your CPU
function BVH8Triangle4iMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4iMeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4iMeshBuilderSAH not supported by your CPU
function BVH8Triangle4iMeshRefitSAH not supported by your CPU
function BVH8Triangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vMeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4vMeshBuilderSAH not supported by your CPU
function BVH8Triangle4vMeshRefitSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderSAH not supported by your CPU
function BVH8VirtualMBSceneBuilderSAH not supported by your CPU
function BVH8VirtualMeshBuilderMortonGeneral not supported by your CPU
function BVH8VirtualMeshBuilderSAH not supported by your CPU
function BVH8VirtualMeshRefitSAH not supported by your CPU
function BVH8VirtualSceneBuilderSAH not supported by your CPU
function not supported
fv8Dd
fvϽjE
fx:_P2
fxº\fm
fxǾ;X2
fy=p:5
f}ͻB碻lC
f~ֺ\f9M
fÈbQ4
fÜ9- w
fżeqD
fǻ4sJ
fȼf\fj
fɐbq|H
fϹk,e:EG1
fӔ;tpw
fջ\tIz
fռ7`s
fغKd̺oU
fܵ;BA
g!3;Rn8
g!T9"d
g#d<'YC
g%H9V
g'L;kd
g(v;\fA
g*?VO
g*U;t
g*k;8
g+m;sOν[3
g+ѻ2PK
g,;wa 9c
g,<\bp3
g->Ra
g0;TQj
g0ܼe_c
g2=ya=A
g2{:Rn
g3>:2w
g3}>Bi
g4o>e
g4v:E
g5=b\nj
g5RҌ<țu
g6H=Co
g6N:B
g8;;\nk
g8B~0GBf
g8ɊúD
g8мFT
g8߰99g
g9@x!8
g9P0\e
g9P[T<Q
g9ھg9
g: kP;O
g:7`U
g:A\n
g:Hǩ;vHO
g:PZP
g:V6s
g:_lu
g:isr9U
g:qmU
g;2zI
g;>\n49
g;G7p
g;G;kyW
g;hD&;E
g;kuG
g;m{5
g<df\t
g<vm2
g<v«9n
g<z(L
g=+8S
g=K\r
g>>wd\r
g@2:9
gB:cc0
gC`;C
gDﻪY1
gGV=pD
gHL+g@H
gHL+g@I
gLV;I3
gM3<Xs
gO;uIg
gQ;'x
gR9>W8
gRC:h
gS;chc;rx
gS<m\vl
gT\\;QYI
gU(:;47
gUD;ZU
gX<FK
gY(<d
gY^8\a
g\\z>RD
g\b:CkK
g\e<fB
g\eL>r
g\fD:\n
g\n<K!G<G
g\t;!LM
g\tC;[P
g\v;KZa:6
g^z:h
g_device
g_j<H_w
gaP=\rH
ga\b;d
gatherEnergyField
gatherImage
gb6=Md
gbѼzQP
general
generateCameraRays
generateListenerRays
generateProbes
generic
geomID
geometries inside group have to be of same type
geometries[i]->getType() == Mesh::geom_type
geometry groups cannot contain other geometry groups
geometry instances only support a single timestep
geometry->intersectionFilterN
geometry->occlusionFilterN
german-austrian
german-lichtenstein
german-luxembourg
german-swiss
getDataSize
getDeviceDesc
getNumDevices
getNumProbes
getOutputs
getProbe
getinfoaH
gfffffff
gfffffffH
gfffffffI
gfffffffL
gffffffff
gflop   for the numerical factorization: %f
gflop/s for the numerical factorization: %f
gg:C\r4<t
gj\f>t
go7H=_;K
gp;:nJ
gr9DH7S
gr:-\rY
great britain
groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    *sum = shmem[groupSize - 1];\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    if (localId == 0){\\ \n    shmem[groupSize - 1] = 0;}\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_PART(type)\\ \n    type group_scan_exclusive_part_##type( int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    type sum = 0;\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (localId == 0)\\ \n    {\\ \n    sum = shmem[groupSize - 1];\\ \n    shmem[groupSize - 1] = 0;\\ \n    }\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    return sum;\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE(type)\\ \n    __kernel void scan_exclusive_##type(__global type const* in_array, __global type* out_array, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    int groupId   = get_group_id(0);\\ \n    shmem[localId] = in_array[2*globalId] + in_array[2*globalId + 1];\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    out_array[2 * globalId + 1] = shmem[localId] + in_array[2*globalId];\\ \n    out_array[2 * globalId] = shmem[localId];\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\\ \n    v2.w += v1.w;\\ \n    shmem[localId] = v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    v2.w = shmem[localId];\\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4_V1(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_##type##4##_v1(__global type##4 const* in_array, __global ty
gu;wI
gvd;>L
gyU:b
g»t\e
gŏ=KG
gŦ:DA
gʼ0;g<o
gͺˇy:2v\n
gκhv付E
gМ;zg
gһuv0
gԺUKL
gۼYVn
h UAVAWH
h VAVAWH
h VWATAVAWH
h#:yo
h&2;2r
h-Ѽws
h16;|x
h4:IgZ
h5]:i
h5e>v
h60;kG
h6D;2t;<6
h6ٺڿB8
h7꼫a1
h8o\vo
h9 20
h9*yx:UQ
h9<qah
h9>0˺_N
h9^c89
h:)J\t:AY
h:/1E
h:2hH;z
h:Z磺\vO
h:g+f
h:or^9
h:p.Y
h;Adi;rr
h;NDn
h;XtۼK
h;\fZV;7e
h;fKn;06r
h;yjo;K
h;̤d;\tUl
h<A<w\a7
h<I\b6
h=:"OV9
h=;kSp
h=E.2
h=I?F>I
h=\n;pD
h>2ip
h>^ht>0
h?=vxX
h?tFپLJk
hA;μw
hA^A]A
hA_A^A
hA_A^A]A
hB)9Ǯq
hB.<C6F
hB:QN49
hB^T{C
hDº\eTr
hEb>0
hHǄ$H
hJ8;zl
hKλyp
hL#=x3
hL;d$p
hL\a;uP
hMK</u
hMK<sJs
hNh4hhh
hN亦Hy
hP:qk
hQƽ2d
hR>\fpm
hU'>k\b
hU<Ǯo
hU\\;CJ{a
hVC;Lo
hW:_z
hX:3jG;F
hX=^y\e
hYD$0
h\e;x
h\eH99x\n;1
h\f\f
h\rm<hz
h\v\a
h];sT
h]A_A
h]A_A^A
h_:~xr9b
ha;gRa:r
had the wrong value or the parameter IPAR(6) was altered by mistake outside of
had the wrong value or the parameter ipar[5] was altered by mistake outside of
hair_accel
hair_accel_mb
hair_builder
hair_builder_mb
hair_traverser
hair_traverser_mb
hbw_free
hbw_posix_memalign_psize
hc;!UR;8
hdK:3
header crc mismatch
hfalse
hffffff
hfffffff
high_quality
histogram
hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    __global int* numrays,     // Number of rays in the workload \n    int offset,                // Offset in rays array \n    __global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny2L(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n
hk<;n
hl(<2xz
hlbvh accelerator max batch size exceeded
hls:PW4
holland
hong-kong
host unreachable
hpT;U
hrd<O
hreset
hrtfSettings
hrtfSettings->normType
hrtfSettings->sofaData
hrtfSettings->sofaDataSize
hrtfSettings->type
hrtfSettings->volume
hs89r
hs:XO
htl<jt\\<lt4<tt$<wt
http://ocsp.digicert.com0
http://ocsp.digicert.com0A
http://ocsp.digicert.com0C
http://ocsp.digicert.com0X
https://github.com/ValveSoftware/steam-audio/blob/master/LICENSE.md
hu=?lq
hugepages
hvļTAS
hwc;kY
hypot
hypotf
hyz8^7B
hz!>I
hz;Xz
h|S:\fE
h»A,0;J
hÊD$g
hü rj
hŻ\aO
hʼa䯼\bT
h̼wyP
hӻC\fC;}p
hܽe\a
hޯ<WP
hᗻ\vPD
h⡽7-h
i 3\bA(L
i ;\e
i < geometries.size
i < numRanges
i < size
i < size_active
i B=w5
i!D\r
i"p<F
i# <Q
i#:xYJ
i#F;y
i$baV\bY
i&=tQ\v
i';Ne
i';ecu
i)U;h
i+i<Uj
i, %i } :  Memory overwrite in %s
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %11.4f
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %11.4f + i* %11.4f
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %20.7lf
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %20.7lf + i* %20.7lf
i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %i
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %11.4f
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %11.4f + i* %11.4f
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %20.7lf
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %20.7lf + i* %20.7lf
i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %i
i,ba~\b
i.;Ws
i.>N5
i0:oȦ9
i1\n;fV8
i3<HO
i4V;\v
i4ۻ?k
i6:\b
i6=uA
i8U,';n
i8g\b2
i8m8@A
i9<S~\r
i9>:\tM
i9B܈9Iw
i9iǋ<Z
i9lzM9
i9v>T\e
i:J+k
i:M)7:^DZ
i:Yoa:\t
i:\bv
i:ik\e
i;LbB
i;Mzu
i;P<5
i;Vv3
i;Zo5
i;\n\fk
i;c+J
i;ku4;iN9
i;l1C
i;oi|:SnO
i;ouJ
i<N && j<N
i<]Cb
i<array2.size
i<tyZ
i=6\nk
i=w?6?T
i>&xO
i>=q8
i>>yo
i>Bsa
i?0@I
i?<Bu-8
iA<p5
iAU;v
iBo<;T
iD2;v\e
iH<QsO
iHȻDee;5
iI=M\t\v
iI=}9
iIĺ8 Q
iK;n~];qe
iM:_R9\r
iM;$LQ
iOA9\t
iS;U,H
iTa;S1\t
iU;GA
iVr9*bn8
iXh<z
i[0] >= 0 && (size_t)i[0] < num
i[1] >= 0 && (size_t)i[1] < num
i[2] >= 0 && (size_t)i[2] < num
i\a:KIz
i\aļVvB?p
i\bH+)H
i\bba~\b
i\eĻ\b2
i\fźXI
i\n;O
i\nW<6
i\r;2
i\r<e3R
i\v7<\r
i`L+iXL
ia(neqns_in+1)-1: %d nb_in         : %d
ia(neqns_in+1)-1: %lli nb_in         : %lli
ia[neqns_in]-1  : %d nb_in         : %d
ia[neqns_in]-1  : %lli nb_in         : %lli
ib/:u
id < nextID
idata$2
idata$3
idata$4
idata$5
idata$6
identifier
identifier expected
identifier removed
identifier).endpointInfluence.center.x
identifier).endpointInfluence.center.y
identifier).endpointInfluence.center.z
identifier).endpointInfluence.radius
identifier).type
identifier).variation
ido_in          : %d neqns_in      : %d
ido_in          : %lli neqns_in      : %lli
ie <GG
if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n \n// intersect Ray against the whole BVH structure \nvoid IntersectSceneClosest(SceneData const* scenedata,  ray const* r, Intersection* isect) \n{ \n    const float3 invdir  = make_float3(1.f, 1.f, 1.f)/r->d.xyz; \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    int idx = 0; \n \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        // If this is the leaf try to intersect against contained triangle. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, isect->uvwt.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                IntersectLeafClosest(scenedata, &node, r, isect); \n                idx = (int)(node.pmax.w); \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                ++idx; \n            } \n        } \n        else \n        { \n            idx = (int)(node.pmax.w); \n        } \n    }; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata,  ray const* r) \n{ \n    float3 invdir  = make_float3(1.f, 1.f, 1.f)/r->d.xyz; \n \n    int idx = 0; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        // If this is the leaf try to intersect against contained triangle. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, r->o.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                if (IntersectLeafAny(scenedata, &node, r)) \n                { \n                    return true; \n                } \n                else \n                { \n                    idx = (int)(node.pmax.w); \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                ++idx; \n            } \n        } \n        else \n        { \n            idx = (int)(node.pmax.w); \n        } \n    }; \n \n    return false; \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosestAMD( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process \n__global Intersection* hits, // Hit datas \n__global int*          raycnt  \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id  = get_global_id(0); \n    int local_id  = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    Intersection isect; \n \n    while (ridx < numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            IntersectSceneClosest(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[ridx] = isect; \n        } \n    } \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAnyAMD( \n    // Input \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices
if;#A
iface%x
iffffff
ifh;#\n
ignore_config_files
igy;p
iiFi#ii
ii\e?j
iix;Tڈ:w
ikR8qN&9\f
il0<Yl
ilj;S
illegal byte sequence
imb;D
imŻ\ny
in instability of calculations
in the MXCSR control and status register. This can have a severe
in(:5
in->data
in->data[iChannel][in->numSamples - 1
in->numChannels
in->numSamples
inType
inappropriate io control operation
include "pmmintrin.h
include "xmmintrin.h
incoherent
incompatible version
incorrect data check
incorrect header check
incorrect length check
incorrect output filename: too long or empty
index < 3
index < 4
index < 8
inflate 1.2.13 Copyright 1995-2022 Mark Adler
inlen == hrtf->N
input matrix size is negative or zero
input value set in DPAR(31) which might result
inputs
inputs->airAbsorptionModel
inputs->airAbsorptionModel)->callback
inputs->airAbsorptionModel)->coefficients
inputs->airAbsorptionModel)->coefficients[iArray
inputs->airAbsorptionModel)->dirty
inputs->airAbsorptionModel)->type
inputs->baked
inputs->bakedDataIdentifier.endpointInfluence.center.x
inputs->bakedDataIdentifier.endpointInfluence.center.y
inputs->bakedDataIdentifier.endpointInfluence.center.z
inputs->bakedDataIdentifier.endpointInfluence.radius
inputs->bakedDataIdentifier.type
inputs->bakedDataIdentifier.variation
inputs->directFlags
inputs->directivity
inputs->directivity)->dipolePower
inputs->directivity)->dipoleWeight
inputs->distanceAttenuationModel
inputs->distanceAttenuationModel)->callback
inputs->distanceAttenuationModel)->dirty
inputs->distanceAttenuationModel)->minDistance
inputs->distanceAttenuationModel)->type
inputs->enableValidation
inputs->findAlternatePaths
inputs->flags
inputs->hybridReverbOverlapPercent
inputs->hybridReverbTransitionTime
inputs->numOcclusionSamples
inputs->numTransmissionRays
inputs->occlusionRadius
inputs->occlusionType
inputs->pathingOrder
inputs->pathingProbes
inputs->reverbScale[iBand
inputs->source.ahead.x
inputs->source.ahead.y
inputs->source.ahead.z
inputs->source.origin.x
inputs->source.origin.y
inputs->source.origin.z
inputs->source.right.x
inputs->source.right.y
inputs->source.right.z
inputs->source.up.x
inputs->source.up.y
inputs->source.up.z
inputs->visRadius
inputs->visRange
inputs->visThreshold
instID
instance
instance@TaskScheduler@embree@@CAPEAU12@XZ
instancedMesh
instancing_block_size
instancing_open_factor
instancing_open_max
instancing_open_max_depth
instancing_open_min
insufficient memory
int4 bin = (localvals >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        if (localid < NUM_BINS) \n        { \n            scanned_histogram[localid] += sum; \n        } \n    } \n} \n \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid ScatterKeysAndValues(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Input values \n    __global int4 const* restrict in_values, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys, \n    // Output values \n    __global int* restrict  out_values \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localkeys = safe_load_int4_intmax(in_keys, loadidx, numelems); \n        int4 localvals = safe_load_int4_intmax(in_values, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localkeys >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LD
integer expected
interleaveAudioBuffer
internal error in ISA selection for BVH4Bezier1iIntersector1
internal error in ISA selection for BVH4Bezier1iIntersector16Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector16Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersector1_OBB
internal error in ISA selection for BVH4Bezier1iIntersector4Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector4Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersector8Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersectorStream
internal error in ISA selection for BVH4Bezier1vIntersector1
internal error in ISA selection for BVH4Bezier1vIntersector16Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector16Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersector1_OBB
internal error in ISA selection for BVH4Bezier1vIntersector4Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector4Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersector8Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersectorStream
internal error in ISA selection for BVH4IntersectorStreamPacketFallback
internal error in ISA selection for BVH4Line4iIntersector1
internal error in ISA selection for BVH4Line4iIntersector16
internal error in ISA selection for BVH4Line4iIntersector4
internal error in ISA selection for BVH4Line4iIntersector8
internal error in ISA selection for BVH4Line4iIntersectorStream
internal error in ISA selection for BVH4Line4iMBIntersector1
internal error in ISA selection for BVH4Line4iMBIntersector16
internal error in ISA selection for BVH4Line4iMBIntersector4
internal error in ISA selection for BVH4Line4iMBIntersector8
internal error in ISA selection for BVH4OBBBezier1iMBIntersector16Hybrid_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector1_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector4Hybrid_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector1Moeller
internal error in ISA selection for BVH4Quad4iIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersectorStreamMoeller
internal error in ISA selection for BVH4Quad4iIntersectorStreamPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH4Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector1Moeller
internal error in ISA selection for BVH4Quad4vIntersector1Pluecker
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersectorStreamMoeller
internal error in ISA selection for BVH4Quad4vIntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersectorStreamPluecker
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector1
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector16
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector4
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector8
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector1
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector16
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector4
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector8
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector1
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector16
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector4
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector8
internal error in ISA selection for BVH4SubdivPatch1Intersector1
internal error in ISA selection for BVH4SubdivPatch1Intersector16
internal error in ISA selection for BVH4SubdivPatch1Intersector4
internal error in ISA selection for BVH4SubdivPatch1Intersector8
internal error in ISA selection for BVH4SubdivPatch1MBIntersector1
internal error in ISA selection for BVH4SubdivPatch1MBIntersector16
internal error in ISA selection for BVH4SubdivPatch1MBIntersector4
internal error in ISA selection for BVH4SubdivPatch1MBIntersector8
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector1Moeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4IntersectorStreamMoeller
internal error in ISA selection for BVH4Triangle4IntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH4Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersectorStreamMoeller
internal error in ISA selection for BVH4Triangle4iIntersectorStreamPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersectorStreamPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH4VirtualIntersector1
internal error in ISA selection for BVH4VirtualIntersector16Chunk
internal error in ISA selection for BVH4VirtualIntersector4Chunk
internal error in ISA selection for BVH4VirtualIntersector8Chunk
internal error in ISA selection for BVH4VirtualIntersectorStream
internal error in ISA selection for BVH4VirtualMBIntersector1
internal error in ISA selection for BVH4VirtualMBIntersector16Chunk
internal error in ISA selection for BVH4VirtualMBIntersector4Chunk
internal error in ISA selection for BVH4VirtualMBIntersector8Chunk
internal error in ISA selection for BVH4XfmTriangle4Intersector1Moeller
internal error in ISA selection for BVH8Bezier1iIntersector16Hybrid_OBB
internal error in ISA selection for BVH8Bezier1iIntersector1_OBB
internal error in ISA selection for BVH8Bezier1iIntersector4Hybrid_OBB
internal error in ISA selection for BVH8Bezier1iIntersector8Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector16Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector1_OBB
internal error in ISA selection for BVH8Bezier1vIntersector4Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector8Hybrid_OBB
internal error in ISA selection for BVH8IntersectorStreamPacketFallback
internal error in ISA selection for BVH8Line4iIntersector1
internal error in ISA selection for BVH8Line4iIntersector16
internal error in ISA selection for BVH8Line4iIntersector4
internal error in ISA selection for BVH8Line4iIntersector8
internal error in ISA selection for BVH8Line4iMBIntersector1
internal error in ISA selection for BVH8Line4iMBIntersector16
internal error in ISA selection for BVH8Line4iMBIntersector4
internal error in ISA selection for BVH8Line4iMBIntersector8
internal error in ISA selection for BVH8OBBBezier1iMBIntersector16Hybrid_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector1_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector4Hybrid_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector8Hybrid_OBB
internal error in ISA selection for BVH8Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector1Moeller
internal error in ISA selection for BVH8Quad4iIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersectorStreamMoeller
internal error in ISA selection for BVH8Quad4iIntersectorStreamPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH8Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector1Moeller
internal error in ISA selection for BVH8Quad4vIntersector1Pluecker
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersectorStreamMoeller
internal error in ISA selection for BVH8Quad4vIntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector1Moeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4IntersectorStreamMoeller
internal error in ISA selection for BVH8Triangle4IntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH8Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersectorStreamMoeller
internal error in ISA selection for BVH8Triangle4iIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH8VirtualIntersector1
internal error in ISA selection for BVH8VirtualIntersector16Chunk
internal error in ISA selection for BVH8VirtualIntersector4Chunk
internal error in ISA selection for BVH8VirtualIntersector8Chunk
internal error in ISA selection for BVH8VirtualIntersectorStream
internal error in ISA selection for BVH8VirtualMBIntersector1
internal error in ISA selection for BVH8VirtualMBIntersector16Chunk
internal error in ISA selection for BVH8VirtualMBIntersector4Chunk
internal error in ISA selection for BVH8VirtualMBIntersector8Chunk
internal error in ISA selection for InstanceBoundsFunc
internal error in ISA selection for InstanceIntersectorN
internal error in ISA selection for QBVH4Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for QBVH8Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH8Triangle4Intersector1Moeller
internal error in ISA selection for QBVH8Triangle4iIntersector1Pluecker
internal error in ISA selection for rayStreamFilterFuncs
internal error: AccelN too small
internal_tasking_system
internal_time_splits
interrupted
intersection_filter
intersector1
intersector1.intersect
intersector1.occluded
intersector16
intersector16.intersect
intersector16.occluded
intersector4
intersector4.intersect
intersector4.occluded
intersector8
intersector8.intersect
intersector8.occluded
intersectorN
intersectorN.intersect
intersectors.intersectorN.intersect
intersectors.intersectorN.occluded
invalid argument
invalid bit length repeat
invalid block type
invalid buffer specified
invalid code -- missing end-of-block
invalid code lengths set
invalid destination pointer
invalid distance code
invalid distance too far back
invalid distances set
invalid geometry
invalid geometry ID
invalid geometry flag
invalid hash bucket count
invalid literal/length code
invalid literal/lengths set
invalid map<K, T> key
invalid number of threads specified
invalid seek
invalid stored block lengths
invalid string position
invalid thread ID
invalid timestep
invalid window size
io error
ios_base::badbit set
ios_base::eofbit set
ios_base::failbit set
iostream
iostream stream error
ipl::HRTFMap::loadAmbisonicsHRIRs
iplAirAbsorptionCalculate
iplAmbisonicsBinauralEffectApply
iplAmbisonicsBinauralEffectCreate
iplAmbisonicsBinauralEffectGetTail
iplAmbisonicsBinauralEffectGetTailSize
iplAmbisonicsBinauralEffectRelease
iplAmbisonicsBinauralEffectReset
iplAmbisonicsBinauralEffectRetain
iplAmbisonicsDecodeEffectApply
iplAmbisonicsDecodeEffectCreate
iplAmbisonicsDecodeEffectGetTail
iplAmbisonicsDecodeEffectGetTailSize
iplAmbisonicsDecodeEffectRelease
iplAmbisonicsDecodeEffectReset
iplAmbisonicsDecodeEffectRetain
iplAmbisonicsEncodeEffectApply
iplAmbisonicsEncodeEffectCreate
iplAmbisonicsEncodeEffectGetTail
iplAmbisonicsEncodeEffectGetTailSize
iplAmbisonicsEncodeEffectRelease
iplAmbisonicsEncodeEffectReset
iplAmbisonicsEncodeEffectRetain
iplAmbisonicsPanningEffectApply
iplAmbisonicsPanningEffectCreate
iplAmbisonicsPanningEffectGetTail
iplAmbisonicsPanningEffectGetTailSize
iplAmbisonicsPanningEffectRelease
iplAmbisonicsPanningEffectReset
iplAmbisonicsPanningEffectRetain
iplAmbisonicsRotationEffectApply
iplAmbisonicsRotationEffectCreate
iplAmbisonicsRotationEffectGetTail
iplAmbisonicsRotationEffectGetTailSize
iplAmbisonicsRotationEffectRelease
iplAmbisonicsRotationEffectReset
iplAmbisonicsRotationEffectRetain
iplAudioBufferAllocate
iplAudioBufferConvertAmbisonics
iplAudioBufferDeinterleave
iplAudioBufferDownmix
iplAudioBufferFree
iplAudioBufferInterleave
iplAudioBufferMix
iplBinauralEffectApply
iplBinauralEffectCreate
iplBinauralEffectGetTail
iplBinauralEffectGetTailSize
iplBinauralEffectRelease
iplBinauralEffectReset
iplBinauralEffectRetain
iplCalculateRelativeDirection
iplCompressedEnergyFieldsBlendAndDecompress
iplCompressedEnergyFieldsCreate
iplCompressedEnergyFieldsCreateEmpty
iplCompressedEnergyFieldsCreateFromProbeBatch
iplCompressedEnergyFieldsGetCompressedData
iplCompressedEnergyFieldsGetDictionary
iplCompressedEnergyFieldsGetNumBands
iplCompressedEnergyFieldsGetNumBins
iplCompressedEnergyFieldsGetNumChannels
iplCompressedEnergyFieldsGetNumProbes
iplCompressedEnergyFieldsGetNumSingularValues
iplCompressedEnergyFieldsRelease
iplCompressedEnergyFieldsRetain
iplCompressedEnergyFieldsSetCompressedData
iplCompressedEnergyFieldsSetDictionary
iplContextCreate
iplContextRelease
iplContextRetain
iplContextSetProfilerContext
iplContextSetVariableBool
iplContextSetVariableFloat32
iplContextSetVariableInt32
iplContextSetVariableString
iplDirectEffectApply
iplDirectEffectCreate
iplDirectEffectGetTail
iplDirectEffectGetTailSize
iplDirectEffectRelease
iplDirectEffectReset
iplDirectEffectRetain
iplDirectivityCalculate
iplDistanceAttenuationCalculate
iplDistanceAttenuationGetCorrectionCurve
iplEmbreeDeviceCreate
iplEmbreeDeviceRelease
iplEmbreeDeviceRetain
iplEnergyFieldAdd
iplEnergyFieldCopy
iplEnergyFieldCreate
iplEnergyFieldGetBand
iplEnergyFieldGetChannel
iplEnergyFieldGetData
iplEnergyFieldGetNumBins
iplEnergyFieldGetNumChannels
iplEnergyFieldRelease
iplEnergyFieldReset
iplEnergyFieldRetain
iplEnergyFieldScale
iplEnergyFieldScaleAccum
iplEnergyFieldSwap
iplHRTFCreate
iplHRTFRelease
iplHRTFRetain
iplHybridReverbEffectApply
iplHybridReverbEffectCreate
iplHybridReverbEffectGetTail
iplHybridReverbEffectGetTailSize
iplHybridReverbEffectRelease
iplHybridReverbEffectReset
iplHybridReverbEffectRetain
iplHybridReverbEstimatorCreate
iplHybridReverbEstimatorEstimate
iplHybridReverbEstimatorRelease
iplHybridReverbEstimatorRetain
iplImpulseResponse2AddChannel
iplImpulseResponse2AddSample
iplImpulseResponse2Create
iplImpulseResponse2GetChannel
iplImpulseResponse2GetNumChannels
iplImpulseResponse2GetNumSamples
iplImpulseResponse2Release
iplImpulseResponse2Reset
iplImpulseResponse2Retain
iplImpulseResponse2SetChannel
iplImpulseResponse2SetChannelDelayed
iplImpulseResponse2SetSample
iplImpulseResponse2Swap
iplImpulseResponse2SwapSource
iplImpulseResponseAdd
iplImpulseResponseCopy
iplImpulseResponseCreate
iplImpulseResponseGetChannel
iplImpulseResponseGetData
iplImpulseResponseGetNumChannels
iplImpulseResponseGetNumSamples
iplImpulseResponseRelease
iplImpulseResponseReset
iplImpulseResponseRetain
iplImpulseResponseScale
iplImpulseResponseScaleAccum
iplImpulseResponseSwap
iplInstancedMeshAdd
iplInstancedMeshCreate
iplInstancedMeshRelease
iplInstancedMeshRemove
iplInstancedMeshRetain
iplInstancedMeshUpdateTransform
iplInterpolatableImpulseResponseBlend
iplInterpolatableImpulseResponseCreate
iplInterpolatableImpulseResponseGetChannel
iplInterpolatableImpulseResponseRelease
iplInterpolatableImpulseResponseReset
iplInterpolatableImpulseResponseRetain
iplInterpolatableImpulseResponseSetChannel
iplOcclusionSimulatorCreate
iplOcclusionSimulatorRelease
iplOcclusionSimulatorRetain
iplOcclusionSimulatorSimulate
iplOpenCLDeviceCreate
iplOpenCLDeviceCreateFromExisting
iplOpenCLDeviceListCreate
iplOpenCLDeviceListGetDeviceDesc
iplOpenCLDeviceListGetNumDevices
iplOpenCLDeviceListRelease
iplOpenCLDeviceListRetain
iplOpenCLDeviceRelease
iplOpenCLDeviceRetain
iplOverlapSaveFIRCopy
iplOverlapSaveFIRCreate
iplOverlapSaveFIRGetBlock
iplOverlapSaveFIRGetChannel
iplOverlapSaveFIRGetData
iplOverlapSaveFIRGetNumBlocks
iplOverlapSaveFIRGetNumChannels
iplOverlapSaveFIRGetNumSpectrumSamples
iplOverlapSaveFIRRelease
iplOverlapSaveFIRReset
iplOverlapSaveFIRRetain
iplOverlapSaveFIRSwap
iplPanningEffectApply
iplPanningEffectCreate
iplPanningEffectGetTail
iplPanningEffectGetTailSize
iplPanningEffectRelease
iplPanningEffectReset
iplPanningEffectRetain
iplPartitionerCreate
iplPartitionerPartition
iplPartitionerRelease
iplPartitionerRetain
iplPathBakerBake
iplPathBakerCancelBake
iplPathEffectApply
iplPathEffectCreate
iplPathEffectGetTail
iplPathEffectGetTailSize
iplPathEffectRelease
iplPathEffectReset
iplPathEffectRetain
iplPathSimulatorCreate
iplPathSimulatorRelease
iplPathSimulatorRetain
iplPathSimulatorSimulate
iplProbeArrayCreate
iplProbeArrayGenerateProbes
iplProbeArrayGetNumProbes
iplProbeArrayGetProbe
iplProbeArrayRelease
iplProbeArrayResize
iplProbeArrayRetain
iplProbeArraySetProbe
iplProbeBatchAddProbe
iplProbeBatchAddProbeArray
iplProbeBatchAddProbeArrayAndCluster
iplProbeBatchCommit
iplProbeBatchCompress
iplProbeBatchCreate
iplProbeBatchCreateCompressed
iplProbeBatchCreateNonUniform
iplProbeBatchGetDataSize
iplProbeBatchGetInfluencingProbes
iplProbeBatchGetNumProbes
iplProbeBatchGetProbe
iplProbeBatchGetProbeArray
iplProbeBatchLoad
iplProbeBatchLoadCompressed
iplProbeBatchLoadNonUniform
iplProbeBatchLookupBakedReflections
iplProbeBatchLookupCreate
iplProbeBatchLookupRelease
iplProbeBatchLookupRetain
iplProbeBatchRelease
iplProbeBatchRemoveData
iplProbeBatchRemoveProbe
iplProbeBatchRetain
iplProbeBatchSave
iplProbeBatchUpdateEndpoint
iplProbeBatchUpdateProbePosition
iplProbeBatchUpdateProbeRadius
iplProbeClusterMapCreate
iplProbeClusterMapGetData
iplProbeClusterMapLookup
iplProbeClusterMapRelease
iplProbeClusterMapRemapNeighborhood
iplProbeClusterMapRetain
iplProbeNeighborhoodCalculateWeights
iplProbeNeighborhoodCheckOcclusion
iplProbeNeighborhoodCreate
iplProbeNeighborhoodFindNearest
iplProbeNeighborhoodGetNumProbes
iplProbeNeighborhoodGetNumValidProbes
iplProbeNeighborhoodGetProbe
iplProbeNeighborhoodGetProbeBatch
iplProbeNeighborhoodGetProbeIndex
iplProbeNeighborhoodRelease
iplProbeNeighborhoodReset
iplProbeNeighborhoodResize
iplProbeNeighborhoodRetain
iplProbeNeighborhoodSetProbeBatch
iplProbeNeighborhoodSetProbeIndex
iplRadeonRaysDeviceCreate
iplRadeonRaysDeviceRelease
iplRadeonRaysDeviceRetain
iplReconstructorCreate
iplReconstructorReconstruct
iplReconstructorRelease
iplReconstructorRetain
iplReflectionEffectApply
iplReflectionEffectCreate
iplReflectionEffectGetTail
iplReflectionEffectGetTailSize
iplReflectionEffectRelease
iplReflectionEffectReset
iplReflectionEffectRetain
iplReflectionMixerApply
iplReflectionMixerCreate
iplReflectionMixerRelease
iplReflectionMixerReset
iplReflectionMixerRetain
iplReflectionSimulatorCreate
iplReflectionSimulatorRelease
iplReflectionSimulatorRetain
iplReflectionSimulatorSimulate
iplReflectionsBakerBake
iplReflectionsBakerCancelBake
iplReflectionsEffect2Apply
iplReflectionsEffect2Create
iplReflectionsEffect2GetFloat
iplReflectionsEffect2GetInt32
iplReflectionsEffect2Release
iplReflectionsEffect2Reset
iplReflectionsEffect2Retain
iplReflectionsEffect2SetBuffer
iplReflectionsEffect2SetFloat
iplReflectionsEffect2SetInt32
iplReflectionsPartitioner2AddTask
iplReflectionsPartitioner2Commit
iplReflectionsPartitioner2Create
iplReflectionsPartitioner2Release
iplReflectionsPartitioner2RemoveTask
iplReflectionsPartitioner2Retain
iplReflectionsPartitioner2RunTasks
iplReverbEstimatorApplyScale
iplReverbEstimatorCreate
iplReverbEstimatorEstimate
iplReverbEstimatorRelease
iplReverbEstimatorRetain
iplSceneCommit
iplSceneCreate
iplSceneLoad
iplSceneRelease
iplSceneRetain
iplSceneSave
iplSceneSaveOBJ
iplSerializedObjectCreate
iplSerializedObjectGetData
iplSerializedObjectGetSize
iplSerializedObjectRelease
iplSerializedObjectRetain
iplSimulatorAddProbeBatch
iplSimulatorCommit
iplSimulatorCreate
iplSimulatorRelease
iplSimulatorRemoveProbeBatch
iplSimulatorRetain
iplSimulatorRunDirect
iplSimulatorRunPathing
iplSimulatorRunPathingForNeighborhoods
iplSimulatorRunPathingPerSource
iplSimulatorRunPathingPerSourceForNeighborhood
iplSimulatorRunReflections
iplSimulatorSetScene
iplSimulatorSetSharedInputs
iplSourceAdd
iplSourceCreate
iplSourceGetOutputs
iplSourceGetOutputsAux
iplSourceRelease
iplSourceRemove
iplSourceRetain
iplSourceSetInputs
iplStaticMeshAdd
iplStaticMeshCreate
iplStaticMeshLoad
iplStaticMeshRelease
iplStaticMeshRemove
iplStaticMeshRetain
iplStaticMeshSave
iplTrueAudioNextDeviceCreate
iplTrueAudioNextDeviceRelease
iplTrueAudioNextDeviceRetain
iplVirtualSurroundEffectApply
iplVirtualSurroundEffectCreate
iplVirtualSurroundEffectGetTail
iplVirtualSurroundEffectGetTailSize
iplVirtualSurroundEffectRelease
iplVirtualSurroundEffectReset
iplVirtualSurroundEffectRetain
ir":r
ir4;D
irUpdateQueue
irish-english
is a directory
is out of admissible interval [0,infinity). Assigning DPAR(8)=%e
isAlignedNode
isAlignedNodeMB() || isAlignedNodeMB4D
isAlignedNodeMB4D
isBarrier
isLeaf
isQuantizedNode
isTransformNode
isZ;f
is_double
isa::Cylinder::verify
italian-swiss
item < size
items<=4
iterations automatically
itime < instance->numTimeSteps
itime+1 < numTimeSteps
itime_range.size() == 1
it|<nto<otb<ptU<st
ivK;H
ivariant == IntersectVariant::FAST
ivariant == IntersectVariant::ROBUST
ix;h58
ixn<JtA<v
iy0=*{u
iy;\fb
izL;x
i|ŢXY
iȽutv=\tV
iʄ;Et
iͻo\t
i⺵gI;F
i繇ٱ:WF;dF
i軲j̻CF
j ;=M
j ?;k9
j ba|\b
j"=Np\n
j&9|6
j(L=N
j) \n \n// Find span occupied by internal node with index idx \nint2 FindSpan(__global int* mortoncodes, int numprims, int idx) \n{ \n    // Find the direction of the range \n    int d = sign((float)(DELTA(idx, idx+1) - DELTA(idx, idx-1))); \n \n    // Find minimum number of bits for the break on the other side \n    int deltamin = DELTA(idx, idx-d); \n \n    // Search conservative far end \n    int lmax = 2; \n    while (DELTA(idx,idx + lmax * d) > deltamin) \n        lmax *= 2; \n \n    // Search back to find exact bound \n    // with binary search \n    int l = 0; \n    int t = lmax; \n    do \n    { \n        t /= 2; \n        if(DELTA(idx, idx + (l + t)*d) > deltamin) \n        { \n            l = l + t; \n        } \n    } \n    while (t > 1); \n \n    // Pack span  \n    int2 span; \n    span.x = min(idx, idx + l*d); \n    span.y = max(idx, idx + l*d); \n    return span; \n} \n \n// Find split idx within the span \nint FindSplit(__global int* mortoncodes, int numprims, int2 span) \n{ \n    // Fetch codes for both ends \n    int left = span.x; \n    int right = span.y; \n \n    // Calculate the number of identical bits from higher end \n    int numidentical = DELTA(left, right); \n \n    do \n    { \n        // Proposed split \n        int newsplit = (right + left) / 2; \n \n        // If it has more equal leading bits than left and right accept it \n        if (DELTA(left, newsplit) > numidentical) \n        { \n            left = newsplit; \n        } \n        else \n        { \n            right = newsplit; \n        } \n    } \n    while (right > left + 1); \n \n    return left; \n} \n \n// Set parent-child relationship \n__kernel void BuildHierarchy( \n    // Sorted Morton codes of the primitives \n    __global int* mortoncodes, \n    // Bounds \n    __global bbox* bounds, \n    // Primitive indices \n    __global int* indices, \n    // Number of primitives \n    int numprims, \n    // Nodes \n    __global HlbvhNode* nodes, \n    // Leaf bounds \n    __global bbox* boundssorted \n    ) \n{ \n    int globalid = get_global_id(0); \n \n    // Set child \n    if (globalid < numprims) \n    { \n        nodes[LEAFIDX(globalid)].left = nodes[LEAFIDX(globalid)].right = indices[globalid]; \n        boundssorted[LEAFIDX(globalid)] = bounds[indices[globalid]]; \n    } \n     \n    // Set internal nodes \n    if (globalid < numprims - 1) \n    { \n        // Find span occupied by the current node \n        int2 range = FindSpan(mortoncodes, numprims, globalid); \n \n        // Find split position inside the range \n        int  split = FindSplit(mortoncodes, numprims, range); \n \n        // Create child nodes if needed \n        int c1idx = (split == range.x) ? LEAFIDX(split) : NODEIDX(split); \n        int c2idx = (split + 1 == range.y) ? LEAFIDX(split + 1) : NODEIDX(split + 1); \n \n        nodes[NODEIDX(globalid)].left = c1idx; \n        nodes[NODEIDX(globalid)].right = c2idx; \n        //nodes[NODEIDX(globalid)].next = (range.y + 1 < numprims) ? range.y + 1 : -1; \n        nodes[c1idx].parent = NODEIDX(globalid); \n        //nodes[c1idx].next = c2idx; \n        nodes[c2idx].parent = NODEIDX(globalid); \n        //nodes[c2idx].next = nodes[NODEIDX(globalid)].next; \n    } \n} \n \n// Propagate bounds up to the root \n__kernel void RefitBounds(__global bbox* bounds, \n                          int numprims, \n                          __global HlbvhNode* nodes, \n                          __global int* flags \n                          ) \n{ \n    int globalid = get_global_id(0); \n \n    // Start from leaf nodes \n    if (globalid < numprims) \n    { \n        // Get my leaf index \n        int idx = LEAFIDX(globalid); \n \n        do \n        { \n            // Move to parent node \n            idx = nodes[idx].parent; \n \n            // Check node's flag \n            if (atomic_cmpxchg(flags + idx, 0, 1) == 1) \n            { \n                // If the flag was 1 the second child is ready and  \n                // this thread calculates bbox for the node \n \n                // Fetch kids \n                int
j/ʼn4
j1;m\a
j3K:\e
j7w:Y
j7֏L8
j8L;x
j8b3M
j8ba|\b
j9!I4
j9:jId
j9\b|89
j9n.칣J
j9~ry
j: \n\t
j:( K
j:K+9
j:P7\a
j:nsr
j:p\rE:\a0Y:6
j;-v6
j;2<a
j;>N3=B
j;J5\t
j;V^b
j;YSc
j;d<H
j;nYB<D
j<W;a
j<\nQ
j<gOǼh\n
j<hln
j<s@X
j=GǬ9W
j?Q>c
j?\fKk?X
j@p;2
j@w;U
jAE;\n
jB:kZx
jB<\eR
jB\t=!U
jCZ<U\f
jCӻ\f\en
jD5;Hp
jD<3eW
jE3<4
jF;@N
jFb=\fl
jH:<QT
jH<r6v;K
jJ0>o4㽞X
jK<8kc
jL-; H
jO;GA
jPj;Ȥ4
jQ7:5(u
jQ:X&9;\bP
jQ;%8
jS.9eI(:8I
jTK;5ۡ<S
jU)9`9
jU;kD
jW2;5]Q
jX\a<p
jXa ŲXA
jY>=|ZY
jY\e;~7
jYd\aTĢQ
jYd\b\bz
j[;kM
j\a\f
j\aba|H
j\aba|\b
j\aba~\b
j\ah<5p
j\ah<m3
j\b A
j\b\a:Z 6
j\bbA
j\bbA|\b
j\e=lV
j\e\n<h
j\f\n<lN
j\fbA
j\nͼs[c
j\t<B\fy
j\vba|\b
j\vͼgA
j`4<EV
jc<\r
jd\e<օx
jdɼ!j
jf93A5
jffffff
jg<=w
jgE;TY
jgr:g
jh\v<5
jj@0HK4
jm%<nv
joC:H7
joL<ha
jrG;&sV
jt":2
jtm}S
jtۺ\e7\t
juD;BK5
jv: t
jxD<,霼U`E
jy:VK
jy=Hܖ=P
j{E>hI
j˂8>GO:}X
jϼ2Qy<C
jѷ<b3s
jֻOM3
jٚ;n3
jݼfB绪j
jސ;Du
jꅽE-I
jﺜܙ80
k [:Y
k w:f
k!U<k
k"5:*ub
k"<\f4F
k$l9\\8
k+g:Y6
k,=LAZ
k-z>P\a
k.2:x_O
k.;9p
k0;b8\e
k1;qP6
k1ӽVk
k2=)i
k46:!S
k4ݺiTx
k53<HC
k6A;\\x
k7˼\bQɼK
k80qA
k89;~W
k8=ԈĽ5l
k92JX
k:;3P0
k:=4w
k:Dq\t
k:N=h:3
k:мCz
k;FLO;C
k;K#H
k;Lnm;\\a
k;\n\aۻ8Y
k;\tu7
k;bLŻa
k;tޏ:I0
k;}lU
k;~XO
k<*b2
k<9cXN
k<Z9k
k<\b8\e=C
k=t\b
k>p"Q
k>pzf>M
k@b1|H
kB<qeλ\tt
kC:ll
kE{;Kx
kH\v;A39;BUn:8
kJ\f>V
kL:mw\b9y
kL<9mK
kL@8o(u
kL\f?g
kP<HI <4jv
kPfff
kPffff
kPfffff
kPffffff
kPfffffff
kPջ8u\t
kQQ:I
kQi<\b
kQƼU}S
kQɻ C
kR9;N
kRi;\n
kS;l\a
kT!;>DZ
kT>Lu
kV[8Y
kW\n<|H廀A
kZ;Z}H
kZ<2"N
kZa<jq
k[F<yT
k\a<xl\a3hm\a*t
k\bA8m(u\vI
k\bba|H
k\e;wT
k\fb!|HX
k\n;w
k\tbq|H
k]\t;9N
kaw;Ff
kb:cD
kc3:\e
ke@<uM
kernel32
kernel32.dll
kf<8B
kfH;B]z
kf\e<g
kg;_A
kg=<Zɼy|J
kh;yua;d
kj;\a );K
kl\t<TpC
km\f<O
kok-IN
kok-in
kp漽\f
kq;j\n
krU9\vUy
kt;:\rs
ku;é3:Q
ky\r9E
kyq;]8
k|^Xm
k}<aq
k~*6Q
k~y:K
kļu\r7
kľ<Eg\e
kȻjꦻqkܻFY
kɻ-eQ
kҼf[R
kջWH2<[Q0
kܥ:zfa
l!s;9p
l$ ATAVAWH
l$ UAVAWH
l$ VAVAWH
l$ VWATAVAWH
l$ VWATH
l$ VWAUH
l$ VWAVH
l$ VWAWH
l$ WAVAWH
l$ ba|\b
l$ ba~\b
l$ fE
l$( b
l$(ba
l$03҉L
l$0D+ D9
l$0E3
l$0Hc
l$0L9n
l$0Lcy\f
l$0ba~\b
l$0bb5
l$0fC
l$4bb
l$8D;l$4s\nH
l$8H9~(v
l$8ba~\b
l$8bbE
l$<bb
l$@D8W\buIH
l$@LcSl
l$@Lcd$|H
l$@fD
l$@fff
l$HA_A^A]A
l$HL9a
l$HL9i
l$HL9k
l$N=1
l$PD;f
l$PHc
l$PHc\\$LH
l$PM#e\bt
l$Pba
l$Pba~\b
l$Pff
l$Pu\afE
l$Pu\vE
l$XE3\tT$`A
l$Xba
l$Xba~\b
l$X~gL
l$\bba
l$\bba~\b
l$\bbb
l$\f0b
l$\rba~\b
l$`Hc
l$`Ii
l$`Lce
l$`ba|H
l$`ffffff
l$fba~\b
l$hH;l
l$pHc
l$pHc\\$LH
l$pHc|$lH
l$pL;l$xL
l$pba~\b
l$pfA
l$pfE
l$pġzY
l%ݼN8m
l&:GF
l-;eM
l/:09
l0+:z
l0=h{D
l0\aba|H
l15;RJ
l1ú\ad
l598_r
l6w<H
l7<dV
l8%9\tc
l9<RW
l9\t;!\nW
l9u;.L
l:Xj纨E
l:\b\n\t;gr󹙌A;bYi;DQ
l:g\r\t
l:j\aB;r
l:nZ>:JzH
l:~ou
l; le
l;B8a
l;\tyٺtM\f;F
l<X94
l<w5Ž\nL\b
l<ǜu=57
l>a|m
l@3=jX
lBL:pj
lB黻n9
lD;LH\e
lD<dq4<K
lE8o]Q
lGo<`m
lH;QS{9
lHYu\rb
lHY|\a\bb
lHY}\abB
lK=$39
lNs:E7
lO5;"S
lP9[В9
lR);ce
lT%\ax
lT0fB
lU ńX
lV;#f
lW2:8
lW?XҶ<M
lWۻ4\fM9
lX\f"H
lY2;\f
lYL @H
lYL0@H
lYL8@H
lZ1<x
lZ=Ru\r
lZ=vI
l\\F żY
l\\G ŌY
l\\G ŬY
l\a<a8):A
l\aPġBYT\a\\L
l\e;Ko\e:b
l\f5;d'P
l\f<< T
l\f<j
l\fI9
l\fx8Ŕe
l\n\v<2
l\t\abA|H
l\vP:7
l\vS9S7
l\v\abA|H
l]U:j
l_Y<K
l_뻗jK
l`I<\eL
lbS;9bU
lc = nodes[idx].left; \n                int rc = nodes[idx].right; \n \n                // Calculate bounds \n                bbox b = bboxunion(bounds[lc], bounds[rc]); \n \n                // Write bounds \n                bounds[idx] = b; \n            } \n            else \n            { \n                // If the flag was 0 set it to 1 and bail out. \n                // The thread handling the second child will \n                // handle this node. \n                break; \n            } \n        } \n        while (idx != 0); \n    } \n} \n
leaves
lf8<E>6
lfW;I
lfffff
lg;;T
lg\v<DZO
li$<}C0=t
li;4ZD
li=YU˼jn
liF;5F
line segments
line4i
line_accel
line_accel_mb
line_builder
line_builder_mb
line_traverser
line_traverser_mb
list too long
list<T> too long
listTanDevicesAndCaps
listener.x
listener.y
listener.z
listenerAhead.x
listenerAhead.y
listenerAhead.z
listenerPosition.x
listenerPosition.y
listenerPosition.z
listenerUp.x
listenerUp.y
listenerUp.z
ljH;p
lk9(mP
lk;6᤹a\n
llHl$ll
lli, %lli } :  Memory overwrite in %s
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %11.4f
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %11.4f + i* %11.4f
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %20.7lf
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %20.7lf + i* %20.7lf
lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %i
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %11.4f
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %11.4f + i* %11.4f
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %20.7lf
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %20.7lf + i* %20.7lf
lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %lli
llɻhOx
lm?;DjW
ln;7M\r
loadProbeBatch
loadScene
loadStaticMesh
loat2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n
local static guard
local static thread guard
local vftable
local vftable constructor closure
localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \nvoid group_segmented_scan_exclusive_int_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1
localTimeSegments > 0
log10f
lp:9#\f
lpֹ1yK
lu/%s
lv;u\rR
lvӼUf
lxໝi];w
ly\r;^pB
l~;n25
lúL #8
lŽVĖ<mE
lϻg{G
lعIEz
lܼ)8u
lޡ=eo\t
l嫼G+6
l蠼3\v_< ot
m / %d / %y
m LcT$8I
m b!|\bX
m b1t\b
m ŐXm
m!=\n3A
m"2;lxO
m"K;u
m'=YYY
m(8?TT
m(;tU
m);6\nr
m*k<o
m/:RG
m0ŨXl
m1q;\a
m2<\a'p
m3$;a
m3:@3\n
m5=R.O
m69jlQ9B
m6;]g
m6=FwK
m7;ka
m8(^S80
m8RDu;~d
m8aK:a
m8ԻWw
m9 k;5
m9b25
m9f/\t
m:Dբ9fI
m:cG?;X#W
m:o黹R\n
m;4Ij;qi\a
m;;X4
m;;zmx
m;F|39
m;o1J
m;y\t\a
m<8楼ky
m<>s2
m<[jg
m<\fi
m='\bڽlM8
m=\a9
m>)VF
m?x:o
m@-pU1
mAF=:D
mB;G\tH
mD><D
mEA;\a1
mF#ʈb3UF
mH@%\vD
mH@\r>z
mH@\ray
mI;g\\U
mJ#;5
mK=lr
mLK:a6t
mLY<F
mOD;7
mPD=I
mPo9"g
mQ<FYr
mQ<^D
mSV;Ux
mU=#si
mWA9o
mWC:1
mX=9\t)C
mXbaT
mY90W
mY9p>o
m[;1NJ
m\abA|H
m\b!t
m\b;w\f
m\bI+\aA
m\bba}HpձbA,@YU\tb
m\e<r
m\fbA$ X
m\fbQ|H
m\fbr}H
m\nE<v
m\nb1}HpֱbQ,HYU\vb
m\rbA|H
m\tQ9
m\t\v
m\tbQ|H
m\vbA|H
m\vbB
m\vbQ|H
m_4:\bN
m_active
m_isec & bits
m_trav_active
m`Hc}(H
ma;Ⱦ1
malloc
managed vector constructor iterator
managed vector copy constructor iterator
managed vector destructor iterator
map/set too long
map/set<T> too long
mask != 0
mask < 16
mask >= 0 && mask < 16
matrix appears to be degenerate. The method probably had to be stopped at the
matrix column indexes are not in increasing order
matrix has no diagonal in CSR format
matrix has zero diagonal
matrix size-1) if IPAR(7)>0, aborting otherwise
matrix size. Proceeding with the parameter equals
matrix_number_in: %d matrix_type_in: %d
matrix_number_in: %i matrix_type_in: %d
matrix_number_in: %lli matrix_type_in: %lli
maxGrowSize
max_builder_isa
max_hrtf_normalization_volume_gain_db
max_isa
max_leaf_size
max_spatial_split_replications
maximally 256 floating point values can be interpolated per vertex
mb<\e
mc;|c
mc^:H
md:jgt
me;9*7
memcpy_s: dest is NULL
memcpy_s: dmax exceeds max
memcpy_s: dmax is 0
memcpy_s: overlap undefined
memcpy_s: smax exceeds dmax
memcpy_s: smax is 0
memcpy_s: src is NULL
memkind".dll
memkind_get_version
memmove_s: dest is null
memmove_s: dmax is 0
memmove_s: smax exceeds max
memmove_s: smax is 0
memmove_s: src is null
memory for inner temporary integer array of size N
memory monitor forced termination
message size
method may fail to converge
mffffff
mg<;z\b
mge:p
mi<78f
min_leaf_size
minimally possible
minkernel\\crts\\ucrt\\inc\\corecrt_internal_strtox.h
mix->data
mix->data[iChannel][mix->numSamples - 1
mix->numChannels
mix->numSamples
mixAudioBuffer
mj9Z[9G
mkX>\r+G
mkl_avx2.2.dll
mkl_avx512.2.dll
mkl_def.2.dll
mkl_mc3.2.dll
mkl_msg.dll
mkl_somatcopy
mkl_vml_avx2.2.dll
mkl_vml_avx512.2.dll
mkl_vml_cmpt.2.dll
mkl_vml_def.2.dll
mkl_vml_mc3.2.dll
mkʻnI\v
ml">Z
mn;$R
mn];A
model->callback
model->coefficients
model->coefficients[iArray
model->dipolePower
model->dipoleWeight
model->dirty
model->minDistance
model->type
morton
morton[j] <= morton[j+1
motion blur hair
motion blur line segments
motion blur quads
motion blur triangles
movdir64b
movdiri
mpHc},H
mp~9GGW
mq:1kA
mq\e:3N
mr;4i
mr=/\b5
mr>\rw
ms:W6x
msM;W
mscoree.dll
msrlist
mt^<E
mtllib %s.mtl\n
must be not bigger than (%i
must be not less than (%i
mv':\eh
mwH9?l\f:@Z`8eTE
mx::dh89mG
myzAn4
m~ҺBT
mÜ8\a
mȣ:ScսEd
mɺDDo;8
m˕9ntH
m˻7\eG;BF
m˻Eg7
mλ8FF
mѸC\e
n            else \n            { \n                lbox = scenedata->bounds[node.left]; \n                rbox = scenedata->bounds[node.right]; \n \n                lefthit = IntersectBoxF(r, invdir, lbox, r->o.w); \n                righthit = IntersectBoxF(r, invdir, rbox, r->o.w); \n \n                if (lefthit > 0.f && righthit > 0.f) \n                { \n                    int deferred = -1; \n                    if (lefthit > righthit) \n                    { \n                        idx = node.right; \n                        deferred = node.left; \n                    } \n                    else \n                    { \n                        idx = node.left; \n                        deferred = node.right; \n                    } \n \n                    if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                    { \n                        for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                        { \n                            gsptr[i] = ldsstack[i * 64]; \n                        } \n \n                        gsptr += SHORT_STACK_SIZE; \n                        lsptr = ldsstack + 64; \n                    } \n \n                    *lsptr = deferred; \n                    lsptr += 64; \n \n                    continue; \n                } \n                else if (lefthit > 0) \n                { \n                    idx = node.left; \n                    continue; \n                } \n                else if (righthit > 0) \n                { \n                    idx = node.right; \n                    continue; \n                } \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return false; \n} \n \n \n#endif \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes, // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef LDS_BUG \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n    // Input \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* ra
n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return false; \n} \n#else \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    if (r->o.w < 0.f) \n        return false; \n     \n    int stack[32]; \n \n    int* sptr = stack; \n    *sptr++ = -1; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    bool found = false; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        leftleaf = LEAFNODE(node.lbound); \n        rightleaf = LEAFNODE(node.rbound); \n \n        lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, r->o.w); \n        righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, r->o.w); \n \n        if (leftleaf) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node.lbound), r)) \n            { \n                found = true; \n                break; \n            } \n        } \n         \n        if (rightleaf) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node.rbound), r)) \n                    { \n                        found = true; \n                        break; \n                    } \n        } \n \n        if (lefthit > 0.f && righthit > 0.f) \n        { \n            int deferred = -1; \n            if (lefthit > righthit) \n            { \n                idx = (int)node.rbound.pmax.w; \n                deferred = (int)node.lbound.pmax.w;; \n            } \n            else \n            { \n                idx = (int)node.lbound.pmax.w; \n                deferred = (int)node.rbound.pmax.w; \n            } \n \n                    *sptr++ = deferred; \n        } \n        else if (lefthit > 0) \n        { \n            idx = (int)node.lbound.pmax.w; \n        } \n        else if (righthit > 0) \n        { \n            idx = (int)node.rbound.pmax.w; \n        } \n \n        if (lefthit <= 0.f && righthit <= 0.f) \n            idx = *--sptr; \n    } \n \n    return found; \n} \n \n#endif \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes, // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n         \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef GLOBAL_STACK  \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData con
n       Lenght: %d   Buffer size: %d\n
n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults,  // Hit results \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    while (ridx < numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[ridx] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRCAMD( \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits, // Hit datas \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    Intersection isect; \n \n    while (ridx < *numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= *numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            IntersectSceneClosest(&scenedata, &r, &isect); \n            // Write data back in case of a hit \n            hits[ridx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRCAMD( \n    // Input \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults,   // Hit results \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    while (ridx < *numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= *numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n
n ;b\e
n <gE
n == 0
n M;B"y
n T:C
n }WH
n }YL
n!r<J{R
n"I\vc
n"a;x
n$ fG
n$v;b
n&ɻwh\b
n'>RR
n)g;v
n+C;\fK
n,:Ff
n-:LT̹K
n.<Uv
n/ ;l
n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable\n#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n\n// --------------------------------------------------------------------------------------------------------------------\n// Constants\n// --------------------------------------------------------------------------------------------------------------------\n\n#define PI                          3.14159f              // Mathematical constant Pi\n#define SOURCE_RADIUS               0.1f                  // Radius of the sound source sphere (in meters)\n#define LISTENER_RADIUS             0.1f                  // Radius of the listener sphere (in meters)\n#define SPEED_OF_SOUND              340.0f                // Speed of sound in air (in meters per second)\n#define RAY_SURFACE_OFFSET          1e-2f                 // Small offset to prevent ray self-intersection (meters)\n#define SPECULAR_EXPONENT           1e+2f                 // Exponent for specular reflection in Phong shading model (unitless, higher value = more specular)\n#define NUM_BANDS                   3                     // Number of frequency bands (e.g., Low, Mid, High)\n#define NUM_BINS                    256                   // Number of time bins used for energy histograms\n#define BIN_DURATION                0.01f                 // Duration of each time bin (in seconds)\n#define NUM_LOCAL_HISTOGRAMS        2                     // Number of local histograms per workgroup (for atomic contention reduction, tunable)\n\n// --------------------------------------------------------------------------------------------------------------------\n// CoordinateSpace\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) CoordinateSpace_t\n{\n    float3 right;\n    float3 up;\n    float3 ahead;\n    float3 origin;\n} CoordinateSpace;\n\nCoordinateSpace createCoordinateSpace(float3 normal)\n{\n    CoordinateSpace space;\n    space.ahead = normal;\n\n    if (fabs(normal.x) > fabs(normal.z))\n    {\n        float3 right = (float3) (-normal.y, normal.x, 0.0f);\n        space.right = normalize(right);\n    }\n    else\n    {\n        float3 right = (float3) (0.0f, -normal.z, normal.y);\n        space.right = normalize(right);\n    }\n\n    space.up = cross(space.right, space.ahead);\n\n    return space;\n}\n\nfloat3 transformLocalToWorld(CoordinateSpace space,\n                             float3 direction)\n{\n    return direction.x * space.right + direction.y * space.up - direction.z * space.ahead;\n}\n\nfloat3 transformWorldToLocal(CoordinateSpace space,\n                             float3 direction)\n{\n    float3 transformedDirection;\n    transformedDirection.x = dot(direction, space.right);\n    transformedDirection.y = dot(direction, space.up);\n    transformedDirection.z = -dot(direction, space.ahead);\n    return transformedDirection;\n}\n\nfloat3 transformHemisphereSample(float3 direction,\n                                 float3 normal)\n{\n    CoordinateSpace tangentSpace = createCoordinateSpace(normal);\n    return normalize(transformLocalToWorld(tangentSpace, direction));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Random Sampling\n
n/97vO
n/C;7
n0,;P0
n03>Pu
n0<)w
n0A:c
n0\tP\bp\a
n0ƻAsm
n1#<OP8
n1=L88
n1i>u
n2:Nu
n4,;E
n5:\n
n5\n`h
n6:!H
n7!;i
n76OL;\nq
n7;XPF
n7T7H
n8=]H
n9%HL
n99%ŻSbǻK
n9FѬ:r
n9\f˜9
n9ofi96
n:/9h
n:/QY
n:3;T
n:3sA
n:VT%;Z
n:\b$o8c
n:\b=5a
n:\bRs
n:\eoe9
n:l)s
n:m~a
n;5Yٺ3w
n;@ d:I
n;A^L
n;C4d<n
n;Ja[;Y
n;Q+f
n;V\fw;\f
n;\r5
n;\v0t;W
n;ai;X
n;b92
n;i|y
n;ku\b;0\nz
n;lvT8\fgM
n;r\b9
n;r\eW9
n;y[f
n<*ki
n</N9
n<4\ro
n<F\rh
n<O}w<p
n<\e4
n<\vzV
n<f8\r
n<s]7
n<uyN
n<vǨ8
n<z4ٻi
n=25b=v
n=4~y
n=9rD
n=TEԼYt
n=e}Q>p
n=fZȼ4u
n=jn\f
n=xnd
n>&CS
n>&S4
n>6<8
n><oF>d
n>Hsk=Q
n>J9H
n>L<Zse
n>Y\n\n>0
n>\e4E
n>log2
n>w%n
n>ֻ6zW
n?0ho?s
n?6\e
n?:Da\t
n?P;H
n?arh
nA>;b4L
nA>Spz
nB/:m
nBϺُt
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n /************************************************************************* \n  INCLUDES \n  **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable \n#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable \n \n \n// --------------------- HELPERS ------------------------ \n//#define INT_MAX 0x7FFFFFFF \n \n// -------------------- MACRO -------------------------- \n// Apple OCL compiler has this by default,  \n// so embrace with #ifdef in the future \n#define DEFINE_MAKE_4(type)\\ \n    type##4 make_##type##4(type x, type y, type z, type w)\\ \n{\\ \n    type##4 res;\\ \n    res.x = x;\\ \n    res.y = y;\\ \n    res.z = z;\\ \n    res.w = w;\\ \n    return res;\\ \n} \n \n// Multitype macros to handle parallel primitives \n#define DEFINE_SAFE_LOAD_4(type)\\ \n    type##4 safe_load_##type##4(__global type##4* source, uint idx, uint sizeInTypeUnits)\\ \n{\\ \n    type##4 res = make_##type##4(0, 0, 0, 0);\\ \n    if (((idx + 1) << 2)  <= sizeInTypeUnits)\\ \n    res = source[idx];\\ \n    else\\ \n    {\\ \n    if ((idx << 2) < sizeInTypeUnits) res.x = source[idx].x;\\ \n    if ((idx << 2) + 1 < sizeInTypeUnits) res.y = source[idx].y;\\ \n    if ((idx << 2) + 2 < sizeInTypeUnits) res.z = source[idx].z;\\ \n    }\\ \n    return res;\\ \n} \n \n#define DEFINE_SAFE_STORE_4(type)\\ \n    void safe_store_##type##4(type##4 val, __global type##4* dest, uint idx, uint sizeInTypeUnits)\\ \n{\\ \n    if ((idx + 1) * 4  <= sizeInTypeUnits)\\ \n    dest[idx] = val;\\ \n    else\\ \n    {\\ \n    if (idx*4 < sizeInTypeUnits) dest[idx].x = val.x;\\ \n    if (idx*4 + 1 < sizeInTypeUnits) dest[idx].y = val.y;\\ \n    if (idx*4 + 2 < sizeInTypeUnits) dest[idx].z = val.z;\\ \n    }\\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE(type)\\ \n    void group_scan_exclusive_##type(int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (localId == 0)\\ \n    shmem[groupSize - 1] = 0;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_SUM(type)\\ \n    void group_scan_exclusive_sum_##type(int localId, int groupSize, __local type* shmem, type* sum)\\ \n{\\ \n    for (int stride = 1; stride
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \n INCLUDES \n **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_f
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_floa
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \ntypedef struct \n{ \n    float3 pmin; \n    float3 pmax; \n} bbox; \n \n// The following two functions are from \n// http://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/ \n// Expands a 10-bit integer into 30 bits \n// by inserting 2 zeros after each bit. \nstatic unsigned int ExpandBits(unsigned int v) \n{ \n    v = (v * 0x00010001u) & 0xFF0000FFu; \n    v = (v * 0x00000101u) & 0x0F00F00Fu; \n    v = (v * 0x00000011u) & 0xC30C30C3u; \n    v = (v * 0x00000005u) & 0x49249249u; \n    return v; \n} \n \n// Calculates a 30-bit Morton code for the \n// given 3D point located within the unit cube [0,1]. \nunsigned int CalculateMortonCode(float3 p) \n{ \n    float x = min(max(p.x * 1024.0f, 0.0f), 1023.0f); \n    float y = min(max(p.y * 1024.0f, 0.0f), 1023.0f); \n    float z = min(max(p.z * 1024.0f, 0.0f), 1023.0f); \n    unsigned int xx = ExpandBits((unsigned int)x); \n    unsigned int yy = ExpandBits((unsigned int)y); \n    unsigned int zz = ExpandBits((unsigned int)z); \n    return xx * 4 + yy * 2 + zz; \n} \n \n// Assign Morton codes to each of positions \n__kernel void CalcMortonCode( \n    // Centers of primitive bounding boxes \n    __global bbox const* bounds, \n    // Number of primitives \n    int numpositions, \n    // Morton codes \n    __global int* mortoncodes \n    ) \n{ \n    int globalid = get_global_id(0); \n \n    if (globalid < numpositions) \n    { \n        bbox bound = bounds[globalid]; \n        float3 center = 0.5f * (bound.pmax + bound.pmin); \n        mortoncodes[globalid] = CalculateMortonCode(center); \n    } \n} \n \n \nbbox bboxunion(bbox b1, bbox b2) \n{ \n    bbox res; \n    res.pmin = min(b1.pmin, b2.pmin); \n    res.pmax = max(b1.pmax, b2.pmax); \n    return res; \n} \n \ntypedef struct \n{ \n        int parent; \n        int left; \n        int right; \n        int next; \n} HlbvhNode; \n \n#define LEAFIDX(i) ((numprims-1) + i) \n#define NODEIDX(i) (i) \n \n// Calculates longest common prefix length of bit representations \n// if  representations are equal we consider sucessive indices \nint delta(__global int* mortoncodes, int numprims, int i1, int i2) \n{ \n    // Select left end \n    int left = min(i1, i2); \n    // Select right end \n    int right = max(i1, i2); \n    // This is to ensure the node breaks if the index is out of bounds \n    if (left < 0 || right >= numprims)  \n    { \n        return -1; \n    } \n    // Fetch Morton codes for both ends \n    int leftcode = mortoncodes[left]; \n    int rightcode = mortoncodes[right]; \n \n    // Special handling of duplicated codes: use their indices as a fallback \n    return leftcode != rightcode ? clz(leftcode ^ rightcode) : (32 + clz(left ^ right)); \n} \n \n// Shortcut for delta evaluation \n#define DELTA(i,j) delta(mortoncodes,numprims,i
nD"PHc
nD8)\bP
nD9Q$t
nEl:c3
nEȾ1l8
nGM;$i
nG۽-F0
nH9G\btsH
nH;A\bu
nH;Q\bu
nH;Q\bu\rL
nHL+n@H
nHȻ=59
nI7;7W
nIr;15\e<[g
nJ:A+5
nJ|;6v5
nK7:v8
nL!PLc
nL\fPLc
nMKL INTERNAL ERROR: message buffer overflow
nMcL$lM
nNANאB
nNq:RuY
nO;HbK
nO<u\a\e
nO}R7V
nOƼ!b\r
nP-<9
nP_=bw
nQ :oV
nR#;4
nR;SdH
nS:](1;m2
nS;GP
nSa=d
nS|;1
nT9Aq̼H
nThreads
nUp<J
nV5> 8
nV;\e\e
nVl<TJG
nVǺciºD
nW:n$Z;K5J
nW\a;O
nWashington1
nX;O냻R
nXY8Ŋ\\a8łXY
nY<*y1
nYD\alġ*Y
nZ<vSk
nZ`<3g
n[:O9d
n\\8z
n\\q łX
n\a9SB;:9
n\a\a;A\e
n\abA|H
n\ay<{c
n\b:A枻y
n\b=jv8
n\bJ<I
n\bY\f*H
n\bf\fn\n
n\e>BJb
n\e\n=U|O
n\es=]T
n\fּI
n\n// The following code is from the Radeon Rays / Baikal GitHub repository. It can be found at:\n//      https://github.com/GPUOpen-LibrariesAndSDKs/RadeonProRender-Baikal/blob/master/Baikal/Kernels/CL/sampling.cl\n\ntypedef struct RNG_t\n{\n    uint    value;\n} RNG;\n\nuint wangHash(uint seed)\n{\n    seed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nuint randUint(local RNG* rng)\n{\n    rng->value = wangHash(1664525U * rng->value + 1013904223U);\n    return rng->value;\n}\n\nfloat randFloat(local RNG* rng)\n{\n    return ((float)randUint(rng)) / 0xffffffffU;\n}\n\nvoid initRNG(uint seed, local RNG* rng)\n{\n    rng->value = wangHash(seed);\n}\n\nfloat2 uniformRandom2d(local RNG* rng)\n{\n    return (float2) (randFloat(rng), randFloat(rng));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Directivity\n// --------------------------------------------------------------------------------------------------------------------\n\n// NOTE: Custom directivity callbacks are not supported at this time.\ntypedef struct __attribute__((packed)) Directivity_t\n{\n    float dipoleWeight;\n    float dipolePower;\n} Directivity;\n\nfloat evaluateDirectivity(float3 point,\n                          CoordinateSpace coordinates,\n                          Directivity directivity)\n{\n    float3 worldSpaceDirection = normalize(point - coordinates.origin);\n    float3 localSpaceDirection = transformWorldToLocal(coordinates, worldSpaceDirection);\n\n    float cosine = -localSpaceDirection.z;\n    return pow(fabs((1.0f - directivity.dipoleWeight) + directivity.dipoleWeight * cosine), directivity.dipolePower);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Material\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) Material_t\n{\n    float  absorptionLow;\n    float  absorptionMid;\n    float  absorptionHigh;\n    float  scattering;\n    float  transmissionLow;\n    float  transmissionMid;\n    float  transmissionHigh;\n} Material;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Radeon Rays Helpers\n// --------------------------------------------------------------------------------------------------------------------\n\n// This must exactly match the ray data structure (struct ray) used by Radeon Rays.\ntypedef struct Ray_t\n{\n    float4  o;\n    float4  d;\n    int2    extra;\n    int2    padding;\n} Ray;\n\n// This must exactly match the hit data structure (struct Intersection) used by Radeon Rays.\ntypedef struct Hit_t\n{\n    int       shapeid;\n    int       primid;\n    int       padding0;\n    int       padding1;\n    float4    uvwt;\n} Hit;\n\n// --------------------------------------------------------------------------------------------------------------------\n// IIR Filtering\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct IIR_t\n{\n    float a1, a2;\n    float b0, b1, b2;\n} IIR;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void generateCameraRays(global CoordinateSpace* camera,\n                               global Ray* rays)\n{\n    uint width = get_global_size(0);\n    uint height = get_global_size(1);\n    uint u = get_global_id(0);\n    uint v = get_global_id(1);\n    uint index = v * width + u;\n\n    float du = ((u / (float) width) - 0.5f) * 2.0f;\n    float dv = ((v / (float) height) - 0.5f) * 2.0f;\n\n    rays[in
n\n<L6
n\n\f
n\nbq|H
n\nҼR
n\rba|H
n\t$;AW
n\t;ud
n\tbQ|H
n\v>c
n\vR<q
n\vb<c\e
n]8-Qz
n]s9P
n]ͺX0
n^r;R4
n`q<D9Q
na\e>i
nan(ind
nan(snan
naۼyt
nb!\fHY
nb!|H
nb\a<\n
nbaL X
nba~\b
nbb}XB
nbq,HY
nbu;T
nc:\ba
nc<\e"7
ncd>0
ncڼY\a
nd'<T\f
nd1;,A
nd8<D1
ndC;D
ndN9^5
nda:h\b
ne::v
ne;=wgU
need dictionary
network down
network reset
network unreachable
new-zealand
newNumThreads
newmtl material_%d\n
nextafter
nfA9\tt\tI
nfA>MI\f
nfe;h
nfffff
ng:2p5
ngN;1
ngf>ZL
ngo<E
nh0;7F
nh;R\b
nh;xl
nh<Spz
nhԼwc
ni#<v\a
ni&<5
ni/=4M
niø>2i
niۺ\e
nj;\rIe9
nj\bT\nf\b
nk;\b$d
nkB;z
nm9C1
nmȻ/n
nn=<AI
nnu;Sl
no buffer space
no child process
no link
no lock available
no message
no message available
no multiple minimum degree on the separator nodes
no protocol option
no space on device
no stream resources
no such device
no such device or address
no such file or directory
no such process
no9yaa
no:%\nO<dA
no;\t
no;o3\e
noJ;1
node.isAlignedNode
nodes
norwegian
norwegian-bokmal
norwegian-nynorsk
not a directory
not a socket
not a stream
not all buffers are unmapped
not be equal to 0.0 at this stage. Either the user had to stop the method as it
not connected
not enough memory
not stopped when it found the solution. The solution may be wrong
not supported
not supported node type in bvh_statistics
not:݊n
npA<0
npJ:4
np\t0\bP
np\t`\b0
np\t`\bP
npɺL+\e
nq:\bx0
nqS<r
nr7;T
nr;r$\a
nr<UV
nre;X,K
ns<\r
nt$\bfG
nt91b\f:뜈94
nt=Ac
ntdll.dll
ntel3L$0\txineI3D$,1
ntel3T$0\t¸ineI3D$,1
nu>mo
num <= maxLeafBlocks
num >= 1
numChannels
numMisplacedItemsLeft == numMisplacedItemsRight
numOctantRays
numOctantRays <= 32
numOctantRays <= MAX_INTERNAL_STREAM_SIZE
numSamples
numTimeSteps > 1
number of columns for each panel: %d
number of columns for each panel: %lli
number of equations:           %d
number of equations:           %lli
number of independent subgraphs:  %d
number of independent subgraphs:  %lli
number of iterations is equal to IPAR(5)-IPAR(4
number of non-zeros in A (%%): %f
number of non-zeros in A:      %d
number of non-zeros in A:      %lli
number of non-zeros in L+U:              %d
number of non-zeros in L+U:              %lli
number of non-zeros in L:                %d
number of non-zeros in L:                %lli
number of non-zeros in U:                %d
number of non-zeros in U:                %lli
number of right-hand sides:    %d
number of right-hand sides:    %lli
number of supernodes:                    %d
number of supernodes:                    %lli
nv?:Fx
nvdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    float3 invdirtop = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    // We need to keep original ray around for returns from bottom hierarchy \n    ray topray = *r; \n \n    // Fetch top level BVH index \n    int idx = scenedata->rootidx; \n    // -1 indicates we are traversing top level \n    int topidx = -1; \n    // Current shape id \n    int shapeid = -1; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, isect->uvwt.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                // or containing another BVH (top level hierarhcy) \n                if (topidx != -1) \n                { \n                    // This is bottom level, so intersect with a primitives \n                    if (IntersectLeafClosest(scenedata, &node, r, isect)) \n                    { \n                        // Adjust shapeid as it might be instance \n                        isect->shapeid = shapeid; \n                    } \n \n                    // And goto next node \n                    idx = (int)(node.pmax.w); \n                } \n                else \n                { \n                    // This is top level hierarchy leaf \n                    // Save top node index for return \n                    topidx = idx; \n                    // Get shape descrition struct index \n                    int shapeidx = SHAPEIDX(node); \n                    // Get shape mask \n                    int shapemask = scenedata->shapedata[shapeidx].mask; \n                    // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                    // otherwise skip the subtree \n                    if (Ray_GetMask(r) && shapemask) \n                    { \n                        // Fetch bottom level BVH index \n                        idx = scenedata->shapedata[shapeidx].bvhidx; \n                        shapeid = scenedata->shapedata[shapeidx].id; \n \n                        // Fetch BVH transform \n                        float4 wmi0 = scenedata->shapedata[shapeidx].m0; \n                        float4 wmi1 = scenedata->shapedata[shapeidx].m1; \n                        float4 wmi2 = scenedata->shapedata[shapeidx].m2; \n                        float4 wmi3 = scenedata->shapedata[shapeidx].m3; \n \n                        // Apply linear motion blur (world coordinates) \n                        //float4 lmv = scenedata->shapedata[shapeidx].linearvelocity; \n                        //float4 amv = scenedata->shapedata[SHAPEDATAIDX(node)].angularvelocity; \n                        //r->o.xyz -= (lmv.xyz*r->d.w); \n                        // Transfrom the ray \n                        *r = transform_ray(*r, wmi0, wmi1, wmi2, wmi3); \n                        // rotate_ray(r, amv); \n                        // Recalc invdir \n                        invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n                        // And continue traversal of the bottom level BVH \n                        continue; \n                    } \n                    else \n                    { \n                        idx = -1; \n                    } \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                // This is an internal node, proceed to left child (it is at current + 1 index) \n                idx = idx + 1; \n            } \n        } \n        else \n        { \n            // We missed the node, goto next one \n            idx = (int)(node.pmax.w); \n        } \n \n        // Here check if we ended up traversing bottom level BVH \n        // in this case idx = -1 and topidx has valid value \n        if (idx == -1 && topidx != -1) \n        { \n            //  Proceed to next top level node \n            idx = (int)(scenedata->nodes[topi
nv}:gn
nv¼\f6
nx:V"3
nxm;n
nzW;soi
nzԉY9
n{;DX
n|4\bfG
n½<FM
nĻljs9
nƉ;8XB
nɍ\f8fD
nʈL$Wba
n˺Zu3
n̼myƼN
nϬ;DD
nӽoZ\r
nֺ]Gc;oq
nۺc{k
nܺ#9Z8\rx
nߋ:qZk
nDkt
o ;^Y
o!:5V
o"I=q
o"j=9
o#r;5C
o%{IiO
o&;Ts\n9
o):8tR\e
o-q=3j
o0;\acL;&1
o0ŰXUp
o1H:\r
o2;ht7
o2R<e
o4;"Q\r
o5\nun
o5{5Q
o7:n>L:F
o8%;n
o9?PI
o9JBD
o9YL軧w
o9\nAܹᆆ9
o9vI!9
o:!ＺU5p
o:=ds
o:CD0
o:Md\n:0
o:cPO
o:ˊV9T
o;0>r
o;7 X9
o;A;k
o;So4
o;a\a_:Hrb
o;n2;F2r;P
o;u ѺR
o;xXq
o<D<c
o<g~1
o<m7¼S
o<}ug
o=;UT
o=\e 2=QO
o=v\e
o>3j\r?\f
o>p-I
o@e:z4
oAJ;o
oB);B
oB)>z
oB<P\b
oC;@cB
oD$\bfD
oD$`fE
oD>Kg
oEb;CK
oHL+o@H
oHL+o@I
oI\\$Hf
oJ;I\am;8
oK.;\vN
oL$ fD
oL$0fD
oL$`fD
oL$pfD
oM̹r0
oO\vbQ
oO{Jw
oQ <]\b
oQ;Bs
oR<X\b
oRۼƿc
oSüoV
oT$ fD
oT$PfD
oT$`fD
oT<cQ˼Ի\t
oV<o6o
oW\v<kD
oZs=s_d
o\\$PfA
o\\$PfD
o\\$pfD
o\e;L
o\f;H
o\f;Wtv8
o\r >w
o\r* C
o\r2|Q
o\rIfR
o\rK@4
o\r[iA
o\r\e*4
o\rbIp
o\ri=o
o\rrNQ
o\r|p6
o\t>j
o\t\r
o\te:xD
o\tĺ\fZ
o]X:C
o`U<R
ob!?K
object
objectID < builders.size() && builders[objectID] == nullptr
objectID < objects.size () && objects[objectID] == nullptr
object_accel
object_accel_max_leaf_size
object_accel_mb
object_accel_mb_max_leaf_size
object_accel_mb_min_leaf_size
object_accel_min_leaf_size
object_builder
object_builder_mb
obq\fHY
octantID < 8
oc̻P[b
od ;S
od$0fD
od$@fD
od$PfD
od$`fD
oe);h
oe;\a{H
of iterations is equal to IPAR(5)-IPAR(4
of the matrix is negative or zero
ofܺ\n
og 9P
oiκHT
oj<WD
oj>OP
oj?;78
ol$ fD
ol$0fD
ol$PfD
ol$`fA
ol$pfD
ole32.dll
omni callsig
onst float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n \n \n \n#define STARTIDX(x)     (((int)(x->pmin.w))) \n#define SHAPEIDX(x)     (((int)(x.pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n \ntypedef struct \n{ \n    // BVH structure \n    __global BvhNode*       nodes; \n    // Scene positional data \n    __global float3*        vertices; \n    // Scene indices \n    __global Face*          faces; \n    // Transforms \n    __global ShapeData*     shapedata; \n    // Root BVH idx \n    int rootidx; \n} SceneData; \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nbool IntersectLeafClosest( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n    if (IntersectTriangle(r, v1, v2, v3, isect)) \n    { \n        isect->primid = face.id; \n        return true; \n    } \n \n    return false; \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r                      // ray to instersect \n) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n    if (IntersectTriangleP(r, v1, v2, v3)) \n    { \n        return true; \n    } \n \n    return false; \n} \n \n \n// intersect Ray against the whole BVH2L structure \nbool IntersectSceneClosest2L(SceneData* scenedata, ray* r, Intersection* isect) \n{ \n    // Init intersection \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    // Precompute invdir for bbox testing \n    float3 i
onst float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n#define STARTIDX(x)     (((int)((x).pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n#define SHORT_STACK_SIZE 16 \n \n \ntypedef struct \n{ \n    bbox lbound; \n    bbox rbound; \n} FatBvhNode; \n \ntypedef struct \n{ \n    // BVH structure \n    __global FatBvhNode const*     nodes; \n    // Scene positional data \n    __global float3 const*         vertices; \n    // Scene indices \n    __global Face const*         faces; \n    // Shape IDs \n    __global ShapeData const*     shapes; \n    // Extra data \n    __global int const*             extra; \n} SceneData; \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nvoid IntersectLeafClosest( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n        } \n    } \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return f
ontext
ooc_cfg_file_name  got by Env=%s
ooc_cfg_path       got by Env=%s
ooc_keep_file      got by Env=%d
ooc_keep_file     got from config file=%d
ooc_max_core_size  got by Env=%d
ooc_max_core_size got from config file=%d
ooc_max_swap_size got by Env=%d
ooc_max_swap_size got by Env=%lli
ooc_max_swap_size got from config file=%d
ooc_path           got by Env=%s
ooc_path          got from config file=%s
ook:e
ooq:w
operation canceled
operation in progress
operation not permitted
operation not supported
operation not supported for this geometry
operation would block
operator
operator co_await
or criterion is very restrictive. CG method has been stopped
or the parameter DPAR(1) was altered by mistake outside of
or the parameter IPAR(1)=%s was altered by mistake outside of the
or the parameter SPAR(1) was altered by mistake outside of
or the parameter dpar[0] was altered by mistake outside of
or the parameter ipar[0]=%s was altered by mistake outside of the
or the parameter spar[0] was altered by mistake outside of
or>P>M
os<`M
ot$ fD
ot$@fD
ot$`fD
ot:Kh
ou;d%w
out of memory
out->data
out->data[iChannel][out->numSamples - 1
out->numChannels
out->numSamples
outType
outlen == newN
outputs
outputs->direct)->airAbsorption[iBand
outputs->direct)->directivity
outputs->direct)->distanceAttenuation
outputs->direct)->flags
outputs->direct)->occlusion
outputs->direct)->transmissionType
outputs->direct)->transmission[iBand
outputs->pathing
outputs->pathing)->binaural
outputs->pathing)->eqCoeffs[iBand
outputs->pathing)->hrtf
outputs->pathing)->listener.ahead.x
outputs->pathing)->listener.ahead.y
outputs->pathing)->listener.ahead.z
outputs->pathing)->listener.origin.x
outputs->pathing)->listener.origin.y
outputs->pathing)->listener.origin.z
outputs->pathing)->listener.right.x
outputs->pathing)->listener.right.y
outputs->pathing)->listener.right.z
outputs->pathing)->listener.up.x
outputs->pathing)->listener.up.y
outputs->pathing)->listener.up.z
outputs->pathing)->order
outputs->pathing)->shCoeffs[iCoeff
outputs->reflections
outputs->reflections)->delay
outputs->reflections)->eq[iBand
outputs->reflections)->ir
outputs->reflections)->irSize
outputs->reflections)->numChannels
outputs->reflections)->reverbTimes[iBand
outputs->reflections)->tanDevice
outputs->reflections)->tanSlot
outputs->reflections)->type
outside of the routine, or the wrong value was assigned to the parameter 'np
outside of the routine, or the wrong value was assigned to the parameter 'nt
outside of the routine, or the wrong value was assigned to the parameter 'nx
outside of the routine, or the wrong value was assigned to the parameter 'ny
outside of the routine, or the wrong value was assigned to the parameter 'nz
ov<v\e1
ovһwB
ow\nbQ
owner dead
owq:Bsb
owʹ12
oxp;O
oy[:Q
oz:Ŷ%;nUr
o|$0fD
o|$PfD
o|:zJC
o~7:95\b
oÍ9ChM
oƺ<t\tv
o˼rә=wqb
oߏ;2Wf
p UWATAVAWH
p UWAVH
p WATAUAVAWH
p WAVAWH
p }8GQ
p!u;w;K
p"<C1
p&7]u
p&Ϻz\vƺ5u
p,m;\eQF
p/C<Dn
p0R^G
p1X>{C
p3L:B
p3ֹVBR
p4+<4
p7M}f
p7N<Bw
p7ǹzRa
p8H:d
p8W+B
p8^|S
p8墀9}\eT8
p9OBc
p9ݘX:2
p:4ߗ8z
p:KF\v
p:\vH\a
p:r\t
p:Ͳ7;9O
p:зٺ]Wr9L
p;5\b6
p;5qm
p;=AH
p;FpR
p;LFS
p;_8C
p;e8i
p<Q=7
p<W:sbI
p<\ba
p<gX\a
p=BAr
p=L\b
p=eaj
p=yO1
p>8MdF
p?<Ap
p?\b\tq?W
p@ݼoI
pA:sE
pA_A^A
pA_A^A]A
pC:\e
pD;#O
pDf;~I
pF<h:d
pG9;Dw
pGA:CH
pH+A0L
pHH+p
pHI+p@A
pHL+p@3
pK\e;E
pL;L$x
pL;d$xL
pL;t$HH
pMٹ2qh
pOE=e
pOߺthM
pS;뮀66
pT$PNf
pT\rA.q
pT|\a
pU\v;j
pVֺ\t'F
pW\v=Z
pXD\v
pYE Š\\M
pYE0Š\\MP
pYEPŠ\\Mp
pY_PŰY
p[:I54
p\aIB
p\abA
p\aj;{s
p\b<I\v
p\bH+0H
p\f<TyQ
p\n|屮uO
p\r6;,E
p\r`\f0\vP
p\r`\f0\vP!l
p\r`\f0\vP!s
p\r`\f0\vP!t
p\r`\fP
p\r`\fP!j
p\r`\fP\v0
p\rk<\t
p\t:lϏ9
p\t<lt)<8
p\tL<dd\a
p\v";LG
p]:ql
p]A_A
p]A_A^A
p^<DGn
pa; V
pa;CT
pa;\f\e5
parameter 'BCTYPE' was not in the admissible range {D,N,P} during initialization stage
parameter 'BCtype' was not in the admissible range {D,N,P} during initialization stage
parameter DPAR(1)=%e. The sine transform may be unsuitable for
parameter DPAR(1)=%e. The staggered cosine transform may be
parameter DPAR(1)=%e. The staggered sine transform may be
parameter SPAR(1)=%e. The SINE TRANSFORM may be unsuitable for
parameter SPAR(1)=%e. The sine transform may be unsuitable for
parameter SPAR(1)=%e. The staggered cosine transform may be
parameter SPAR(1)=%e. The staggered sine transform may be
parameter dpar[0]=%e. The sine transform may be unsuitable for
parameter dpar[0]=%e. The staggered cosine transform may be
parameter dpar[0]=%e. The staggered sine transform may be
parameter number %4i had an illegal value
parameter spar[0]=%e. The sine transform may be unsuitable for
parameter spar[0]=%e. The staggered cosine transform may be
parameter spar[0]=%e. The staggered sine transform may be
params
params->airAbsorption[iBand
params->bakeBatchSize
params->bakeFlags
params->binaural
params->delay
params->direction.x
params->direction.y
params->direction.z
params->directivity
params->distanceAttenuation
params->eqCoeffs[iBand
params->eq[iBand
params->flags
params->height
params->hrtf
params->identifier.endpointInfluence.center.x
params->identifier.endpointInfluence.center.y
params->identifier.endpointInfluence.center.z
params->identifier.endpointInfluence.radius
params->identifier.type
params->identifier.variation
params->interpolation
params->ir
params->irSize
params->irradianceMinDistance
params->listener.ahead.x
params->listener.ahead.y
params->listener.ahead.z
params->listener.origin.x
params->listener.origin.y
params->listener.origin.z
params->listener.right.x
params->listener.right.y
params->listener.right.z
params->listener.up.x
params->listener.up.y
params->listener.up.z
params->numBounces
params->numChannels
params->numDiffuseSamples
params->numRays
params->numSamples
params->numThreads
params->occlusion
params->openCLDevice
params->order
params->orientation.ahead.x
params->orientation.ahead.y
params->orientation.ahead.z
params->orientation.origin.x
params->orientation.origin.y
params->orientation.origin.z
params->orientation.right.x
params->orientation.right.y
params->orientation.right.z
params->orientation.up.x
params->orientation.up.y
params->orientation.up.z
params->pathRange
params->probeBatch
params->radeonRaysDevice
params->radius
params->rayBatchSize
params->reverbTimes[iBand
params->savedDuration
params->scene
params->sceneType
params->shCoeffs[iCoeff
params->simulatedDuration
params->spacing
params->spatialBlend
params->tanDevice
params->tanSlot
params->threshold
params->transform.elements[iRow][iColumn
params->transmissionType
params->transmission[iBand
params->type
params->visRange
pardiso_read_ooc_file: Fseek error
pardiso_read_ooc_file: Read error
pardiso_write_ooc_file: Write error
pardiso_write_ooc_file: nfirst is EOF
pascal
paλ-h
pbndkb
pb{>m
pc=i9
pclmul
pconfig
pd^=R
pdata
pe##4* out_array, uint numElems, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    shmem[localId] = v1.x + v1.y + v1.z + v1.w + v2.x + v2.y + v2.z + v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    type offset = shmem[localId];\\ \n    type t = v1.x; v1.x = offset; offset += t;\\ \n    t = v1.y; v1.y = offset; offset += t;\\ \n    t = v1.z; v1.z = offset; offset += t;\\ \n    t = v1.w; v1.w = offset; offset += t;\\ \n    t = v2.x; v2.x = offset; offset += t;\\ \n    t = v2.y; v2.y = offset; offset += t;\\ \n    t = v2.z; v2.z = offset; offset += t;\\ \n    v2.w = offset;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_PART_4(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_part_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __global type* out_sums, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupId   = get_group_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\\ \n    v2.w += v1.w;\\ \n    shmem[localId] = v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    type sum = group_scan_exclusive_part_##type(localId, groupSize, shmem);\\ \n    if (localId == 0) out_sums[groupId] = sum;\\ \n    v2.w = shmem[localId];\\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_GROUP_REDUCE(type)\\ \n    void group_reduce_##type(int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n#define DEFINE_DISTRIBUTE_PART_SUM_4(type)\\ \n    __kernel void distribute_part_sum_##type##4( __global type* in_sums, __global type##4* inout_array, uint numElems)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int groupId   = get_group_id(0);\\ \n    type##4 v1 = safe_load_##type##4(inout_array, globalId, numElems);\\ \n    type    sum = in_sums[groupId >> 1];\\ \n    v1.xyzw += sum;\\ \n    safe_store_##type##4(v1, inout_array, globalId, numElems);\\ \n} \n \n \n// These are already defined in Apple OCL runtime \n#ifndef APPLE \nDEFINE_MAKE_4(int) \nDEFINE_MAKE_4(float) \n#endif \n \nDEFINE_SAFE_LOAD_4(int) \nDEFINE_SAFE_LOAD_4(float) \n \nDEFINE_SAFE_STORE_4(int) \nDEFINE_SAFE_STORE_4(float) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE(uint) \nDEFINE_GROUP_SCAN_EXCLUSIVE(float) \nDEFINE_GROUP_SCAN_EXCLUSIVE(short) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_SUM(uint) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(float) \n \nDEFINE_SCAN_EXCLUSIVE(int) \nDEFINE_SCAN_EXCLUSIVE(float) \n \nDEFINE_SCAN_EXCLUSIVE_4(int) \nDEFINE_SCAN_EXCLUSIVE_4(float) \n \nDEFINE_SCAN_EXCLUSIVE_PART_4(int) \nDEFINE_SCAN_EXCLU
pej;0
performance impact. Please enable these modes for each application
permission denied
pf:6K
pf<^n
pffffff
pgL:vt
pg\n?pg\n
pgݻDv
ph:t4-;c
phonon.dll
phonon_itest.exe
phonon_perf.exe
phonon_test.exe
piٻCb\t
pk9e\\V
pk;{ZR
pl':U!y:JW
placement delete closure
placement delete[] closure
pmg;xz?9}\a
pn9II0:SfR9Z
pn<dó<H
pn>6ނB
poh=qO
popcnt
portuguese-brazilian
pp9* \n
pp;0E
pr china
pr-china
prefetchi
preordering failed (matrix types 11, 13 only
previous iteration. The solution may be wrong
prim.lower.a & 0xFF000000) == 0
primID
primitives
probe.center.x
probe.center.y
probe.center.z
probe.radius
probeArray
probeBatch
problems with opening OOC temporary files
profilerContext
program name unknown
progress monitor forced termination
protocol error
protocol not supported
provided geometry ID already assigned to a geometry
ptr & (size_t)align_mask) == 0
ptr64
ptwrite
puerto-rico
pv<gX
pw8;;\v
pw<dqs
pz9<\nT
pz<\ta
p{h2Һi
p}Dsubdivpatch1
pňX}P
pƻ8XN
pǄ:5j
p˔;yS
pͼ#BмKg\b
pΥ<03
pф;e6M
pӅ=T\nM
pԡ9j3
pؼWl9
q bR%H6
q!:F A:3
q!; s7
q!L$0
q!L$P0H
q!L$p
q!\f8
q!\f9
q!c;BF
q"L P
q"L"P
q#>;Wqc
q'h96
q)9wa
q*;0X
q+:3MyX+z8
q+۽Rzt
q0Ȼi(j
q1<k\r
q2';m26:D2J
q35;bK
q3h;r
q5-;fW
q8,PF
q8\aX
q8ŒXa
q9:w8;;Q
q9<l'\r
q9d>W9
q:5Cߺ\ewt
q:9I\t;8V
q:Rj\r;Gt5
q:Y\f
q:d/κQsW
q;0Tz
q;39\a
q;R>b
q;Tl\f
q;WkE
q;h1v
q;i\eP
q<TJ"=k4
q=.Ca
q=Ҳ9>BF
q?V<b
qB9/^o
qB>kjg
qBǻtOA
qCm=>\av
qGL="l~=M\f3
qGS9w?z
qH=}c
qJ;\e
qJ<W%A
qJT$pp
qJT$ppH
qMX:Jj
qP:eAлz
qQQ:*5ʺa
qRG;Q
qS>g?h3
qTŊ\\I4
qTŢ\\I4
qU~;e
qW$;\eJg
qX=˱j
qX\a;Zu
qZ:aߺ9m
qZ;"9M;l
q[ݹWvɺa
q\a;Le
q\b7;(wV
q\b;6RֺF
q\b;j
q\bL+1H
q\bba~\b
q\e\e
q\nba|H
q\rչt
q\t;e7r
q\t\a=Ezz
q\tba~\b
q\vba~\b
q`k:c
qb!}Hp$ٱbA
qbvh4.triangle4i
qbvh8.triangle4
qbvh8.triangle4i
qbڻŤl9
qe-<L}g
qeB<FAE
qffff
qg<s%w
qgY=EG
qgw=(\a\t
qiT;B
qiX:S
qj/9;E
qj:axY9l
qjļDw
qot:׀X
qp2:R
qt5<-r
quad4i
quad4v
quad_accel
quad_accel_mb
quad_builder
quad_builder_mb
quad_traverser
quad_traverser_mb
quads
quantizedNodes
quz-BO
quz-EC
quz-PE
quz-bo
quz-ec
quz-pe
qw+=k5R
qxs?qxs
qxs?qxs?qxs?qxs?qxs?qxs
qyb:O2
q{3摻T
qƷ;coM
qǺu!w
qȽJ30
qںOKm:t
r %:Aj
r";Xb
r#=lRr
r$>9L
r%:y6
r'<Ms
r'=dB
r'X9|b
r'j=Zf
r(H=ja
r(T;Fh
r)7<'H9
r);DBX
r*:v5
r+w2L
r,2:n
r.'>Xft
r.9pR\n
r.size() == 1
r/d=rH
r0 < 8
r0;sƐ9
r0\fP
r0\fp\v`\n
r1 < 8
r130801120000Z
r1;D t
r1<%h
r1ֺB :9
r210429000000Z
r220323000000Z
r220801000000Z
r240926000000Z
r241012000000Z
r250404180119Z0
r271008235959Z0a1\v0\t
r2:bO
r2<u4һq
r2=Iz
r311109235959Z0b1\v0\t
r351125235959Z0B1\v0\t
r360428235959Z0i1\v0\t
r370322235959Z0c1\v0\t
r380115120000Z0b1\v0\t
r3>l`ݽK
r3Ӽ_t
r42:n2F
r5:D/z
r5:zp58z\ff
r6ƻ\t\nĻD
r6ǼHY
r7;&v
r7<}ZԼ}8j
r8,;5
r8\\=rd
r8\v:WO
r8q:Q
r9=)K\v
r9=gD2
r9>Hߺ5
r9IT\v
r9N8y9
r9Rǳ:y
r9mpe;Dk":\b
r9obֺޟm
r9z6;\tQg
r:%h4
r:'X̻yn
r:,Ul
r:Q\a89
r:S(ڻlq
r:Yoa
r:\f;L94
r:eSĺ A
r:gom:fp
r;0 h
r;0=MIA
r;81\t=\t
r;9>\t:R6
r;9D2
r;9Tr
r;:CQ
r;;bIE
r;;쇻05r
r;A\vx;w2
r;C"7
r;E%4
r;FG{8
r;GHM
r;I,w:GoQ:W
r;K%n9
r;N2<v
r;Q\e@9
r;XE]:N
r;\n9V
r;`kD
r;`sD
r;d$c
r;d|d
r;pBL
r;q=t:0s
r;q>Q
r;usb;_i
r;wH@<m
r<25A
r<2wg
r<FO.<X
r<T9a
r<Z^6
r<dKļGB
r<v;f
r="rD=bx
r='DN
r=2uz
r=;3Kh
r=O>m
r=\tSD>\t
r=kB\e
r=on5=D
r=u8\b
r>3;caN
r><7ag
r>KQA>x
r>P\n
r>Rq=>2
r>\fB
r>e4F
r>e\n
r?fQ3
r?ѻTS
r@0:WI
rAwHL
rB;ިL
rB\t0\bp\a
rB\v;v
rC<RE
rCCޱb#UCC
rE\b=6yM
rF 9d
rFV:J
rH :P
rH6;3
rH;~r
rHR=w
rH\e;!A
rJ;\e\n
rK<ldC
rLc]lI
rLg<qr
rM?\t7\a
rMI+\nN
rMe;u
rM»\f"W
rN*;D
rO@brMH
rO|:wv
rPܺr嬻y
rR\\;eV
rSಸCd9
rT%>2
rT1<3e
rUC:ºf;a
rW;(F
rX"<6
rX6:;z
rX;pf
rX<)E
rX[;X
rXy`łY
rXypŚXyt
rXϻ(\nF
rY-fq6
rY;\tbC
rY<}S
rY>P/1
rYI<\bK
rYL<\fXC
rZ2;nvܺt
rZ8>\v
rZ98r
rZ>"n
rZ\a<Yeûk
rZk;\fj
r[k8B
r\\y4łY
r\a(:Kb
r\abbmH
r\b<5
r\b<gAt
r\bSA|X=G
r\b\a>4hl
r\bb"e@6
r\bbA
r\bba|\b
r\bba~\b
r\br><A
r\e\f
r\ebA|\b
r\f;[w6
r\f<(DF
r\fbA
r\fl<\tFU
r\fp\v`\n0
r\n$;T4t8
r\n0\tP\bp\a
r\n;r@5
r\n<\eqǻm0
r\r:NB
r\rbA
r\t9,g0
r\tVr.>T
r\ta<1G
r\ta<؆e
r\tbA
r\tba
r\tba|\b
r\v0\np\t`\b
r\vba|H
r\vw<?hG
r`\f0!V
r`\f0!l
r`\f0\vP
r`\fP\v0
r`j9ϹI
rae:m2R;B
range.size() == 1
ranspose
raoint
ray.tnear >= 0.0f
ray.valid
rayID < MAX_INTERNAL_STREAM_SIZE
rb!4@Yt
rb!\f@Yt
rb,9J
rbA|H
rbQ|H
rb\t0\bp\a
rba$@X
rba~\b
rcalculating laplacian: %.2f
rcp(min_rcp_input)*FLT_LARGE+FLT_LARGE < 0.01f*FLT_MAX
rdata
rdata$T
rdata$r
rdata$voltmd
rdata$zzzdbg
rdseed
re;0w8
reU>\v
read from files: %10.3f Mb
read from files: %d
read from files: %lli
read only file system
read-write problems with the OOC data file
real (including 1 factor): %d
reconstructImpulseResponse
reloc
remove
remove@ThreadPool@TaskScheduler@embree@@QEAAXAEBV?$Ref@UTaskScheduler@embree@@@3@@Z
removeData
removeProbe
removeProbeBatch
removeScheduler@TaskScheduler@embree@@CAXAEBV?$Ref@UTaskScheduler@embree@@@2@@Z
reorder
reordering problem
residual stopping test and the stopping test for the maximal number of
resource deadlock would occur
resource unavailable try again
restrict
result
result out of range
result.center.x
result.center.y
result.center.z
result.radius
result.x
result.y
result.z
resulting from this problem
retain_uncompressed_reverb
rf;2Py
rfJBGo
rfffff
rg<<e
rh.;s
rh\t;<Q
ri/=q
ri4<wb
riP<d3
rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, isect->uvwt.w); \n \n        if (leftleaf) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node.lbound), r, isect); \n        } \n \n        if (rightleaf) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node.rbound), r, isect); \n        } \n \n        if (lefthit > 0.f && righthit > 0.f) \n        { \n            int deferred = -1; \n            if (lefthit > righthit) \n            { \n                idx = (int)node.rbound.pmax.w; \n                deferred = (int)node.lbound.pmax.w;; \n            } \n            else \n            { \n                idx = (int)node.lbound.pmax.w; \n                deferred = (int)node.rbound.pmax.w; \n            } \n \n                    *sptr++ = deferred; \n            continue; \n        } \n        else if (lefthit > 0) \n        { \n            idx = (int)node.lbound.pmax.w; \n            continue; \n        } \n        else if (righthit > 0) \n        { \n            idx = (int)node.rbound.pmax.w; \n            continue; \n        } \n \n                idx = *--sptr; \n    } \n \n    return isect->shapeid >= 0; \n} \n#endif \n \n#ifndef GLOBAL_STACK \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    if (r->o.w < 0.f) \n        return false; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            leftleaf = LEAFNODE(node.lbound); \n            rightleaf = LEAFNODE(node.rbound); \n \n            lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, r->o.w); \n            righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, r->o.w); \n \n            if (leftleaf) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node.lbound), r)) \n                                    return true; \n            } \n \n            if (rightleaf) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node.rbound), r)) \n                                return true; \n            } \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = (int)node.rbound.pmax.w; \n                    deferred = (int)node.lbound.pmax.w;; \n \n                } \n                else \n                { \n                    idx = (int)node.lbound.pmax.w; \n                    deferred = (int)node.rbound.pmax.w; \n                } \n \n                if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                { \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        gsptr[i] = ldsstack[i * 64]; \n                    } \n \n                    gsptr += SHORT_STACK_SIZE; \n                    lsptr = ldsstack + 64; \n                } \n \n                *lsptr = deferred; \n                lsptr += 64; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = (int)node.lbound.pmax.w; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = (int)node.rbound.pmax.w; \n                continue; \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n
rj$:o\b
rj9=Q
rjQ9u3
rk9Bi
rk<<p
rkV<M
rk_;bt
rl7=V
rlԻDJ
rm;8m^9
rmarking potentially diffracting voxels: %.2f
ro:?f
ro:xPG
roU;i
robust
roup_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n} \n \n__kernel void compact_int_1(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output, \n    __global int* out_size) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_group_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n \n    if (global_id == 0) \n    { \n        *out_size = in_address[in_size - 1] + in_predicate[in_size - 1]; \n    } \n} \n \n__kernel void copy(__global int4* in_input, \n    uint  in_size, \n    __global int4* out_output) \n{ \n    int global_id = get_global_id(0); \n    int4 value = safe_load_int4(in_input, global_id, in_size); \n    safe_store_int4(value, out_output, global_id, in_size); \n} \n \n \n#define FLAG(x) (flags[(x)] & 0x1) \n#define FLAG_COMBINED(x) (flags[(x)]) \n#define FLAG_ORIG(x) ((flags[(x)] >> 1) & 0x1) \n \nvoid group_segmented_scan_exclusive_int( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2
routine to work by setting IPAR(7)=0 before the call to this routine
routine to work by setting ipar[6]=0 before the call to this routine
routine was not called. Computations have stopped. The result may be incorrect
routine, or DFGMRES_CHECK routine was not called. The solution may be wrong
routine, or the user had to stop FGMRES method because it had converged
routine, or the wrong values were assigned to parameters 'ap' and 'bp
routine, or the wrong values were assigned to parameters 'at' and 'bt
routine, or the wrong values were assigned to parameters 'ax' and 'bx
routine, or the wrong values were assigned to parameters 'ay' and 'by
routine, or the wrong values were assigned to parameters 'az' and 'bz
routine, or the wrong values were assigned to the parameters 'ap' and 'bp
routine, or the wrong values were assigned to the parameters 'at' and 'bt
routine, or the wrong values were assigned to the parameters 'ax' and 'bx
routine, or the wrong values were assigned to the parameters 'ay' and 'by
routine, or the wrong values were assigned to the parameters 'az' and 'bz
rp;Kv
rp;bB
rp\f0\vP
rp\f0\vP!l
rp\fP!c
rp\f`\v0
rp\f`\v0\nP
rp\f`\vP
rp\f`\vP\n0
rpb<2
rq<NuW
rqp:J
rr:K\r\v
rrA<l
rs\b:B^B;c
rset.ext_end() + left_ext_range_size == set.ext_end
rsrc$01
rsrc$02
rt8lS
rt<1k
rtc$IAA
rtc$IZZ
rtc$TAA
rtc$TZZ
rtcCommit
rtcCommitJoin
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcCommitThread
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcDebug
rtcDebug___avx
rtcDebug___avx2
rtcDebug___sse2
rtcDebug___sse4
rtcDeleteDevice
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_avx
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_avx2
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_sse2
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_sse4
rtcDeleteGeometry
rtcDeleteGeometry cannot get called in static scenes
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcDeleteScene
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcDeviceGetError
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_avx
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_avx2
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_sse2
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_sse4
rtcDeviceGetParameter1i
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_avx
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_avx2
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_sse2
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_sse4
rtcDeviceNewScene
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx2
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse2
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse4
rtcDeviceSetErrorFunction
rtcDeviceSetErrorFunction2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_avx
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_avx2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_sse2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_sse4
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx2
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse2
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse4
rtcDeviceSetMemoryMonitorFunction
rtcDeviceSetMemoryMonitorFunction2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_avx
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_avx2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_sse2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_sse4
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_avx
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_avx2
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_sse2
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_sse4
rtcDeviceSetParameter1i
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unuavx
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unuavx2
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unusse2
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unusse4
rtcDisable
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcEnable
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcExit
rtcExit___avx
rtcExit___avx2
rtcExit___sse2
rtcExit___sse4
rtcGetBounds
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_avx
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_avx2
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_sse2
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_sse4
rtcGetError
rtcGetError___avx
rtcGetError___avx2
rtcGetError___sse2
rtcGetError___sse4
rtcGetLinearBounds
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcGetParameter1i
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_avx
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_avx2
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_sse2
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_sse4
rtcGetUserData
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcInit
rtcInit has to get called before rtcExit
rtcInit___un_3C_Cunt_3E_avx
rtcInit___un_3C_Cunt_3E_avx2
rtcInit___un_3C_Cunt_3E_sse2
rtcInit___un_3C_Cunt_3E_sse4
rtcInterpolate
rtcInterpolate2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse4
rtcInterpolateN
rtcInterpolateN2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse4
rtcIntersect
rtcIntersect and rtcOccluded not enabled
rtcIntersect16
rtcIntersect16 and rtcOccluded16 not enabled
rtcIntersect16 not supported
rtcIntersect16Ex
rtcIntersect16Ex not supported
rtcIntersect1Ex
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcIntersect1M
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse4
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse4
rtcIntersect1Mp
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcIntersect4
rtcIntersect4 and rtcOccluded4 not enabled
rtcIntersect4Ex
rtcIntersect8
rtcIntersect8 and rtcOccluded8 not enabled
rtcIntersect8Ex
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcIntersectN and rtcOccludedN not enabled
rtcIntersectNM
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx2
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse2
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse4
rtcIntersectNp
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx2
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse2
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse4
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx2
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse2
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse4
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcMapBuffer
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcNewBSplineCurveGeometry
rtcNewBSplineCurveGeometry is not supported
rtcNewBSplineCurveGeometry2
rtcNewBSplineHairGeometry
rtcNewBSplineHairGeometry is not supported
rtcNewBSplineHairGeometry2
rtcNewBezierCurveGeometry
rtcNewBezierCurveGeometry is not supported
rtcNewBezierCurveGeometry2
rtcNewBezierHairGeometry
rtcNewBezierHairGeometry is not supported
rtcNewBezierHairGeometry2
rtcNewCurveGeometry
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewDevice
rtcNewDevice___un_3C_Cunt_3E_avx
rtcNewDevice___un_3C_Cunt_3E_avx2
rtcNewDevice___un_3C_Cunt_3E_sse2
rtcNewDevice___un_3C_Cunt_3E_sse4
rtcNewGeometryGroup
rtcNewGeometryInstance
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcNewHairGeometry
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewInstance
rtcNewInstance2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcNewInstance3
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcNewLineSegments
rtcNewLineSegments is not supported
rtcNewLineSegments2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewQuadMesh
rtcNewQuadMesh is not supported
rtcNewQuadMesh2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewScene
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx2
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse2
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse4
rtcNewSubdivisionMesh
rtcNewSubdivisionMesh is not supported
rtcNewSubdivisionMesh2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuavx
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuavx2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunusse2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunusse4
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunuavx
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunuavx2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunusse2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunusse4
rtcNewTriangleMesh
rtcNewTriangleMesh2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewUserGeometry
rtcNewUserGeometry2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcNewUserGeometry3
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuavx
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuavx2
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunusse2
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunusse4
rtcNewUserGeometry4
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcOccluded
rtcOccluded16
rtcOccluded16 not supported
rtcOccluded16Ex
rtcOccluded16Ex not supported
rtcOccluded1Ex
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcOccluded1M
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx2
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse2
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse4
rtcOccluded1Mp
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx2
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse2
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse4
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcOccluded4
rtcOccluded4Ex
rtcOccluded8
rtcOccluded8Ex
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcOccludedNM
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx2
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse2
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse4
rtcOccludedNp
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx2
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse2
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse4
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx2
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse2
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse4
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcSetBoundaryMode
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_avx
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_avx2
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_sse2
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_sse4
rtcSetBoundsFunction
rtcSetBoundsFunction2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_avx
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_avx2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_sse2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_sse4
rtcSetBoundsFunction3
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_avx
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_avx2
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_sse2
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_sse4
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_avx
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_avx2
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_sse2
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_sse4
rtcSetBuffer
rtcSetBuffer2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunuavx
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunuavx2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunusse2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunusse4
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuavx
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuavx2
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunusse2
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunusse4
rtcSetDisplacementFunction
rtcSetDisplacementFunction2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcSetErrorFunction
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx2
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse2
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse4
rtcSetIndexBuffer
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_avx
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_avx2
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_sse2
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_sse4
rtcSetIntersectFunction
rtcSetIntersectFunction16
rtcSetIntersectFunction1Mp
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx2
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse2
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse4
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx2
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse2
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse4
rtcSetIntersectFunction4
rtcSetIntersectFunction8
rtcSetIntersectFunctionN
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx2
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse2
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse4
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx2
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse2
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse4
rtcSetIntersectionFilterFunction
rtcSetIntersectionFilterFunction16
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx2
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse2
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse4
rtcSetIntersectionFilterFunction4
rtcSetIntersectionFilterFunction8
rtcSetIntersectionFilterFunctionN
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx2
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse2
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse4
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx2
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse2
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse4
rtcSetMask
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuuniavx
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuuniavx2
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuunisse2
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuunisse4
rtcSetMemoryMonitorFunction
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_avx
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_avx2
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_sse2
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_sse4
rtcSetOccludedFunction
rtcSetOccludedFunction16
rtcSetOccludedFunction1Mp
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx2
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse2
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse4
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx2
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse2
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse4
rtcSetOccludedFunction4
rtcSetOccludedFunction8
rtcSetOccludedFunctionN
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx2
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse2
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse4
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx2
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse2
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse4
rtcSetOcclusionFilterFunction
rtcSetOcclusionFilterFunction16
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx2
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse2
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse4
rtcSetOcclusionFilterFunction4
rtcSetOcclusionFilterFunction8
rtcSetOcclusionFilterFunctionN
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx2
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse2
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse4
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx2
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse2
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse4
rtcSetParameter1i
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unuavx
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unuavx2
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unusse2
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unusse4
rtcSetProgressMonitorFunction
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_avx
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_avx2
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_sse2
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_sse4
rtcSetSubdivisionMode
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_avx
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_avx2
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_sse2
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_sse4
rtcSetTessellationRate
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfavx
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfavx2
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfsse2
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfsse4
rtcSetTransform
rtcSetTransform2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unuavx
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unuavx2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unusse2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unusse4
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_avx
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_avx2
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_sse2
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_sse4
rtcSetUserData
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_avx
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_avx2
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_sse2
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_sse4
rtcUnmapBuffer
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcUpdate
rtcUpdateBuffer
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
ru6:2
run@Task@TaskScheduler@embree@@QEAAXAEAUThread@23@@Z
rv;Ovg
rw*<y\a
rw5<Rh
rx<]Im
rxt:3
ry \rG
ry6rcI
ry=4Ы=\b7
r}R9N,N
rǼExd
rȺd#4
rȻhf\r
rɋL$PH
rː;Nu
r̻de8;L9\n;U
r̻hiK
rЯ:G8s
rҺEe0
rԼYvI=\f
rػfK\f
rںmY`:ry
rڻX1ĹQ
rݻXt9
rݼ+QӼHh
rދD$0f
rߺF)0
rᇺJ2};S
r辽ICA
r깺\bn
r엺o\b5<\e 8
rY4t
s ;Pr/;G
s WATAUAVAWH
s WAVAWH
s build %s for %s %s
s double precision computation is turned ON
s single precision computation is turned ON
s!< N
s$W<M\b
s%9"Ue
s%O:bLE
s'b;sy
s(D+s0
s)3:l
s,fffff
s0;;O
s0C;yd
s1;ʭ0
s3:?L
s59=p}Խm
s5Ic\aH
s5fE9
s5ͼ\vpi
s6}:g
s6߹PtG
s82٫9v
s: HRTF data contains Ambisonic HRIRs of unsupported order: %d
s: Unsupported HRTF data format version: %d
s: invalid %s: %s = %s
s: solving a Hermitian indefinite system
s: solving a Hermitian positive definite system
s: solving a complex nonsymmetric system
s: solving a complex structurally symmetric system
s: solving a complex symmetric system
s: solving a real nonsymmetric system
s: solving a real structurally symmetric system
s: solving a symmetric indefinite system
s: solving a symmetric positive definite system
s:0xS
s:DYa9
s:Ja)<K
s:qn\r
s:s梺t7
s;3!G
s;7dE
s;8|p
s;^o6
s;rYO<4
s;t\v
s;whk
s<MBs
s<\tk
s<fff
s<pD[<l
s<yln
s<zde
s>P=6z
s>\bE
s@=aa0
sBȻQ8
sEӺHMM
sFȺi0
sFҺ\a
sFں2f
sHH;sHs
sI"9_R\n
sI:59
sI\e;t1
sJ:v6
sJt<9\n
sK:&r
sL:rq
sL;20~<d
sLݺmvH
sM:\e\t
sN:\e
sNL9~\btxH
sP=Ywżi+J
sRA; J
sT`>y1
sUN;y
sV< Mp
sV\t<Ax㻞j
sX-Nk
sXX:*q
sZֻVt
s\a;1i
s\a<Xy
s\eֺn
s\fbq|H
s\n;E
s\nF;R5
s\t>9
s\v8>\t4
s\v@9
s\vD88w
s\vHcҋD
s\v\r=L
s\vba|H
s_<d2
s_forward_trig_transform/s_backward_trig_transform routine
s`3;Y
sa_<z
sah_fast_spatial
sah_presplit
saveOBJ
sc\r;rά;a
scalar deleting destructor
scan_exclusive_int4
scan_exclusive_part_int4
scene got not committed
scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n
scenes do not belong to the same device
segments
selected scene intersector
sequential
serializedObject
set to default value (%i
set.end()+numExtElements<=set.ext_end
set.ext_range_size() > 0
set.has_ext_range
set.object_range.size() > 0
setInputs
setProfilerContext
setScene
setSharedInputs
set_affinity
settings
settings->anyHitCallback
settings->closestHitCallback
settings->data
settings->embreeDevice
settings->flags
settings->fractionCUsForIRUpdate
settings->frameSize
settings->freeCallback
settings->irSize
settings->materialIndices
settings->materialIndices[iTriangle
settings->materials
settings->materials[iMaterial].absorption[iBand
settings->materials[iMaterial].scattering
settings->materials[iMaterial].transmission[iBand
settings->maxDuration
settings->maxNumOcclusionSamples
settings->maxNumRays
settings->maxNumSources
settings->maxOrder
settings->maxSources
settings->numCUsToReserve
settings->numDiffuseSamples
settings->numMaterials
settings->numThreads
settings->numTriangles
settings->numVertices
settings->numVisSamples
settings->openCLDevice
settings->order
settings->radeonRaysDevice
settings->rayBatchSize
settings->reflectionType
settings->requiresTAN
settings->samplingRate
settings->sceneType
settings->simdLevel
settings->subScene
settings->tanDevice
settings->transform.elements[iRow][iColumn
settings->triangles
settings->triangles[iTriangle].indices[iTriangleVertex
settings->type
settings->vertices
settings->vertices[iVertex].x
settings->vertices[iVertex].y
settings->vertices[iVertex].z
sf\n>Y0
sffffff
sg@;m
sh9w3I
sha512
shadeAndBounce
shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n#define LDS_BUG \n \n#ifdef LDS_BUG \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    int stack[STACK_SIZE]; \n    int* ptr = stack; \n \n    *ptr++ = -1; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        if (LEAFNODE(node)) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node), r, isect); \n        } \n        else \n        { \n            lbox = scenedata->bounds[node.left]; \n            rbox = scenedata->bounds[node.right]; \n \n            lefthit = IntersectBoxF(r, invdir, lbox, isect->uvwt.w); \n            righthit = IntersectBoxF(r, invdir, rbox, isect->uvwt.w); \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = node.right; \n                    deferred = node.left; \n                } \n                else \n                { \n                    idx = node.left; \n                    deferred = node.right; \n                } \n \n                *ptr++ = deferred; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = node.left; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = node.right; \n                continue; \n            } \n        } \n \n        idx = *--ptr; \n    } \n \n \n    return isect->shapeid >= 0; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r) \n{ \n    //return false; \n \n    const float3 invdir = native_recip(r->d.xyz); \n \n    //if (get_global_id(0) == 0) \n    //{ \n \n    //} \n \n    int stack[STACK_SIZE]; \n    int* ptr = stack; \n \n    *ptr++ = -1; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    bool hit = false; \n \n    int step = 0; \n    //if (get_global_id(0) == 1) \n        //printf("Starting %d\\n", get_global_id(0) ); \n    while (idx > -1) \n    { \n        //printf("%d", get_global_id(0)); \n        step++; \n        //if (get_global_id(0) == 1) \n        //{ \n            //printf("Node %d %d\\n", idx, step ); \n        //} \n \n        if (step > 10000) \n            return false; \n \n        node = scenedata->nodes[idx]; \n \n        if (LEAFNODE(node)) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node), r)) \n            { \n                hit = true; \n                break; \n            } \n        } \n        else \n        { \n            lbox = scenedata->bounds[node.left]; \n            rbox = scenedata->bounds[node.right]; \n \n            lefthit = IntersectBoxF(r, invdir, lbox, r->o.w); \n            righthit = IntersectBoxF(r, invdir, rbox, r->o.w); \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = node.right; \n                    deferred = node.left; \n                } \n                else \n                { \n                    idx = node.left; \n                    deferred = node.right; \n                } \n \n                *ptr++ = deferred; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = node.left; \n
shared
sharedInputs
sharedInputs->duration
sharedInputs->irradianceMinDistance
sharedInputs->listener.ahead.x
sharedInputs->listener.ahead.y
sharedInputs->listener.ahead.z
sharedInputs->listener.origin.x
sharedInputs->listener.origin.y
sharedInputs->listener.origin.z
sharedInputs->listener.right.x
sharedInputs->listener.right.y
sharedInputs->listener.right.z
sharedInputs->listener.up.x
sharedInputs->listener.up.y
sharedInputs->listener.up.z
sharedInputs->numBounces
sharedInputs->numRays
sharedInputs->order
should be a positive integer. Parameter was probably altered by mistake
should be a positive integer. The parameter was probably altered by mistake
should be an even number. Assign a proper value to parameter 'np
should be an even number. Assign a proper value to parameter 'nt
should be an even number. Assign a proper value to parameter 'nx
should be an even number. Assign a proper value to the parameter 'np
should be an even number. Assign a proper value to the parameter 'nt
should be an even number. Assign a proper value to the parameter 'nx
should be divisible by 4. Assign a proper value to parameter 'nx
should be divisible by 4. Assign a proper value to the parameter 'nx
should be positive. Parameter was probably altered by mistake outside of the
should be positive. The parameter was probably altered by mistake outside of the
should not be equal to 0.0. The FGMRES method may fail to converge
si)<ZO
simulator
size of largest supernode:               %d
size of largest supernode:               %lli
size_t)&data[0]) & (maxAlignment-1)) == 0
size_t)node & align_mask
size_t)tri & align_mask
siںGC
sl;܀F
slotMask
slotMutex[i].isLocked
slovak
sma-NO
sma-SE
sma-no
sma-se
smj-NO
smj-SE
smj-no
smj-se
smn-FI
smn-fi
sms-FI
sms-fi
sn$:p
solve - write&read: %d
solve - write&read: %lli
something wrong with diagonal matrix row %d
something wrong with diagonal matrix row %lli
source
source.ahead.x
source.ahead.y
source.ahead.z
source.origin.x
source.origin.y
source.origin.z
source.right.x
source.right.y
source.right.z
source.up.x
source.up.y
source.up.z
source.x
source.y
source.z
sourcePosition.x
sourcePosition.y
sourcePosition.z
south africa
south korea
south-africa
south-korea
spW;w
spanish-argentina
spanish-bolivia
spanish-chile
spanish-colombia
spanish-costa rica
spanish-dominican republic
spanish-ecuador
spanish-el salvador
spanish-guatemala
spanish-honduras
spanish-mexican
spanish-modern
spanish-nicaragua
spanish-panama
spanish-paraguay
spanish-peru
spanish-puerto rico
spanish-uruguay
spanish-venezuela
sphereOcclusion
spherical
sponse[(batch * numChannels * numBands * numSamples) + (channel * numBands * numSamples) + (band * numSamples)];\n\n\tfloat xm1 = 0.0f;\n\tfloat xm2 = 0.0f;\n\tfloat ym1 = 0.0f;\n\tfloat ym2 = 0.0f;\n\n    global IIR* filter = &filters[band];\n\n    float a1 = filter->a1;\n    float a2 = filter->a2;\n    float b0 = filter->b0;\n    float b1 = filter->b1;\n    float b2 = filter->b2;\n\n\tfor (uint i = 0; i < (numBins * samplesPerBin); i += NUM_WORK_ITEM_SAMPLES)\n    {\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tworkItemSamples[j] = signal[i + j];\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tfloat x = workItemSamples[j];\n\t\t\tfloat y = (b0 * x) + (b1 * xm1) + (b2 * xm2) - (a1 * ym1) - (a2 * ym2);\n\n\t\t\txm2 = xm1;\n\t\t\txm1 = x;\n\t\t\tym2 = ym1;\n\t\t\tym1 = y;\n\n\t\t\tworkItemSamples[j] = y;\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tsignal[i + j] = workItemSamples[j];\n\t\t}\n    }\n}\n\n// todo: linear reconstruction?\nkernel void reconstructImpulseResponse(global int* energy,\n\t\t\t\t\t\t\t\t\t   uint samplingRate,\n                                       uint samplesPerBin,\n\t\t\t\t\t\t\t\t\t   uint numSamples,\n\t\t\t\t\t\t\t\t\t   global float* airAbsorption,\n\t\t\t\t\t\t\t\t\t   global IIR* filters,\n                                       global float* whiteNoise,\n                                       global float* impulseResponse,\n                                       uint offset,\n\t\t\t\t\t\t\t\t\t   float scale)\n{\n    size_t bin = get_global_id(0);\n    size_t band = get_global_id(1);\n    size_t channel = get_global_id(2);\n\tsize_t numBins = get_global_size(0);\n    size_t numBands = get_global_size(1);\n    size_t numChannels = get_global_size(2);\n\n    global float* impulseResponseBin = &impulseResponse[offset + (channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n    global float* whiteNoiseBin = &whiteNoise[(channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n\n    float e0 = (float)energy[0*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n    float e = (float)energy[channel*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n\n    if (fabs(e) < ENERGY_THRESHOLD || fabs(e0) < ENERGY_THRESHOLD)\n    {\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = 0.0f;\n        }\n    }\n    else\n    {\n        float tMean = ((bin + 0.5f) * samplesPerBin) / samplingRate;\n        float tVariance = MIN_VARIANCE;\n\n        int sample = bin * samplesPerBin;\n        float binEnergy = 0.0f;\n\n        float t = sample / (float) samplingRate;\n        float dt = 1.0f / (float) samplingRate;\n\n        float g = exp(-((t - tMean) * (t - tMean)) / (2.0f * tVariance));\n        float dg = exp(-(dt * ((2.0f * (t - tMean)) + dt)) / (2.0f * tVariance));\n        float ddg = exp(-(dt * dt) / tVariance);\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = g * whiteNoiseBin[i];\n            binEnergy += impulseResponseBin[i] * impulseResponseBin[i];\n            g *= dg;\n            dg *= ddg;\n        }\n\n        float normalization = e / sqrt(e0 * sqrt(4.0f * PI));\n\n        normalization *= exp(-0.5f * airAbsorption[band] * SPEED_OF_SOUND * ((bin + 0.5f) * samplesPerBin * (1.0f / samplingRate)));\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] *= normalization;\n        }\n    }\n}\n\nkernel void combineBandpassedImpulseResponse(uint numSamples,\n                                             global float* bandImpulseResponses,\n\t\t\t\t\t\t\t\t\t\t\t global float* impulseResponse)\n{\n    size_t sample = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t batch = get_global_id(2);\n\tsize_t numChannels = get_global_size(1);\n\n\tfloat value = 0.0f;\n\n    for (int i = 0; i < NUM_BANDS; ++i)\n    {\n        value += bandImpulseResponses[(batch * numChannels * NUM_BANDS * numSamples) + (channel * NUM_BAND
sptr_node < stackEnd
sptr_node == stack_node
sptr_node > stack_node
sr-BA-Cyrl
sr-BA-Latn
sr-SP-Cyrl
sr-SP-Latn
sr-ba-cyrl
sr-ba-latn
sr-sp-cyrl
sr-sp-latn
src->data
src->data[iChannel][src->numSamples - 1
src->numChannels
src->numSamples
src[iArray
ssM+\nH
sse2::BVH
sse2::BVH4IntersectorStreamPacketFallback
sse2::BVH4Triangle4Intersector1Moeller
sse2::BVH4Triangle4Intersector4HybridMoeller
sse2::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse2::BVH4Triangle4IntersectorStreamMoeller
sse2::BVH4Triangle4IntersectorStreamMoellerNoFilter
sse2::BVH4Triangle4iIntersector1Moeller
sse2::BVH4Triangle4iIntersector1Pluecker
sse2::BVH4Triangle4iIntersector4HybridMoeller
sse2::BVH4Triangle4iIntersector4HybridPluecker
sse2::BVH4Triangle4iIntersectorStreamMoeller
sse2::BVH4Triangle4iIntersectorStreamPluecker
sse2::BVH4Triangle4iMBIntersector1Moeller
sse2::BVH4Triangle4iMBIntersector1Pluecker
sse2::BVH4Triangle4iMBIntersector4HybridMoeller
sse2::BVH4Triangle4iMBIntersector4HybridPluecker
sse2::BVH4Triangle4vIntersector1Pluecker
sse2::BVH4Triangle4vIntersector4HybridPluecker
sse2::BVH4Triangle4vIntersectorStreamPluecker
sse2::BVH4Triangle4vMBIntersector1Moeller
sse2::BVH4Triangle4vMBIntersector1Pluecker
sse2::BVH4Triangle4vMBIntersector4HybridMoeller
sse2::BVH4Triangle4vMBIntersector4HybridPluecker
sse2::BVH4VirtualIntersector1
sse2::BVH4VirtualIntersector4Chunk
sse2::BVH4VirtualIntersectorStream
sse2::BVH4VirtualMBIntersector1
sse2::BVH4VirtualMBIntersector4Chunk
sse2::BVH4XfmTriangle4Intersector1Moeller
sse2::InstanceIntersectorN
sse2::QBVH
sse2::QBVH4Triangle4iIntersector1Pluecker
sse4.1
sse4.2
sse42::BVH4IntersectorStreamPacketFallback
sse42::BVH4Triangle4Intersector1Moeller
sse42::BVH4Triangle4Intersector4HybridMoeller
sse42::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse42::BVH4Triangle4IntersectorStreamMoeller
sse42::BVH4Triangle4IntersectorStreamMoellerNoFilter
sse42::BVH4Triangle4iIntersector1Moeller
sse42::BVH4Triangle4iIntersector1Pluecker
sse42::BVH4Triangle4iIntersector4HybridMoeller
sse42::BVH4Triangle4iIntersector4HybridPluecker
sse42::BVH4Triangle4iIntersectorStreamMoeller
sse42::BVH4Triangle4iIntersectorStreamPluecker
sse42::BVH4Triangle4iMBIntersector1Moeller
sse42::BVH4Triangle4iMBIntersector1Pluecker
sse42::BVH4Triangle4iMBIntersector4HybridMoeller
sse42::BVH4Triangle4iMBIntersector4HybridPluecker
sse42::BVH4Triangle4vIntersector1Pluecker
sse42::BVH4Triangle4vIntersector4HybridPluecker
sse42::BVH4Triangle4vIntersectorStreamPluecker
sse42::BVH4Triangle4vMBIntersector1Moeller
sse42::BVH4Triangle4vMBIntersector1Pluecker
sse42::BVH4Triangle4vMBIntersector4HybridMoeller
sse42::BVH4Triangle4vMBIntersector4HybridPluecker
sse42::BVH4VirtualIntersector1
sse42::BVH4VirtualIntersector4Chunk
sse42::BVH4VirtualIntersectorStream
sse42::BVH4VirtualMBIntersector1
sse42::BVH4VirtualMBIntersector4Chunk
sse42::BVH4XfmTriangle4Intersector1Moeller
sse42::QBVH4Triangle4iIntersector1Pluecker
sso;2b
st* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults  // Hit results \n    , __global int* stack \n    ) \n{ \n \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef GLOBAL_STACK  \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef GLOBAL_STACK  \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults   // Hit results \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef GLOBAL_STACK  \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny
st:PM
st\r<utK
stackPtr < stackEnd
startThreads@TaskScheduler@embree@@CAXXZ
startThreads@ThreadPool@TaskScheduler@embree@@QEAAXXZ
start_threads
state not recoverable
static
static scenes can only contain static geometries
static scenes cannot get modified
staticMesh
stdcall
stream buffer empty
stream end
stream error
stream timeout
stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \n__kernel void segmented_scan_exclusive_int_nocut(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_nocut_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n \n__kernel void segmented_distribute_part_sum_int( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    //inout_array[globalId
stride <= unsigned(inf
stride of vertex buffers have to be identical for each time step
string
string too long
strncat_s: dest is null
strncat_s: dest unterminated
strncat_s: dmax exceeds max
strncat_s: dmax is 0
strncat_s: not enough space for src
strncat_s: overlapping objects
strncat_s: slen exceeds max
strncat_s: src is null
strncpy_s: dest is null
strncpy_s: dmax exceeds max
strncpy_s: dmax is 0
strncpy_s: not enough space for src
strncpy_s: overlapping objects
strncpy_s: slen exceeds max
strncpy_s: slen is zero
strncpy_s: src is null
strnlen_s: dmax exceeds max
strnlen_s: dmax is 0
structure singular or input/parameter problem (matrixtype 11,13
stλ$oZ
subTrees[subtrees] == ref
subdiv_accel
subdiv_accel_mb
subdivision surfaces
subdivpatch1cached
subdivs
subtrees < MAX_NUM_SUB_TREES
success
sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; in_flags[globalId + i] == 0 && i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                inout_array[globalId + i] += sum; \n            } \n        } \n    } \n} \n \n__kernel void segmented_distribute_part_sum_int_nocut( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    bool stop = false; \n    //inout_array[globalId] += sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                if (in_flags[globalId + i] == 0) \n                { \n                    inout_array[globalId + i] += sum; \n                } \n                else \n                { \n                    if (stop) \n                    { \n                        break; \n                    } \n                    else \n                    { \n                        inout_array[globalId + i] += sum; \n                        stop = true; \n                    } \n                } \n            } \n        } \n    } \n} \n
supported
sw@;E
swapThread@TaskScheduler@embree@@CAPEAUThread@12@PEAU312@@Z
swedish-finland
swift_1
swift_2
sy\v:6
symbolic (max): %d symbolic (permanent): %d
syr-SY
syr-sy
s|@9l
sºJlֺM
s»;6P
sǙ=di
s͛=Ei
sϺu`M9
sݹsQM
s移\erH
s躭\te
t $;c
t ]9p
t!+V\bH
t!1;zP
t!:6C
t!Hc\vH
t" fC
t#B;o
t#k:M
t$ ATAUAVAWE3
t$ ATAVAWH
t$ AUAVAWH
t$ AVH
t$ AWH
t$ H;t$\b
t$ L;p\b
t$ L;r\b
t$ L;t$\b
t$ Lc
t$ M#f\bt
t$ UATAUAVAWH
t$ UWAUAVAWH
t$ UWAVH
t$ WATAUAVAWH
t$ WATAVH
t$ WAVAWH
t$ ba|H
t$(A2
t$(HcE
t$(ba|H
t$(t\vH
t$0H+t$pH
t$0L;p\b
t$0ba~\b
t$0fff
t$0ŸX
t$48_\bu?H
t$4ba~\b
t$8H;t$0
t$@HcD
t$@IcD
t$@M#f\bt
t$@fff
t$Dba~\b
t$HA_A^A]A
t$HHct
t$HHǅp
t$HL9{0
t$HL;x\b
t$HM+t$@I
t$Hffff
t$Lba
t$Lba~\b
t$O7:\a
t$PIcD
t$Pba~\b
t$PfE
t$PfH
t$Pu!A
t$PňT5
t$Vba~\b
t$XH;T
t$XH;t$P
t$XIcD
t$XIcmlC
t$Xba~\b
t$Xr[H
t$\bI+4$H
t$\bM+4$L
t$\bff
t$\ebA~\b
t$\fbq<HY
t$`fB
t$`fD9+t$I
t$`v&Ncd
t$`ňTEP
t$dI91
t$dba~\b
t$hMc9L
t$hr[H
t$ht\fH
t$lbb
t$pD;nD
t$pH;t$0
t$pu\bE1
t$pňXD$P
t$pňYE
t$pŠT5
t$pŨXM
t$x3\tD$HH
t$xE3
t$xHcOH
t$xLc
t$xba~\b
t$xt*3
t$xtPM
t$xu\a1
t$xuyH
t$|Hc
t%TvZ
t%fE9\bt
t&A88t
t&b;Ab
t'HcG
t'L;\rQW5
t'j=2\fB
t'ѹm3
t(9Z\ae
t(:dIf
t(c<@_j9aE
t)IcV\bH
t)fffff
t* fC
t+;RU
t+z:X
t,D8p0t
t,D8x0t
t,fffff
t-Z;anJ
t-s;D
t.;bzZ
t.C<p
t.k:H9
t.ۺubL
t/D8p0t
t/D8x0t
t/̺Ttz
t0 fff
t099\t
t0<Yi
t0@fff
t0\bp\a
t0\e:R
t0t1.size() > 0.0f
t0t1i.empty
t1?"t1?"t1?"t1
t1p;ˣ\b
t2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    c
t2V<Ϛ0
t3 b1
t38C0t
t3<S-a
t3ҋ4%8
t3ܻA\a
t4;ExF
t4L;C\bt*L
t4N;V
t4\b\bd<\b
t4\e;9V
t4z;@;k
t5\b\bd<\b
t5\t`h
t5ƺO/M
t6$:N
t6B<g
t6P=H\f
t6p7MOf
t7A8@0t1A
t7A8A0t1A
t7t9]9m
t7ݹIMj
t8<Q.I
t8=j&꼪o
t8=tD
t8B: \b
t8M<TTs
t8Tڿ:baK
t8d<xvt
t8r<G
t95:B
t98_2t
t9Cʈ8
t9Oa0
t9q x
t:!xC
t:1iV
t:3]T
t:B0\r
t:DkL
t:\at
t:_Li
t:c\a\e
t:dS\a9
t:lyY
t:o[4
t:uEZ
t;.9t9
t;8F|:G
t;8_2t
t;:ZM
t;A8\bt6
t;GR4;KKY
t;J479
t;O\av
t;TXQ9
t;\aJt
t;\e5f
t;\vw\n:sT\r
t;eAK
t;hR\f
t;ig4
t;pcl:V
t;qs\r
t;y8z
t;ܣɻGcA
t< >M
t<$6C
t<%fH
t<*dK<7
t<:r8
t<;FP
t<@cO
t<Fer
t<J"˻3O
t<R8u
t<\e3
t<\rN\e9
t<\tFU
t<b8o9Hu
t<jeܻ6
t<u<Y
t<u=4<I
t<wTj
t<zTa9b
t=8dE
t=A8@0t7A
t=A8A0t7A
t=UWټi
t=\aMf>,u
t=\fO
t=cl;=L
t=gW켼\fg
t>&EF
t>QW2
t>Yj >h~5
t>\bU
t>n;r
t>u}9
t>͛g<4F
t?@b1
t?L;YᴻL
t?X5I
t@)fLL
t@Attempted to create SOFA HRTF without either a file name or a data buffer
t@HcS\bH
t@REF%08lX
t@\b\bdH\b
tA8_:t
tA<DF
tA@8s)u2H
tAO:q
tA\v9
tB9\a4
tB:,NR
tB<#b
tCI9I
tCU:Y
tD='sC
tDA;m$t>H
tDH9\nu
tDĻ&cS
tE=@8
tED8k2u7H
tF*<ZIj
tF;^d
tF=A䴼th
tG<zmZ
tGѻ.N
tH#:P
tH+X@I
tH696d
tH;\r=VI
tHкKY
tJ:4zs
tJ>\a
tJR>8o
tK9_\bt
tKI=dXW
tL$@fD
tL:\t0
tL;!lD
tLcA\bH
tLg:C
tLջJ0
tM99WC
tM:>V|;mB
tMF<TV
tM\e;>m
tN:;\fP
tNear[index] >= 0.0f
tNear[r0] >= 0.0f
tNear[r1] >= 0.0f
tO,>f
tO;7Q
tP@;r
tPϹƃg
tQ:|nG
tQD8c:u0M
tQX<sF
tQfD9 tK
tQg;l
tR$;9p
tRV=\v
tR躽1ݹY
tSf91tNH
tT:V05
tT\r/s
tT\r\tKQ
tTػRa
tU;\\$0tH
tUH95U0
tUbo\bZ
tV9;\v\e
tV;#4
tVݻr\r
tW=1¬=n
tWt:ttt
tX+>a
tX-< Gd
tXF:OPͺo
tX\b%dW\b%4V\b
tZ<eGv<\b4
t\a-<jv
t\a:Z
t\a?GY\r
t\aH9D$PuCH
t\aār^L
t\aġrYL
t\aġzYD
t\e;D
t\f;e
t\fH;Q@s
t\fO;l¯:Y
t\n@88t\bH
t\nF?s
t\nH9P A
t\nH;B\bv
t\nH;C\b
t\nH;C\bv
t\nI9Jhs
t\nL9Qhs
t\nbatH
t\r98t H
t\r; iҼn
t\r;vW
t\rfD9"u\aB\bL
t\t\n:9
t\v>\fw
t\vH;B\bv
t\vK9D'\b
t`:MK
ta97zX
ta;e,F
ta<pN
taL9Chu
tail[BUCKETS-1] == head[BUCKETS-1] + count[BUCKETS-1
tail[BUCKETS-1] == num
task cancelled
task stack overflow
tb!T@Yt\t
tb!|H
tb1>\bY
tbA\\HYe\ab
tbA|H
tbI<XO
tbQ|H
tbad(W
tba|H
tba|\b
tba}Hp
tbb=\b
tbq}HpɱbA
tbq}HpбbA
tc7=P
tc;7!C
tc蹇k9
tdm;O1h
te=\tGR
tessellation_cache_size
text file busy
text$di
text$mn
text$mn$00
text$x
text$yd
tf/<LP
tf<KN
tfffff
tfffffff
tg;iY
th*;073
th/;On
th9@p
th<V3̻I
that provides the minimal Euclidean norm of the solution will be computed
that should be discarded according to the threshold
the D_COMMIT_TRIG_TRANSFORM routine
the D_COMMIT_TRIG_TRANSFORM routine. Assigning to DPAR(1) the default value
the S_COMMIT_TRIG_TRANSFORM routine
the S_COMMIT_TRIG_TRANSFORM routine. Assigning to SPAR(1) the default value
the call to D_FORWARD_TRIG_TRANSFORM/D_BACKWARD_TRIG_TRANSFORM routine
the call to S_FORWARD_TRIG_TRANSFORM/S_BACKWARD_TRIG_TRANSFORM routine
the call to d_forward_trig_transform/d_backward_trig_transform routine
the call to s_forward_trig_transform/s_backward_trig_transform routine
the d_commit_trig_transform routine
the d_commit_trig_transform routine. Assigning to dpar[0] the default value
the default value
the first call to DCG routine. Otherwise, the maximal
the parameter 'BCTYPE' were out of admissible range {D,N,P} during initialization stage
the parameter 'BCtype' is not in the admissible range {D,N,P} during the initialization stage
the parameter 'BCtype' was outside of the admissible range {D,N,P} during the initialization stage
the s_commit_trig_transform routine
the s_commit_trig_transform routine. Assigning to spar[0] the default value
this data vector
this problem
thiscall
thread the following way
thread@TaskScheduler@embree@@CAPEAUThread@12@XZ
threadCount@TaskScheduler@embree@@SA_KXZ
threadCounter == 0
threadID@TaskScheduler@embree@@SA_KXZ
threadIndex < threadLocal.size
threadIndex@TaskScheduler@embree@@SA_KXZ
threadLocal[threadIndex].load() == nullptr
threads
thy<F
ti;?z$9
ti;ڣ0;M
tiY:SV
ti\e>I
timed out
tj;+Z
tj;5R
tj<jtV
tjL;@(H
tk<\vD
tkE>fvw
tk\a=W
tl;\bGE
tlT9t
tl\v*dk\v*4j\v
tls$ZZZ
tm\f;q
tn$;Wc
tn)=0O
tn,<w7
tnM;:Lf
tn\v*dm\v*4l\v
tny<l\nB
to provide memory for temporary data structures
to use periodic boundary conditions in x axis direction
to use periodic boundary conditions in y axis direction
to use periodic boundary conditions in z axis direction
to:\taع4
to;6O
tograms to reduce the chance that an atomic_add leads to contention (see below for details).\n    local int localEnergy[NUM_BINS * NUM_LOCAL_HISTOGRAMS];\n\n\t// These base pointers are used in stage 2 of the kernel. See below for details.\n    local int* workItemEnergy = localEnergy + mul24(localIndex, NUM_LOCAL_HISTOGRAMS);\n\n\t// Initialize all local-memory histograms to zero.\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++)\n    {\n        workItemEnergy[i] = 0.0f;\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 1\n\t// Each work-item processes one ray. If it is not occluded (i.e., it carries non-zero energy), the energy is added\n\t// to one of the local-memory histograms for the work-group. These adds need to be atomic, since multiple rays\n\t// being processed in the same work-group may write to the same bin of the same histogram. The contention\n\t// due to atomic_adds can be reduced by increasing NUM_LOCAL_HISTOGRAMS, at the cost of increased local memory\n\t// usage.\n    if (!isOccluded)\n    {\n\t\t// Adjacent work-items in a work-group do not use the same local-memory histogram. A work-item with local\n\t\t// index i writes to local-memory histogram (i % NUM_LOCAL_HISTOGRAMS).\n\t\t// When calculating the bin index, bin index i is mapped to index  NUM_LOCAL_HISTOGRAMS * i in the\n\t\t// local-memory buffer. This is because the histograms are interleaved.\n        local int* shiftedLocalEnergy = localEnergy + localIndex % NUM_LOCAL_HISTOGRAMS;\n\n        global float* rayEnergy = (global float*) (&totalEnergy[offset + rayIndex]);\n\n        float time = totalEnergy[offset + rayIndex].w;\n        uint bin = convert_uint_sat(floor(time / BIN_DURATION)) * NUM_LOCAL_HISTOGRAMS;\n\n        if (bin < NUM_BINS)\n        {\n            float energyValue = scale * rayEnergy[band] * shCoefficients[channel * numRays + rayIndex];\n            int quantizedEnergyValue = convert_int_sat(floor(energyValue));\n            atomic_add(shiftedLocalEnergy + bin, quantizedEnergyValue);\n        }\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 2\n\t// Each work-item processes one bin. The corresponding bins for all local-memory histograms are added, and the\n\t// result is stored in a private variable. No atomic operations or barriers are required here, since each work-item\n\t// operates on independent data.\n    int accumulatedEnergy = 0;\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++)\n    {\n        accumulatedEnergy += workItemEnergy[i];\n    }\n\n\t// Stage 3\n\t// Each work-item processes one bin. The summed values from the local-memory histograms are added to the corresponding\n\t// bin in a global-memory histogram. Here, atomic_adds must be used, because multiple work-groups may be trying to\n\t// write to the same global-memory bin at the same time.\n    atomic_add(energy + channel * NUM_BANDS * NUM_BINS + band * NUM_BINS + localIndex, accumulatedEnergy);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Reconstruction Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\n#define ENERGY_THRESHOLD            1e-7f\n#define MIN_VARIANCE                1e-5f\n#define NUM_WORK_ITEM_SAMPLES       32\n#define WORK_GROUP_SIZE\t\t\t\t64\n\nkernel void applyIIRFilter(global IIR* filters,\n                           global float* impulseResponse,\n\t\t\t\t\t\t   uint numBins,\n\t\t\t\t\t\t   uint samplesPerBin,\n\t\t\t\t\t\t   uint numSamples)\n{\n    size_t band = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t numBands = get_global_size(0);\n    size_t numChannels = get_global_size(1);\n    size_t batch = get_global_id(2);\n\n\tlocal float localSamples[(NUM_WORK_ITEM_SAMPLES * WORK_GROUP_SIZE) + NUM_WORK_ITEM_SAMPLES];\n\n\tconst int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\tlocal float* workItemSamples = &localSamples[localIndex * NUM_WORK_ITEM_SAMPLES];\n\n    global float* signal = &impulseRe
tolerance multiplied by the matrix row L_2 norm
too many files open
too many files open in system
too many length or distance symbols
too many links
too many symbolic link levels
total
total            : sah
total - write&read: %d
total - write&read: %lli
total memory wanted here: %d kbyte
total memory wanted here: %lli kbyte
tp;GJl
tp;bJ̺j
tp<\nZ3
tpH91uk
tp[9\aO
tp\b`\a0
tp\b`\aP
tpɼy\tw
tr%<.Om
tr:b51
tr\v>l(C
transform.elements[iRow][iColumn
transformNodes
traverser
traverser_mb
tri_accel
tri_accel_mb
tri_builder
tri_builder_mb
tri_traverser
tri_traverser_mb
triangle4
triangle4i
triangle4v
triangle4vmb
triangles
trinidad & tobago
ts,<aM
ts;Hj
tsg:B
ts̸pv
tv;<D~G
tv>`I6=yW
tvL<U
tvûY`ԻA
twx\\w
tx<w]Y
tx\a*dw\a*4v\a
txмkn
ty<Geometry::NUM_TYPES
tyfD9 tsH
typeof
types & BVH_MB) || (ray.time >= 0.0f && ray.time <= 1.0f
types & BVH_MB) || all(valid, (ray.time >= 0.0f) & (ray.time <= 1.0f
tz/9u1
tz\a>yI5
t{757
t{<j4
t}9;p
t}һO\r0
t~; Q
t~E;C
t»Wv̻Hu
t¼!8W
tƻCrb8"q
tȉD$\f1
tл\tm
tѣ<EW
tӎ;3u
tӺP\e\r
t۹>WJ
tۺ$4f
t⻲x\n
t焹G!y
t蝼^Pf
t뾖2j<C
u HcA<H
u ba|H
u }<w88
u!bA|H
u$D8r(t\rH
u%@8j(t
u%A8x,u
u(;3EV
u(A+u0A
u(k:9
u+L=B
u. ;BS0
u.>:wSG
u0H;u
u0I;]8
u1!D$0H
u2ffffff
u4\f<$v
u6ɸNGq
u7;otR;U
u7n;w7
u7t=fD
u8;-h
u8@8{,u2L
u8D9{\bu2M
u8U\e
u8ffffff
u9<%F
u::wG
u:B\tP
u:R$h
u:h[0:U
u;2*m
u;5tg
u;;UsK
u;H"n
u;Lx9P쉺c
u;UȪ9
u;seؼr
u<>xg
u<K\nQ<f
u<\rDk
u<g~l<it[<ntP<ot,<pt
u<ջiR
u=K,J
u>2jh
u@:SG
uA8D$`t\bH
uA;=Ne`=aE
uB<_Kt
uBa|)CG
uC<Y3V
uD=W2
uDx;!\e
uE:4Z
uED8r(t\rH
uF<xXߺR
uGL;^PtAL
uHI9U8v
uHI9U8v(I
uJ<0uF
uJA:4a
uJ\rJ,0
uJ\r\a
uJ\rnJ
uJ\rw
uK8o-\a
uK;xXL
uMcσ~\b
uN:w\n*9T
uN漘\e
uOɼ3\r
uP96K\v9
uQ8G\buAH
uQr;s
uV;U\n
uWh<Z
uX%-Ze
uX%5\fj
uX뼔y\t<\b
uY<opx<c
uY\v:A
uZ;u{\v
uZEeu\b
u\a3\bB
u\abA
u\b< t=<\tt9
u\b<oel
u\bM;h\b
u\bM;i\b
u\bM;n\b
u\bbA|H
u\bbA|I
u\bbQ|H
u\bh;I
u\e@8j(t
u\ee<XT
u\f9\r
u\fbQ|H
u\nA8
u\nA84
u\nD8AP
u\nH9]8
u\nL;q r
u\nfA9
u\nfA9\b
u\rb>g
u\rba,HY
u\rba|H
u\rfA9P
u\rfD9d$0
u\rw=Uf
u\t<BFb
u\tb"-H
u\tbA
u\tbA4HYM
u\v>W
u\v@8~0tM
u]D8O\buIH
u^8G\buGH
u^n=Zn
u_H:dB
ua;'W
uaA8_\buEI
ub'vb'v
ucF:\\T
ucO;oO09
udt returning
uf\v:5n
ufffff
ugD;B$t
uh4;E9u
uh{:8
ui="jf
uiA8_\buEI
um;o(k
umٺ\bC
un;DW
unable to open output file. Print to STDOUT
unaligned
unalignedNodes
unalignedNodesMB
united-kingdom
united-states
unknown
unknown buffer type
unknown builder
unknown compression method
unknown error
unknown exception caught
unknown header flags set
unknown motion blur triangle acceleration structure
unknown readable parameter
unknown traverser
unknown triangle acceleration structure
unknown user geometry accel
unknown user geometry mblur accel
unknown writable parameter
unordered_map/set too long
unsigned int)timesegments < max_time_steps
unsigned(morton[j]) >> shift) & (BUCKETS-1)) == i
unsigned(v) >> shift & (BUCKETS-1)) == i
unsuitable for this data vector
uoA8]\buMI
up traversing bottom level BVH \n        // in this case idx = 0xFFFFFFFF and topidx has valid value \n        if (idx == -1 && topidx != -1) \n        { \n            //  Proceed to next top level node \n            idx = (int)(scenedata->nodes[topidx].pmax.w); \n            // Set topidx \n            topidx = -1; \n            // Restore ray here \n            *r = topray; \n            // Restore invdir \n            invdir = invdirtop; \n        } \n    } \n \n    return false; \n} \n \n \n// 2 level variants \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n) \n{ \n \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest2L(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny2L(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    __global int* numrays,     // Number of rays in the workload \n    int offset,                // Offset in rays array \n    __global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest2L(&scenedata, &r, &isect); \n \n
up;Ijf
updateTransform
upŸYMp
upƺ%W
uq`:)SK
us=;aI
usE8E\buQI
use_single_mode
used blocks
usemtl material_%d\n
user32
usergeom
usermsr
using
uuNu'uu
uv+:t
uv\r;DF
uwo;Pw
uz-UZ-Cyrl
uz-UZ-Latn
uz-uz-cyrl
uz-uz-latn
u~9t$Xt
uƂnA&Q
uɊ9Rbj9
uɺ=z8
uδ;cf
uϋD$$LcL$(Hcl
uԋ<8Q
uݼ,Jn
v %f %f %f\n
v ><W
v Lc\\$8I
v ɺM119
v";jd
v#9Lo_9
v#S;Pe
v$G<@A4
v%m=k
v(A+v0A
v)0;Px
v)9%4o
v)\a=Q2
v-;bG6
v-Y:\ev
v-o;~z7
v.<zBA
v0,<\nTF
v0<a_\n
v1d-v0d) != 0.0f
v1ͻ&e
v2!L.2
v2;[8e
v2Z;s\f
v4#:0
v4.x = v4.y; v4.y += t; \n    t = v4.z; v4.z = v4.w; v4.w += t; \n    *offset3 = v4; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    *histogram = total; \n} \n \n// Calculate bool radix mask \nshort4 radix_mask(int offset, uchar digit, int4 val) \n{ \n    short4 res; \n    res.x = ((val.x >> offset) & 3) == digit ? 1 : 0; \n    res.y = ((val.y >> offset) & 3) == digit ? 1 : 0; \n    res.z = ((val.z >> offset) & 3) == digit ? 1 : 0; \n    res.w = ((val.w >> offset) & 3) == digit ? 1 : 0; \n    return res; \n} \n \n// Choose offset based on radix mask value  \nshort offset_4way(int val, int offset, short offset0, short offset1, short offset2, short offset3, short4 hist) \n{ \n    switch ((val >> offset) & 3) \n    { \n    case 0: \n        return offset0; \n    case 1: \n        return offset1 + hist.x; \n    case 2: \n        return offset2 + hist.x + hist.y; \n    case 3: \n        return offset3 + hist.x + hist.y + hist.z; \n    } \n \n    return 0; \n} \n \n \n \n// Perform group split using 2-bits pass \nvoid group_split_radix_2bits( \n    int localId, \n    int groupSize, \n    int offset, \n    int4 val, \n    __local short* shmem, \n    int4* localOffset, \n    short4* histogram) \n{ \n    /// Pointers to radix flag arrays \n    __local short* shmem0 = shmem; \n    __local short* shmem1 = shmem0 + groupSize; \n    __local short* shmem2 = shmem1 + groupSize; \n    __local short* shmem3 = shmem2 + groupSize; \n \n    /// Radix masks for each digit \n    short4 mask0 = radix_mask(offset, 0, val); \n    short4 mask1 = radix_mask(offset, 1, val); \n    short4 mask2 = radix_mask(offset, 2, val); \n    short4 mask3 = radix_mask(offset, 3, val); \n \n    /// Resulting offsets \n    short4 offset0; \n    short4 offset1; \n    short4 offset2; \n    short4 offset3; \n \n    group_scan_short_4way(localId, groupSize, \n        mask0, mask1, mask2, mask3, \n        shmem0, shmem1, shmem2, shmem3, \n        &offset0, &offset1, &offset2, &offset3, \n        histogram); \n \n    (*localOffset).x = offset_4way(val.x, offset, offset0.x, offset1.x, offset2.x, offset3.x, *histogram); \n    (*localOffset).y = offset_4way(val.y, offset, offset0.y, offset1.y, offset2.y, offset3.y, *histogram); \n    (*localOffset).z = offset_4way(val.z, offset, offset0.z, offset1.z, offset2.z, offset3.z, *histogram); \n    (*localOffset).w = offset_4way(val.w, offset, offset0.w, offset1.w, offset2.w, offset3.w, *histogram); \n} \n \nint4 safe_load_int4_intmax(__global int4* source, uint idx, uint sizeInInts) \n{ \n    int4 res = make_int4(INT_MAX, INT_MAX, INT_MAX, INT_MAX); \n    if (((idx + 1) << 2) <= sizeInInts) \n        res = source[idx]; \n    else \n    { \n        if ((idx << 2) < sizeInInts) res.x = source[idx].x; \n        if ((idx << 2) + 1 < sizeInInts) res.y = source[idx].y; \n        if ((idx << 2) + 2 < sizeInInts) res.z = source[idx].z; \n    } \n    return res; \n} \n \nvoid safe_store_int(int val, __global int* dest, uint idx, uint sizeInInts) \n{ \n    if (idx < sizeInInts) \n        dest[idx] = val; \n} \n \n// Split kernel launcher \n__kernel void split4way(int bitshift, __global int4* in_array, uint numElems, __global int* out_histograms, __global int4* out_array, \n    __global int* out_local_histograms, \n    __global int4* out_debug_offset, \n    __local short* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n    int numGroups = get_global_size(0) / groupSize; \n \n    /// Load single int4 value \n    int4 val = safe_load_int4_intmax(in_array, globalId, numElems); \n \n    int4 localOffset; \n    short4 localHistogram; \n    group_split_radix_2bits(localId, groupSize, bitshift, val, shmem, &localOffset, \n        &localHistogram); \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    __local int* sharedData = (__local int*)shmem; \n    __local int4* sharedData4 = (__local int4*)shmem; \n \n    sharedData[localOffset.x] = val.x; \n    sharedData[localOffset.y] = val.y; \n    sharedData[localOffset.z] = val.z; \n    shar
v4:6ݸ;f
v5?:7IN;\e
v5\v`h
v5~:P
v6:Gq\n
v8F9\n
v9&;D
v9+M=9
v9A^5
v9d[z
v9o{W
v:+YC
v:5Il;˅N
v:;C5\n
v:<mF2;T,\b<uNV
v:JzK
v:M:3
v:X$T
v:ZQS
v:\br\t:H
v:kaH:l
v:lP :TFt82
v:պH\aa8
v;)mM9
v;0^8
v;509;4
v;:Pl
v;D\v
v;S\r
v;Us3;G
v;Zy\e
v;\tLr;{tb
v;\tnʺSF
v;`n5
v;dW><K
v;oOc:L
v;reO
v;s}p
v;w0N
v;x;K
v<Aj\n
v<F㴻JV
v<eiƼ1
v<er󻗇\t
v<n$b;L\r
v<~0p
v=#hD
v=Qeh
v=Y]Bv
v=YiZ
v>'5C
v>P9#>nV
v>x掾2
v>yE\v
v>{Ed=o
v>Ĩ\f>JfJ>MM
v?,\tm2
v?PDt?a
v@D8s(t\rH
v@DIMENSION_SCALE
v@L:qY
vA03>A
vA;b\n
vAD8s(t\rH
vBF:\r
vC<RDJ<s
vCք\tes\vC
vD$(A\v
vDN<V
vD\v$H
vF;6S8
vF<a5L
vG|HO
vH9y\bu
vH;A\bu
vH;Q\bu
vH;Q\bu\rL
vHȻd(5
vID$\b
vK;A\fL
vL77㉼Q
vL9u O
vL<2N
vL{j\t\f
vLûbSv:̦I
vM8¶R
vM>TYӾI
vMW;q#6=2
vM~;Av
vN;\fLu
vNcD\b
vNr:oU
vO,;Y2
vO<lCF
vPE;E
vQ;7&N
vQ츟Xc
vR!;0
vSc<bAӽy
vT$9f
vT;nur;W
vT;|j
vTv<F
vU˻=nT
vValve Corp.0
vValve Corp.1
vWf;Ob\e
vX:s,\e
vX廑|Q;K
v[;\r6s
v[GbO\b
v\\8E5
v\a4:n
v\bD;3
v\bYL$ b
v\f(<BI
v\f>GvS
v\f@8k(t
v\f̺e\t
v\n\f;C4
v\nbatH
v\t;~y0
v\t<8Rj
v\t>k
v\tL;Y
v\tbQ|H
v\tcvo
v\tݺEx\v
v\v_;VYf:UPH
v\vɻz
v^>\nhh
validi == -1
value has appeared (small with respect to the input
value too large
vaw</i
vaݺ\nkt
vb"5H
vb-;R
vb:<I
vb:o\t
vb<PK
vbA|H
vbA|\b
vbB5H
vbQ|H
vban\bX
vbase destructor
vba|H
vbqLHX
vbtable
vc<PM?;l
vcall
vde=s
vd˺;U
ve;;w
vector constructor iterator
vector copy constructor iterator
vector deleting destructor
vector destructor iterator
vector too long
vector vbase constructor iterator
vector vbase copy constructor iterator
vector<T> too long
vector<bool> too long
vectorcall
verbose
verbosity
vertex buffer can be at most 16GB large
vertices
veɹt쵺5
vf;2yt
vf=;,UG;e
vf?;A@F
vfD9!H
vfffff
vftable
vg\v;.JB;N
vh:L=9
vh;Am
vhT;m$k
virtual displacement map
vj&<SS
vj8jB49
vla;"Y
vm:ay
vm:ay̺K\n
vm;9)t
vm<R\b
vn;\b
vo$;E
vp$;V/A
vp\nP!\r
vp\n`\tP\b0
vpclmulqdq
vq9xk
vq;?7\t
vq;p\n
vq<<3
vqJ=C
vs:'cl
vsd=\fJ
vt;\vqi
vt\r<x
vt}<x
vu:XXR
vvܻOs
vw˼R識4
vx=-o
vx\r=YG
vy;."w9\b
vy}:\nD
vz̻UWC
vzټw2D
v{;9I&9
v|G9RT
v}8<\bo
v}ŹWl#9!L
v~9;UF
v~:oe
v~o<gS
vä;OH
văa!4\n
vĎ:Hf
vʉL;\fH
v̺B8c
vΉL;\fH
vӽ9NB\n:3
vԥ;aY
vܻh+G;0I
vߔ<Av
v↻vhW
w"ʻvbV
w$j:3\n
w%7;9Q
w':UlO
w+=P8
w+\r<s\no
w,a;Yk
w.:IQ
w/:3\aw
w0<s4
w0<y6\n
w0\t<3u
w0Ӻo)9
w11:c
w2&:sx
w29iN\t
w4;\tp
w4G;\r\f
w4_;W
w5<;V
w9T\rM
w9\r쭺>zr
w:RΙ;P9
w;"Nd
w;7aٻ7r
w;G9\a
w;W:2
w;\nJ
w;\t㊽xY
w;oC?<4
w;rWz;5
w;sG\n
w;tGB
w;w"L
w;y?J
w<0|H
w<v0c
w<wB\f
w=^eI
w=wSN
w>B7c
wA]A\\]_^[ÐSVWUATAUH
wA^A]A
wA_A^A]A
wB;9ٳ;S
wB<1\a
wBE9)t
wD:ę\t7
wF7=1D
wF;wk绢J
wF\\:Pjb
wF\e;Vf
wG0:\a
wGB:Jρ:F
wH:|7
wH;\rCiS
wH;\rׁe
wIE9)tD
wIz<=Ug
wJ\r9
wJ\v<$p
wLC<ɬ\e
wLD9`HtF
wM;GI
wNM:>Vk9M
wOb:mj
wQ<:\nT
wQ?;g
wSԼD\n
wT:;dsp
wT:Fv\e
wT\t=\a
wY:%E\n
wZ:Wv
wZw=www w
w\\K:pz
w\a9xx\a0hy\a'4
w\a<I
w\a\t
w\b:E\auj
w\bUUUU
w\bf;E\auuA
w\eu;\e
w\f;˪k9
w\fS:hC
w\t9\v/};xrb
w]A_A
w]A_A^A
w^;5aD
w_*<GaQ
w_F;P
wait@TaskScheduler@embree@@SA_NXZ
waitpkg
was altered by mistake outside of the D_COMMIT_TRIG_TRANSFORM routine
was altered by mistake outside of the S_COMMIT_TRIG_TRANSFORM routine
was altered by mistake outside of the d_commit_trig_transform routine
was altered by mistake outside of the s_commit_trig_transform routine
wasted
wb9X-s
wbnoinvd
we;\nS8
weV=Fq
wgQ=]h
wgj;p49
wh?9nMW
which is equal to %e
which is equal to %s
wi_<a
wide-kl
will always lead to failure in computation of LU factors
with multiple minimum degree on the separator nodes
wiںSys
wl989d
wlY>s
wlԼ\r
wn>Jj
wn_;Ysڻs
wp\b>\tX
wqu:B
write to files : %10.3f Mb
write to files : %d
write to files : %lli
write&read     : %10.3f Mb
wrmsrns
wrong column indexes in CSR format
wrong control step parameter ido %d
wrong control step parameter ido %lli
wrong integer array of row positions in its CSR
wrong protocol type
wrong row indexes in CSR format
wrɼCk
ws1:Mt
ws;PXR
wt4:M
wv;\r\f\r
www.digicert.com1!0
www.digicert.com1$0
wxԺ\r/7
wy:-hs9
wyh;\b
wz@7\n
wzT<\f
wz\n=#qn
w{9YM
w|y<Q
w};b7\f
w¹Sg̺n
wÐUAWAVAUATVWS
wĢ<EC
w˼QPü`V
w̺MK}<6
wξ\fZD>L
wϼ{Tl
wԹ3\aB9
wպOY2
wڗ:GY
w۹qVO
w㔻97\b
w挽\b8
x :\e)K
x ATAVAWH
x AUAVAWH
x AVAW
x AVHcA
x UATAUAVAWH
x UAVAWH
x(D$pH
x(L$ H
x(L$0H
x(L$0L
x(L$PH
x(L$PL
x(T$ H
x(d$0I
x(l$ H
x(t$PL
x(t$pL
x)L$PH
x)L$PI
x)T$`Hc
x)d$0I
x)d$`Hc
x)d$pH
x)l$ H
x)t$PL
x+9- G8
x+:xb
x+<efI
x-;CT0
x.>5bF
x.S9L
x/L\n(v
x4:sS
x4D>qI
x8:Sb(8h
x8}0\t9
x9:\nV
x9;Fu
x:;dH\e
x:P5Q:Zx
x:U8ǻi
x:\fd2
x:\rhN
x:f#9
x:ۚ\e9Fl
x;)Li
x;<a 9p
x;CaR
x;Er\v
x;MҠ9
x;R7̻1
x;\eI\a
x;hKR
x;q_x9
x;uLO
x;|8O
x<$OV
x<1f켹c
x<EHv
x<J\r
x<qio
x=&UǽWN4
x>0\n
x>Q<\aQ
x>V6'?C
x?;1BN
x?S;3
x@bB%H6
xA^A]A
xA_A^A]A
xB-zC\f
xC<@x
xEV<V
xFG;vMV
xG :*魹h
xG)=p
xH;D$h
xH;}0
xH<jc
xHY9#yn
xJ>Hf
xJF;E6
xM;\\YU
xN.<S
xN\v<>,l6
xP:Ed\r
xQ*;A
xQ4:\fF
xR;[SA:L
xRZ;U
xS69:yX
xU";c
xU9:O
xU:b~\a
xU;qGK
xWI96tRI
xWؽX"K
xX'>ubW<]1
xX8:ՄJ
xXI96tSI
xXL& ġHY
xXL+ ġ@Y
xXL. āHY
xXL. ġHY
xXL0 L
xXL0 ġHY
xXL1 āHY
xXL2 āHY
xXL2 ġHY
xXL4 ġHY
xX\r<Xx
xXs<S
xYD$0ŨY
xYD$`H
xYT  H
xYl$PŰY
xYnPŸY
xYoPŸY
xZ\n:2
x[9[xE
x[Q:xJx
x\\g:cH
x\aH;m
x\bH+8H
x\bntelu
x\f=9Z\a
x\nIcL$l
x\n|\fX\n
x\v;f#C
x\vL;0
x]A_A
x]A_A^A]A
x]L$pH
x_x;5
x`D<7J
xa9;EJ
xbػ(Ri
xdata
xdata$x
xdgemm
xdp>n
xe;&j
xeq<H
xf;}ws
xh"9A
xjͻKQs
xk]:45R
xl;!\r5
xn5;|:A
xo78$E
xoM=6
xoؾvK
xr<Ir
xs;6y
xuĻv\fx
xw;^n
xwg=.,f
xwֻ\an
xxJ;*\f
xxJ<&X
xy<Aq9
xǊ:2C
xϻ8go
xؙ9eUl
xݻhṻI
y ba~\b
y º KI
y!A 0H
y!A@0H
y!D$p b
y!X8 H
y!`8 I
y!p8 H
y!x8 H
y!x8 I
y"-o3
y"5Yw
y"D!P
y"D"P
y"D\fP
y&:kw
y(J9h1
y+Y<w
y+{YB
y-N:Pv
y.<Hm
y.K91\aZ:-E
y/8Qv
y0G=XM
y1d<0
y2@\e
y2o9,p\b
y2úڪZ
y3H:wO
y4<G3
y5zo1
y63˼}l
y67;\eq
y9.9W
y9<wh
y9\r`y
y9`;S
y9gt\b3
y9k>":0
y9x0C;\n
y:)Jp
y:< 6K
y:@FO
y:Bm(:t
y:\rz
y:gt\t3
y:oSj
y;-y5
y;;vV
y;aAڻeD
y;cev:V
y;ƗJ:Vt
y;ƼPDx
y<;TDf
y<L9{0
y<W%7
y<l:lEV
y=F:LO
y=e;q\t
y=uYX
y=u\n3
y=ľS=jz
y>(0r
y?Nny
yA9TYi
yA<\fM
yEٺn3
yI!<o;P
yJ=0xN>7
yKc:\n
yM:'S`9
yM<pIл[!j
yM>ȞI
yN<qyC
yNӻ!n{bk
yO>;g
yQ&<C7
yTw:Nr
yU;J\vǻty
yY;rY8
yZy;ᴀ:t
y\\PD
y\a\b
y\b< Dn9
y\bH+9H
y\bL+9H
y\bW;,l
y\bba~\b
y\eq;d
y\fbA~\b
y\fúbM
y\r<o
y\r=5
y\rk;b\b
y\tV<&h
y\v;\vNX
y^O;T
y_U;O\t
ya=OYY
yb;\rA
ycI<p
ycO:"K
yd=Oi
ygV:J(6
yj';f
yl苼$P\r
ymIXa
yn->l7
ynD#PHc
ynL'Pģq"L#P
yni;t
you can use rtcSetIntersectFunctionN only in stream mode
you can use rtcSetIntersectionFilterFunctionN only in stream mode
you can use rtcSetOccludedFunctionN only in stream mode
you can use rtcSetOcclusionFilterFunctionN only in stream mode
you have to use rtcSetIntersectFunctionN (and optionally rtcSetIntersectFunction1Mp) in stream mode
you have to use rtcSetIntersectionFilterFunctionN in stream mode
you have to use rtcSetOccludedFunctionN (and optionally rtcSetOccludedFunction1Mp) in stream mode
you have to use rtcSetOcclusionFilterFunctionN in stream mode
you have to wait for spawned subtasks
yp; \eA
ypg<9M
ypm;pR
yrL9JT
ys,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults  // Hit results \n    , __global int* stack \n    ) \n{ \n \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef LDS_BUG \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef LDS_BUG \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults   // Hit results \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef LDS_BUG \n            hitresults[global_i
ytV;D
yuϻ%NX
yv;\v
yzC<Z
y~;8J
yȺ\nY
yɻP.K
y̺4\e6
yͺ:rN-7
yϻ/Z0
y耺SC\a
z <tHm
z v"z$e
z!U:I
z"(pkh
z";WF
z&:RC
z*Y9Pw
z+R<4T
z,;EAI
z096?\a
z0=|Q
z0U;6x
z0\f>L
z1=<D
z2v;Ns
z4:(lk
z4:NA
z4\f<Elf
z4v?\f\b
z7:hv¹p_v
z7<Gi
z7H<ur
z8J:X
z8W;r=A;ATB
z8\axغB
z8v>\r
z8ڻad
z9>z\rf
z9MdU;\nV
z9XxGT
z9ں;u
z: SR
z:2\v
z:3:D8a0
z:3{g:xp
z:> R9f
z:bIm
z:c夺Q
z:jPj
z:o4.;E
z:vhT
z;7WH
z;GRt
z;\tOg<K
z;bhD
z;g<p
z;qbC
z;ѲI;7I
z<62P
z<;<fvu
z<rc+;\al9<gn
z<t\f
z=;NSH
z=T/P=tA
z=l4ݽw
z>W\f
z>h4Ժ/so
z?<5T
z?ƽA\t3
zA*=c
zA7<EU
zF;u+\f
zGf:XV
zH\t=p
zJ6;[O
zJ;߸89
zL<&Cs;2
zL\r;N
zQv<>8
zR>_OB
zRB:5
zRc;>E
zUżL^Q
zWM;L
zX\a;N
zX\f2āz
zXq ŊY
zX|Dz
zY$!M
zY,\vĢa
zY0v;C
zY6;j
zY;>u:m\t
zYD(\bL
zYD\v\fġz
zY\\\v\bH
zY\f2K
zY\f2āz
zYt\a
z\aGl
z\aba|\b
z\bH+:H
z\e3<,S
z\fba~\b
z\r=t
z\rba|\b
z\t:|FO
z\tb"u\b
z\tbA
z\tba|\b
z\tba~\b
z\tƼ\a켭 w
z\v2;\a
z\vba~\b
z\vܺ78
z^\r;hU
zb2:E
ze<58\e
zffffff
zg;9_ûc
zh-CHS
zh-CHT
zh-chs
zh-cht
zh:8n
zh\f:\n
zhb>f
zi3==\aR
zi9uMe
zi<g)C
ziS<D
zjS:6>Q:aph
zk3:\t(5
zkD;=N
zm?9CD
zmϼ`8r
zn==bR
znӺWT
zo%$tR
zo%FdR
zo%V'q
zo%Y&o
zo%\e
zo%\vcR
zo%g{R
zo%l8o
zo%ogR
zo-$Ds
zo-+Ms
zo-6Lq
zo-Ol
zo-}kq
zo5 |3
zo5Vl
zo5fkL
zo5vU3
zo=5sL
zo=h1O
zo=zIn
zoD$\bMc
zoG\bMc
zoL$pH
zoT$pL
zo\r.k
zo\r7TP
zo\r88q
zo\r;Nq
zo\rG)r
zo\r[(q
zo\r\bKH
zo\rn]P
zo\rntQ
zo\rq`n
zo\rwJP
zo\r}Rp
zq<gCn
zqz:r
zr`:o
zsX<\r
zt;\ar
ztߺv\a4
zut<[H
zx ;ɾn
zx%ܻK
zz1;j1
zzp;lQ
z~4\bġz
z~=gC
z˺jwx:c
z̓;9WG
zͻyp˻\aL
zѻ>\tCp
zּNDf
z߳;Rk
z㹭6/:oĤ6q
