0 ACr
0%:I7
0&>\vxe
0(J>a
0(¼2K
0*=tP
0+<5oϻU
0/8;&jt
00000000@@@@@@@@PPPPPPPP
0000@@@@PPPP
00=Ps
00cfg
0123456789
0123456789-+Ee
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\\]^_`abcdefghijklmnopqrstuvwxyz
0123456789ABCDEFabcdef-+Xx
0123456789ABCDEFabcdef-+XxPp
0123456789abcdefghijklmnopqrstuvwxyz
02<N`N
03\tD
040904b0
045>,D
06*>L
07T:R
08Y;zQ\n
08ܻM\nB;i
09G|\t;i
09kP\n
09})C
0: =p
0:'E9
0:8\r#8
0:<q6r
0:=Mg
0:HQo
0:Yk\a
0:qg 8
0:zh#;L
0:ďI9
0:ѳn86
0;!AI
0;7zA
0;?aq
0;B1ͺR
0;C8j8
0;Ts#:d
0;Z$D
0;hLw
0;iZ-:X
0;nU\r;f
0;vn2
0;xCg
0< l\f
0<4xS7
0<4~O
0<>2!<kRZ
0<QIx
0<\azJ
0<\boX;z
0<\tw\b
0=!cl
0=>yJ
0=s!N
0=􀒽\ttK
0><[cZUg
0>H8B
0>\bQ
0>\nW4
0>\rg
0?K;1F
0@>1j4
0A+ËȉD$HH
0A_A]A
0A_A^A
0A_A^A]A
0B:;n
0E|;Ox
0FV:6
0G=·l=G
0H+=i
0H;o\br
0H;w\br
0Hq;qj\v
0II;6
0Ic\aIcW
0JV;\f
0K:y\a
0L9{0
0Lck0I
0Lc{0I
0M#o\bt
0M;x\b
0N;shY
0Pr<o\f
0R:;xW
0S,;iJM
0S;BF
0S;\tw2
0S_;f
0To:@75
0X8b?~\e
0Xh:u95
0YL$0ŨYD
0Yr709
0\aba|H
0\eY8(iA
0\fѸS
0\n`E1
0\rD;0
0\tJ= H
0]A^A
0]A^A]A
0]A_A
0]A_A]A
0]A_A^A
0]A_A^A]A
0^;MzP:Q
0_:7r5
0_L$pI
0b!|H
0b!}Hp4
0b1\v0\t
0bA|H
0ba|H
0c1\v0\t
0df=Ŗ\n
0e1\v0\t
0e=;a
0e\\9f
0eɺB\v
0fffffff
0gû[x
0h<nBp
0hU<a
0i1\v0\t
0l:<z
0m;YG
0pU;ͲA
0r\a=FF
0r\r<,4
0s; $5
0sh;K
0t\e;U
0u;6B
0u;ȺJ;C
0w0c1\v0\t
0x%I64x
0x2r0e\v4t8v4m
0y<2\r6
0zD;wD
0zj;V
0}0i1\v0\t
0}<LB
0ġz~4
0ŨXU`ŰX
0ŰYUP
0ŻQ!v
0ż\tk
0ȹq!O:B
0Ϭ8Uh
0҇8,q
0ڼvYмr
0ފ;Rj
0籼d#3
1!;5jf
1#QNAN
1#SNAN
1*̽ Z
1+;\tk<Tt
1, 1))) \nvoid ScatterKeys(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localvals = safe_load_int4_intmax(in_keys, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localvals >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LDS \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals.x = keys[localid << 2]; \n            localvals.y = keys[(localid << 2) + 1]; \n            localvals.z = keys[(localid << 2) + 2]; \n            localvals.w = keys[(localid << 2) + 3]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n
1-8=M8I
1.2.11
1/;Be
1/;hR
100.00
10=`M
119[V
13,<j
14;&Q
15:g7E
18?FMT[bi
18H\núy
19>]4
19eď9 Y
1:3\ae
1:\rh
1:a^l
1:f\tV
1;5`b
1;^u8
1;pOe:f
1<Egd;"m
1<\bL
1<\r2
1<]HB
1<tŨ;wvp
1<樫=H2E
1=hǽW
1=wgֻaQ<O
1=Ϻp\b2
1>:Do
1><pM
1>c\v8>gp
1>vER=\a
1B=!e
1BLQXC?l
1C;pW\n
1C<ID\r
1D8G\buIH
1D8G\buQH
1D<)T
1DZ<jF\n
1F;F碻-i
1FW:C
1G3;yWY
1H;>u?I
1I27K
1IL$LD
1IL$TD
1IL$\\D
1IL$lD
1Iw<C3
1J9rt纀T
1L9O7n8
1M;*S
1N;dC
1NI;K
1O);k
1Q:ay
1T'::1q
1T;=}88
1V";Bw
1Wz<cl
1\\>14C
1\\z9
1\a9x2\a0h3\a'4p
1\n9t
1\t:QG3
1\t>\faS
1b!|H
1b!}Hp,ұb
1b1, X
1b1}Hp,бb
1bO;d
1ba4@X\tba|H
1ba\\ X
1ba\f
1bq}HpԱbQ$@Y
1b{9eV
1e;y\aW
1e\a:^M
1gt;O
1h$:\eZy
1hq<Jp\v
1hq<Y
1i]9{K
1j=\n
1jx;5\bλQE
1kG:y5
1l;(8G
1m><uE
1rE;k
1rd>y
1t\t9
1tں&s
1u0;t`b9
1wP=%Id
1wX:<n
1yD{z
1{S;c
1{q;kq
1|U;eG
1ºH=58
1ûZ\a\f
1żah6
1˻UEV
1ֻ\bC6
1ֻuQ\b
1צ;zoR
1ٗ<V7\f
2 ;k/p
2!:Xs
2"A:j
2+=-tG=br
2,S;TS
2.17.7-alpha.1
2.8OVd
2.=jiD
2/x;Oq
20:WϽ;3
20P@hD2B>F>H>J
20l;g
21];ZD
21a;?H8:6
22:RNz
2333333
23=Dͳ=\tJ
26K;$N
27:ȵO
27<AFK
27O;P
29&b\f9
29[yi
2:6W\v:3ľ8
2:F_b
2:L`o9L
2:YFk:k
2:b=m<f
2:gDx
2;*l8
2;0"e
2;7i̻C
2;TiJ83CR
2;Ue绳w
2;\bT
2;\bZ8
2;` w
2;arX
2;s=2
2;sNL
2;vM\v
2;}w5
2<2\tźO
2<6r⼐kz
2<D@L
2<KB\r
2<j)i
2<u\bt
2<vdR
2<xD2BNF
2<۽CK
2=i>3
2>~m6
2>ʚo>J2
2>۽vx
2A;sZ\v
2C\t9U
2DE=au
2DigiCert Trusted G4 RSA4096 SHA256 TimeStamping CA
2DigiCert Trusted G4 RSA4096 SHA256 TimeStamping CA0
2E=82R<d
2Ee<pI8
2Ej;?l3
2F=\f
2FҺ^J
2G8ƶy90
2GG>!B
2I;"bA
2I;\f
2J\f=Ԉ2
2Js;~n
2Jw;r􈺅Tb
2Ky;Un
2M¼\a\e
2Q;rf\r
2R=\fӽ<au
2T*<6
2TK;>nE
2T~:CS\b9
2Tлl8
2U1<J
2V1;(%v
2V:ϥC:M
2Vv=F
2W">`92
2YL\a|Ģa
2Y|2d
2\a<K
2\b:OZ\b
2\e>vc\a
2\e\v
2\f:p4q
2\f<1W
2\n[:S0e
2\rp\f`\v0\b
2\rp\f`\vP\b
2\v<X\v9
2\v=\n X
2\vL$PL
2]fQ\t?5
2^˼78
2`ġJYt2d
2a\v:)YD
2b!<HY
2b!|H
2b!}Hp
2b'>Q8
2bF;y
2b\b<Z
2ba}Hp\f
2bq}Hp
2dh=(X
2f<w\r7
2g/:G
2h9sp
2http://crl3.digicert.com/DigiCertTrustedRootG4.crl0
2izj|4
2jG:z
2jP;3hN
2p;V+n
2p</MT
2r*9U
2v6r8
2wx:rd
2xk:F
2yY9u&U
2z<#k
2{A\vDcC
2|8Et
2ǼzSO<n
2Ɉ9dcz
2μcRƼc
2ֺ8WG
2ٻZᙻmg
2ݺv>F
2捻rF2<f\v
2蚻ǰV9NJ
3 :\v
3 ;4T
3 H=t
3!y:G
3$m<3
3%0=9
3%I;wDb
3%P;Ul
3)ƼkWy
3*V<gL
3+r:ߨ2;Qq
3- =cO
3-:MPN
3/C>R
30;th
31<(M
32źs౻a
333333
35i<sC
36;3\vR:Y
36A;rn5
36`=s\b
37ܻ4h
38$Dk9
38(3q;τr
38:\vk
38;qwZ
38غ%F
39.6v
396js
39\aq@;4
3:8me
3:JpV;l\v
3:}3w
3;&vh
3;7\bS
3;:HF\a
3;CScs
3;TWɻs
3;\n N
3;\tTʺK
3;atH
3<!lN
3<Cܮ<WP
3<dF\b
3<dU\r
3<y8B
3=:w2
3=N\f
3=h\a\t
3>4A\a
3>N;kU
3A-;w
3A;XI6
3A</a
3A\a;^ᇻ8d1
3BڼlxǼG
3DC@H
3DF@H
3DG@H
3D{7ýt
3E9>l
3E<tF
3F:Nڂ:4m
3G*=1
3GV;VL
3Gܻ\r7
3Hc\f\bH
3I9)ZZ
3I:OP8
3Jg;d
3L:<h
3L;2V
3LA<n,\e
3O<qoW
3OIX:0w*:\f
3P=\v1`<ci1
3P>=U
3Q;\e/t
3Q\r<n
3Sk>r
3TF<F
3W<HF
3YY:4F
3\f<L
3\fW;T
3\n=Fw\n
3\n\t;Q
3\r<p6L
3\tD$ H
3\tD$09G
3\tD$0E3
3\tD$0H
3_<2l\r
3a\n<ZB
3b,;V2
3b1|\b
3b:NSm
3bA|H
3bad@X
3batHX
3c*:"u09\n
3c,:KFӺv
3eG<rb
3hZ;\aX
3hi:٢b
3iD:P
3jȺ!eX<ܻV
3k;'N4
3k>Sgq
3kg;iX
3mo=EX
3oƻrn
3q;dŦ;E
3r=:WB
3t::T
3tD;\a
3t\b<kg
3v9\\sZ
3vQ:6˿;O
3xźOH4
3y->W
3zϺqh
3z꠩7Z\b
3}b;\nCR;eL
3~:yS
3ɉD$8H
3ɉL$HE
3ѻNgQ
3ѻadl:e
3҉T$ A
3҉T$ L
3҉T$0A
3҉T$8H
3҉T$tH
3ҋD$(Mc
3ۉT$HD
3ۻD\vb<N
3J\n
4 <(Xx
4!<VE
4"4&N,N2l8 :\t
4"T:PD
4%V<2u
4/bA~\b
4/bbUH
40<k5
40{;N
41<zgE
42:|\fv
42;YAg
42B>F
43b!|\b
44?:S
45X9.H0
469;}X
47;0^68r
47\b=x
47bA~\b
47c#\e
49G%\a;bi
49HoKC
49u O
4:HmݼH
4:bFܺ7F
4;,Ip
4;K\v\b
4;Y/l;\n6
4;\nCs
4;bA|H
4;bBu
4;ba$@X
4;mA\n;Q
4;qH+:h
4;t }956
4;ʼuc\f
4</fb
4<4;ZvջA
4<6>8
4<>\v0A
4<G,ӼQkj
4<X8A
4<YP6
4<cZ44<\t
4<k:F
4=7#=5Z
4=D}Q
4=HH3
4=\tJ
4=rUľ}p
4>%4m
4>3RO
4>5IF>_X
4>PQ\a
4>b!L
4>v<r
4@=m0\r
4@bb}H
4A;!q
4B;$y
4Bo;n
4D8l$2u
4G3<%E
4GE:m
4Gbr}H
4Iڻ/A\f
4JB:킩8
4L廉zN
4M*<e
4M8Y?6
4M<D\nL
4N8=C
4N;Y*\r
4NŻ|6\a;s
4Q<\a8Y
4QY=M
4R):wvҺJ
4R9\v]5
4R<K3
4R=i7
4TԄWak>E
4Uʻa*w
4VR=ޗp
4Vc70d
4Xϻ7cu
4Y,96r
4YL$`ŬYE
4YM`ŬY
4Ym ŬX
4Y̺Dis
4Z\n;1
4[<WH
4\\i7n
4\abq|H
4\b6\n@\f
4\f<z<K
4\f^;mS
4\nbA|H
4\r<0Li
4\r>v
4\t<QU4
4\tbrm
4\tbr}H
4\vb;_Y
4_Q;2
4`q9P\r
4a<S\aF
4b;<l
4bA|H
4bL<dM
4bQ4HX
4df<W_9
4e;[h
4g<k\a5
4h:oW\v
4hG<"0
4hT<\r
4http://crl3.digicert.com/DigiCertAssuredIDRootCA.crl0
4i9CdS
4i;w9
4j;6\t
4j\v:\t{k
4k!:C8
4l;G{f
4l<\nt
4p:jCH;y
4p[7w
4q<+3U
4q<+l
4r<ܽ˽Sx
4s\b>Z4ԽO
4t;3u\n
4u9Ig
4ve;x
4x*9S
4xt;ђ9
4z<4/Q
4|λ8YŻ8
4ӺVڅ;p啻pW
4Թ:Qi
4ػOz\n<rg
4ݯ>28
5 ;=dU
5!D=6
5#:r\eO
5#\b<Yt
5%9ZKK
5&b?B1s
5';Z4\f
5(96N\r
5)m:F^k
5+;ruL
5,O<w
5-;e1
5-C:r
509;k
51+<Y
51:`k\a
51:sk
54;Djp
55M>vG
56*;n0
58\ej
58ٻ\tx
58ᓍ:紻92
59Z;\et
59ZEz
5: ]O
5:'4o
5:/F1
5:PAY
5:\vqY
5;+,v9C\f
5;6\r4:u
5;B\\c9
5;D\e
5;X(o
5;e5X=L
5;f\b
5;kc1<4H
5;n4b:\n
5;om컠\v
5;r\vb8hr
5;}SZ
5<FE.:TP
5<[ E
5<\f>лuxk
5<^ZA
5<e+L=H
5<eB0
5<m(3
5>'MX
5>cQW
5?5=A
5?l 6?#:7
5@D;OJ
5B:\b
5C3=f3
5C;\nN
5D0<dr\f
5Dۺvg
5E>haR
5F=4u
5FB;[Jz
5FM<5tE
5Fj;q i
5GJ:ʍg
5J;҇u
5JO<s
5Lv;E
5M;j2\f
5M\t;O
5N9t.y9
5NC<Dz
5Pһ\eM
5RC9!Ŵ9
5TK;c>d
5U!;Y
5UC7֚A
5Ul<"V
5V9;4
5V;'di
5VӼL\fl
5\aS<c
5\b:yώ9
5\bY:hǱ9P
5\e=lOf
5\f4:T
5\nJ:U
5\nk=e
5\v;hag
5\vʻ_2h
5b691n6
5bt;\n
5cI<S
5e"=k!z=Y
5e:)N6
5e:\t
5h5<d
5http://cacerts.digicert.com/DigiCertTrustedRootG4.crt0C
5k>\rW\f=v
5l˽F{P
5lԽLX
5m8>8=t
5n:"f8
5n<<99Q
5o< I
5pME:i
5q1;R
5qB=g
5r:Q}4
5rv;S
5s0;B
5t:\\K6:U
5tĻrD
5w<6A
5xA9E
5xF;+gE
5xm?\a
5x¼@E
5{˻kN
5ºs0\t
5Ǻ033
5ʎ:Y5
5ʻG]9;a
5̸n[λNuM:9B
5պ91n;h
5ڹ\nG
5ڽp3Q
5ۺ:Q2
5蝽,4z=Fks
6!x<0R
6!»Br
6$)2Az
6';pIY
6*p;d
6,\f>brg
60u\rA
60ÜZ{i
61f;\tMK
61̼M\n
62F;u
64ι_e\v
666<jHv
68^dh<f\\A<2
68tGS
6:%Q6
6:;Uu
6:C8*;acy
6:CI1
6:\v\ae
6:enZ
6:iSB:V
6:scM9
6;!Iz;p
6;O\f\e
6;\t M
6;hVH
6<'(4;nAK
6<,|n=XQ1=3Y
6</in
6<2wN
6<Pr3
6<\to\e
6<cNx
6<k\rP
6=3D\a
6=4iＨxp
6=K웼S
6=X t
6>D\rF
6>v쓼L
6?<Vj
6@1<8
6A$:r
6C9>L
6D:\a_O
6E:Eo
6F#>\ff
6F;Dd\t
6FQ=47
6F½{o
6Gg;E.C
6Go;\v
6H<=Y
6I;uBV
6Ix=5
6Lc;R
6N<? q
6NK>\e\r
6OB,n
6Rɼ<X
6UļVJǼ1Hۼ42
6W绱}d
6X[;dIR;S
6Z_;4
6\\\e<Va7
6\a ;c
6\b>s
6\e;+C9
6\f9<'L
6\fA=\e
6\fXO>\ntA
6\fw9
6\nR<u
6\nܼt
6\v;r45
6_8<u
6`h;C
6`tl:hO
6a<\erb=6
6aR;5
6aͼ`8F
6b!F\bX
6bB;n
6d;zܩ9j
6d<HMr
6e;vu
6e}:}Ru:t
6f&;Y
6f?;\vu
6g=$Y
6gU9f
6iZ<vb
6iӻ`wh
6jG<,Q
6ko;T%;j
6l8\eQ
6m:\e
6mZ<DgJ
6nB;r\v
6nd<f
6oh;\f
6p7MOf
6q;fUR
6qO<F
6r9 5
6rǻ Y
6t:$2t
6t;FY
6tX<\v21
6wo=e
6x<Q\nX
6ys\b$;o
6yк%S
6zz<c
6}3= 5
6Ó;pC
6Ƿ;L\v9
6ͻqy"<3
6κj侺*Es9
6Ҽ46Żvt
6յ;vH
6㔻>SS;9
6璻UAۼU\t
7 :IƝ;du
7#bI;nR
7$\eD:g
7%;+xe9
7&n>h\fn
7'\a7=A
7+G;C
7+u:PH
7,;UX
7-:Zu\n
700WP\a
70:Y@4:I
70?Hz\e
72-<f\e
729:g
72L=L
72r=AY
73<q\f
75AJ9\n
75{V:\n
77;tc
78`_:V\bx9
79$畺3B$;E
7909b
79?G8
79bp\r:(L
7: 6J;@75
7:!8J
7:!X1
7:<7L
7:LRιr4
7:Z-f
7:\nn89
7:qZ9
7:vbA
7:vrt:0
7;%La
7;0\t
7;B|Q;R
7;l\n\t
7;rnպu
7<Q)5
7<RLK
7<dDW=v
7=7gS
7=<\ey7
7=\bK\a
7=dUt
7=wRj>K
7=}Jp
7>HֺBz
7?Լ\a3t
7AP:!o4
7BƼ|o
7BھXSB
7Cu<d
7E>9Lo=d
7F!;E
7H9x\fY
7HcD$(L
7I3:\b
7Ld:I
7PR;D)k
7Q;E#i
7Q<F[l
7QC;\v5n
7R[<` p
7S>;s
7U:;X
7Uʻ/c
7V;g3
7Vmq:w
7Vӹ'Zt
7Xd<ηz
7YJ;~V
7Z1|9e
7\aǻ0Y
7\aɼ=KC
7\bu;C
7\e:Y
7\e{U;n
7\eջ1
7\fؘvOV
7ae:%z
7b!|H
7bA~\b
7bJ;C7
7ba|H
7e:\f
7fi9\aYG
7h[;\e7
7h\e1;V
7http://cacerts.digicert.com/DigiCertAssuredIDRootCA.crt0E
7hz\a
7i:lp
7iݽg\v
7j,<KDa
7jnj;D
7mh:h
7n?ǺM
7ni&9N
7nuH8
7p;f 3;q
7p<<xq
7q:42i;a
7q;8\\y9
7s1<R1\a
7s\t0
7sƜ:\b߉9m
7u<NT\a
7ur;yI
7vf;AJ
7x<\n
7{KV\nU
7~:\nTW
7ƍ;hND
7ơ<AY
7˺8`89\v
7˼*Es<V
7ͷ9kD
7φ:U9ֹa
7л<wH<v
7ӏ<H8Ȼ2z
7Ս<vZ
7ݻJ\e
7ޗ<b\eE=Ys
7릻yFF<m
7뻆\bڻ1V
8 V<bz
8"&08l
8#J\f
8#Po:M
8$ $9D
8$v2;E
8%h&;gn
8&#89K
8&GS9
8(Wһj\e
8(\tC;B
8(e=E0
8)B\a>8B
8,3M:QN
8,\rk;S
8-Z\v:H
8/;in
8/NG8
8/Uĺ2
80d\t
80pR<pIQ
81!;cr
81;*^C9~6B
81Eɻ~\vc
81¼R9？h
82AI9
82˦9R\r\n
83:aN
83;9M
84<HAJ
84XŹ7
85<ιL
85G<r\a\f
86:u6
86;rJ2
86>V9\f0
87t\nH
88/\ve
88u\bL
897}:I3G
89H`fD
89Z6{[u<;w
89\\$Pf
89\\$pf
89\n0w
89t$0fA
89whS<\v
89|$4
89~n0;h
8:1%Z;c
8:6,:5!m96
8:;dd
8:OBc
8:\bc\t;n
8:b\eg
8:dIj
8:q\t\n
8;'qw
8;)xV
8;3)D
8;5G\t
8;Bt::gW
8;PBA
8;W:p
8;XM8
8;\a^9X
8;e\b:U
8;fy3;r\e
8;jMa:aX
8;mH793
8;o.v
8;q`9:\vT
8;w{s
8;xNw;m
8;yHc
8;zsM
8;zʭ;of
8< .f
8<A?5
8<TYf
8<\f6t;͚T
8<]p3
8<aik
8<f<f9
8=#xѼa4
8=Qsg
8=RY\t
8=XPfA
8=`PfA
8=hPfA
8=pPfA
8=x$5>Y
8>9:k
8>G2\e=mf
8>\ew\t
8>c\eքBC?>6t9^\tc
8>~08
8?oЈ>Vc
8@Hd;L
8A;\b;f0
8A^A]A
8A_A^A]A
8B"\e<l
8B+59&pt9
8BNK:Z
8BYV;Nٰ8
8B\r=[L
8Bh\e;\eH
8Bko9f
8C0u\tI
8C\buAH
8C\buGH
8Cj;<s
8Csinf
8Cؼ}98
8D<<2
8D=V;C
8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA1
8DigiCert Trusted G4 Code Signing RSA4096 SHA384 2021 CA10
8G\a\e=\r
8G\buAH
8G\buBH
8G\buGH
8GdH;z
8H;E!Q
8H=E;y
8HS2:A
8I*\v
8I?=&UN
8Ia\n;u
8IջO/0
8J\f<qJ
8KyD9
8L$ܹz
8L:{r\f
8L;x\b
8Lck0I
8Lcs0H
8M,;Iw
8M;D$0u
8M;x\b
8M\v;X1
8Ms;\fTf
8N>u\e[>e
8NG1:'}\b
8NS`:iVR
8N\vɻV
8PX\a\b
8R"L;x
8Sf<\ap
8T$Ht\fH
8U)zj
8U;\ncN
8UL<ޭ\v
8UUUUU
8V;ŹR
8Vk;J
8W;2o
8Ww;z
8Xüy\f
8Xċt$x
8Xޠ;VY\e
8Y3<:fc
8Z0Ļu
8Z6\t:m
8Z;y\v
8Z=M1o>C*0
8ZüK|G
8[yǺTq
8\a;s
8\aj躥$u
8\b\a
8\bg88ew
8\eIN:7
8\eQq7
8\eǻZOp
8\n<[Hm
8\n<_Dp
8\nӺyqg
8\t'0:_sd9
8\t:^9U
8\tpw9q\ee
8\v$=KO
8\v?m9y
8\vؼ"72
8\vߺ"S6
8]:\vo9
8];f\nB
8]A_A
8]A_A^A
8]A_A^A]A
8]ｾxD
8_9"3a
8_\bu?H
8_\bu@H
8_\buAH
8_\buEH
8`gԸBt
8avu\rA
8avx2u
8avxiu
8b!|H
8b!}Hp
8b!}Hp4
8b2ad69f899ca0710f94d10303a2f02d7426faaf
8b:c{p
8bf=`a8
8bunz8
8bwE:O
8d;k活^as:L
8d=?9Y
8d>:v㐻Q
8e:u:c
8eY<L
8e\b<kw
8fޗ:Gؠ9
8g=ʹi
8gnu;!~N
8h;;R
8hВ82Pa8
8iV=ˣP
8i\a=6x
8kqp;H
8kz[91
8l$8t\fH
8lA99c
8m+:it
8m5йвd
8m:StY
8m=OSb
8n<PnZ
8nݹ>0r9
8o;EIJ
8o_9^Q
8p4[;=0
8p6y:\n
8pb0;S
8sse3u
8sse4u
8sse4u\aA
8ssseu\rA
8ssu\rA
8t;e13
8tR/;R
8tZJ;P\tV;E
8u\e:tf
8u{b;\b
8v?Q:X
8vH<\vPZ
8vL96W
8vL;\bX
8v\tۺZw:J
8w(;s
8w:]C2
8w\bu?H
8w\buAH
8wpv0H
8wع]x
8x;\e
8x?I:z
8y tmH
8zq(;X
8{\bt
8|$Pt
8|$PtN
8|$PtP
8~!tKH
8»MHa<L
8ÐATAUAVAWH
8ŻqGx
8ɺUr5
8˺8hC
8˻ë99
8̮e9\tL
8̶9)o
8ʹv72
8֖S:VX
8ֽwSt<R
8ؼI7\r
8ܧ9lM
8ދ\b9
8ျ\vJr8p
8ṉ;4op
9 ;Ԣi;O
9 OҺ]ej
9!6N:q
9!AF:\t
9!r9:U
9"2ԺEH0
9"]Q;tY
9"o&8+Pj:4T
9"ҼrB
9"٘;rBI
9#WùWiC
9$x[<Ac
9%/C9
9%?9j
9%B<2$c
9'I:0F
9(D>O
9(e;aP
9)eA:ڧ2
9)v<z
9*K:r
9*QY:\a
9*|G<uG
9+l\a
9,c :\a
9-W\n:Vk69
9.}c:Mi
9/5i:\a
9/Q 9y
9/x9l
9/}M9u
90-\v8B
90;Hc
90f#<0hm
90|ƺU
90Ì;yK
90ܳ:0?j:Id
91#v:4
91C-:a
92$n9c
929ںOD
92;d\tr
92<T;v
92B;F_k;gl
92B\r;F
92_J8
92i;9d
92ճ:fp
932;A
93;fK
93R;\a
93Y\e;'t
949^;2
94UzPW
94ݻ31
951\t:J
96;MC\e
96<Ns
96K"<i
96VR;v
96qe8
96ލ:ͤa9
9738;L
97\r; AS
97d]:=w
97ڻZB
98/ºza5:B
98VŻ^I
98Wdu
98m:$J
99-9X
991%ڹ\b\n
99\bS;.G
99\fu:U
99fɹmL
99q\a:a
9:R\r?9
9:[i59
9:ck\n
9:rM9vG
9:rл#\tV9
9:x\tK
9;&QH
9;)NN;k
9;3V;\fV\f
9;7Nz
9;\n;jk
9;\va:4K5:`iX
9;_\aS9iY0;0
9;a?9
9;jm7<Cp
9;m_J
9;qtE
9;|P;eW
9;|\nHcC\bH
9<'md
9<)M72
9<1*:F4
9<1;B
9<90o
9<H8d
9=8H;J
9=\tuȼp
9>=N9
9>LXN
9>uQ[;Y
9?]X9\v
9?m8:7
9@@Y9ZS
9@We:>5
9@\nY9
9@мYF
9A';o
9A\b~6Hc
9Ar-:{f;9
9B J:s
9B<\bI5
9B\ef9
9C\b~)D
9C\b~4HcR\bD
9C빔Zƻm
9D%W9
9D*\v
9DBu9
9DE\f;aUF
9D\t/9a
9D_\v:G
9DgX;STU
9E,E:G
9E;3r8
9EE.9Y
9ES9\n5c
9E\b=B\t
9F) 90
9F:cJA
9FF>\\d
9FHtJH
9F\bt\fI
9G:P᭺\e
9G:hO
9G\bt\vI
9G\vS:$f)9
9Gg:m\e
9H7&;1
9H;CPv
9HPu9*ms
9Hn%:U
9H}\n:5N
9HŻyTw:D
9Idɺu
9Ig:Y
9Iڢ;LN
9J;N3W
9J>t9
9JHi:w
9Jk<jw
9JÊ:j\v
9K :#R
9K%{<0lj
9K-R;ys
9KG?;GD
9K\eg;C
9K\nM
9K\r:a
9K];7
9L>bN2
9L\bF
9Lj\f
9Lڂ;U\ag9
9MI+;{C
9Msd87
9N%|6
9N7w9}G
9NIz:G
9N\rC9
9NeغVb
9O';S
9O5S;q
9ODp;l
9PSc;Y
9Pa]9(,H9
9Pwָ\b
9Pʫ;A
9Q.ȺPE
9Q4:)I6
9Rp:k#\n
9Rͻ:P
9S1ֹAC
9S7]d
9S>K<C
9SP<Q
9Sk\n
9Sz\e9q9
9T1[:}LQ
9T9]:x
9TF;loQ
9U9¹eO\e9
9U;6[v
9U;\e
9U[C87
9Udչm\rV
9V<7;Kt
9VBA;2
9VL;W
9W!s;{m
9W6!;x
9WQ;DVԻ\n
9W獷mf\r
9W裺Q>\v
9XEC8Ii
9X\buwH
9XbN:9R
9XɹyH
9Y$v:D
9Y(1;bk
9Y_Q8
9Z3ʻeG
9Z47<75C
9Z<;Dp
9ZQK9J
9Zzɷb
9ZӠ9i
9\\\vh94
9\\dk9R
9\a><kY
9\aXN;m
9\az;bpj
9\b4B
9\b\ed;\b
9\b\fT9T
9\bqm:z
9\bwn
9\e:H
9\f;qK\n
9\fyͺR
9\nd7
9\nh_9I
9\r\tp
9\rz^;5
9\tRD
9\tx&;z
9\v j9hKU
9\v.S:V
9\v:x9\b
9\vFz9v
9\vQx
9\vde:U;:t5
9\vhe
9\v~8
9]!/9\txD
9]\am
9]o?9]o
9^ t"H
9_hs'H
9_ns:i3
9`C;No
9a*p:\n
9a,\a;Z
9aw\t;RA
9b!}Hp
9b;nj1
9ba4 Y
9ba|H
9bdt;vCb
9bl-:3l
9br%<7
9c-d:7
9c-m;A
9c\\99E
9csb9w
9d;e4
9e9O:e
9e:\rf\n
9et~;l
9e{\b
9e|I:P
9f.X8\a
9fQT:q
9gN>9N
9gfr9
9hG5:f
9hPJ;4
9hU<?km
9h\\F
9h\b9
9h\r;\alS
9ha\t:j
9i?>H
9iL$:-p
9ia{90
9ih\r:I
9j;i}W
9j<\e;9
9jK;Tl
9j`M;p
9kB\b:F
9kEM;v9
9khO9ad
9kv\b
9kwͺAB
9k{I:c
9kO[x:T
9lDŻط\f
9lt\e6
9m2?<W
9mN캘UQ
9mP/:U
9mRӹ\f
9mXZ:L
9mu8;#q
9n4\t:T
9nD=wD
9nT":B
9oE#9
9oF-:p|V:6
9oF\v:I1
9otx:7
9o|;967
9pS[7z
9p\aJ
9pfM:(\e
9p}\v
9q+B;nn
9q;tx
9q\aڻs:\t
9q\r8;$V
9rcE9V
9r~?9
9rļ8,w
9s\aԻ{O
9s\b~63
9s\vY:n\v8
9s`A;L
9t$Pu\t
9t$P~58
9t6%;w
9t:VW
9t:qY\n
9tL)9'e
9tVK9
9t\v96
9u@u\nH
9u@u\tH
9uve9
9v J;*0
9v.ƼS%B
9v\te9
9v\vE9M
9v\vz
9v_u;h
9vg@:A
9vů9tH
9vԼR5ȼri
9w3/:ͥs
9w8=H\v\n
9w9\t:lϏ9
9wPA:V
9w\bt'HcW\bH
9w\b~tL
9w\eS
9x,<dy
9x9;P
9x>\f
9xxr9SYo8
9yH9B
9yI?:r-ȹm
9y\b~\\Hc
9z8OH
9z\e5:{K
9z\eպ2
9zmp;oH\t
9{ M9Y
9{6r:u\n
9{\bu\b9
9{\fu\t9
9|7[9Uu
9~0t\vH
9~6ѺJ
9~C:9
9~D1;d
9~\tD
9·L0x:b
9ĉA:q
9Ļ]1q
9Ż;Zb
9ƎD;7\e
9Ƭ49hky
9ǘy9&\rw9
9ȮB80I
9ɖI;gu
9ɫѺ4t
9ɲi:kJW
9ɾCF8
9ʁ:pAv:3
9ʙF;'Aa
9ʚ˺GV|9Q0
9̔E<c
9Ϫλ iX8
9Ͼ1:U\r
9ӽr|ȽT0C
9Ժd=m:r
9դ?89
9ջrF2<J
9اB:J
9طx:9
9ٽ2Va
9ݙ-9X7
9ݶg;H|U
9ߛ?9F
9ߟ=x3
9ờy\e
9鷬9>H
9:Z\tI
9:uXQ
A :\a.L
A ;\f\r
A \\L
A \\g H
A"Yt/4
A$¼1b0
A$ƻP7
A'i:E
A(H+A H
A(L+A H
A*D;iײ9
A+=p7
A+]0A
A+_0A
A+}0A
A+ƉD$hD
A,8`e
A,ba~\b
A.5<sx
A2a<\\w
A2ٸcʞ8pm
A5;"f
A5g;e
A81t@@8r
A86taH
A8<$u~M
A8@0u\fH
A8@0u\fI
A8@0u\tH
A8@0u\tI
A8A0u\fI
A8A0u\tI
A8G\buBI
A8G\buGI
A8H+A0I
A8H90t
A8L9 t
A8L9(t
A8L90t
A8W\v|$X
A8z,u\bH
A8{,u\bH
A9(݊9\n
A90~(3
A99R\fH
A99~*3
A99~6H
A9<C;\e
A9D$\bs
A9F+\e;a
A9P t\nI
A9\riֻ5
A9}8~,H
A:HBι5
A:\at\vI
A;2#z
A;>M3
A;>VP
A;E8v#A
A;Exsd
A;H7,:x
A;Jk\a
A;W\e
A;\aʆ93
A;\e7F
A;^Pc
A;czC
A;v<s;Kq
A;|$lu4A
A<$90
A<GfS
A<GmO
A<HrH<\a
A<l;5
A=!U༾JL
A=:t9
A=\ews
A=\rw
A=cT9
A=k"N
A>{rS=t
A@K=q6I
A@Yt$P
AAW:uk
ABCDEFGHIJKLMNOPQRSTUVWXYZ
AC\b<\bU\e
ACh B`z
AC˹Y&2;C
AD4<;tH
ADVAPI32.dll
AG:^3
AHH+A@H
AHYl$0
AHԻgɬ;q
AI(9%s
AI99C`N3A
AJ9"ݬ:R
AJC<w
AJL$PP
AJL$`P
AJ_n$ŘT
AK;Hv
AKZ<X
AKi;)lr
AKn:h
AM:am:PM:pm
AMFInit
AMFQueryVersion
AN;`U
AOڻUx
AP9\f g:O
APD90
APD9\b
APIName
APIVersion
AP\r;li
APi9+\a
ARI SOFA API for Matlab/Octave
ARY\\/4
ATAUAVAWH
ATAUAVAWUA
ATAUAVAWUH
ATAVAWD
ATAVAWH
ATAVAWUH
ATVU`E
ATzYuW
AT}9dI3
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree
AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$03VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$03VAccelSet@embree@@UObject@2@@sse2@embree
AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree
AU?$BVHNBuilderMBlurSAH@$07VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AU?$BVHNBuilderSAH@$03VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAH@$03VAccelSet@embree@@UObject@2@@sse2@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AU?$BVHNBuilderSAH@$07VAccelSet@embree@@UObject@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AU?$BVHNBuilderSAHQuantized@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AU?$BVHNBuilderSAHQuantized@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UObject@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$03UObject@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeaf@$07UObject@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AU?$ClosureTaskFunction@V<lambda_0257928c69f3ca6a7123b06d6f3b7ad5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_02ef727abba9baf050cb44766040526f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_050b646956caed7fdaa67b1d4ef38836>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_05b090693c19e65375dfc04e4614d831>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0770016c8ad601d2b3ee9869de84d45c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0773d8b51a03587d5ebba0f0babe1c61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0810e6a1c682feee9e21662b6d5895fd>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0ba0f6951c95034592039939e46e6adc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0bf7e7f8026686a4e169d2a2a3fbc284>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0c8a48911d9bc79b5f63ab68fda175d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0cb4938c3329244fdc7d28e8b68531d8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0d9816577c66ed0e5876af74f65ec1db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_0f7d48f0f13c849ea2f5d5d06cc32f61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_103b8eb5296c081133f5f0633a6e0f4c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1070d15b2e0a459f12353442e1087446>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_10bd3097dea0ffc4d7ea5f99aff55ff7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_10edfa8ff134489e84f7d6842fbc9e53>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_111454f9162f4fd44ee79f232ea41ce6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1159125f07c0da4d1ef4a077b779c95d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_123bfa89286d9a69a48a2507fdc91ec5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1393b5adec419286175685534c302c36>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_142286e99081977ea9b431b977dc397b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1465822f4afc21711940feab4a96b609>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_14a2b0a7490cecf62e5c1db7e187e003>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_15c1675cce59426cee48e7d3701830a1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_16bd739913477f65c3b295a4a9a3f780>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1754c6088f7d2e7d8e5d85049ea46eeb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_17d4f0c18989a074d0b73f3e32af3e2d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1880cd30ca9875de576e86fdcbc9aea9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_18b6e499d28522ad747e42f02fe514e1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_19a60362099440456374c87deae05897>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1a2ec9725e19309b34301891f7ef37e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1b881d296a37095bf2ba4916f5766bb9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1b963dc7c01448ed9caf0d427c40482c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c483ea2f1582478c6c36bcdf50a5ac5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c53c660fe2e31e74957829702466677>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1c7d7fa76e2ecd4691d00f6774bb98cc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1d3d46b83459c751b5a1d3866bac4d84>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1de437dcfdac90722fd45cb17c885504>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1e4859f33cc101bb139d2d68512ab37f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1efb61c2450c0d64b50121ed4ccf7512>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_1ff75bbda1119736a8ea2bffa74f1117>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_203168769a8752ed39c0084eb5e0f86b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_237a8dac36ab9cef0f09490973046d65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2564acea42ca70f5289378535b1a5fda>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_25818e8b46e81478b20a71647dce67b0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_25fa0f05dd69fd0fbb5d98e1b9f22a17>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_277246a1dad0b789de0a5bf300615a69>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2785e509a66b39750953fa2172977bc6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_28ab207b4a4cae8f2a329ddaaa8347ab>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2983dbeae842cbca40c80bf7c793ff50>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2bcfad3a1040075454eb8c492a4817a1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d19c8f57b057314e1eba0879795a2d3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d4f244b7e192fa43e226589d452c701>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d7849d795cecafc716deb9906d0679d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2d8b8f927bcf3f56c8e097fe75fb6a9b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2eebba4634f99d4722efcb197e612f81>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2f1a84cd769cdaf119ff64e0db1ac73f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_2fd1025fa3c16d025feaa7c82cac6e45>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_30292f8def386cbd3ab393de8852bc8d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_307a912a967dbe18ca3d867cf49db7bf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_30da547d4d136440398053afe6d6df52>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_324f8f85fa5a734b0d69e373a8615fde>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_333cd141d30f0c3d1182719aaba1ca1f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34687d5f8161bf526d0ed813b8bc2956>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34788c56ac2c8d8d43be324f69291a1d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_34f6c0c15de95f59ebc592d1a646999f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_35955c6a6d524fbc4260398ea787ea12>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_35aab39df7b5f8da4606f471a502b4b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_364906aee425af1aee8cd5882b619dcc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_36d192ec4c56e9df0060dbd486f9ba7c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3709d78c9da312d1da6a52b8a7ed02eb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_374c4fe9bc8934a13c1dfba0c8a2e3fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_38b497ee7dde3dad4a2bff651d24f01e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_39ae3cd435bbc28b90f1c4fcf8a9f2cb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3bf6dbbfa27fcd585f246e455d9164d3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3c183140e38f6db62b774fd8bd404466>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3d5e40bb487df58a36c0f1bd0972ce5e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3dc49f9a80eb9d6a2ca9dc4b73f6df9d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_3e52b8c63300cd110fa13ae0b7c1cd60>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4019ef4b11105db1b5343b7f18c18453>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_402a737f13eafe9fe16d70ff6a894992>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_40845830eed773233b2942955217836c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_46f0b9a674db9f12d178d60ec90bd3b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_470e83d3d8279e1c869990724c4026e1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_48756a50904fde6adffda6e05318fa21>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_48eb3204b05163a7edd86df9082ae2bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_493c4fcd97d59cfa23518cfe7cef909b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49431b271f192c26f3d82d74f978add2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_49a55a7560c70477acccc84f560607af>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4af68bccd17ee4982ce6cf6c17df8fb2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4b6cea141daed67a603d8c3129f48861>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4c09c780d1c23c4be6ef9f0906c92c13>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4cf4a25052f797060e3602408b7d83db>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4d1d9e37a82f7399d0daf11b0e003fe0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4d860d2828d694467f37646af49512ad>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4dfaeb055a2848a18e1c2a693664e365>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4e9a920d3a0e8077c04dbbeaba34d69b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_4f52ac6b547d139d4666992287a1d33e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_508d5c5eae2e09ca974019602570497b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_519d6864de56dd813715a3324da6ab03>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_528c6aeae8d7a6235882068fbe18ba29>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_52e835bfebfdf243c300b842bcfbd693>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_55d7d6d7e9c3cf78dc032fa18e0a1756>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_56228ec77c1bf800c98ea10cf09dbdca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5806bf8c82548594d7b14a6031d3becc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_587c3387fd00b5c47d777280f639ccbb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_58a007f1dcfdcf2842a0651c9cf4fb16>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_596624f597bd50de0edc513e65f10248>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_59708c2094bd10121cdb0d0feee13575>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5a4619dfc5b3f52888e410231d1b76c6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5b205f904e6a5e922c78b0780f6595fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5cccc2026c15c9f772dc34068e64dbd3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5ce543f4f6f460823047169427ff959b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5df809d8ba8774c0c3e07d9023dc361f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5e0af431c85d723742ac31139cf4f6cf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5f057fc8dd507ba4420188be12b864a7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5fa18547fd1c49e47f8a1482795f6bfa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5fbae35bffd37dd4454c255c3bfe1423>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_5ff1317532aa23eaa4235a4897d071c5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6076a43db63a4a654b76b3906f0fa336>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_612f275e48608a47fe6f208f6f90ef2c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_61a5893ea96d3e3c22460dd21bc6918f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6208554dadd1a347baaf9698a23260b0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_63774194788fd674aeda94589387ad7e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_63f62a6d4554716cd85d4437cc4e8d6b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_642da8bb02350bf3bc1e2d17da1782a2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_658ade971d81b8d2c4aff7e1c8316fd9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6928df31523de1d77177658324507289>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6972a451ddef89ded0359c514c93674c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_69b60174e657725950226c292dfe8810>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6a1d60d8252eb56aa624ccee38aae3f8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6a9765672699b15200b9e625cbe78fe2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6bd70ec753e41fe9ef52ce2294285ffc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6dd588069b0497955952869d46623054>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e12b1e7ea1c3cabb970d9aad37b880e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e1c069ffa23258a04e4132daf8ae5a6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6e24166b0a6550ce4ca0fd16b21eaedc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6f395463036b9f2ef27cb319ec541679>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_6ffea1e26fc61475c82a269c9412ff7c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_701f58262cbf59178d70f368547d4be4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_70adec8fff91ba581942c3e7e58800bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7137bbdf7501823d38edf36447a4c5da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_72eb2d970ec2715c3cb455dc8b65e700>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_73d76564d82f8824c0d011a96892e820>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7447278d269d570e2d5a575a040ac0d5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_761150a6dbf7b3e8e149529b93d7def9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_769b7396f06b114caaad51b6d1c2033a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_76ecf3bf9e9ee6806f09118ecd9063fe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_791ac13d4d779712e0fc089e446ba11d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7926a52cb91716c6e9c7b46e42baf2b7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7a3f31a682378d6bb22d8b79968ded5d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7a41611522e2560efa455142ae8ae3f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7b832da9ba6e6ec113b237e338498c20>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d52ab0d031b883d77281a985b5128ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d71192f9be9b7b5111bb3afe6336625>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d7b9a8a8418fcb9f2476126aff61395>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7d90ad674d8d89632a4cc3c6a77a230d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7ec6b5632644aa2f0854d1191db4876a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7ec874256f6ac9fb0cb0ccf0b23709fc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f4ecb58a9eca6a896f3913eca50e647>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f688a3c57e8b39313eac45d84608341>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7f891e51f0ef2b3b767c0c2ff1810fc9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7fa6182c81737d0353c54febe17bfbe3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_7fab0ac51a8990f2a7558b9e7bf9140a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_80bba59ad49d13103ad66077542bc181>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_81325ab80d9ffd100b657d78df5f2705>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8139ebda25fc1cb5d72fb097fc720fb9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_82f44bf085fe83988536c56ffe856489>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_83743a4f871b15f1a702394e12997bf4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_84b6c724f2443266e7ce254992f9c5da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_85d19732fb13b56beb1c219db1abe8fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_85d203de33fad9040c2eb1d8e4b12ebc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_85f24a3907079e650ca1db2021e42117>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_866091200b38baa804ebb0acd27cdbe3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_869ce95d276aa5f0e5ad098cae581aed>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_87fc12fb3ccde100f0a609f5c0fd3efe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_881194d5bcdf56d290b5a3890c7a7fd9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_884393cb3e516c3d8a80c164c6933801>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_88815198c2a58dc16ce4c22605b79ab2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_89b1cbae6bac656013c873e1b7d54903>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a022dfc4ff070f70bdf133f193a8ee1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8a6f7d40767aad6609d3ca0b66f1dee7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8aac9ef93071c0774417f4dc8397b96c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8b8d7bdc0350d5ca99ff86da49d813c7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8bb36c840ee4e2d1368a0c16750e547c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c0daac60dcd7ba85b78d65683e249cf>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8c73507aad286028b6059eb192af892d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8cb4b4d8bcabfa96351bf47410136244>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8cc2b536a046cc8ac89776f7a665e528>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8d1805ec003b6fbd327129a9f3a725a8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8d2db962c0f243ae1a45e956ee5728d6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_8f02bd655e3495eac01ecb3adbbea0c0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_90ed84fa9333cdc12bda8b8d14ad8fe0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9152e8397bdc19577a0393abaf1b6dd0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_91742af8957171a092115533b682d41a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9241f93aadcafa7b129d36c659088890>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9249e8aa16a2d29a7983072b56338515>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9385af4936c854d2afe7f028e7e3ee65>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_93984adfa5c9e9b7fdebd37ff069f084>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_93e55b2f7065a3bdd2d2b66c9ba2c1da>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_943576034df25ad54b025192b8cffb10>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_949501f6172a69753cb894e7be6f4ac7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_94fe20416c45f7915d75432d64d9334d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_952ff9f245e0e20c4f4453f24ba87d85>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_95cc731380b2fab9d8d1b177110fb7f9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_963c47aeb0ddb526503fc0f9cb48533a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9648822dc6f816d0211bfcb8628576f2>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_97613cd1c18bf2204ec7d59dd6c2efe6>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_980311499bf94cba279fc3e02d6c8e25>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9adfacac89ae04da373bb2c86bf2e785>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9b9375a65e69303d3d685621f3f002df>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9db83e7e70a7c8ba33a06ed4b85b3976>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9e1b0c1d4f37825716630f67a2282b86>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_9f4ad124d614903c866b98a110355e96>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a1d4ea9e4ba6d18f9801458e384703a3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a23496410d5cc29c9a9a40d5466b2f49>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a3145c4db4c07e91b74a82630ed60970>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a4208c0a8979a608aca52e893a4df9b8>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a44afce2e29d983e48149fa0bd663010>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a473ef03c623ac047962bdb06b5479ca>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a506632a0478e305a2a9e0fb82c9a6ba>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a6934328d76b0f105e91326357ee4397>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a70f7bb15801ea4a0648e665aa087fcb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a7c826f3e82e808a18562b298e752e25>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a7e93f04524f80620b388d6353a1f85f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a8b2023aa1b4d1a7199f8af3bb7763ee>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a8bb5dd076802398bbdb2bb82bb6b808>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_a9d22604637b8ab881820f7262f57ddb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aa2b3d86106154a41df4d9e750d27e29>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aa41b87e783e4d6d1cc483279e07b81b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_aa649782e95517a76fdb98d192cff8a3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ae88fe0c7f2a852c30e9582f143c23ea>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af2efa9cb3646c20724995a52541df4d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af4af31444d1dcf4037a6119b331bade>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_af60c21cc7f286de97aa0bfefd3f4c95>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b02a51061afae8ace83b3547b12602b4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b02fd97c6c7c1a650eb55e6ebd421022>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b15e0bf1a6a3756600ce6412ff604756>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b181c1383ded4db84c53e8c5e12f4607>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b293711f313ff97f0acda51fe2f55992>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b399192e05ed586364e549af91af1089>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b45bfaee1b976145c0498b58fdb3a1ea>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b4cd2aca1bbac98ba795a14d230855ce>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b589f3793c9428fe1b0321ccee3aad61>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_b902b2bacef501b1eb21b79562702b69>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ba11a5935e2a0ad0f5b0151297439f49>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bc5e7b60f199be10075f04536edcd8d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bd1501ca16ab979bb9c6a91264c0ef79>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_bf88c16418418e9d04f2d0a74994d5bb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c0955aedf17321d1ddb93318daf5508e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c0c956f33ac4d840b0f2a78dc9649eec>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c27ccc40853f6653f4126af1f5587982>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c308f3f4f90cb392f9b6a1afdedb8fa7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c5b37c3d4343119f010a70c507f5fa35>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c64ded238af9365da3bb2fb9aa06d2c4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c7a2e929408f0fe05b554ed2e2c60b4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c84049b567c18d000c9f14ffb8574de3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c8c96faa707bef900dff317fab2982f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c8f03e1c48140a7c0a2eb449dd0e1c34>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_c9d47d2a6c0ca0586e511764ee2a2660>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_caa044740ccfe4a6927e4afa964b7a53>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cad120d6a3f256d13fe99516a5a33a8c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cb0b673290f3ffb7b0d9066c6ab85b20>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cb2120e9b24416c3e735c0fc7b9a22cb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cbf0e018a22e77e1d8203b6989d4fc50>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cc0550cacd0e26dcbee934735dd7c566>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cd65f27202c6944bcdb92cd324393d2c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cd91ae3365950228a915ee058c35cc6f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cdb8465e765f90309f597d7a8eec059a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_cfb4df5bdda74f8f01e37a4dd9fb02fa>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d0248521766bdb5cae133d7e4133acef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d14f8e6bb372a4f82c01d529ef8f6797>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d1aa5966c6b0f9baed433e5ae134fd3c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d232ccb9559db976d92b550558ba6081>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d4625f1e524954737e1c304658606ff5>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d4f8a24a716d3c865e8f813376763d96>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d583195d41bb96e6e15f56bd9b10e414>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d8bf7531551fd906ae24fcffe76011e7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d971ad00998fa48a17bd80b22f7660b9>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_d9f5ab55c39609572c638d6b6428a7a3>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_da96c3ac85e55a41a8750c63c7ce8537>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_daf5afdcf783a7225068096e149dd869>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dc0fc851e427b8494ef13afc8d0ebad1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_de581c8ebdd980d24c86cbca4215513c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_df9052d790dac606cf5a47c9d876c608>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dfcf2bb000bbe6dd33de7b65de01cf43>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_dfe97666f81a8a9621776384ff25b219>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e048fd7cf3385f4678eccd267ef05d8b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e0518c94692270d68a8bc445c176346d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e0cd4179ccb986fe30e51c91dbfaf4d7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e0ebd27de42e56945aa333f9c23150fb>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e150f3251fef807f4cef8bf9b86ebe6a>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e16a78992ea44989935f19163566fc39>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e1e7cbf5942d94bfdd4d5b63d6a8b060>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e2be729290318259e0eec8a02cf5019b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e32b4ba674e64610246503fd7a7e2d68>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e3a1910586cc979ff1ab63b3aea48d27>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e5d4ce89eea4f46ccc67ca69aecfa6dc>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e5f67dba5eefee75a32542ba3adcee30>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_e91231a8a971d33fcce73921f66993f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ea8b8104235951fa3f399193535068d0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eb2429a57718bce23b7d1eac85038a8e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_eb55f89d2c339b07a708773692607068>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ebca007067980e8000c5006e83d27415>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ec4c8c147918a8d768009fd5b551b5ed>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ec4d0eb5b6fed30b55121dbb7767792c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ecaf0da6470494d8972033a51ea6668d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_edf43b92f1a50dcb9304df3415c38318>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ee3ef6a9143c2fd26054b2bd0a01c510>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_ee5fe37d3e2608b4336ca03267d352be>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f021cdef2cbfe511e6cf411d575df7e0>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f035ab843647e98a8c72603effe69b12>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f176e0f30d685b750646c0a2baccf296>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f2bea8a1dee18cc4582d2ef5cb538d0d>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f3eb69b11fcd9a25a8f712cf84755c70>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f88672913bccab0428a46555adc85e6e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f88925e772ef98816ab7eb5e40a10a64>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8aed9c70924e61b413f0ef14704f70b>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f8fa0d76bf6846da50700a400af0a5ef>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9c9d2e87cd66f42c75f50f430def7f7>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_f9f0bab5d448810eee5808d354c2f0f1>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fa9ceb962d5423042e9694103eb6e93f>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fb819125baff5b558ae74f00dd26ba4e>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fbb01ee15e5f4b27ee8320fbf60e8e54>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fc0ff580a5b442854e44c3c6deb6a15c>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fc19415e17ea706413f0561e2a91e020>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fd6087856a329f8cc019cf1262bdbafe>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fda3769582440d59c66ab3ddc3ad5a24>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fdbd198e5b4ebd72dcf16140169c88c4>@@@TaskScheduler@embree
AU?$ClosureTaskFunction@V<lambda_fe6fd13753666c6a6b315fd1a1433b87>@@@TaskScheduler@embree
AUAVAWH
AUAVAWUH
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@avx@embree
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree
AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$07@avx@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@avx@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@sse2@embree
AUBVHNBuilderV@?$BVHNBuilderVirtual@$07@avx@embree
AUBuildProgressMonitor@embree
AUBuildProgressMonitorInterface@Scene@embree
AUCalcBufferHolder@RadeonRays
AUCalcEventHolder@RadeonRays
AUGeometryGroup@embree
AUGeometryInstance@embree
AUInstance@embree
AULeafBoundsInterface@?$BVHNRefitter@$03@avx@embree
AULeafBoundsInterface@?$BVHNRefitter@$03@sse2@embree
AULeafBoundsInterface@?$BVHNRefitter@$07@avx@embree
AUMemoryMonitorInterface@embree
AUPrimitiveType@embree
AURegressionTest@embree
AUState@embree
AUTaskFunction@TaskScheduler@embree
AUTaskScheduler@embree
AUTriangleMesh@embree
AUTriangleMeshISA@avx@embree
AUTriangleMeshISA@sse2@embree
AUType@?$LineMi@$03@embree
AUType@?$QuadMi@$03@embree
AUType@?$QuadMv@$03@embree
AUType@?$TriangleM@$03@embree
AUType@?$TriangleMi@$03@embree
AUType@?$TriangleMv@$03@embree
AUType@?$TriangleMvMB@$03@embree
AUType@Bezier1i@embree
AUType@Bezier1v@embree
AUType@Object@embree
AUType@SubdivPatch1Cached@embree
AUTypeCached@SubdivPatch1Cached@embree
AUUUUUU
AUUserGeometry@embree
AU_Crt_new_delete@std
AUbarrier_sys_regression_test@embree
AUctype_base@std
AUdeleter@ipl
AUfast_allocator_regression_test@embree
AUmessages_base@std
AUmoney_base@std
AUrtcore_error@embree
AUtime_base@std
AV<lambda_081ca0496a4617227558c690037022b7
AV<lambda_0b237fb88318a2c5a2569350bfa1edb5
AV<lambda_258caa2aa93fdeed38b7932ab14ce555
AV<lambda_498b6f04f2beccab8c714618b3ad669c
AV<lambda_500571d1f9d0a65aa1db1f219ecd57cd
AV<lambda_62a9d32afc8d6b63df56e96e440ec261
AV<lambda_a38cb66fac85a719ba71f2c8faa44676
AV<lambda_be12e81c125b702ef2e41724fd1f6d30
AV<lambda_d9cc229929455c8f29444ad9f7024193
AV<lambda_dff3c1b6999eee227e24249907461f6e
AV<lambda_fe89cc8dd20d17b87ff8094e4c964cc6
AV?$BVHN@$03@embree
AV?$BVHN@$07@embree
AV?$BVHNBuilderInstancing@$03UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderInstancing@$03UTriangleMesh@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$03VAccelSet@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$03VAccelSet@embree@@@sse2@embree
AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@@avx@embree
AV?$BVHNBuilderTwoLevel@$07VAccelSet@embree@@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$03VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$03VAccelSet@embree@@UObject@2@@sse2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNMeshBuilderMorton@$07VAccelSet@embree@@UObject@2@@avx2@embree
AV?$BVHNMeshBuilderMorton@$07VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree
AV?$BVHNRefitT@$03VAccelSet@embree@@UObject@2@@avx@embree
AV?$BVHNRefitT@$03VAccelSet@embree@@UObject@2@@sse2@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree
AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree
AV?$BVHNRefitT@$07VAccelSet@embree@@UObject@2@@avx@embree
AV?$CLWBuffer@D
AV?$CLWBuffer@H
AV?$CLWBuffer@M
AV?$ReferenceCounter@PEAU_cl_command_queue@@$1?clRetainCommandQueue@@YAHPEAU1@@Z$1?clReleaseCommandQueue@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_context@@$1?clRetainContext@@YAHPEAU1@@Z$1?clReleaseContext@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_device_id@@$1?clRetainDevice@@YAHPEAU1@@Z$1?clReleaseDevice@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_event@@$1?clRetainEvent@@YAHPEAU1@@Z$1?clReleaseEvent@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_kernel@@$1?clRetainKernel@@YAHPEAU1@@Z$1?clReleaseKernel@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_mem@@$1?clRetainMemObject@@YAHPEAU1@@Z$1?clReleaseMemObject@@YAH0@Z
AV?$ReferenceCounter@PEAU_cl_platform_id@@$0A@$0A
AV?$ReferenceCounter@PEAU_cl_program@@$1?clRetainProgram@@YAHPEAU1@@Z$1?clReleaseProgram@@YAH0@Z
AV?$Stream@H@embree
AV?$Stream@VToken@embree@@@embree
AV?$_Ebco_base@V?$allocator@UImpulseResponse2@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@V?$TripleBuffer@VOverlapSaveFIR@ipl@@@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VBinauralEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VBufferedIndirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VContext@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VDirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VDirectSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeInstancedMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VEmbreeStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHRTFDatabase@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VHybridReverbEstimator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectMixer@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VIndirectPartitioner@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VInstancedMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOpenCLDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOpenCLDeviceList@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VOverlapSavePartitioner@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPanningEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPathEffect@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VPathSimulator@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeArray@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeBatch@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VProbeNeighborhood@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VRadeonRaysDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VScene@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSerializedObject@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSimulationData@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VSimulationManager@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VStaticMesh@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VTANDevice@ipl@@@ipl@@$00@std
AV?$_Ebco_base@V?$allocator@VVirtualSurroundEffect@ipl@@@ipl@@$00@std
AV?$_ExceptionPtr_static@Vbad_alloc@std@@@?A0x626bcf6a
AV?$_ExceptionPtr_static@Vbad_exception@std@@@?A0x626bcf6a
AV?$_Func_base@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_base@XPEAVBuffer@Calc@@@std
AV?$_Func_base@XPEAVDevice@Calc@@@std
AV?$_Func_base@XPEAVEvent@Calc@@@std
AV?$_Func_impl@V<lambda_498b6f04f2beccab8c714618b3ad669c>@@V?$allocator@H@std@@XPEAVBuffer@Calc@@@std
AV?$_Func_impl@V<lambda_62a9d32afc8d6b63df56e96e440ec261>@@V?$allocator@H@std@@XPEAVDevice@Calc@@@std
AV?$_Func_impl@V<lambda_dff3c1b6999eee227e24249907461f6e>@@V?$allocator@H@std@@XPEAVEvent@Calc@@@std
AV?$_Func_impl_no_alloc@V<lambda_081ca0496a4617227558c690037022b7>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_0b237fb88318a2c5a2569350bfa1edb5>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_258caa2aa93fdeed38b7932ab14ce555>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_500571d1f9d0a65aa1db1f219ecd57cd>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_a38cb66fac85a719ba71f2c8faa44676>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_be12e81c125b702ef2e41724fd1f6d30>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_d9cc229929455c8f29444ad9f7024193>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Func_impl_no_alloc@V<lambda_fe89cc8dd20d17b87ff8094e4c964cc6>@@XHAEAU?$atomic@_N@std@@@std
AV?$_Iosb@H@std
AV?$_Mpunct@D@std
AV?$_Mpunct@G@std
AV?$_Mpunct@_W@std
AV?$_Ref_count@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std
AV?$_Ref_count_obj_alloc3@UImpulseResponse2@@V?$allocator@UImpulseResponse2@@@ipl@@@std
AV?$_Ref_count_obj_alloc3@V?$TripleBuffer@VOverlapSaveFIR@ipl@@@ipl@@V?$allocator@V?$TripleBuffer@VOverlapSaveFIR@ipl@@@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsBinauralEffect@ipl@@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsDecodeEffect@ipl@@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsEncodeEffect@ipl@@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsPanningEffect@ipl@@V?$allocator@VAmbisonicsPanningEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VAmbisonicsRotateEffect@ipl@@V?$allocator@VAmbisonicsRotateEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VBinauralEffect@ipl@@V?$allocator@VBinauralEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VBufferedIndirectEffect@ipl@@V?$allocator@VBufferedIndirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VContext@ipl@@V?$allocator@VContext@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VDirectEffect@ipl@@V?$allocator@VDirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VDirectSimulator@ipl@@V?$allocator@VDirectSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeDevice@ipl@@V?$allocator@VEmbreeDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeInstancedMesh@ipl@@V?$allocator@VEmbreeInstancedMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VEmbreeStaticMesh@ipl@@V?$allocator@VEmbreeStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHRTFDatabase@ipl@@V?$allocator@VHRTFDatabase@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VHybridReverbEstimator@ipl@@V?$allocator@VHybridReverbEstimator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectEffect@ipl@@V?$allocator@VIndirectEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectMixer@ipl@@V?$allocator@VIndirectMixer@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VIndirectPartitioner@ipl@@V?$allocator@VIndirectPartitioner@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VInstancedMesh@ipl@@V?$allocator@VInstancedMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOpenCLDevice@ipl@@V?$allocator@VOpenCLDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOpenCLDeviceList@ipl@@V?$allocator@VOpenCLDeviceList@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VOverlapSavePartitioner@ipl@@V?$allocator@VOverlapSavePartitioner@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPanningEffect@ipl@@V?$allocator@VPanningEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPathEffect@ipl@@V?$allocator@VPathEffect@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VPathSimulator@ipl@@V?$allocator@VPathSimulator@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeArray@ipl@@V?$allocator@VProbeArray@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeBatch@ipl@@V?$allocator@VProbeBatch@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VProbeNeighborhood@ipl@@V?$allocator@VProbeNeighborhood@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VRadeonRaysDevice@ipl@@V?$allocator@VRadeonRaysDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VRadeonRaysStaticMesh@ipl@@V?$allocator@VRadeonRaysStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VScene@ipl@@V?$allocator@VScene@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSerializedObject@ipl@@V?$allocator@VSerializedObject@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSimulationData@ipl@@V?$allocator@VSimulationData@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VSimulationManager@ipl@@V?$allocator@VSimulationManager@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VStaticMesh@ipl@@V?$allocator@VStaticMesh@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VTANDevice@ipl@@V?$allocator@VTANDevice@ipl@@@2@@std
AV?$_Ref_count_obj_alloc3@VVirtualSurroundEffect@ipl@@V?$allocator@VVirtualSurroundEffect@ipl@@@2@@std
AV?$_Ref_count_resource@PEAVEnergyField@ipl@@Udeleter@2@@std
AV?$_Ref_count_resource@PEAVIReconstructor@ipl@@Udeleter@2@@std
AV?$_Ref_count_resource@PEAVIReflectionSimulator@ipl@@Udeleter@2@@std
AV?$_Ref_count_resource@PEAVIScene@ipl@@Udeleter@2@@std
AV?$_Ref_count_resource@PEAVImpulseResponse@ipl@@Udeleter@2@@std
AV?$allocator@UImpulseResponse2@@@ipl
AV?$allocator@V?$TripleBuffer@VOverlapSaveFIR@ipl@@@ipl@@@ipl
AV?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl
AV?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl
AV?$allocator@VBinauralEffect@ipl@@@ipl
AV?$allocator@VBufferedIndirectEffect@ipl@@@ipl
AV?$allocator@VContext@ipl@@@ipl
AV?$allocator@VDirectEffect@ipl@@@ipl
AV?$allocator@VDirectSimulator@ipl@@@ipl
AV?$allocator@VEmbreeDevice@ipl@@@ipl
AV?$allocator@VEmbreeInstancedMesh@ipl@@@ipl
AV?$allocator@VEmbreeStaticMesh@ipl@@@ipl
AV?$allocator@VHRTFDatabase@ipl@@@ipl
AV?$allocator@VHybridReverbEstimator@ipl@@@ipl
AV?$allocator@VIndirectEffect@ipl@@@ipl
AV?$allocator@VIndirectMixer@ipl@@@ipl
AV?$allocator@VIndirectPartitioner@ipl@@@ipl
AV?$allocator@VInstancedMesh@ipl@@@ipl
AV?$allocator@VOpenCLDevice@ipl@@@ipl
AV?$allocator@VOpenCLDeviceList@ipl@@@ipl
AV?$allocator@VOverlapSavePartitioner@ipl@@@ipl
AV?$allocator@VPanningEffect@ipl@@@ipl
AV?$allocator@VPathEffect@ipl@@@ipl
AV?$allocator@VPathSimulator@ipl@@@ipl
AV?$allocator@VProbeArray@ipl@@@ipl
AV?$allocator@VProbeBatch@ipl@@@ipl
AV?$allocator@VProbeNeighborhood@ipl@@@ipl
AV?$allocator@VRadeonRaysDevice@ipl@@@ipl
AV?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl
AV?$allocator@VScene@ipl@@@ipl
AV?$allocator@VSerializedObject@ipl@@@ipl
AV?$allocator@VSimulationData@ipl@@@ipl
AV?$allocator@VSimulationManager@ipl@@@ipl
AV?$allocator@VStaticMesh@ipl@@@ipl
AV?$allocator@VTANDevice@ipl@@@ipl
AV?$allocator@VVirtualSurroundEffect@ipl@@@ipl
AV?$basic_filebuf@DU?$char_traits@D@std@@@std
AV?$basic_ifstream@DU?$char_traits@D@std@@@std
AV?$basic_ios@DU?$char_traits@D@std@@@std
AV?$basic_iostream@DU?$char_traits@D@std@@@std
AV?$basic_istream@DU?$char_traits@D@std@@@std
AV?$basic_ostream@DU?$char_traits@D@std@@@std
AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$basic_streambuf@DU?$char_traits@D@std@@@std
AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std
AV?$codecvt@DDU_Mbstatet@@@std
AV?$codecvt@GDU_Mbstatet@@@std
AV?$codecvt@_WDU_Mbstatet@@@std
AV?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std
AV?$collate@D@std
AV?$collate@G@std
AV?$collate@_W@std
AV?$ctype@D@std
AV?$ctype@G@std
AV?$ctype@_W@std
AV?$enable_shared_from_this@VIScene@ipl@@@std
AV?$messages@D@std
AV?$messages@G@std
AV?$messages@_W@std
AV?$money_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$money_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$money_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$money_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$money_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$money_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$moneypunct@D$00@std
AV?$moneypunct@D$0A@@std
AV?$moneypunct@G$00@std
AV?$moneypunct@G$0A@@std
AV?$moneypunct@_W$00@std
AV?$moneypunct@_W$0A@@std
AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$num_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$num_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$numpunct@D@std
AV?$numpunct@G@std
AV?$numpunct@_W@std
AV?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$time_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$time_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std
AV?$time_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std
AV?$time_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std
AV?$wstring_convert@V?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std@@_WV?$allocator@_W@2@V?$allocator@D@2@@std
AVAWUF
AVAWUH
AVAccel@embree
AVAccelData@embree
AVAccelInstance@embree
AVAccelN@embree
AVAccelSet@embree
AVAllocator@flatbuffers
AVBakedPathData@ipl
AVBakedReflectionsData@ipl
AVBatchedReflectionSimulator@ipl
AVBuffer@Calc
AVBuffer@RadeonRays
AVBufferClw@Calc
AVBuilder@embree
AVBvh2lStrategy@RadeonRays
AVBvh@RadeonRays
AVBvhStrategy@RadeonRays
AVCAmbisonicsBinauralEffect@api
AVCAmbisonicsDecodeEffect@api
AVCAmbisonicsEncodeEffect@api
AVCAmbisonicsPanningEffect@api
AVCAmbisonicsRotationEffect@api
AVCBinauralEffect@api
AVCContext@api
AVCDirectEffect@api
AVCEmbreeDevice@api
AVCHRTF@api
AVCInstancedMesh@api
AVCLWCommandQueue
AVCLWContext
AVCLWDevice
AVCLWEvent
AVCLWException
AVCLWKernel
AVCLWPlatform
AVCLWProgram
AVCOpenCLDevice@api
AVCOpenCLDeviceList@api
AVCPanningEffect@api
AVCPathEffect@api
AVCProbeArray@api
AVCProbeBatch@api
AVCRadeonRaysDevice@api
AVCReflectionEffect@api
AVCReflectionMixer@api
AVCScene@api
AVCSerializedObject@api
AVCSimulator@api
AVCSource@api
AVCStaticMesh@api
AVCTrueAudioNextDevice@api
AVCValidatedAmbisonicsBinauralEffect@api
AVCValidatedAmbisonicsDecodeEffect@api
AVCValidatedAmbisonicsEncodeEffect@api
AVCValidatedAmbisonicsPanningEffect@api
AVCValidatedAmbisonicsRotationEffect@api
AVCValidatedBinauralEffect@api
AVCValidatedContext@api
AVCValidatedDirectEffect@api
AVCValidatedEmbreeDevice@api
AVCValidatedHRTF@api
AVCValidatedInstancedMesh@api
AVCValidatedOpenCLDevice@api
AVCValidatedOpenCLDeviceList@api
AVCValidatedPanningEffect@api
AVCValidatedPathEffect@api
AVCValidatedProbeArray@api
AVCValidatedProbeBatch@api
AVCValidatedRadeonRaysDevice@api
AVCValidatedReflectionEffect@api
AVCValidatedReflectionMixer@api
AVCValidatedScene@api
AVCValidatedSerializedObject@api
AVCValidatedSimulator@api
AVCValidatedSource@api
AVCValidatedStaticMesh@api
AVCValidatedTrueAudioNextDevice@api
AVCValidatedVirtualSurroundEffect@api
AVCVirtualSurroundEffect@api
AVCalc@0
AVCalcClw@Calc
AVCalcIntersectionDevice@RadeonRays
AVCalcIntersectionDeviceCl@RadeonRays
AVCustomScene@ipl
AVDefaultAllocator@flatbuffers
AVDevice@Calc
AVDevice@embree
AVDeviceCl@Calc
AVDeviceClw@Calc
AVEmbreeInstancedMesh@ipl
AVEmbreeReflectionSimulator@ipl
AVEmbreeScene@ipl
AVEmbreeStaticMesh@ipl
AVEnergyField@ipl
AVEvent@Calc
AVEvent@RadeonRays
AVEventClw@Calc
AVException@Calc
AVException@RadeonRays
AVException@ipl
AVExceptionClw@Calc
AVExceptionImpl@RadeonRays
AVExecutable@Calc
AVExecutableClw@Calc
AVFatBvhStrategy@RadeonRays
AVFileStream@embree
AVFlatBuffersAllocator@ipl
AVFunction@Calc
AVFunctionClw@Calc
AVGeometry@embree
AVHRTFMap@ipl
AVHlbvh@RadeonRays
AVHlbvhStrategy@RadeonRays
AVIAmbisonicsBinauralEffect@api
AVIAmbisonicsDecodeEffect@api
AVIAmbisonicsEncodeEffect@api
AVIAmbisonicsPanningEffect@api
AVIAmbisonicsRotationEffect@api
AVIBakedData@ipl
AVIBinauralEffect@api
AVIContext@api
AVIDirectEffect@api
AVIEmbreeDevice@api
AVIHRTF@api
AVIHRTFMap@ipl
AVIInstancedMesh@api
AVIInstancedMesh@ipl
AVIOpenCLDevice@api
AVIOpenCLDeviceList@api
AVIPanningEffect@api
AVIPathEffect@api
AVIProbeArray@api
AVIProbeBatch@api
AVIRadeonRaysDevice@api
AVIReconstructor@ipl
AVIReflectionEffect@api
AVIReflectionMixer@api
AVIReflectionSimulator@ipl
AVIScene@api
AVIScene@ipl
AVISerializedObject@api
AVISimulator@api
AVISource@api
AVIStaticMesh@api
AVIStaticMesh@ipl
AVITrueAudioNextDevice@api
AVIVirtualSurroundEffect@api
AVImpulseResponse@ipl
AVInstance@RadeonRays
AVInstancedMesh@ipl
AVIntersectionApi@RadeonRays
AVIntersectionApiImpl@RadeonRays
AVIntersectionDevice@RadeonRays
AVLineCommentFilter@embree
AVMesh@RadeonRays
AVOpenCLEnergyField@ipl
AVOpenCLImpulseResponse@ipl
AVOpenCLReconstructor@ipl
AVPrimitives@Calc
AVPrimitivesClw@Calc
AVRadeonRaysReflectionSimulator@ipl
AVRadeonRaysScene@ipl
AVRadeonRaysStaticMesh@ipl
AVReconstructor@ipl
AVRefCount@embree
AVReflectionSimulator@ipl
AVSOFAHRTFMap@ipl
AVScene@embree
AVScene@ipl
AVShape@RadeonRays
AVShapeImpl@RadeonRays
AVSplitBvh@RadeonRays
AVStaticMesh@ipl
AVStrStream@embree
AVStrategy@RadeonRays
AVTokenStream@embree
AVVWUSH
AVWorld@RadeonRays
AVX512BW
AVX512CD
AVX512DQ
AVX512ER
AVX512F
AVX512F H
AVX512IFMA
AVX512KNL
AVX512PF
AVX512SKX
AVX512VBMI
AVX512VL
AV_ExceptionPtr_normal@?A0x626bcf6a
AV_Facet_base@std
AV_Generic_error_category@std
AV_Iostream_error_category2@std
AV_Iostream_error_category@std
AV_Locimp@locale@std
AV_Ref_count_base@std
AV_System_error@std
AV__non_rtti_object@std
AVbad_alloc@std
AVbad_array_new_length@std
AVbad_cast@std
AVbad_exception@std
AVbad_function_call@std
AVbad_typeid@std
AVbad_weak_ptr@std
AVcodecvt_base@std
AVerror_category@std
AVexception@std
AVfacet@locale@std
AVfailure@ios_base@std
AVios_base@std
AVlength_error@std
AVlogic_error@std
AVout_of_range@std
AVrange_error@std
AVruntime_error@std
AVstl_condition_variable_interface@details@Concurrency
AVstl_condition_variable_vista@details@Concurrency
AVstl_condition_variable_win7@details@Concurrency
AVstl_critical_section_interface@details@Concurrency
AVstl_critical_section_vista@details@Concurrency
AVstl_critical_section_win7@details@Concurrency
AVsystem_error@std
AVtype_info
AW&qB
AWAVATVWUSH
AWAVAUATVWUSH
AWAVVWUSH
AX:gex:J
AXH+API
AXH+API;D$0
AXH+API;E0
AXH+APL
AXzLuJ
AYAXZY
A[YƋL$0H
A\a9Ћi
A\b%\b 0
A\bA;ŋI\fA
A\bH;\bu
A\bL;\bu
A\bba|\b
A\bi:L
A\eP;g
A\fba~\b
A\nYL
A\nYT
A\nba|\b
A\nba~\b
A\ny:\a
A\rba|H
A\t%\a 0
A\t8;:X\a
A\t;vk
A\t<&a0
A\tB(M
A\tE\a 0
A\v:O)3
A\vE\b 0
A]A\\]_^[ÐSVWUATAUH
A^A]A
A_A]A
A_A^A
A_A^A]A
A_H<r
AbYd/4
AccelN::intersector1
AccelN::intersector16
AccelN::intersector4
AccelN::intersector8
AccelN::intersectorN
Access violation - no RTTI data
AcquireSRWLockExclusive
Ad\\?HcC
AdjustTokenPrivileges
Advanced Micro Devices
Ady;.s
Af<ZXk
AfC`ěA
Ag5<I
Ah\f;o
Ai<ִv
Ak==9
Ak\f<\a
Ak»mS
Alz2u0
AmQ,BP\a
Am\a9D
An>uCv
AoҼh9
Ap_p@H
Aq:UV
Aq:k\n
AreFileApisANSI
As< g
Asg<0gk
Assertion failed
Assertion failed: %Ts, file %Ts, line %d\n
Attempted to create SOFA HRTF without either a file name or a data buffer
Atz%u
August
Auu:L
Aw9/1
Awj;:m\e
Ax/t1
Ax5;U
AxXd$0
AxYt$P
AxY|$P
Ax]D$p
Ay<xeV
Aynt\f0
Ayn|\fd
A{A=dg
A{L.B
A|(TD
A|(tE
A|=T2P
A}oKL$X
A}oȉL$X
AƼCNϼ\fc
Aʼ;\vdb
A˻bC3<\aHN
A̪;VB
A̻fsv<?c
À:bf
A֟;Sr
Aໂi\a
A酼Xto
A튺r*o
B :;NM0
B :UsK
B"B&B*B.B2B6B:B>BBBFBJ
B(<t5A
B(I9A(u\r
B)bA|\b
B+N>ZaS
B+Q4\a
B-H<WP
B0;0=k
B0i9B
B0ɼ"7
B1<J\aJ
B93)\v
B9<ybl
B9dڕ8nO
B9ᑙ:7m
B:BbZ:R
B:\f0u M
B; rs9
B;"3J;g
B;(kW
B;0JH
B;Q医9
B;RbT
B;WO5
B;XNN;$9J;6
B;Y)Y;2N
B;ZwH
B;\bEO
B;jOH
B;peL
B;íc8hxs
B<;YV1
B<\t\r\b8
B<xym<[\nM
B=2}\t=Cٞ=i6h=JC
B=Jk8
B=R67
B>Bh9?\a
B>F\fE
B>\tSԽe
B>zZ\v
B>{Pn
B?d!\vY
B?d"C
B@bQ|\n
BA.L$p
BA.d$p
BB:;o\t
BB<.m
BCŻHl5
BCױbc}IC
BC߱bc}IC
BD>Lɏ<s
BD\v7
BENCHMARK_BUILD
BF8<pjM
BF>XoT
BH;% H
BI.L$p
BI.T$p
BJ8=R
BJƼ{K
BK=\b
BL0<:;H
BM<mcW
BM];Ha
BMa=!9
BMr:Km
BN9"X
BN:;lY
BNe<\v@P
BNi;\b
BOO<̊r
BP<p\r
BQ#"C\n
BQZ:K:G
BSp<fm0;\a
BT{zb
BUY:P
BUμVx
BXHc\bI
BXI+KPI+BPH
BXQ<ŊXy
BXm:|v
BY,T,L
BY\t>w
BYԀB8B
B\\s;Mse<\vu0
B\a8pUx
B\bH9A\bu\rH
B\bHcEgH
B\bbQ
B\bba|\b
B\e>fH\b
B\eCW&qB
B\n:Q+K
B\nba|\b
B\nba~\b
B\r;Lnm
B\r;oN9
B\rV:9
B\rbA|\b
B\t;n*l
B\t=L\v3
B\vba~\b
B]\n>wZU
B`ěAi\\BB
Bad dynamic_cast
Base Class Array
Base Class Descriptor at
Bd#<miE
Bfڻm`3
Bg; T7
Bhba|\b
Bi'LCNאB
Bi.D$p
Bi.L$p
BitHistogram
Bj'?I
Bj:\vB5ڻBI
Bjûoc
Bk(#B3
Bm\b> H
Bm^<C\ef
Bn<pZ
BnB=^D
BnE;UN
BnI<Bb
Bpֹ=7G;Z
Bq.D$p
Bq.L$p
BqȻ"s
Br!<35
Br=/y
Bu<\a|p
Build
BuildHierarchy
BuilderFastSpatialSAH
BuilderInstancing
BuilderMBlurSAH
BuilderSAH
BuilderTwoLevel
Bw:<F
By.L$p
By.T$p
By.l$p
Byź`2
BzŰC*!3B0y
B{t:6
B|nZB\r
B}ļ G
B~0GB
B~Z=Q
Bŕ\rB
BȻoH뻎A
B̻w\fлJ
BϻLd0
BЋA(H
Bґ<mg
BһR1q;\e
Bպ+TO
Bք\tAl1"B
B۸YI>9
B⽦qG;t
C 9t$0
C rWH
C!p;l
C$ɺ12
C&:5Q\f
C(D;i2
C):4Z\e
C);PNO
C);nnA;p
C*!3B
C+;87
C09p\btU
C0;^F
C0F;<\n
C0H+C(H
C0HcH\bL
C0HcH\fH
C0Hc\tH
C1<tA
C23;}K
C2j:v
C2u<ӐK
C4=mwV
C8;C4s
C8H+C0I;D
C8H+C0I;E
C8O:;Ŵ6
C9JD$p
C9_S8
C9n,.;8j
C:&\fS9
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_instancing.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_morton.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_sah.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_builder_twolevel.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_intersector_stream_filters.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_refit.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/bvh/bvh_statistics.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/embree/src/embree/kernels/geometry/instance_intersector.cpp
C:/buildslave/phonon_main_win64/build/core/deps-build/mysofa/install/windows-x64/share/libmysofa/default.sofa
C:70W:ﯸ7sK
C:GpK
C:\\buildslave\\phonon_main_win64\\build\\core\\build\\windows-vs2019-x64\\src\\core\\Release\\phonon.pdb
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\algorithms\\parallel_for.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\algorithms\\parallel_sort.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\math\\range.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\math\\vec3fa.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vboolf4_sse2.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vboolf8_avx.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vfloat4_sse2.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vfloat8_avx.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint4_sse2.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint8_avx.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\simd\\vint8_avx2.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\alloc.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\alloc.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\sysinfo.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\sys\\vector.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\tasking\\taskschedulerinternal.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\common\\tasking\\taskschedulerinternal.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../../common/algorithms/parallel_for_for.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../../common/algorithms/parallel_partition.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\../common/primref_mb.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_binning.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_binning_array_aligned.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_openmerge_array.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_spatial.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_spatial_array.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\builders\\heuristic_timesplit_array.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/bvh_builder_msmblur.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/bvh_builder_sah.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../builders/splitter.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../bvh/bvh.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../common/alloc.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/triangle.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglei.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglev.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\../geometry/trianglev_mb.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh4_factory.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh8_factory.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_instancing.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_instancing.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_morton.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_sah.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_twolevel.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_builder_twolevel.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector1.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_hybrid.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_stream.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_stream.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_intersector_stream_filters.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_refit.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_statistics.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_traverser1.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\bvh\\bvh_traverser_stream.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/algorithms/parallel_for.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/simd/simd.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\../../common/sys/array.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\accel.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\acceln.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\accelset.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\alloc.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\buffer.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\device.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\rtcore.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_triangle_mesh.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\scene_triangle_mesh.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\state.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\common\\vector.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\../common/primref_mb.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\../common/scene_instance.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\filter.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\instance_intersector.cpp
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\intersector_epilog.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\trianglei.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\embree\\src\\embree\\kernels\\geometry\\trianglev_mb.h
C:\\buildslave\\phonon_main_win64\\build\\core\\deps-build\\mysofa\\src\\mysofa\\src\\hrtf\\easy.c
C:oMt
C;%La
C;=Db
C;L\v0
C;Mub
C;S\t
C;XDb;S
C;e৺HB
C;i,N;4
C;i{j
C;t嬺0
C<2sR
C<;C4A
C<CPX7
C<G;g
C<Tzv
C=8,z
C=B \b
C=M5)=7
C=\v8
C=p\eཛྷ6
C=z"d9
C>5x=h4
C>7hk
C>9^a6
C>\b84>eJ
C>t}C
C@H98t$H
C@H9\bt
C@I=5P
C@f91H
C@f99H
CA< t(<#t
CB';t
CC>/b
CD:\nE2
CG<UlX
CGj:zK
CH;\n
CHH+C@I;D
CHٹ`N7
CI9y\bi;)o\a
CJ>sm
CKW;b
CKc=YC
CL interop not supported
CLv\vH
CM:TkJ
CMF}A
CN@=!kC
CO ;qd
CO9`2
CONOUT
CPHc\bI
CPU does not support SSE2
CQȺ0\\Ǻty
CRT$XCA
CRT$XCC
CRT$XCL
CRT$XCU
CRT$XCZ
CRT$XDA
CRT$XDZ
CRT$XIA
CRT$XIC
CRT$XIZ
CRT$XLA
CRT$XLC
CRT$XLZ
CRT$XPA
CRT$XPX
CRT$XPXA
CRT$XPZ
CRT$XTA
CRT$XTZ
CS;"i
CW&qB쾩C
CWD>~3
CXH+CPH
CXH+CPI;G0
CXH+OPH+CPH
CXHc\bI
CXL+CPH
CYA>HM
CZ滘dٻO
C\\,50J
C\a>8B\a
C\a>8B\r
C\b;e4ƹZ
C\b@80u#H
C\fA]A
C\fHcOLH
C\fbA
C\nżi3
C\r\r;M
C\tJup
C\tJvp
C\tJwp`H
C\v$9!J
C\v;f7
C`H+CX
C`H;CXt"I
C`H;CXt#A
C`N3A
C`N3Gs
Ca;=\nJ
CalcMortonCode
Calculate any intersection \n            hitresults[ridx] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process \n__global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process                     \n__global int* hitresults  // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,      // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \n__global int const* numrays,     // Number of rays in the workload \n__global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest(&scenedata, &r, &isect); \n            // Write data back in case of a hit \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \n__global int const* numrays
Cannot read the contents of a file
Caｎ ~=7
CcR;9
Cf;4AC
CfC=&p
CfνP\\T
Cg8\t
ChLcK\bH
Ch\n=*S
CiK=>N
Ci^;XW
Cj:\vBs\t
Ck(#B
Ck(#Bsx
Class Hierarchy Descriptor
Class name
CloseHandle
CloseThreadpoolTimer
CloseThreadpoolWait
CloseThreadpoolWork
ClŻBq
Co:}j
CoTaskMemFree
CompanyName
CompareStringEx
CompareStringW
Compiler
Complete Object Locator
Config
Conventions
CorExitProcess
CoҺcP
CqY:Y
Cr;Npl
Cr;WVz
CreateEventA
CreateEventExW
CreateEventW
CreateFileW
CreateSemaphoreExW
CreateSemaphoreW
CreateSymbolicLinkW
CreateThread
CreateThread failed
CreateThreadpoolTimer
CreateThreadpoolWait
CreateThreadpoolWork
Ct;ti
Cu0f9w
Cw:\b
Cw;CD:\t
Cy2@K
Cy9LH$9\r
Cylinder test
Cylinder { p0
Cz,;\nfS
Cz\e<L
C|nZB
C}żDiмo
Cú9eo
CŻ9AE
Cȼ=8Q;g
CʺfhƺeY5
C˽YL\e=F
Cӷ;fYt
Cք\tA
Cڳ; \fm<Q
Cߺ\vo0
C㏻|h编ZR
D  fB
D AMD
D AMD_MEDIA_OPS
D W?{W
D WIN32
D"<k7
D$ 3\tD$,H
D$ 9A
D$ BǄ\a
D$ D+E
D$ D3
D$ H;Q
D$ H;W
D$ H;\r
D$ H;\rA
D$ `fD
D$ b!|M
D$$bb}H
D$(fff
D$03ɉL$8L
D$0D9P
D$0D;L$(u
D$0H;G
D$0HcH
D$0L9H s\n
D$0N;l
D$0fE
D$0tVA
D$0tWA
D$0t]A
D$0t^A
D$2E3
D$4Lc
D$8D8T$1u\f
D$8E3ɋB$I
D$8H;S
D$8HcJ
D$8L98
D$8fff
D$@E3
D$@L;D$Hu
D$@fD
D$D+ȉL$TD
D$DDtRH
D$HD;l$4s\vH
D$HE3
D$HL9gXt
D$P;Mw}\nH
D$PHcH
D$PHcX H
D$PL;D$Xu
D$PL;\r`L
D$PLcH
D$PLce
D$PfD
D$PsOH
D$Pt#A
D$Pt&A
D$XD8p\bH
D$XD90
D$XHcE
D$XI+D$PI;E0
D$XI+D$PI;E8v*M
D$XsUH
D$XsaH
D$\bH;A
D$\nba~\b
D$`D9;u
D$`E3
D$`fff
D$`sQH
D$`sWH
D$`tGM
D$`tKM
D$`t\fH
D$d:v
D$hHcC(H
D$hLc\t
D$n<od
D$pA;w
D$pHcH
D$pHc\bL
D$pLc7L
D$pfA
D$pfD
D$pu\bH
D$xHcA
D$xba
D%;m5\r
D%<V7
D%k;w
D&pA;l$l
D';kzT
D(8Ht
D(:s8
D(T=FD\n
D*0fB
D*\r<3y
D+T$Hfff
D.\ab!D
D.ǻJH
D08@t\t
D2ٺV\a\v
D2庈-p
D3 b1
D39\aW-;R
D3f\bD3n\fH
D3мuxc
D4S<U
D6\v:߬B
D6r:w`w
D8&t4H
D8+t\nD8k
D82u&H
D83t\tH
D88Ht
D88Hte
D8APttH
D8G\buBH
D8G\buIH
D8G\buOH
D8L$0uP
D8W\buOH
D8Y:uEH
D8\\$8uOH
D8\atl
D8]\v
D8a:uDH
D8d$8t\fH
D8d$Ht\fH
D8d$ht\fH
D8g\buAH
D8l$<tNI
D8l$@tOI
D8l$@t\fH
D8l$ht\nH
D8o\bu@H
D8o\buFH
D8o\buHH
D8o\buNH
D8t$8t\fH
D8t$Ht\fH
D8|$Ht\fH
D8|$Pt\fH
D9!t\tH
D91AO<zDy;ɛ\r
D92<a
D98Ht;H
D9I ~wHc
D9K\b~+A
D9S\f~J
D9\vucL
D9c4t\bH
D9s\bu\t9k\f
D9} ~t
D:#)g:rEy9
D:E7\n
D:H\b
D:M+B
D:Q<r\t
D:UT\e
D:\b| D8R
D:\b|$D8R
D:\f0u6H
D:\f0u:H
D:vXh:Y6
D;#rg
D;-Bb
D;H$t\n
D;M<J
D;RN8=0r
D;S\b}8A
D;bY\e
D;iHJ
D;yLj:Sj
D;y\b|:A91
D;}CQ
D<\bW59\n
D=7@U
D=;\axb
D=maQ
D>#U7
D?\f<fVO:5
D?\v9:U
D@Q=s
DA9wX3
DAb<eE
DBY^uB
DB]8Ta
DC:th
DC;ӫ7
DCh9js
DDhu"E
DFԽNk
DG9:N2
DGл\r}ܻsD
DH>=h
DI;?mQ8
DIMENSION_LIST
DJQ;Bƅ:وn
DJ\b=<a
DK8ɠ\t
DK;n5
DKO;g
DKf:5
DLڻL\f\n
DN];h
DOm;c
DQa<Ua
DQ»߃ͻKF
DR;97
DRB<b
DS<tl1
DSp;d
DVe@A\v
DWغ*o
DX4"H
DX<"H
DXƻ&1y
D\a\aba|H
D\b;o1o;f
D\eƻp
D\f;rb
D\f<Sa
D\n=OQK
D\n\abq|H
D\n\bbA|H
D\n\e;U
D\n\nba|H
D\t<4W6
D\thġx
D\v\nba|H
D\v`r]E
D\vf:%b
D^F<n
D^ӻmq
D_ԼW6q
Da<ll{;d
Data.Delay
Data.IR
Data.SamplingRate
DataType
December
DecodePointer
DeleteCriticalSection
Dfb:'Q
Dgi;d
DigiCert Timestamp 20230
DigiCert Trusted Root G40
DigiCert, Inc.1 0
DigiCert, Inc.1;09
DigiCert, Inc.1A0
Dk;hYn
Dm4<x5
DoG;R
DoL9I
DpɹjYj
Dqt=c
Duf<"`4
Dva<R
Dvc:e4
Dvz;N
Dw<\r\a
DyH<B
D|;qyf
D|>9f
D~ "H<O
D~9q\n
D¼9\vr
Dƨ:pR1<2
Dƻ0\ae
DɺlNv
D˻mĥ8
DЋ;M4
Dйl\e;b
DҼl9ؼD
Dܼ1x̼2
D眻F뗻4w
E HcT$0H
E fff
E ŜY=g
E"(<ZOw
E$G=@Mt=w6
E%9/q3
E'@6?2s
E(A+E0A
E(E+E0E
E(G<R
E(H;E
E(Lc7L
E);I\ni
E)B:In
E*:Vh
E*ѼL7
E+}0E
E+܉t$ D
E.ѻ2j
E0;E\bstL
E0H;EH
E0HcH\fD
E0IcD
E0Lc`\fI
E0M;p\b
E0stL
E2S9>E
E2[<oO
E2\f<@b
E2j:?z
E3\nS\tI
E3\nW\tI
E3\vD$8A
E3\vT$<L
E3ɉ|$ D
E3ɸVUUUA
E3҉U(N
E3ۉEDI
E3ۉEHI
E3ۉEPI
E4;"y
E4?;H
E6;Mm
E6x<E\b\a
E8E\buHI
E8E\buLI
E8E\buQI
E8E\buWI
E8]\buXI
E8a>9
E9.u\aA
E91~)3
E92:W
E99~4H
E9<$A
E9N:5\a
E9e\b~i3
E9l$\f~t3
E9|$\f~k3
E9|$\f~t3
E9}\b~h3
E9}\b~t3
E:+cW
E:2dB
E:6QP
E:<2P
E:<9o
E:Zfl
E:\t=680
E:r?ԻXT
E:yu;29Y
E;*dݺx\ny
E;3>F
E;?tv
E;Fh}AO
E;J+x
E;O䴹R
E;P\n
E;S\rһB
E;Wtg
E;X (;+Zy
E;`2Q
E;kW2
E<<uw
E<MF3
E<P\et
E<nZ\r
E<sS;y
E<tdp
E<uZ*<z
E<xQv
E=E*a
E=WIf
E>p;v
E@D9 u
E@D90u
E@stL
EA5;Ɗs
EACǱb#eAC
EBN9[Bo
EBs<YV6
EDw>P
EGԼ)G
EI;zL
EID$ E3
EID$8H
EJ;8N\t;vj<;nN
EJ;D]\f:M
EJ;^i\t
EJӻegk
EKa;q
EL;\r
ELH9dR{9N
EMcɃ~\b
EMcɃ~\f
EOʼ.s
EPM;HD$0L
EPstL
ERROR
ERV:8DN
ES:2k
ET;#Pz;ѸU
ET;OB7
EU*?N
EU;&C
EU=\ve
EUG;0c
EVٻ4rY
EWb"e
EX"<f&9
EX3ҋM`D
EX6;RV
EXI+EPI
EXI+EPI;D$0
EXI+EPI;D$8v/H
EXI+EPI;G0w
EXL;E\bu\r
E[;V3
E[S;i
E[\rn?gc
E[b"m
E\abQ|H
E\auNH
E\b:_h6
E\bHc]`M
E\bbA|J
E\bbQ5H
E\bba}Hp
E\bfA9]\n
E\bs|I
E\btGE3
E\bāx/D
E\e<GQպh
E\ebQT
E\fbA|H
E\n::cXG
E\r<j e:Q&F
E\t|$PH
E\vbA|H
E\vbQ|H
E_<two
E`bbu
Eb>>Hu
Ec:ud9
Ecb>aS
Ed<+8G
Eg1<rK
Eg\n;a
EhI+V@L
Ei:݈0;x
EkZ;Q
Em1>ap
Em\t:f
Embree Ray Tracing Kernels
Embree: Invalid argument
Embree: Invalid error code
Embree: Invalid operation
Embree: No error
Embree: Out of memory
Embree: Unknown error
Embree: Unsupported CPU
EmitterPosition
En[vP
En\b>w
EncodePointer
EnterCriticalSection
EnumSystemLocalesEx
EnumSystemLocalesW
Eo;Ki
Eo<\e:3
Ep\a>9
Et9Z\v
Et;Z( ;x
Et<]0M
Eu+=V
Eu:Ovûv7Y
EvD<l
Ev\a;6;J
Ew8<AF
Ewx:kۜ7
ExitProcess
ExitThread
Expression
Ez=uB$>0
EzR;Oo
E{:cAq
E|#9A
E|H9q
E|\f;Zr
E»QZ9P
EûmME
Eǣ=B\v7
EΎ<z6Z
EӍZ\bD
EԋD$0D
Eٹ\tn0
F HcT$0H
F LcL$4I
F#<2z|8r0
F%:Xy0
F&p;bH
F'<nBJ
F(,:Ts3
F(9=lt
F(D:9
F(I<U
F):o4\e
F)n;rW
F-N;ro
F19:\n
F6:LUP:~so8Ì8;\n
F6û\b2
F8}-L
F9!\aֹP
F9N֑:M
F9Z39
F9`;p
F9o<BwV
F: PӺ\nX
F:4Gǻ\f
F:CVH
F:OKzԣW
F:^Gk
F:j\v
F;8;sG
F;D6S
F;Iy(;De
F;Og{9ޞH
F;Psb;j
F;Q\fL
F;YR3
F;gS¼ʤu
F;nL0;-g
F;tZǺt
F;wr\\6
F;~SS
F<B1v
F<ptO
F<x$Y=zI
F=%=034
F=0;1
F=;AkV
F>qUxv
F?b;yU
F@LcN\bI
FB;:L
FBݻ,DE
FC>yR\t
FDƼ\e
FE?>G
FF\n@acosf
FH8;xI
FHD:]T
FHI+F@H
FI;d]N8Qo
FIg=k4
FJ ;>'k
FL_;eS
FOϹLC*;rF
FPH+FHH
FT;IXY
FVN;\f
FWӻǎg
FX=rV?=0
FXH+FPH
FXH+FPH+KPH
FXH+FPI
FXI+FPI;E0
FXI+FPI;E8v*M
FZ$:Ue9
FZ<Th9
FZ_9\a
F[6:f
F\\V9^J
F\a;R\b¹v
F\a<EG
F\a=LH\e
F\b9D$(}s
F\bH90u
F\em;Y
F\n:5V
F\n;F
F\t;RwN
F\tl<a
F\v;Dq
F\v;q
F\v=u
Fa;Q}p
Fc*99
FdU</3\b
Features
February
Feẜo蹠k
Ff;ivv
Ffջ(zQ;mv
Fg9\bZ
Fh 9e
Fh:O"c<-W
Fh<9̓=w
FhY<\nKX
FileDescription
FileVersion
FindClose
FindFirstFileExA
FindNextFileA
Fj!;o5F
Fj9lmc
FjB:C2
Fk.9db
FlsAlloc
FlsFree
FlsGetValue
FlsSetValue
FlushFileBuffers
FlushProcessWriteBuffers
Flº\t
FoO;pb
Foj;w
For information on how your program can cause an assertion\nfailure, see the Visual C++ documentation on asserts
Fpbal
Fq;_S
FreeEnvironmentStringsW
FreeLibrary
FreeLibraryAndExitThread
FreeLibraryWhenCallbackReturns
Friday
Fu:.T
Fv;T\f
F{$gT
F|w;b\a
F};AS5
FȈD$HH
FͼV\t
FкZ"G
FջN(J=S
FֻK^N
Fܺ#3R<co
Fݻ3kU;L
Fޘ;Ftf;rJ
G"e;D
G(A+G0A
G(E+G0D
G(H+G H
G-;wX
G0HcH\bL
G1m:4I
G20=l
G4l;9k
G6<3yp
G6<ʺL
G7:B6
G7;TO
G8);M
G8;XW
G8z:qW
G9Z!¹p
G9zn7<T
G:$eC
G:UL0
G:j-۸kQ
G:ncG
G:~lD
G:~mQ:U
G:՚ϺZJ6;q
G;0=x
G;M1s
G;Shd
G;brD
G;j,S
G<)mk
G<1\a
G<P\b\f
G<VO+<K
G<\aVлd
G<`Q0
G=0~K
G>l\f
GB:h38
GC;.X\b:3
GEG;\rs
GFw<5W
GG=2{ĽV
GG??L
GGR8|Q
GH;#H
GH='l
GI\a<s
GJ:F\b
GJ繭?G
GJ켟u!=8
GL9\rXѹcv
GL;M\e,;L
GM;\vL
GNp:W
GPH+GHH
GPHcW\bH
GPUUtilities.dll
GRC<r
GSλiPg
GU\r=L
GX$8aQ
GXH+GPI
GXH+GPL
GX˻.zֻXJ
GYd;em
GZu<M
G[<Ax
G[I;y"g
G\a:Hd
G\aO;\ehs
G\bH+\aH
G\bH+\aI
G\bI+\aH
G\bba|H
G\bāx/D
G\bġx/D
G\n;[wD
G\nf;E\ttT
G\nf;E\ttW
G\r<i
G\r=t|s
G\ri;0
G\t4;H
G\t:E\btK
G\t:E\btO
G\t:E\ftO
G\t:E\ntO
G\t:E\nu`H
G\t:E\nubA
G\t<I
G]H;I
G_ rr\e
G_a=6
Gbb}H
GdͽUW\n
Generated by Steam Audio\n
GenuineIH9
GenuineIntel
Genuu\aH
GetACP
GetActiveProcessorCount
GetActiveProcessorGroupCount
GetActiveWindow
GetCPInfo
GetCommandLineA
GetCommandLineW
GetConsoleCP
GetConsoleMode
GetCurrentPackageId
GetCurrentProcess
GetCurrentProcessId
GetCurrentProcessorNumber
GetCurrentThreadId
GetDateFormatEx
GetDateFormatW
GetEnvironmentStringsW
GetExitCodeThread
GetFileInformationByHandleEx
GetFileType
GetLargePageMinimum
GetLastActivePopup
GetLastError
GetLocaleInfoEx
GetLocaleInfoW
GetModuleFileNameA
GetModuleFileNameW
GetModuleHandleExW
GetModuleHandleW
GetOEMCP
GetProcAddress
GetProcessHeap
GetProcessWindowStation
GetStartupInfoW
GetStdHandle
GetStringTypeW
GetSystemInfo
GetSystemTimeAsFileTime
GetSystemTimePreciseAsFileTime
GetTickCount64
GetTimeFormatEx
GetTimeFormatW
GetTimeZoneInformation
GetUserDefaultLCID
GetUserDefaultLocaleName
GetUserObjectInformationW
Gez\es$;J
Gf<@s
Gg;Ӎo
Giy:S
Gj;Wk0
Gk:cd
Gk<D\eS
GkӼ\bHN
Gl;h3
Glu?A
GlubA
Gm轜ls
GnC<O
Gn\t>\b
Gr@;vA
GrJoq
Gr\r<G
Gs:97
Gs;k~\a
Gv;|J1
Gv<3;N
Gvκ6d
Gx9]uP
Gyƻq5
G|b=52
G}F92wu
G}G;S
GĒ:WL
Gɹq@a:t
Gݾ\bWB
GᅻD\e
H : %M
H : %M : %S
H A;\bt
H SVWH
H UATAUAVAWH
H WATAUAVAWH
H!D$ E
H!K=eC
H!T$0D
H"<jV\t
H#L$8H
H#؉M\bH
H%B;IM4:G
H(۸33
H)G0E3
H*:IE
H*=I8
H+D$pH
H+D$xH
H+D$xL
H+E\bH
H+E\bI
H+HXH+P
H+HhH+P
H+L$ xFH
H+OPH
H+Q\bI
H+SPH
H+T$pH
H+T$xH
H+r;pq
H+ÉM\bH
H+ЋG0
H0:~bV
H1<sF\b
H1ʻ;9
H2\t;c44
H30;t
H39dYk
H3E H3E
H3̋D$ H;\r
H3ۉl$P
H5<M\bv
H5<mN
H5ڻ>1M
H7;5Ӫ:Z\n
H8DQ7;s
H8|UT
H9'wٻP
H92t\tI
H9:t\fH
H9>&X
H9A u\bH
H9A\btgH
H9C s(H
H9D$@t;A
H9D$Ht;A
H9D$Pt
H9D$Xt
H9D$`t
H9D$pt
H9E\bt>A
H9H s
H9L$Ht?H
H9\at\tH
H9c(8
H9i\bvZD
H9q\bt\a3
H9s\bt\vH;C\bv
H9t$@t\f
H9溅s
H:7-9
H:<qkv
H:H=I
H:y\n\t
H;0c4
H;3u-I
H;3u0I
H;3u7H
H;3u:H
H;5\bB:\eL
H;A w7A
H;A w9
H;A\bt\e
H;B\btY
H;B\bt\e
H;CXt\e
H;C\bt\aH
H;C\bu\f
H;C\bv\bA
H;C\bw(H
H;C\bwfH
H;C\bwkL
H;D$Pu\bM
H;D$Pv\r
H;D$hv
H;F w%H
H;G w%H
H;G\btO
H;H s\bH
H;H\bu\rL
H;H\bv\a
H;K w\t
H;NPt
H;NPt)A
H;O\bt/H
H;P\bu\fL
H;P\bu\rL
H;Qz";R
H;W t\t
H;XXs\v
H;\asPD
H;\at$H
H;\at'ff
H;\n8
H;\rE
H;\rG4
H;\rT4
H;\ra4
H;\rn
H;l$8
H;m(0
H;o`r
H;t$0L
H;t$0t
H;tjy
H;xXu5
H;yNa
H;|80u\nK
H<(i1
H<8La
H<9&l
H<=wU9ܾc
H<Z깻L4
H<cmV
H=e<Ui
H=hSm
H>*OA
H>7T켆F
H>hl\f
H>́h?5u
HA=\f/A
HA^A]A
HA_A]A
HA_A^A]A
HB廨}ȻA\bx
HC<VX
HCL;o
HFX=ej
HG<?wQ
HGݻsp
HH:mm:ss
HH;^Hs
HH;{Hs
HHH+H
HI96vԐH
HIԼ\nK\f
HJ\n?J
HL:Ƅp
HLc@\fIc
HM9\bJJ;(\f
HMcɃ~\b
HMcɃ~\f
HO<A!R
HPH+HHH
HR;xu
HR><y5
HS伳q\r=0
HT5K)T
HT9)\a
HT\a;H
HV:N<H
HV^<1
HW:m,ݻ6
HWҼ6j
HX\r;\t
HX\rB\f
HX\r\a\a
HX|$R
HY&:g
HY,+bA
HY,\ebA
HY1:Q
HY:.G
HYFpŠY
HYM\nbQtHY
HYe\fbAT@Ye
HYt\a\fb
HYu\fbA
HZh<s
H\\M ŨY
H\\M0ňY
H\\MpňY
H\a\b;u
H\b9b\f
H\b:Z
H\bH+\bH
H\bL9I\bu\bD9
H\bSUVWATAUAVAWH
H\bSVWATAUAVAWH
H\bUATAUAVAWH
H\bUATAUAWH
H\bUATAVAWH
H\bUAUAVAWH
H\bUSVWATAUAVAWH
H\bUVWATAUAVAWH
H\bUVWAWH
H\bUWATAWH
H\bUWAUAWH
H\bVWATAUAVAWL
H\bVWATAVAWH
H\bVWAUAVAWH
H\bVWAVH
H\bWATAUAVAWH
H\bWAVAWH
H\e/=n9
H\f;xz6
H\f<C|8
H\r4:k
H\r<w*f
H\t#;8A
H\t<gT\t
H\vT$PH3
H]A]A
H]A^A
H]A_A
H]A_A^A
H]A_A^A]A
H^=NTm
H^T<u
H_D8f
H`3\bD$8H
Ha=RjR
HaL;K
Haswell
HcAHH
HcA\bH
HcC(HcK,E
HcD$(H
HcD$(Mc
HcD$0LcL$(H
HcD$0LcT$(H
HcD$8LcT$0Lc\\$(H
HcD$xLi
HcD$xM
HcEWLi
HcEoL
HcF(Hk
HcF(Lk
HcG(HcO,E
HcI\bLk
HcL$p3
HcL$pL
HcS\fHcK
HcT$`H
HcU\bHcM\fK
Hc\\$4H
Hc\\$8H
Hc\\$DH
Hc\\$HH
Hc\\$TH
Hc\\$XH
Hc\\$pA
Hc\\$pE3
Hc\\= H
Hc\\= I
Hc\aHcW(HcO$LcG
Hc\tt$H
HciHH
Hcl$`LcT$pLc|$h
Hcq;:&g
Hct$pD
Hc|$hH
Hc|$xH
Hc} Hc]$LcU(LcE,I
HcȉD$0
HcȋB\bA
HcˉD$P
HcҋE0H
HcҋEHH
Hcҋl$`M
Hc߉M H
Hc߉T$0H
Hc߉T$PH
Hc߉U H
Hc߉U(H
Hc߉U\bH
Hd<BZ\n
Hd<g{7
Hd\e:hE
Hdͻ\rr
Hdлp/\r
He3<9
HeapAlloc
HeapFree
HeapReAlloc
HeapSize
Hfǹ4IX
Hg%;e5
Hi1:I
Hjֻ*Jn
HkT$HpH
HkT$`pA
HkT$xpH
Hkv=k_E
Hm<x\vw
Hmm>\r
Hn\v:v
Hnռ\ajX
Ho;lJ5
Ho@;i
HoK=eM
Hp$1b
Hp$qH
Hp$qb!}Hp\f
Hp$±b
Hp$±b!4HY
Hp$±b!D@Y
Hp$ñb
Hp$ȱb
Hp$ȱb!4HY
Hp$ʱL
Hp$ʱbq\\H
Hp$˱H
Hp$˱b
Hp$رb
Hp$ٱb
Hp$ڱH
Hp$ڱb
Hp$ܱbQ}Hp\fԱbR\r
Hp,qb
Hp,qba}Hp
Hp,ñb
Hp,ȱb
Hp,ɱb
Hp,ʱb
Hp,ʱbAT@YU
Hp,˱b
Hp,˱ba<@Y
Hp,бI
Hp,бb
Hp,бb"E
Hp,бba4@Y
Hp,ұb
Hp,ԱbA}Hp
Hp,رb
Hp,رb!}Hp4бb!tHY
Hp,ڱb"5H
Hp,۱I
Hp,۱ba|H
Hp1b!}HpԱb
Hp1b!}Hpرb
Hp1b2M
Hp1bA|H
Hp1bA}Hpձbq|H
Hp1ba|H
Hp1ba}Hpʱbr}H
Hp1bq|H
Hp4±bQL@Yu\nb
Hp4ñbq
Hp4ıbQ}Hp\fܱb
Hp4ȱb
Hp4ʱL
Hp4ʱb
Hp4ԱbQ}Hp<ܱb
Hp4ֱI
Hp4ֱbQ}Hp<ƱbA}Hp
Hp4رb
Hp4رbq
Hp4ڱL
Hp4ڱb
Hp4ޱb
Hp<1b
Hp<1bq$HY
Hp<qb
Hp<±b
Hp<ñbq$HY
Hp<ıb
Hp<ƱbA}Hp\f
Hp<ȱb
Hp<ʱb
Hp<ʱbQDHYM\fb
Hp<ʱba}Hp,ڱbQDHYM\fbA
Hp<̱bA}Hp
Hp<бb
Hp<ұb!}Hp
Hp<ұbQ|H
Hp<ֱbq,HY
Hp<ױb
Hp<ڱL
Hp<ڱb
Hp<ڱb!}Hp
Hp<ܱb
Hp<ޱb
Hp<߱b
Hp\f1L
Hp\f1b
Hp\f±b
Hp\fƱbQDHY
Hp\fȱb
Hp\fʱb
Hp\fʱb!}Hp
Hp\fʱbAtHYE
Hp\fϱbQDHY
Hp\fбbat@Y
Hp\fұb
Hp\fұb"EH
Hp\fرb
Hp\fڱf
Hp\fܱb
Hpqb!D@Y
HpqbA|H
Hp±b!}Hp
Hp±bA|H
Hp±ba}Hp
Hpñb2
Hpñba|I
Hpñbqt@Y
HpıbA|I
Hpűb!L@Y
HpűbQ}Hp
Hpűba|H
HpƱb2E
HpƱbA
HpƱbQ}Hp
HpƱba|H
HpǱb1}Hpӱb
HpǱbA
HpǱbQ}Hp
HpǱba}Hp
HpǱba}Hpѱb
Hpȱb!|H
Hpȱba\f@Y
Hpɱb!|H
Hpɱb!}Hp1b
HpɱbQ|H
HpɱbQ}Hp
Hpɱba
Hpɱba|H
Hpɱbb
Hpɱbq}Hp̱b1}Hp߱b1}Hp
Hpɱbr}H
Hpʱb"U
HpʱbA|H
Hpʱba|H
Hpʱbr}H
Hp˱bA|H
Hp̱bA4H
Hp̱ba|H
HpͱbAD@Y
Hpͱbq}Hp1b
Hpαb!}Hpбb
Hpϱb!|H
Hpϱb!}Hp1batH
Hpϱba}Hp
Hpбb!|H
Hpбb1
Hpбba|H
Hpѱb!TH
HpѱbA,@YU
HpѱbAD@Y
HpѱbQ}Hp
Hpѱba
Hpұb!|H
Hpұb!}Hp
Hpұb2UH
HpұbA|H
HpұbQ,HYU
HpұbQ}Hp
Hpұba|H
Hpұbr
Hpӱb!|H
HpӱbA}Hp
HpӱbQ\\HY
HpӱbQ}Hpݱb
Hpӱba}Hp
Hpӱbq|H
HpԱbA,@YU\vbB
HpԱbQ,HYU\rbB-H
HpԱbr
Hpձb"=H
HpձbA,@YU\abB
HpձbQ,HYU\tbB-H
Hpձba|H
HpֱbA}Hp
HpֱbQ,HYU
Hpֱbr}H
Hpױb!|H
Hpױb1|H
HpױbA,@YU\rbB
HpױbQ
HpױbQd@Y
Hpرb!}Hp
HpرbA}Hp
HpرbaD@X
HpرbaL@X
Hpٱb!|H
Hpٱb1,HY
Hpڱb!\fHY
Hpڱb!}HpԱbrM
Hpڱb1
Hpڱb1|H
Hpڱba}Hp
Hp۱b!|H
Hp۱bA|H
Hp۱bBUH
Hp۱bQ}Hp
Hp۱ba
Hp۱ba|H
Hp۱bbE
HpܱbAl@Yu\bb
HpܱbQ,@Y
Hpܱba|H
Hpܱba}Hp
Hpݱb1,HY
Hpݱb1|H
Hpݱba|H
Hpݱba}Hp
HpޱbQ}Hp
Hpޱba4@Y
Hp߱bAd@Y
Hp߱ba|H
HqP:\ai
Hq\e9\a
Ht:;HA
Hu;`4F
HvvGa
HyͻKR
H{<no6
H{\f<OUv<8Ra
H|m;J
H~S=ita
Hǽ:pJe
H͛:pL
HлLj\t9j
Hա:Fo
Hܐ> 8o>d
H廼 \a
H쐼l6ϼD
I : %M : %S %p
I ;64
I I;U8r
I I;V8r
I \v; x1:H
I!>HuR
I"9U/x
I#<ILK
I#=fW
I%7M\f\r7
I'9J\r
I(<4K
I(H+H H
I(L+I H
I+3;c
I+A0I+K
I,<zuH
I.Q;<ZI9Q
I/:6BB
I0T<UO
I0ŪXi
I2ּak
I3=8I
I3?;1
I3s:Ɂ\f:5u
I6<3b
I7,QG9d
I7v9#rX=O
I87:F:G:s
I90t\tH
I91t\tH
I96t4H
I98u*A
I99C\eG
I9<$v0
I9U0v
I9U8v+I
I9kj^;b
I9q sEI
I9}(tiH
I:'kh
I:2T\r9
I:5r:q
I:U+i
I:c:3ޙ9
I:k\f69c)4;x
I:ýND\v
I;6\nw;uL
I;:\vje
I;;DC
I;D$ w%H
I;D$Pt
I;E vBH
I;E vEH
I;E veH
I;E w%H
I;EPt+A
I;FPt
I;L$ w\n
I;L$ w\t
I;M w;I
I;M w\n
I;M w\t
I;MPt
I;NPt
I;O w\n
I;O w\t
I;U w\tI
I;U8r
I;V8r
I;\bA
I;\bt\aH
I;is\n
I;pf7
I;q s?I
I;s8A
I<$wh
I<N:8
I<RRĻ8
I=0\aW
I=Xwm
I=jm\b
I=xvW
I=|WZ
I>TtɾI
I>[eL>G
I?N;j
I@L9{8u\vH
IA:)Nx
IC;Z{k
ICMF}A
ICμyj
ICܱb!}Lp
ID + n-1 <= set.ext_range_size
ID$@H
ID$TL
ID<d-\n
IG4=>V
IH9;MK\r
IH9B\ftEHcR\fI
IHHcB\fJcL\b
IHŪ\\yP
IIݻEQ
IJL$PP
IJL$`P
IKD:fx
IKg<k
IM1:MT
IM<\e%2
IND)ind
IP<ga
IP<qN
IPL;N0
IPLAirAbsorptionModelType
IPLAmbisonicsType
IPLAudioEffectState
IPLBakedDataType
IPLBakedDataVariation
IPLDirectEffectFlags
IPLDirectSimulationFlags
IPLDistanceAttenuationModelType
IPLHRTFInterpolation
IPLHRTFNormType
IPLHRTFType
IPLOcclusionType
IPLOpenCLDeviceType
IPLProbeGenerationType
IPLReflectionEffectType
IPLReflectionsBakeFlags
IPLSIMDLevel
IPLSceneType
IPLSimulationFlags
IPLSpeakerLayoutType
IPLTransmissionType
IPLbool
IPLbyte
IPLfloat32
IPLint32
IPPCODE
IPPDATA
IQj=n
IS8Lpn:\nb
ISӻ\e\t
IXH;J(H
IXI;HXI
IZ;gFE
I\\\e;VYJ
I\aba|H
I\aba|\b
I\aba~\b
I\bI+\tH
I\bL+\vI
I\bba~\b
I\f@;z0u
I\nba^\bX
I\nкH
I\rba~\b
I\v<K6M
I\vڻXa
I`W<b
Ia<\t
Ib&:0\b
Ib:2\vP
Ib\t<2
IcD$ A
IcD$$D
IcD$(IcL$,E
IcD$\bA
IcD$\bIcL
IcD$\bIcT$ McT$,H
IcD$\f
IcD$\fD
IcD$\fIcL
IcD$lL
IcElL
IcF\bIcN
IcF\bIcV McF$McV
IcF\fIcN
IcG\bIcW McW,H
IcL$lF
IcT$ McT
IcT$$McL
IcT$(IcL$$McD
IcT$8H
IcT$<H
IcV McV
IcV$McN
IcV(IcN$McF
IcY\fIcI
Ic}\bIcu
Ic̉U0H
Ic̉U`H
Ic͉T$0H
Ic͉U H
Ic͉U0H
Ic͉U\bH
IcԉL$HH
IcԉM H
IcԉM(H
IcԉM0H
IcԉM\bH
IcԉMpH
IcՉL$@H
IcՉM H
IcՉM0H
IcՉM@H
IcՉMPH
IcՉM\bH
Ic։M\bH
Id7;9O
IdP=s
Ig8-QʹD19
Ihttp://crl3.digicert.com/DigiCertTrustedG4RSA4096SHA256TimeStampingCA.crl0
Ij$>P
Ij;#mD:K
IjL;C
Ik?<g
Iks:og
Il(;R
Il?333333c
Il\n;x
Ilu;Q
Index is out of bounds
InitOnceExecuteOnce
InitializeConditionVariable
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
InitializeCriticalSectionEx
InitializeSListHead
InitializeSRWLock
Initialized AMD Advanced Media Framework v%d.%d.%d.%d
Initialized Embree v%lld.%02lld.%02lld
Initialized OpenCL device: %s %s (%s
Initialized OpenCL platform: %s %s (%s
Initialized Radeon Rays v%.2f
InterlockedFlushSList
Internal error
InternalName
IntersectAny
IntersectAny2L
IntersectAnyRC
IntersectAnyRC2L
IntersectClosest
IntersectClosest2L
IntersectClosestRC
IntersectClosestRC2L
Io;<W
Io;mS
IpŢ\\i0
IpƱba}Jpqb
Ipɱba}Jpڱb
Ip˱bA|H
Ip̱bA|H
Ip̱ba|H
Ipͱba|H
Ipαba}Jp±b
Ipѱba}Jp۱b
IpԱbA|H
IpݱbA|H
Ipݱba|H
Iq~;Y
Ir==s
IsDebuggerPresent
IsProcessorFeaturePresent
IsValidCodePage
IsValidLocale
IsValidLocaleName
Is\t;n
Iv*;zy
Iw\bZ
Iz!4\a
Iz&94Z
Iz\t;OJ
I}ļm\vs
IƟ;Zo
Iɾy?ԽDC
I˔;\agi
I̺\epF
Iͤ:oq\t
Iιy9o
IϼX>R
Iм)lv
Iػ3ld;R79
IⱾ" V
J"bA|\b
J%:9J
J(=Y\tu
J(ba|\b
J):\bzs
J)\r;xhX
J,ba~\b
J-;kUQ
J-;mhۻg
J.i:_TC
J0:LN
J0:fQ
J0W;%\t
J0úJM
J2<2h
J4ba~\b
J5<#h\a
J5ջ\rFz
J79 X
J93ζ9
J9\re+:\e
J9`?Y
J:;5W;dw
J:@ž7v6z
J:B9\t
J:`\nx9
J;8n9d
J;D10t\tH
J;K[U9ly
J;Lk5;9
J;Un#;J
J<0"0i3
J<Q2F
J<UP6
J<X[A
J<Ӻju
J=<qX
J>F*j=s
J?:RFk
J?\v<Xb
J@1;C
J@>HBh
JAKgdB
JAj;P
JBԓpBXchB
JCmQ,B
JG1>jY
JG<zf
JIU<:O
JJ:2uQ
JK\t;H
JL\v;C㍻qB\a;m\b5
JLνn;\b
JO2<i7y
JS9\fuq
JSv:J
JT:wx\t
JU/9F=3
JVC;fN
JVͻM(1
JW,:IYK
JW,:k
JWP:>О7t
JWP;\a
JWĻCb
JX.<C
JXI źXy
JY;.iF;\rl
JYk;\n
JYl\al
JZ;pm
J\a;rd\v
J\ab!|H
J\abA|\b
J\aba|\b
J\b3\tB\f
J\b?ZU1
J\bba|\b
J\bba~\b
J\f=d3a
J\f\b
J\fba~\b
J\nbA
J\nba|\b
J\nba~\b
J\r9<c
J\rbA|\b
J\t:4
J]f=Dh
J`;3j
Ja':q
Ja8N؍:\vn
Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December
January
JbT:;ZB
Jbk9f
Jc,;_Yc;Gd6
JcD0\fI
Jgv<p
Jgн˜3=F\a
JhȽ|z
JkS>1C
Jl<MnA
Jnj:.N
Jo;ZQK
Jpαba}Ip
Jq<ٴN
Jq=\bt
JqӽoA
Jr5<P
Js\e;$E
Js~<b\t
JtC=L
Jv,=H5
JwH;k5
JxѻPK
Jy:<P
J|iNd
J~A<q\vi
Jž1k\t
Jƞ;\v6T
JʻamȻf
Jώ;M7
Jј<z1
JӰ9+Y9;4
Jӻv}i
Jԋ>I0
JֺVT98
Jٹ?Zi:7
JڹF\v
K H+ЋD
K SUVWAVH
K"ԺWT
K#̈bS-J
K#͈bC\rL
K%2;V
K%Z;h
K(y:j
K)=2m
K*;1r\b
K*w;B
K+U<_jr
K-;EzY
K-k<C$C
K.Z9R
K.Ϻ5 ݻJe
K0HcQ\f
K0HcQ\fD
K4:{e
K4w;E
K7r:3`9:%0
K8:˾Q
K90;\f
K9Hu^9
K9Tљ9n
K9Y3u
K9k_(;mA4
K9v4%;Fu&:G
K;"bH
K;7`8
K;A\a@9
K;GqY
K;Nٰ8S"5;N=6
K;T3L
K;j2ļyP8
K;zj\r
K<V=s
K<aXG;0
K<gOo;k
K=9ev
K=o64=y\bc
K={wl>r1
K>H(L>Sg
K>exU?3
K>g'9
KAF:0
KB;1R\v
KD$ E3
KD=;k
KD?;h
KE; H
KERNEL32.DLL
KERNEL32.dll
KEѻSN
KF:)uV
KG\n;I
KHH;\rt4
KHf9}rx9
KHi;\\h
KI;)hR
KIڽ02
KJ;7-\a
KJ;?U
KJj;Z
KJn>EN
KM:\r
KM:^C\b
KN;\eN
KT,>w
KTW;Xr
KW;0'\t:T
KW;wy
KW\r;Υu;i
KWc;jۛ;a
KXH;\r
KXM+KPI
KZI:5\t
KZ[:i!N
K[:cc
K\aU:3Of
K\b;b
K\b<ic
K\b=CŹ=Yg
K\bATAUAVH
K\bH;\rO
K\bSUVWATAUAVAWH
K\bSUVWH
K\bSVWAVAWH
K\bUATAUH
K\bUAVH
K\bUSAVAWI
K\bUSVWATAUAVI
K\bUSWATAVI
K\bUVWATAUAVAWH
K\bUVWATAUAVI
K\bUVWAUAVAWI
K\bUVWAVAWH
K\bUWAUAVAWI
K\bVWATAVAWH
K\bVWAVH
K\bWATAUAVAWH
K\bWAVAWH
K\bbA|H
K\n9[M
K\r<3S\a
K\r?z
K\v\tr\r0n
K]F;^3O
K]o9\v4
K]taM
K^a9ma
K`H;\rq
Ka=tCP
Ka|ptt
KbP9v
Kd %f %f %f\n
Kd:>J
Kernel32
Kj:\f[H
Kk;\\S39
Klh:Rw
Klɻ22\r
KmV<3
Km|;jV7
Knights Landing
Knջdx
Ko\v=Y
KpH;\rx4
KpI;J
Kq6:_\r
Ks %f %f %f\n
Ks9\n
Kt@<TN
Kw!=>h8
KxH;\rn4
KxS:HQ
Kxɻ.U17n
Kz<1fS
Kz_;Zk
K{J9y
KŻ9\vo;\f
K˼g%7
KѼ\vC
Kѽ8:t
KԻY{G
KֻO\eͻz
Kּ]bK
KݻbW9
Kޢ;FM
L  fB
L 0fC
L <gtȻl
L" fC
L#܈bs]I
L$ E3
L$ E3\v1
L$ H;H\b
L$ Lc\\$4L
L$ SUVWH
L$ SVWH
L$ SWAT
L$ SWAW
L$ SWH
L$ UATAUAVAW
L$ USATAVAWH
L$ USVATAWH
L$ USVAUAVAWH
L$ USVWATH
L$ USVWAVAWH
L$ USVWAWH
L$ USWATAWH
L$ USWAUAVH
L$ USWAUAWH
L$ UVWATAUAVAWH
L$ UVWH
L$ VWAVH
L$ WATAUAVAWH
L$ fA
L$ fD
L$ t!A
L$(3ɉD$ D
L$(A2
L$,fD
L$0H;K\bt\nH
L$0H;u
L$0HcD
L$0IcD
L$0IcL
L$0fA
L$0t!A
L$0t\rA
L$0ŘYD
L$0ŘYD$P
L$0ŘYE
L$0ŸX
L$89L
L$8;G
L$8LcȋQ
L$@A9MP
L$@E)uP
L$@Hc
L$@HcD
L$@IcD
L$D;L$T
L$HH;\r
L$Hb!|H
L$Hfff
L$Hs!E
L$P+L$8
L$P+L$H
L$P3\tD$8H
L$PD9v
L$PHc
L$PIcD
L$PfC
L$PfE
L$Pfff
L$PŰTE@H
L$PŰT\f
L$THc
L$XI+L$PI;M
L$\bATAVAWH
L$\bAVH
L$\bE
L$\bH
L$\bSATAUH
L$\bSAUAWH
L$\bSUVWATAUAVAWH
L$\bSUVWATAUAVAWL
L$\bSUVWAVAWH
L$\bSUVWAVH
L$\bSUVWH
L$\bSUWATAUH
L$\bSVWATAUAVAW
L$\bSVWATAUAVAWH
L$\bSVWAVAWH
L$\bSVWAVH
L$\bSVWH
L$\bUATAUAVAWH
L$\bUSATAVH
L$\bUSVAVH
L$\bUSVWATAUAVAW
L$\bUSVWATAUAVAWH
L$\bUSVWATAUAVH
L$\bUSVWATAVAWH
L$\bUSVWAVAWH
L$\bUSWATAUH
L$\bUSWH
L$\bUVWATAUAVAW
L$\bUVWATAUAVAWH
L$\bUVWAVAWH
L$\bUVWH
L$\bUWATAVAWH
L$\bUWAVH
L$\bVATAUAVAWH
L$\bVWATAVAWH
L$\bVWAUAWH
L$\bVWAVH
L$\bWATAUAVAWH
L$\bWATAUAVH
L$\bWAVAWH
L$`H+t$PH
L$`HcD
L$`IcD
L$`fD
L$`fff
L$hH+t$PH
L$pH;L$P
L$pfA
L$pfB
L$pfff
L$pŰXMp
L$x3ۉT$XD
L'3>7
L( fB
L* fC
L*t.r0
L+@9\nu
L+L$xL
L+d$8I
L+e E3
L+w>p{B
L. >Y
L0;CV\b
L3 b1
L38;<d
L3:\a
L3;Kp
L3=,J
L5#;48
L5;Wp
L5<4끼<o
L6<v|Q
L7=Vo
L7A@V
L8<wNb
L9"t\rH
L90u H
L9;0ʍ:Y
L9;<T
L9@JL;4w
L9c\bt\vH;C\bv
L9d$(s
L9hc\n
L9p\bt H
L9s.λJ
L9x s\nD
L9~Xv=I
L9~XvCI
L:%kM
L:Bx\f
L:E\bC:Tv
L:Zfc
L:nl~:85\f
L:x\e
L:{Lr9
L; u9H
L;3u3I
L;3u7H
L;3u;H
L;3u>H
L;9Bl;.u
L;;u6I
L;<\r9j
L;PPZ
L;X-x
L;\r2
L;\r2E
L;\r4a
L;\ra
L;\rrE
L;\t8g
L;\tM&9
L;a\ac:C
L;d$HH
L;i%R
L;sMi9䳮8
L;u}W
L;x\b
L;y s|H9V\b
L<%OW
L<iWj
L<j_J
L<pAͺNt
L<q\fs<8
L<tsF
L=C\e
L?UUUUUUU
L?n(Zy
L@Y<9b
L@YA\vbaL@Yi
L@YI\fb
L@YQ\bb
L@Ya\tbaL@Ya\rbaL@Yq\nb
LA;$H
LAѼ\tx
LB(9J\bMc
LBʺ,1
LCIDToLocaleName
LCMapStringEx
LCMapStringW
LCW&qB
LC_ALL
LC_COLLATE
LC_CTYPE
LC_MONETARY
LC_NUMERIC
LC_TIME
LCr;xp
LEv;B
LGλߞ4:nF
LHYu\bb
LHYu\fbBMH
LHYu\nb
LJ;t*6;\r
LL(;sd
LLS;D\n
LM>:Gs
LO=IKR=i
LQ::3F;U
LQ<\fm
LR;xP
LT fC
LTW;zh
LTϻpz
LU fC
LV{;z
LX<"H
LXֻK\t
LYN`ŔY
LY\e<<A
LZ6;Dc
LZ><5
LZCNT
L[:u5
L\a;h
L\a\nbQ|H
L\af;w
L\b;J\aU
L\bt;n
L\e:\ep\b
L\n\\;oPZ:rq
L\n\vba|H
L\r+;22
L\r<oK8
L\t<c(Y
L\t>J沾fQ
L\vN;Ye39
L\v\r)C
L\v\r,8
L\v\r|B
L`;wm
La9;F
LcA<E3
LcB\fHcJ
LcD$4I
LcD$HI
LcD$xH
LcL8\bL
LcSlI
LcT$(Mc
LcT$`Lc\\$pLc|$h
LcU\bLcE\fI
Lc]0LcM4HcU8
Lc]lI
Lcc0I
Lcd$tH
Lcd$xH
LcewHc
Lcg0āz
Lco0āz
Lcs8L
Lcs<L
Lcǉt$8
Lcʍ\fRL
LcщL$HI
Lc҉T$4I
Ld;6,R
Ldy<x4
LeaveCriticalSection
LegalCopyright
Leպj'g
Lf ;1
LfH;xR
LgQ<R
Lgk<pMm
Lhttp://cacerts.digicert.com/DigiCertTrustedG4RSA4096SHA256TimeStampingCA.crt0\r
ListenerPosition
ListenerUp
ListenerView
LjȼF0
Lk6;S
LkڻA\n
Ll;=Z
LoadLibraryA
LoadLibraryExA
LoadLibraryExW
LoadLibraryW
LocaleNameToLCID
LookupPrivilegeValueW
Lpd9\b
LsY;w
Lt:-q
Lu*E;t
Lu:/vR
Lu;4\a
LuȻS!T
Lw#;aR
LwCԓpB
LwZ:\aa
Lx4;V
LzdA9
L{;JlA
L{=R7
L}7;R
L~Z<9
Lú,vE
LǼhE強U
LȺ`FU
L۾=kmT
Lܟ<Fi
Lܻ/h0<S
L毺#$p9M
L溬U2<2
L뢺HCA;(sպ\tG
M HcD
M HcE\b
M ŀYM0
M#g\bt
M#l$\bt
M#o\bt
M%;3J}6i
M&t:Z
M'y>0y
M(A+M0
M(A+M0A
M(f95
M)\r=Dk
M+1 < max_size
M+2;5V
M+D$PI
M09L8\bu
M0HcE\b
M0L;x\b
M0ȹ6,h
M19uA
M1ػ\r
M2\e>(G0
M5D:\t
M6%:V\b
M8J<^N
M8L+M0L
M8LcC\bI
M9,<o
M9e t4L
M9n t4L
M9n8v,I
M9~Xv=I
M9~XvAI
M9~XvCI
M9~XvDI
M9~XvEI
M::\fR6=F0
M:FWC9\a
M:F\t
M:F]T;i
M:i\r
M:mZI
M:~\aO9
M; Tz
M;=0c
M;Cis
M;D$0u
M;FXr
M;Iq
M;O w\n
M;O w\t
M;\vC
M;\vu.H
M;_\n0<d7
M;a)Y:cWa
M;gzѻj
M;uZ)9
M;x\b
M;yKL
M<Z⣼je
M<g-7
M<okk
M<u\a
M<v4S=dp
M<|nZ
M=F\rp
M>9rT
M>N:hO
M>jYX
M?H;MGs H
M?ؼ5T
M@9GlL
M@;\buA
M@ŔYq
MA!;b
MAh9k
MB (100.00
MB(iVR
MC'<x
MC|D\t
MD#Έb3}D
ME\r<*j
MFغBV
MK&;A
ML<\aur
MM/dd/yy
MM<-r
MM[<\fb
MM\v;S
MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON
MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON
MN(;n\bI
MO=#II
MOy:O
MP9'/r
MP;4nf
MP;H(s\bD
MP;H8s\bD
MP>9(4
MPH;w
MQ(;q\b
MQO;AG
MR:}U8
MS:DP
MVC9bj
MW(;a\v
MW\\;yP
MXCSR
MXI+MPI;L
MYZ=t
MZC;\b\n
M\\Z:Zc
M\a>LmB
M\abQ|H
M\bIc\aI
M\bbA|H
M\e"<Pp
M\e;C3B:r
M\fC:E
M\fbA|H
M\nbQ4HV
M\nbQ|H
M\r=e
M\rb"eH
M\rbQ|H
M\t<T3
M\t\f
M\tbA\\@YE\fbbu
M\tbA|H
M\tbb
M\vb"5H
M\vbQ|H
M]k9đ9;,h
M`I;4
Ma%=sQ
Max split depth
MaxRealTimeComputeUnits
MaxRealTimeComputeUnits2
Mc,$H
McD$lL
McL$l3
McL$lI
McL$lL
McU\fMc
Mc\rL
Mcl$0āz
Mcl$0ġz
Mcl$4H
Mcl$8H
Mcl$<H
Mco0ġz
MessageBoxA
MessageBoxW
Mf:\nVD:1
Mh<<l
Mhttp://crl3.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0S
Mhttp://crl4.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crl0
Microsoft Visual C++ Runtime Library
Min node overlap
Mi̻OT
Mj: <;e
Mkd;`8
Mkλ\f
Ml><\rm
MlJ;DhE
MmE;=\t
Mn,<e
MnY>g
Mnݺ?K
Monday
Mp\e<I⩼K
Mpqba}Npɱb
Mprim/s
Mp±ba}Npѱb
Mpȱb!}Np1b
Mpбb!}Npqb
Mpܱb!}Np
Mpݱb!}Np
Mpޱb!}Np
Mp߱b!}Np
MtR:gTK9
MultiByteToWideChar
Mw黋hºY
Mx=;81
M{<g5\b
M~ӻeD\r
MÅ9bs
M˻Voû9B
MЈD$0H
Mѻf'N
MԺXH:U
Mވ;TI
N 6:f
N ňYEp
N"7<aX3
N()8Ix
N(+N0
N(A9O(A
N*;eaL;A
N+h:J\t
N-<odm
N.9c\fu
N0l;g\a\n
N0ŨYE
N12:T\rz
N2Lɭ3
N3;:qV
N5:<3
N7w:\a
N8=?3w
N9Ɏm;q
N9ꚨ9*x
N:"l9;H0
N:&kK
N:,ZX
N:6hҺI
N:@ok
N:Bnz:l
N:I\n
N:\fJ
N:d$p9
N:xV 9lwm:L
N;2]P
N;:3S
N;EN\f<Wm
N;\eu\t;oV
N;yF(;d
N<<O0
N<>8Z*8.h
N>?mt
N>O=I9
N?6;\t9
N?m;WN\n
NA;Re0
NAN(IND
NAN(SNAN
NB;9*\e
NC<\r&O
NCŻrB
NEչ;F9
NF-;FE
NGV:ps
NHv<\b4
NK"<4
NK=XiG
NLv!H
NLv"H
NO+;p
NP:DJt
NPH;I|$p
NS[;\br
NU:tv
NUֺRv
NVG<j
NW;Jʘ:I
NWW=D
NXI+NPI;M
NZt>R
N\a7>YP
N\bL91u
N\eh;nD
N\f<5\e
N\fN\b
N\n<6,u
N\n<g蚻=sM;Ez
N\n>m
N\v;S
N\vk;d5
N\vxV
Nb!|H
Nb!}Hp
Nb!}Ip
Nb!}Jp
Nb!}Kp
Nb!}Lp
Nb!}Mp
Nb!}Np
Nb!}Op
Nb"5@6
Nb"5Ce
Nb"]Oe
Nb"uMe
Nb1|H
Nb1}Hp
Nb1}Jp
Nb1}Kp
Nb2\rOe
Nb;f4
Nb<]f
NbA|H
NbA}Hp
NbA}Jp
NbA}Kp
NbA}Lp
NbA}Mp
NbA}Np
NbA}Op
NbB-Be
NbB-Ce
NbBMKe
NbBUCe
NbB]Me
NbBeDe
NbBmDe
NbB}Me
NbQ|H
NbQ}Jp
NbQ}Kp
NbQ}Lp
NbQ}Mp
NbQ}Np
NbQ}Op
NbR5Ce
NbRMKe
NbR]Me
NbR}Me
Nba|H
Nba}Hp
Nba}HpP
Nba}Jp
Nba}Kp
Nba}Lp
Nba}Mp
Nba}Np
Nbb5@6
NbbE@6
NbbUMe
Nbb}Me
Nbq|H
Nbq}Hp
Nbq}Jp
Nbq}Kp
Nbq}Lp
Nbq}Mp
Nbq}Np
Nbr%Le
Nbr%Ne
Nbr\rMe
Nbr]Me
Nbr}Me
Nc\\\b\fF
Nc|0\fA
Nehalem
Nf\a<@\n1
Nfffff
Ng;a7a
Ni)9sW3
Nj7<h
Nl/7D\e
Nm,:p3
No such kernel in program
Node overhead
November
Npqba}Mpɱb
Np±ba}Mpѱb
Npȱb!}Mp1b
Npбb!}Mpqb
Npܱb!}Mp
Npݱb!}Mp
Npޱb!}Mp
Np߱b!}Mp
Nq);p
Nr维iT
Nso<Uh <[EF
Number of nodes
Number of nodes in corresponding non-split BVH
Number of rays in the workload \n__global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n
Number of triangle refs
Number of triangles
Nv<v\b
Nwܻ[Q
Nxr;z}C
NzQ759
NÒ9a/ֺG
NʹKwR
Nʼ8\r
NʽqQ;<b
Nйh4L
Nѫ8F k
NӹE0ٺ[YF
N֖<Hj
NֻM?c
Nސ:aG
N߈<7m\e
N꺑了9w
O +O0
O <6qﻁ?8
O ŰYL
O!9u\tr
O"<Fox
O%<bZ7
O&G=GM
O(A+O0
O(D;O,L
O*u;C
O+ԻFcU
O,;42
O/;2R
O/M:Yj
O0L;`\b
O0S:#Q
O0ŨYEp
O2\r:T
O3 <9
O34<u
O3<\rL
O7;CN\a
O8eq۹9
O9:\e
O9>g+̾F~C
O9k\eL;7
O:L`z;6G
O:OI\t
O:XZ0
O:\rI
O:j\vκ\f6
O:n%I
O:n&c
O;)Kh97H
O;0JV
O;3eu
O;>Kf
O;EMX:L1
O;Q;0S
O;xY~:3
O;ʊZ9I
O<+Ch
O<I8r<55
O<PTS
O<RoL
O<\nm\a;U
O<o|x
O=Эl=rf
O>'Nz
O>A\v
O>a4\e
O@H+GHH
OB9>&L
OC;Ox
OE:;Cmɺn
OF<;AX
OFȻQ=\n
OI2;#C#8T9
OI>4v
OK;)n
OMs9Gr
OP4=q
OPH;It
OR<nNE
OS<\eoS
OT9IGU9
OU=\t9
OUA:\v
OXH+OPI
OXH;OPt
OXL+OPI
OY;;T
O\b&tN\b&dM\b&4L\b
O\bH99u
O\e{dP\r<u
O\r?e
O\ru>O\r
O\v⼋G
Obk:nz
OcE9H
Oci;60
October
Od:KF
Of ;EKr
Oh6>I
Oh:t84;˴A
Oh;1O
Oi;Ǒs
Ok˻\n}4
Ol\f>k
Ol{gN
Om;Fq29"U
Oo<C`2
Oos<"m
Ooy:G9c
OpenCL.dll
OpenProcessToken
OriginalFilename
Osq<%\e
Ou:|J\a
Ou=g[P
OutputDebugStringA
OutputDebugStringW
OwR<H
Oxb;V
Oy;_R\n
OyR=MI
OyT]Z
Oz;80\b
O}'<soV
O}Q;\ec
O}|8x
OŸdxp
Oȹa5\a
OȺaOι/x7
Oɻ\fS
Oλh%S
Oμ\btF
OϺ+i1
Oջ\fN
OܼRZȼS:S
OܼYGƼ9
O춻_xB;d
P#8\bUo
P$;5vc
P%8=R
P%;7vy
P&u:.Qs
P':Udo
P)e:J
P*;0pz
P+z;%\nP9
P,9E5
P.<dcm
P.T:X
P2<C.s
P2L^T2RvV
P2L|R2
P4Ի.Co
P5=BM
P7%Cs
P7*;Y
P7g<hVB
P88EB8j
P90p»N2
P9ue!9
P9v_W
P9vۊ:y
P:;VNZ
P:KH2;v`\n
P:PYi
P:bB|:N^i
P:c!F
P:glm9
P:o!w
P:o/9
P;-sp;Q
P;2p-:cY
P;5\t
P;9G\b
P;:u6
P;;%z9P
P;;uD
P;HSr=P65
P;\eZ
P;nRǻ\b
P;ތh9
P<6{e
P<;pVq;y
P<_zûx8
P<x:C
P<zZ\t
P=X&a
P=id1=u
P> {r
P>FDO=mJg
P>q_Y
PA^A]A
PA_A^A
PA_A^A]A
PAq=?Mp
PC6>g
PC<C\r
PCż<0
PD@?h
PE:WGO
PE:[U
PE:ߴf
PG;82
PHH+P
PHH+P@3
PHcB M
PJ;I:qE
PJ;ug5;mɤ:|\r6
PJ<\f>ʻTH0
PKS;L
PL>\e7J
PLci\fM
PM<H\eW
PME<NT
POPCNT
PO˴@N
PPPPPPP
PQN;n
PS;RG
PS~;ok
PT:\bnL
PTf %f %f %f\n\n
PUUUUU
PV:R3\f
PX2?q\v
PY5cp
PYGpňY
PZ)>0X\b
P\aX=db
P\bG<A\f2
P\bJ<"ac
P\eR;g
P\rT91
P\rbA
P\t:YN9
P\v;I7\f
P\vT8D5
P\v˻b
P]A_A
P]A_A^A
P]DSH
P`m8ս\t
Pb!|H
Pb3]A
PbQ;y
PbQ}Hp
Pc;J,Z
Pc<mf\t
Pd=J=j
Pe?9ȭ9
Ph=\tcw
Phttp://cacerts.digicert.com/DigiCertTrustedG4CodeSigningRSA4096SHA3842021CA1.crt0\f
Pl;=r
Pl>FE\e
Platform
Pm<̱g
Pn_;A\fݺ9
PoԻ\b
PpH;G\btpH
Pr3<1
Press Retry to debug the application - JIT must be enabled
Probe clustering complete. (%lld probes, %lld clusters)\n
ProductName
ProductVersion
Program
Ps >O2
PsӼ{Q
Pt*9Z
Pv\f;n
Pw;D\a
PwK:7
Px$9ϧH;[Fs;M:B;6
Px:1IN
Px\e=5
Pxm=b
Pz}b!\n
P{;tiO
P{\b80\r
P}W9c\n
P~|94
Pũ;jR
Pƹ:HV9b/x
PʽJX@=1\b
Pꁺz1\r
Pﺜkn;TB
Q ba|\b
Q g;#a39e
Q)9&T
Q)G>v
Q*;9fͻ5
Q*\n8
Q,9mv
Q.>39
Q09ز1
Q0\n;Q
Q2;Wg
Q2\v>r
Q5rHg
Q6:%E
Q6:jkf
Q8+<\rp
Q8:@uZ9
Q8Kڐ:s
Q9-LM
Q99Ȋ9o
Q: 䙻l^K;v
Q:(ky
Q:@8R
Q:D=J
Q:Xji
Q:nDa
Q:|mH9
Q;3ң9
Q;9\e
Q;i\t4;8
Q;k$K
Q;rP,;9
Q;v#N
Q<6;˹hs
Q<Ee5
Q<LL㻷M
Q>)Hu
Q>.3Z
Q>9;D
Q?;4v
QA;ll
QC<CL\a
QCN:J
QC{;b
QDI:w
QF<k\nϻ,O
QF<wt9
QGջ}7;T
QH;Af;=jlG
QI);mF
QJI?me
QJr<h$4
QJ ~;F$I
QK[;pe
QL"<z
QM:&WJ
QO<^UC
QQH:Nj
QRAPAQ
QRU=$m
QS:o|2
QT;3RB
QUٻtv
QW1<|KؼY
QXX9l
QXz<%V
Q\a:RM6
Q\aba~\b
Q\bI9Q\bu
Q\bba~\b
Q\f:z
Q\fba|\b
Q\fba~\b
Q\v=\tx\a
Q\v>'QP
Q\vb!f\bX
Q\vbaN
Q\vba~\b
Q]2<4
Q`1<l3
Q`H+QXH
Q`O;F
Qa;\rE
Qa湥\fY
Qc<rGP
Qd~;lM
Qg;]bĺn
Qg\t;\b
Qg󻤍f<P
Qh٢%v
Qi9<`N
Qi<;qӼf
Qj2<2
Qkkbal
Qk}9UHĻP
Qlp9iFٺ[Uk
QlغT7G
Qm9\b
QoF9vG
Qp:P3W
Qp;4^B
Qp\v;\f
Qq@<k`9
Qt"=3
Qu;|k99
QueryPerformanceCounter
QueryPerformanceFrequency
QwI;2
Qx$=nE
Qx:+BF
QzhÐ;3
Q{:re
Q~N;I
QĹh1F96(6
QŌ=ZF\a
QȻP1L
Qɼf+l
Qѻ6,L
Qڊ;\e 8
Qܼg1Z
Q於o~t<z
R!;6K
R$ba|\b
R$p;K
R&:1L
R&ٺrO
R(ȻTL
R+<cD
R-;\rqE
R-L;4
R-b:Z
R0<^2
R0<`6
R2<S1r
R3#;q
R3:#6
R4.:;bF
R6;:E膺8
R6;S+O
R8?Bh9
R8bXźN
R8sjz9
R8|=r
R9.vӹ\a
R9=Io9<}D5
R9A\f\f
R9D:U
R9NPh
R9Wd9
R9m>,P
R:7=K
R:=uo
R:o1j
R;F\n
R;JIG
R;[x~9\fA
R;g\eN
R;zY<h
R;ĹmS
R<jeźO%4
R<l6y=E`0
R<omۻ@} :zhg
R=xRl
R>B/e
R>z☿i
R@L;FXr
R@M;FXr
R@M;FXrϿ\b
RA4;9
RAA;z\b
RC=hb
RCF;Z
RD=6>k
RDATA
RDRAND
RE\n;zD
RF:9RL
RH<PX\e<ڀ=2Bk
RHлBnk
RIQ:az
RK>VWI=N
RM:PS
RN;Q5u
RNP=eN
RO;Uk
RPܻ=K
RRG<F0
RRX8Cv
RX;u1n
R[<bRl<v`p=4
R[N;n
R\aba|\b
R\b+z\bA
R\bba|\b
R\bbb
R\ebA|\b
R\fba~\b
R\fӻA@\t8
R\nK9r#M
R\nba|\b
R\r4:BF
R\r;C
R\rp\f`\v0
R\rp\f`\vP
R\rϺi\aC
R\t:f3
R\tba|\b
R\v:V
R\vۊk
R`Q<l\r
R`bA|\b
Ra;-jf
Ra\e:dB
RaiseException
Rb=ib>>s
ReadConsoleW
ReadFile
Reb;,9
ReceiverPosition
Ref duplication
RefitBounds
Release
ReleaseSRWLockExclusive
ResetEvent
ResetEvent failed
RhbR%H6
RiF7B4
RjԻ6bM
Rk/<r
Rn黵_s9
RoInitialize
RoUninitialize
Rp3\tD$4I
Rs\e>$i
Rt>Y\v
RtlCaptureContext
RtlLookupFunctionEntry
RtlPcToFileHeader
RtlUnwind
RtlUnwindEx
RtlVirtualUnwind
Rx.:M
RxL;l$P
RyV;I7
Rzh;~օ9%SP;iO
R~R;o
RĢ: x
RźE_M:j
RƺZWg
R˷cu*:Q
R֞:PC
Rݻ\eYP
R􂻬9ɻ1
S \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localkeys.x; \n            keys[newoffset.y] = localkeys.y; \n            keys[newoffset.z] = localkeys.z; \n            keys[newoffset.w] = localkeys.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localkeys = ((__local int4*)keys)[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals = ((__local int4*)keys)[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n        int4 bin = (localkeys >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.x; \n            out_values[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.y; \n            out_values[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.z; \n            out_values[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.w; \n            out_values[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        scanned_histogram[localid] += sum; \n    } \n} \n \n \n__kernel void compact_int(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_g
S$\r;ua
S%2;n
S%R;1mi
S(H+S0H
S)<:GO;4W
S,, <Zw
S,f<Ma
S-K=5
S03\tD$03
S0<CwS
S19=-o
S1<H6Y
S2<!fE
S2D<U
S38u\f
S76ƛ:G
S7;31
S8-pԺ7g
S8pŕ:r3\t
S9US}9Do
S9\e1ƺx_u;d
S9b,T:G
S9bmD:M
S:5\fI
S:RRݻʇE
S:^6O
S:a5B
S:jg.;O
S:nHJ
S:orA
S:tJ\a
S:u{q
S;AT5
S;ThM
S;XUѺ\r
S;\nKa
S;\vK
S;p\eg:ya
S<0M\e
S<;NI
S<DQӽ?\aQ
S<dl\f
S<dxU
S=E砽\f4\v
S>$hkDh$h>[2
S>ɽ\v5R
S?ۺuj
S@I;p\b
S@bR5@6
S@bR=@6
SATAUAVAWH
SATAUAVAWUH
SATAUAVH
SATAUAVUH
SATAWH
SAVAWH
SAVAWUH
SAVAWUI
SBx;L
SD<\fs6
SE,<1x
SE˻E\f
SG;t'\e
SIVE_PART_4(float) \n \nDEFINE_DISTRIBUTE_PART_SUM_4(int) \nDEFINE_DISTRIBUTE_PART_SUM_4(float) \n \n/// Specific function for radix-sort needs \n/// Group exclusive add multiscan on 4 arrays of shorts in parallel \n/// with 4x reduction in registers \nvoid group_scan_short_4way(int localId, int groupSize, \n    short4 mask0, \n    short4 mask1, \n    short4 mask2, \n    short4 mask3, \n    __local short* shmem0, \n    __local short* shmem1, \n    __local short* shmem2, \n    __local short* shmem3, \n    short4* offset0, \n    short4* offset1, \n    short4* offset2, \n    short4* offset3, \n    short4* histogram) \n{ \n    short4 v1 = mask0; \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y; \n    shmem0[localId] = v1.w; \n \n    short4 v2 = mask1; \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y; \n    shmem1[localId] = v2.w; \n \n    short4 v3 = mask2; \n    v3.y += v3.x; v3.w += v3.z; v3.w += v3.y; \n    shmem2[localId] = v3.w; \n \n    short4 v4 = mask3; \n    v4.y += v4.x; v4.w += v4.z; v4.w += v4.y; \n    shmem3[localId] = v4.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + shmem0[(2 * localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + shmem1[(2 * localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + shmem2[(2 * localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + shmem3[(2 * localId + 1)*stride - 1]; \n        } \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    short4 total; \n    total.s0 = shmem0[groupSize - 1]; \n    total.s1 = shmem1[groupSize - 1]; \n    total.s2 = shmem2[groupSize - 1]; \n    total.s3 = shmem3[groupSize - 1]; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    if (localId == 0) \n    { \n        shmem0[groupSize - 1] = 0; \n        shmem1[groupSize - 1] = 0; \n        shmem2[groupSize - 1] = 0; \n        shmem3[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem0[(2 * localId + 1)*stride - 1]; \n            shmem0[(2 * localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1]; \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem1[(2 * localId + 1)*stride - 1]; \n            shmem1[(2 * localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem2[(2 * localId + 1)*stride - 1]; \n            shmem2[(2 * localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem3[(2 * localId + 1)*stride - 1]; \n            shmem3[(2 * localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + temp; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    v1.w = shmem0[localId]; \n \n    short t = v1.y; v1.y = v1.w; v1.w += t; \n    t = v1.x; v1.x = v1.y; v1.y += t; \n    t = v1.z; v1.z = v1.w; v1.w += t; \n    *offset0 = v1; \n \n    v2.w = shmem1[localId]; \n \n    t = v2.y; v2.y = v2.w; v2.w += t; \n    t = v2.x; v2.x = v2.y; v2.y += t; \n    t = v2.z; v2.z = v2.w; v2.w += t; \n    *offset1 = v2; \n \n    v3.w = shmem2[localId]; \n \n    t = v3.y; v3.y = v3.w; v3.w += t; \n    t = v3.x; v3.x = v3.y; v3.y += t; \n    t = v3.z; v3.z = v3.w; v3.w += t; \n    *offset2 = v3; \n \n    v4.w = shmem3[localId]; \n \n    t = v4.y; v4.y = v4.w; v4.w += t; \n    t = v4.x
SJ:U]\r
SJ;uK0
SL:o\vu
SLD<;d
SLY:Ca
SMٻEG
SOFA file %s contains non-zero values for Data.Delay; this is not currently supported
SOFAConventions
SQ@>X
SR=:\bB
SS<J\f
SSE4.1
SSE4.2
SSSE3
STJ>T
SU;CB
SUATAVAWH
SUATH
SUAUAVAWH
SUAWH
SUVATAUAVAWH
SUVATAUAVH
SUVATAUH
SUVATAVAWH
SUVATH
SUVAVAWH
SUVWATAUAVAW
SUVWATAUAVAWH
SUVWATAUAWH
SUVWATAVAWH
SUVWATAWH
SUVWATH
SUVWAUAVAWH
SUVWAV
SUVWAVAWH
SUVWAVH
SUVWAWH
SUVWH
SUWATAUAVAWH
SUWATAUH
SUWAUH
SVATAUAVAWUH
SVATAVAWUH
SVATAVH
SVATAWUH
SVAUAVAWH
SVAUAVH
SVAUAWH
SVAVAWH
SVAVAWU
SVAVAWUH
SVAVH
SVAWH
SVWATAUAVAWH
SVWATAUAVAWU
SVWATAUAVAWUH
SVWATAUAVUH
SVWATAUAWH
SVWATAUAWUH
SVWATAUH
SVWATAVAW
SVWATAVAWH
SVWATAVAWU
SVWATAVAWUE
SVWATAVAWUH
SVWATAVH
SVWATAWH
SVWATH
SVWATUH
SVWAUAV
SVWAUAVAWH
SVWAUAVAWUH
SVWAUAVUH
SVWAUAWUH
SVWAVAW
SVWAVAWH
SVWAVAWUH
SVWAVH
SVWAWH
SVWAWUH
SVWUATAUAVAWH
SVWUATAUAVH
SVWUATAUH
SV{TIJ
SV|;Th
SVۺcj
SWATAUAVAWUH
SWATAVAWUH
SWATAVUH
SWATAWUH
SWATH
SX<ZoG
SX<eTk
SX=fmZ
SXH+SPH
S\a>1J
S\aN>pl
S\aba
S\b&tR\b&dQ\b&4P\b
S\n99\f6
S\n\e;V@3
S\t=Bo
S\vl<\b
S\v˻3X
S`H+SXH
S`Q;Udc
SandyBridge
Saturday
Sb<DPL
Sc\\9Y
ScatterKeysAndValues
Scene is empty
SeLockMemoryPrivilege
September
SetEndOfFile
SetEnvironmentVariableA
SetEvent
SetEvent failed
SetFileInformationByHandle
SetFilePointerEx
SetLastError
SetStdHandle
SetThreadAffinityMask
SetThreadAffinityMask failed
SetThreadGroupAffinity
SetThreadGroupAffinity failed
SetThreadIdealProcessor
SetThreadIdealProcessor failed
SetThreadIdealProcessorEx
SetThreadIdealProcessorEx failed
SetThreadpoolTimer
SetThreadpoolWait
SetUnhandledExceptionFilter
SimpleFreeFieldHRIR
Simulating reflections for %d sources, which is more than the max (%d). Some sources will be ignored
Sj-;16\r9
Sj<#1\e
Sk0;1Z
Sk;|2M
Skylake Server
SleepConditionVariableCS
SleepConditionVariableSRW
Sls<69
Sm<HF
Smc:[oT
Sn8:\bn
Sn;-\fO
Sn;\t
SourcePosition
Sp>g8d
SplitBvh\n
Sp커斻K
Ss=pM
Ss\b>(a
St;c|B
StJ:z7
StO9>T
Steam Audio
Steam Audio Core
StringFileInfo
SubmitThreadpoolWork
Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday
Sunday
Sv\a>6
Svڻ%W
SwitchToThread
Sy*>TE
SzԺ`3
S{h;R
S~:\bz,9F
SŴ:p1i
Sƒ6jp
Sʅ;QV
SӀ:FfZ91
SӋ>x0
SӺWs\f
SԹk@Y
Sռk\r콆1
SܹS0-;\aX
S߹\rX6
S溝OƻlU
T  fB
T 6<.è7k
T :H]Z
T!;\fAI=HH
T!<qf
T" fC
T"9xh
T$ IcG
T$ fA
T$ fff
T$ t!A
T$09t
T$0Hc\aE
T$0Hc\v
T$0IcG
T$0Lcd
T$0fA
T$83ЉT$8I
T$89T
T$8E+T$\bE
T$8t8E
T$<9T$D
T$@HcElH
T$H3\tD$8
T$H3ۉL$P
T$H9SD
T$Hb!|H
T$PIcG
T$Pb!|H
T$Pfff
T$PŀW
T$PŨTE
T$XI+T$PI;U0w\tI
T$Xfff
T$Xt!A
T$\bI;T
T$\bvpA
T$\fuPH
T$`A9r\b
T$`HcۉD$XHc
T$`IcD
T$`IcG
T$`Mcd
T$pIcG
T$pfA
T$pfD
T$xuMA
T$xuQ
T%O;J
T%^EW
T( fB
T* fC
T*\abA|H
T+=\elA
T+\aba|H
T,7#1T:g
T,Z=T
T.;WLY
T/;ivJ
T1R:3
T1X;2\v
T1\\;kO
T2E:m
T2]:v
T2xġjYT2
T3:.a19
T3:\rc`:0
T4;r~c<v2
T8*NR:5
T8-9D
T8^<r
T8e;!RT
T8Ǽ6뽣s
T9E)y; 9o
T9Q=C
T9i5Z:\tH
T:/Iu:0
T:7*h
T:9(j9
T:I:Z
T:ZXW;10
T:\aEe
T:\ts
T:r~s8
T;9?N
T;\nb
T;f%g;An ;6
T;hD\e
T;s@K
T;лIB
T<@zɽA\fC
T<gLk:F\fX
T<p;ol
T<q\tӼ\tI
T=G\n
T=Pms
T=Yh7
T=fQμ\n
T=f]1
T>G'i>s;I
T?E;EAf
T?j?Y
T@YU\bb
T@Ym\nb
TANCreateContext
TANCreateConvolution
TAz<)o
TBgvlC~0GB
TC:i5
TC>0L
TCg:G
TEP:$q
THYT\a\fb
THYɍT
TIf:'XȻz
TJ;Z6
TKS;X
TKS< R
TL¼\vR
TM@ŰTE
TMd;g
TN;?l
TNǻo\f
TO@ŀTG
TO@ŐTG
TO@ŠTG
TQ\v;K
TS;0C
TT fC
TT.:77
TTo;\t
TU fC
TV;<\fd
TV;l>n9
TV@ŨT
TX,"H
TX\f1L
TY,>5
TYO`ŤX
T[9d%D
T\a<Vn4<rD
T\a\bba|H
T\a\bbq|H
T\a\tbQ|H
T\a\v:8
T\a\vba|H
T\b<J
T\bY=SJ
T\bY=s
T\fU;Sm
T\n(v5B
T\n<a5
T\nM90A
T\n\bba|H
T\n{O<W
T\nŀTB
T\nňTB
T\nŐTB
T\nŘTB
T\r*1g
T\rL-U
T\tƻZ
T\v!hn7
T\v8=\vO
T\v<a\a
T^9;qA
T_:4Y
Targets
Tasking
Tba:Wi
Tbߺ1h
Te;hQG
TerminateProcess
Teջ\rKD
Tf %f %f %f\n\n
Tf黌:7
Th'= s\r
The maximum number of elements for scan exceeded\n
This device does not support HLBVH construction\n
This is a netCDF dimension but not a netCDF variable
Threads
Thursday
Tj(<1Q
TjO;]eD;W
TjQ>g
Tl<W*G
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
Tn":xH\r
To;d|\v
Translation
Tree height
TrueAudioNext.dll
TryAcquireSRWLockExclusive
TryEnterCriticalSection
Tts;1
TtƼ_T
Tu;S{A
Tuesday
Type Descriptor
T~780
T~=\rwZ
T~żpA
TúfW5
Tü\tFF
Tƻj\rŻZ
Tʃ;zN
TҨ>6y
TӨ\bt\v
Tָ/7^94LȻ5
Tٽlh\b
Tۥ<zo
Tݓ>Hmg
T㈼y2G
T溚0c;Uw
T󶹡xȺ30
U 5<'\aZ
U bA, X
U";<1dP
U%bRE
U(A+U0A
U)x;TJ
U*=\vPe
U,9Sn
U.2<TNM
U09\f
U0;9iS:\\K
U27<S
U2弇:l
U5<\aB
U6+;b
U6<F4̻K
U6w<N
U7>\nt\e
U7y;O
U8D83A
U8LOR9Y
U:$I=9ZLo
U:)MK
U:,D6
U:,VO9
U:6<r
U:93w
U:\eje;F7
U:\rCV
U:\vgR
U:oF,;i
U;'97
U;)f7
U;6<QY
U;A\vu
U;Bu=;7o\a
U;ES-9b
U;L]@9XbE
U;\egr
U;\tpZ
U;mRj
U<&e0
U<Os:TP
U<g<4.n
U=.m0
U=9xk
U=dh!?K
U>s82
U?q:dq
U@M;p\b
UA>N0Wl
UAH:dxe
UATAUAVAW
UATAUAVAWH
UATAUAWH
UATAVAWH
UATAVH
UATAWH
UAUAVH
UAUAWH
UAVAWH
UAVVWSH
UAWAVAUATVWS
UAWAVAUATVWSH
UAԻV1
UAݽ{FO
UBdn~C
UD$pfA
UD$pfD
UDm;hʤ<o'Z
UDݺ\f\b
UEͻv{\v
UF,:fAG
UF>yd
UGݼ|Gӻc
UHG;8X
UHM<g
UJ%:R\v
UNKNOWN
UO <\n
UOW9\b
UP;;c
UQq;"O
URn<t
US;z\tP
USATAUAVAWH
USATAUAWH
USAUAVH
USAUAWH
USAVAWH
USVATAUAWI
USVATAWH
USVAUAVAWH
USVAUI
USVAVAWH
USVWATAUAVAWH
USVWATAUAWH
USVWATAUH
USVWATAUI
USVWATAVAW
USVWATAVAWH
USVWATAVH
USVWATH
USVWAUAVAWH
USVWAUAVH
USVWAUAWH
USVWAUH
USVWAV
USVWAVAWH
USVWAVAWI
USVWAVH
USVWAWH
USVWH
USWATAUAVH
USWATAWH
USWATAWI
USWAUAVAWH
USWAUAWH
USWAWH
UT:N%\n
UTF-16LEUNICODE
UTc;֛b:su
UTu;HX\n;L
UU;"V
UUUUUU
UUUUUUU
UV;ab
UVATAUAVH
UVATAVAWH
UVATAVH
UVAVAWH
UVAVH
UVAWH
UVWATAUAVAW
UVWATAUAVAWH
UVWATAUH
UVWATAVH
UVWATAWH
UVWAUAVH
UVWAUAWH
UVWAVAWH
UVWAVH
UVWAWH
UV\e=o
UWATAUAWH
UWATAVAWH
UWATAVH
UWAUAVAWH
UWAUH
UWAVAWH
UWAWH
UXI+UPH
UXI+UPH;S8w\tH
UXI+UPI;T$0w\nI
UXI;UPt
UZ%;w
UZ;\f{D
UZ?5t,?G
U\\:s&c9e
U\aI>^v
U\abA|H
U\af;b
U\b4>L
U\b<x/2
U\bbA|H
U\bt;X
U\nbQ|H
U\r;Z
U\t<Gd
U\t>u
U\tbA|H
U\vbA|H
U_;F6
U_d:Fd!;q
Ua;pr
Ua=Wf
UaK<N36
Uba|XZ
UcY:(3\b;3B
UdǺ8I
Ufj:0
Uft;]a
Ug)<pD
Ug;B"a
Ujn;Lr\b
Ul;uN\\8
Um<bn
Unable to create OpenCL kernel %s. [%d
Unable to load SOFA data. [%d
Unable to load SOFA file: %s. [%d
UnhandledExceptionFilter
Unknown CPU
Unknown exception
Unknown matrix type
Unĺ\r
Uo:DR
Up;LG\t
Urp;kv6
UserProfile
Using %d CUs for convolution, %d CUs for IR update
Using OpenCL device: %s %s (%s
Using OpenCL platform: %s %s (%s
Uu;)L
UuL;Cb
UvW;aRr
Ux;=k
Uzz:C\b
U{pNo
U|j;c
UĻ@LS
UƹS9B9
Uɹjbs
Uк0\a
Uټo 3
U܄;r\nD
Uܹ8Q˺ז8
Uܺp(D
Uݺ;y71
U㽼T_D
V!;i5
V&ͽRU
V'Z<_2P
V)< R
V,H*D.8
V,H*D.V0H
V-s=Qj
V.;Yw麑\rG
V/f9% 1
V/ҺKc\v
V0z\vx
V0};ur
V38sHR
V5=os
V7:ZC
V8<W&B
V9#EM:z
V:<kv:i
V:Lj\v:9
V:bsr;\b
V:dX;:o
V:dz8
V:nfP:{&z
V:s.q
V:w1f
V;-IM:Z
V;0Lq
V;3{59
V;=dY
V;Bx\r;w
V;Gw\t
V;LwR<0
V;WU3;N
V;gs\f
V;h=vCN
V;j5X
V;wR\a
V;͞j;mm19h2u;z
V<<f06
V<D~j<s\v
V<GZs
V<`gg
V<l;Bk
V=/6R
V=2KN
V=ʸ\rAf;d
V>\aV
V>h:w
V>o6A
V?&pW?SHX?j
V?:wF
VA';e
VA7<5
VATAVAWH
VATAVH
VATAWUH
VAUAVH
VAVAWH
VAVAWUH
VAVAWUI
VCϺNp
VEa9Sk
VFổfa;'W
VKV:E
VL;B?3
VOȽGd :v
VPH;VXw
VQ[;Ba
VQߺ2z
VR0;X
VS<kS
VS_VERSION_INFO
VUUUA
VV}:j
VWATAUAVAWH
VWATAUAVAWUH
VWATAUAVH
VWATAUAWH
VWATAUH
VWATAVAW
VWATAVAWH
VWATAVAWUH
VWATAVAWUL
VWATAVH
VWATUH
VWAUAVAWH
VWAUAWUH
VWAVH
VWAWH
VWUSATAUAVAWH
VXH+VPH
VXH+VPI;U0w\tI
VXH+VPI;W0w\tI
VXI+VPI;U0w\tI
VXI+VPI;W8w\tI
VXS;\n\t
V\\:SUn
V\\t;aFe
V\a=F@Y<N
V\b6\n6\f
V\bA9W\bA
V\bN\f"\n
V\bXy\bb
V\b\\a\vb
V\b\\i\bb
V\fлZj
V\r9>Q
V\rO8M\n
V\tT;5
V\ta<Y
V\v6I]Dc
V\v;N
V]8iMĺÇI
V]ügHS
Valve Corporation
Vam;9lE
Vc=N-\t
Vc>L\bH
Vd;kT
VeO<Qm
VeU:Z
Vg}9OE
Vh>6Q&?f
VirtualAlloc
VirtualFree
VirtualProtect
VirtualQuery
Visual C++ Compiler
Vlۼd\e
Vr<NfݼA9k
Vs:=2
Vs^<WV
Vu;ӿl
VuK<y
Vv;JQf
Vv;LL4
Vw:;u\f
VzO:ӪO
V{N;jyr
V|3<K\f9
V|;6fb
V}0<NTq:Q
Vƺ60N
Vƻ_ZV
VǽHc7
Vȼ5D<p
Vμ4R»Z
VϺBh6
Vӻ8%t;y
VԹBQZ
W \aae
W%.;JtS
W%3<Wx
W%\t=DX
W%t<l#s
W%ҼMN
W&b<O3
W(A+W0A
W)9\a
W+A>zgD
W,;Yb
W,<fr
W,=gzq
W.s;j
W1a>C
W2:L3
W2ʺ`m
W2ؼFl
W35;|p
W5L:q6
W6;s6
W6\tf
W8<UW
W8WAD
W8m;A
W9>58l
W9BHA9Y
W9j^!;U
W9u#3
W9}0Y
W9ЪG:D
W:'Bl;A
W:7CW
W:7eO95
W:KwӺd
W:L~V9
W:R㸹s
W:j)b;N
W:uls
W:xs`9
W;&wS
W;'8J
W;*I6
W;JJD
W;\bj\a
W;\fVA;av
W;d A
W;j\vl;A
W;ԼJ9
W<96裻\e
W<>Sa
W<XrR
W=*zd=z
W=UՒ>Sb
W>EWC
W>P$D
W@ӻhK
WARNING: "Flush to Zero" or "Denormals are Zero" mode not enabled
WARNING: AdjustTokenPrivileges failed to enable SeLockMemoryPrivilege: Add SeLockMemoryPrivilege for current user and run process in elevated mode (Run as administrator
WARNING: AdjustTokenPrivileges failed while trying to enable SeLockMemoryPrivilege
WARNING: LookupPrivilegeValue failed while trying to enable SeLockMemoryPrivilege
WARNING: OpenProcessToken failed while trying to enable SeLockMemoryPrivilege
WATAUAVAWH
WATAUAVAWL
WATAUAVAWUH
WATAUAVH
WATAUAVUH
WATAUAWH
WATAUH
WATAUUH
WATAVAWUH
WATAVH
WAVAWH
WAVAWUI
WAֹDl
WC<p\f
WCQ;ǡA
WCv;Щ29D
WD$PL
WD$`I
WD$`M
WD$pI
WD$pL
WD2:o
WD8l$@t\fH
WD;N \b9f
WD<Ig
WG$85d
WJ=Q$a
WK?;7zx:i4
WLcT$PLc\\$HHc\\$@Hc|$8Hct$0L
WN;Z2
WNd;S
WPB:YQ
WQ-<P
WR-:L
WR2;D
WR;RmA
WS<_Z
WT=lY
WU(;O
WU3:\n
WU;t9d
WUUUUU
WXH+WPH
WXH+WPI;T$0w\nI
WX½\bT6
WXмhcO
WYֽ]a
WZp:h9!<B
W[k;W
W\b:vC0:J
W\bM;P\b
W\bfD9g\n
W\bʼ9c
W\bʼN
W\ns;.X
W\r3;I
W\r>0쏽W
W\rz=pc
W\t=T\b\n
W\t˺l8
W_2;1\a
Wa:wvf
WaitForSingleObject
WaitForSingleObjectEx
WaitForSingleObjects failed
WaitForThreadpoolTimerCallbacks
WakeAllConditionVariable
WakeConditionVariable
Warning
Wc;!42
Wd>;5\b
We)=D
We9 =N
Wednesday
Wg;;n
Wg~;R
Wh9<.WC
WhƹcJ\n
WideCharToMultiByte
Windows (64bit
Wj;Z;x9
Wk%;t
Wk̼;l3
WkֻTdp
Wl*<0`w
Wl;eEH
Wm:\b`a9
WnȼPQ
Woy:\v\a
Wp>;vi
Wqݻ)D
Wr95B
WrM<dr
WriteConsoleW
WriteFile
Wrong number of vertices per face
Ws,<WrQ
Wv:u5B
WvQ;:Mj
WwN<&yx
Wx;GoI
Wz+9Sx
Wz{:u
W|F<u
W}U:8h
W}u;C\v7
Wí9QcW9q
WƼqѼV
WȮ9WH\r
WɄ:AaI
W̼\raq
Wκ[5J
WӚ>n2
W⊼ \t
X 843"8
X UVWATAUAVAWH
X UVWAVAWH
X VWAVH
X"<Ikd
X&:9G
X)9/j
X,;dJ
X,;s 5;xA
X2ԺK\r6
X3g=Xx
X3ۉT$HD
X4:[447)9
X5w9}^O;}C
X69}%r
X6;H3\e
X7f:\e\r\r
X9=\f
X9\bY
X9iAy:g
X9}ٓ8e
X9ܰt:4
X:9.08
X:=Ic
X:AuI<WBV
X:\e8\a
X:\et0
X;%Cu
X;\v$p;C2
X;yb!<v
X< w\eH
X<\e1M
X<\evx
X<f<2
X<f\vw
X<o`5
X<t\eu
X=[g8>t
X=t\vu<E
X>7iad8
X>\ek
X@I;XH
XA(źXy
XA_A^A]A
XC\b;R_\b
XF:g.A
XG.:n8
XG;uٯ9p
XG\a<\\ 3
XHսi7
XI+@PH
XI+@PI+JPH
XI@źXy
XI\tba
XIm< A
XKO<#B
XL#@L
XL&@ġLY
XL6@ġLY
XL>@ġLY
XLc_lA
XOK;gL
XOK;t
XP\e9
XQ\fŢXi
XR?9Dz
XRe76o
XS&=0
XSh;Yq
XT,9Иk:0
XT<ZO
XTR;|b
XT\rs0
XV27U
XW;\a
XW<\tv
XY$ŢXi
XY<Dm
XYFpŀY
XY\nba^\bXI\tb
X\\tH$5
X\a;yh
X\bUVWATAUAVAWH
X\bUVWAVAWH
X\bm;5
X\r;3
X] ŸXU
X]A_A
X]A_A^A
X]A_A^A]A
X]pĂy
X]pŸX
X`n:a
Xa:vE>;t
Xa\vbaN
XbS;~Y
Xbt<f
Xc;FKu
Xc=+Xc=+Xc=+Xc
Xe ŬX
Xe=kme
Xe@żX
XeL;'2
Xe`ŬX
Xfy9q
Xhl:(D
Xi Ś\\I
Xi\fbaF
Xj:Gnw
Xl$\bba
Xl:n")9
Xl;\a\a
Xl<-W
Xm.=o9R
Xm0ŘX
Xm@ŘX
XmPŸ\\MP
Xm\b?#8
Xob:ͪ\v
Xp:IH
Xq3;f\e
Xq4Ś\\aT
XqLł\\iL
Xq\fba
Xs.<(1V
Xt$ w\t
Xt$PĂy
Xt$pĢy
Xu`Ăy
XupĂy
Xvϻqz
Xw>YZ
Xwj:β;9
Xwǽ5c
Xx;YmƽϺ\t
X}PŐY
X~úY9
X~ʼcg
Xʒ:5d
Xʻ6M3
X̼Y漼yh
Xͻ\t2
XӺ+5q
XԻk%v
Xⷸ%PZ
Y F;R
Y a:j
Y ba|\b
Y ŢXY
Y!;yU
Y$:7l
Y%2;+5n9
Y%:nFh
Y&:hj
Y&<b2B
Y'̺3T
Y*<5Y
Y+9)K
Y-D<G
Y-w;W\rA
Y/o<Ww
Y/Ļoon
Y0<9m
Y4+bA|@Yt
Y4>M&\f
Y4ba~\b
Y76<(\v
Y83hѺF
Y8ba~\b
Y8~\t
Y9;H&E
Y9Q\b_9
Y9\rHN9
Y:ZhJ;*Xߺ4h
Y:aB3;Y
Y:dKb
Y:vg~9D
Y:~fw
Y;%ki
Y;/Bg
Y;9b\t;s
Y;<t2
Y;\f g
Y;\r3e
Y;\tw\f;M
Y;gk2>xQ
Y;p9f;Ԡf
Y;xbV
Y;z)k
Y<\v8X<Vh
Y<_B6
Y<ba~\b
Y=\f\eI
Y=u:2
Y=u<R
Y=v6L9
Y=}4A
Y>eu>>S
Y>kX>M\e
Y?;oB
Y@[9ϩs9L
YBT>x
YD$ H;\r
YD$ H;\rV
YD$ H;\rv
YD$ ŀY
YD$@ŠXt$pŨXl
YD$PM
YD$PŘY
YD$PŠXt$pŨXm
YD$PŠY
YD$`ŰXT$0
YD$pI
YD$pŠXt
YD$pŠY
YD$pŨY
YDؼ4g
YE(<e
YE0ŠXupŨXm
YE0ŨXm
YE0ŰX
YE@ňY
YE@ŤX
YE@ŨXm0ŠX
YE@ŨXm0ŠXu
YE@ŰX
YE\vbQ
YE`ŔY
YE`ŰXUP
YEpŀY
YEpŠXu`ŨXm
YEpŨXm@ŠXu
YEpŸYM
YF\n<Z
YF`ńY
YGpŀYO
YHS;rM
YHa>K]I
YHb=0
YJ1:u
YL!<h5
YL$ ŐYD
YL$ ŘYD$0
YL$ ŘYE
YL$0ŠYE
YL$0ŨY
YL$Pt=fD
YL$Ptef
YL$PŰYD
YL$`ŨYE
YL$pňY
YL$pŐX
YL;Sw
YM ŘYE0
YM0ŠYE
YM0ŸYD
YM@ŘYEP
YMPŘY
YMPŘYE
YMPŠYE
YM\a:'Y
YM\rbA|H
YM`ńY
YM`ŘYE
YM`ŘYEp
YM`ŠYE
YM`ŨX
YM`ŬY
YM`ŸYE
YMpŀY
YMpňY
YMpŘY
YMpŘYE0
YN`ńY
YN`ŰY
YNb=#uA
YO0ŠYE
YO;ΝA
YO@:h
YO`ŔY
YO`ŤYE
YOz;7\b
YO캨9P
YPŊ\\I0
YQ<We9
YQȼzN
YR<U깺!aS
YT$@fA
YT;7]A
YU;5Z\a<7
YU\tbAD@Y}\vbBmH
YV;H]\b
YV;y]j;LkZ
YWw;j'w
YW˹l\b
Y[L;w
Y\a=l
Y\aba|\b
Y\b<VS
Y\b>H
Y\b>p
Y\bba~\b
Y\e<V l
Y\f+Z\fA
Y\f.9\nX
Y\f>b
Y\fba|H
Y\fba~\b
Y\nba~\b
Y\r1=.e
Y\rbav\bX
Y\t;4$n
Y\t;gdӻu
Y\t\b
Y\tba~\b
Y\vba~\b
Y\vl\rm p
Y]PŠXt$PĢy
Y]PŠXu0
Y`>0\nS
Y`O:@8j
Yb :3:W
Ybo;`Ox
Yc;,6f
Yd$@ŐYU
Yd$`ňYU0
Yd$pŀY
Yd$pŘY
Yd$pŘYU
Yd\a\nb
Yd绝oۻ4
Ye0ňY
Ye@ŀY
YePġHY
Ye\nbA|H
Yh\a=V
Yi;PC
YiN<hA
Yk'>X
YkƻҳJ
Yl\atĢY
Ym Ÿ\\M
Ym0Ÿ\\M
Ym\bb!4HY
Ym\bb"EH
Ym\bbbM
Ym\rbA\\@Y
Ymں\tJ
Yn;ư*9E
Yn\v<fD
YnպյL;K
Yqz>~/k
Yr@;7
Ys\f;,F
Yu9l]A:5
YuPŰ\\E
Yu\fb
Yu\nbA|H
Yu\vbA|H
Yvc;cT
Yw;\b0c
YwǼ)汼MTi
Ywۼ;Q
Yx:\n
YxԻwJo;{Q
Y}N:Mb
Y}\bbA4HYe
Y}\nbA<@Ym\fbA|@YE
Y~ügN\v
YĻyj
YƉD$hB
Yͼiuм5
Yև>0g
YۻK[W
YbѼYZ̼r
Z R$f
Z ba~\b
Z!0;1
Z#;Go8
Z&R$f
Z':cn
Z'M;c
Z(8;H\b
Z(\a<bt
Z)8E/W9
Z)bA|\b
Z*R$8
Z+5<1
Z,ba~\b
Z0=M,N
Z0[<E
Z0bA|\b
Z2:Bm
Z2b:y Y9
Z30:Bq
Z3@<s
Z3m<B\t
Z3Խ3-d>R
Z4g<Vh
Z5-;iK
Z6=r^9
Z7s:9
Z8\e0
Z95~j
Z9F<rti;Q
Z:4\e
Z::Mt:t
Z:=QtS
Z:Glj8
Z:T4c:J
Z:d?p9
Z;"X4
Z;/aC;M
Z;K*c
Z;MUh
Z;\es
Z;b\v:b
Z;e3мU
Z<2b1
Z<N$O
Z<S;\rl
Z<cDݼ\b
Z<riw
Z=1ችDP
Z=\rIn=U
Z=qh\n>5
Z>6E\v
Z>M#O
Z?<Gsg
Z?ǻUa
Z@t<3y
ZC=\rg
ZCr;B
ZE:Ik1
ZE\t:l\f
ZFa=b
ZFλgX\e
ZGϺqFx
ZH<\f1
ZI{;Ct
ZM:iR\a
ZN;\e
ZO:"k
ZR<)dl
ZRU=3e
ZS\b;EN\r
ZT;kJ
ZU<\v
ZWz;nc
ZX ;|i
ZX<xۣ;X
ZXǼDSC
Z\\Q4ŊXY0
Z\aba|\b
Z\b;\e4
Z\bba|\b
Z\e{&1q
Z\eŻle
Z\f:Md
Z\fbA
Z\rbA|\b
Z\rκ9;9
Z\t1<Ⱦ9
Z\tbA
Z\tba|\b
Z\vbA
Z\vo>8
Z]輴dY
Z^<C9
Za;\a
Zb(<N\vG
Zci:eF
Zd;،g;s
Ze+:g
ZgC;d
Zj9dtK
Zk;k袻K
Zk\r9
ZlͻZm\v
Zrk;D
Zu1;At
Zw:3>f
Zy9\b
Zy;R齺ݺE
ZzS;\t
Z{Etm;,M
Z{L:J
Z}F7Q;l
Z~@f#aCW
Z¼n4\b=v
ZȺ2AE
Z̻y\rR
ZЕ;Jcm
ZԻEs3
ZԻ[S2
ZոV\b6
Z㻩t:r2
a >= 0 && a <= 255
a D=Q
a e=^v
a";gn
a"C<EV
a#Ib?AG
a$9\n
a$ba~\b
a%;vGj
a';N8
a*c:n
a-2<H8
a/1<MX
a/ݻi\ne
a09;z
a0;JJs
a0;u8
a1R;\t
a1\t9(f
a2;%\bn
a32:1
a3<U2
a3F:γ4
a4-;Z
a5::I
a5;hE
a5ӻ\n@Y
a8ܻA_軙14
a9,_W8
a9;E\e :2
a9<4Lṻ1
a9=2ں|Q
a9F$ 9
a9\bfr
a9k}\f
a9t;2
a9x"\a0h#\a'4P
a9x&\a0h'\a'4X
a9z9|v
a:&Ex
a:0)b8
a::\amٺUI
a:;Pi
a:?h\nx
a:IrQ:q
a:VHZ
a:ZlH:co
a:\eEF
a:\rnߺi
a:mᗼN
a:oF\n
a:r?a8
a:wݑ9
a:䋆:RGI
a;"jf
a;/kY
a;GI\b
a;HJ\n9
a;ScֺM
a;W9滻b
a;WHj
a;Wvp
a;\f\rh
a;\te7;a
a;\vUe
a;\vis:3
a;djE;AXO
a;hzx
a;ja».E
a;mG\r
a;o\n
a;o}K
a;qϠ6/do
a;rX\n
a;v&G
a<#o9
a<%hf
a<)pL
a<)q2
a<KN\n9
a<K嘻sk\b
a<SXԼ2
a<V"a9
a<XBF
a<\au`I
a<\aufH
a<\aujH
a<\tWZ<omJ
a<a櫼\fy
a=#qn
a=,ücAv
a=FA8
a=X5i
a=b4D
a=bV\n
a=fiJ
a=lHe>z
a=lV\e
a=o=1
a=v_g
a>2MR
a><gAd
a>B}h
a>Q>TQ
a>Ud6>O7n
a>uZ>2
a?;RFe
a?a:s
a@;C3
a@b;zO
aAͽ:\f5
aAݻis
aB=i\n\r
aCo7"L
aE3\nS\tI
aE3\nW\tI
aE<zQ
aEh;VB
aF\r:0i
aH9D$8t
aH9D$8t0
aH9G\btkH
aHcwHB
aHc|$dH
aHc|$tH
aHc|$xH
aHc}$H
aHh:P
aIcp\bH
aJ:TRH
aJn?L
aKi;E훺b
aL;<V
aL<Z\f
aL=T\a8
aM+\vE+C\bL
aM5;k
aNX<C
aO=W"L
aP3:GG
aP5<L1Q
aP<ut
aQ8=S
aQ;l&\n
aQ<6`d
aQ<=u
aQżqK3
aR=?3
aS;_a\b9
aSU:LD
aT0:b
aT4;#L
aT4>m
aTI=\f
aU_=d
aV\n;gt
aX:8m
aY>7%Z
aYw;e
aYỒ;C
a\a<\a0
a\aba|H
a\aba~\b
a\abq|H
a\b<z
a\bL+!I
a\bL\ne\v
a\bbQ|H
a\bba~\b
a\bd \a
a\bd&\a
a\bf=\a
a\e<\va
a\f$9
a\fba|\b
a\n8_F
a\n;V
a\n;x3
a\n<ps\b
a\n^=ci
a\nba~\b
a\r9l}M
a\rm;\fS#:xx
a\rx:T\f
a\rӺE
a\tD;A
a\tba~\b
a\v:6
a\v:x
a\vba~\b
a]:MyH
a_\r;wVD
a`h;ziV
a`ۼRZ
aa\b;t
ab!}Hp
ab5;a
ab<0\ba
abA|H
aba|H
abcdefghijklmnopqrstuvwxyz
abq}Hp\f
acc.type
accel
accel_mb
accels
accumEnergyDelay[rayIndex].xyz *= ((float3) 1.0f - hitMaterialAbsorption);\n        accumEnergyDelay[rayIndex].w += hitDistance / SPEED_OF_SOUND;\n\n        float4 reflectedDirection = (float4) 0.0f;\n        if (randomFloat < hitMaterial.scattering)\n        {\n            uint sampleIndex = randomUint % numDiffuseSamples;\n            float3 transformedDiffuseSample = transformHemisphereSample(diffuseSamples[sampleIndex].xyz, hitNormal);\n            reflectedDirection = (float4) (transformedDiffuseSample, 0.0f);\n        }\n        else\n        {\n            reflectedDirection = (float4) (reflect(rayDirection, hitNormal), 0.0f);\n        }\n\n        reflectedRays[rayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * reflectedDirection.xyz, FLT_MAX);\n        reflectedRays[rayIndex].d = reflectedDirection;\n        reflectedRays[rayIndex].extra = (int2) (0xffffffff, 1);\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Image Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherImage(uint numSources,\n                        global const int* occluded,\n                        global const float4* totalEnergy,\n                        global float4* image)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t numRays = get_global_size(0);\n\n    for (uint i = 0; i < numSources; ++i)\n    {\n        if (occluded[i * numRays + rayIndex] < 0)\n        {\n            image[rayIndex] += totalEnergy[i * numRays + rayIndex];\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Energy Field Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherEnergyField(float scale,\n                              global const float4* totalEnergy,\n                              uint offset,\n                              global const int* occluded,\n                              global const float* shCoefficients,\n                              global int* energy)\n{\n\t// The number of global work-items for this kernel is #rays * #bands * #channels.\n\t// The number of local work-items for this kernel is #bins * 1 * 1. Here, #bins is a compile-time constant.\n\t// This kernel runs in three stages:\n\t//\t1.\tEach work-group operates on a subset of rays, and accumulates their energy into one of multiple\n\t//\t\tlocal-memory histograms.\n\t//\t2.\tEach work-group adds all of its local-memory histograms together.\n\t//\t3.\tThe work-groups cooperate and combine their local-memory histograms into a global-memory histogram.\n\n    uint rayIndex = get_global_id(0);\n    uint band = get_global_id(1);\n    uint channel = get_global_id(2);\n\n    size_t numRays = get_global_size(0);\n\n    bool isOccluded = (occluded[offset + rayIndex] >= 0);\n\n\t// FIXME: shouldn't this be just get_local_id(0)?\n    const int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\n\t// Each work-group stores NUM_LOCAL_HISTOGRAMS histograms in local memory. These are interleaved, i.e.,\n\t// bin i of histogram j is at index (NUM_LOCAL_HISTOGRAMS * i + j) in the buffer. We use multiple local-memory\n\t// histograms to reduce the chance that an atomic_add leads to contention (see below for details).\n    local int localEnergy[NUM_BINS * NUM_LOCAL_HISTOGRAMS];\n\n\t// These base pointers are used in stage 2 of the kernel. See below for details.\n    local int* workItemEnergy = localEnergy + mul24(localIndex, NUM_LOCAL_HISTOGRAMS);\n\n\t// Initialize all local-memory histograms to zero.\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++)\n    {\n        workItemEnergy[i] = 0.0f;\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 1\n\t// Each work-item processes one ray. If it is not occluded (i.e., it carries non-zero energy), the energy is added\n\t// t
activeTimeSegments > 0
acۺT?I
add@ThreadPool@TaskScheduler@embree@@QEAAXAEBV?$Ref@UTaskScheduler@embree@@@3@@Z
addProbe
addProbeArray
addProbeBatch
addScheduler@TaskScheduler@embree@@CAXAEBV?$Ref@UTaskScheduler@embree@@@2@@Z
address family not supported
address in use
address not available
advapi32
ae<~Q
aeD<]\f
aeG<L
ae\r=W
af7<\af
afD9 t
afD9 t\a
af\n=X
affinity
ag=<zM
agH;\tD
ah9{SR
aho9K>\t
ai9\aiI:bq
ai;"q
ai\n;qGV
airAbsorption
airAbsorption[iArray
aiܻbiE<j
aj;P\vB;L
ajq;U
ak:Pq
ak˺<lQ
align & (align-1)) == 0
align <= maxAlignment
alignedNodes
alignedNodesMB
alignedNodesMB4D
all(valid, ray.tnear >= 0.0f
all(valid, ray.valid
alloc
allocSize >= bytes
allocThreadIndex@TaskScheduler@embree@@QEAA_JXZ
alloc_i
alloc_main_block_size
alloc_num_main_slots
alloc_single_thread_alloc
alloc_thread_block_size
allocateAudioBuffer
allocation is too large
already connected
already initialized
alse; \n} \n \n#ifndef GLOBAL_STACK \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    if (r->o.w < 0.f) \n        return false; \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            leftleaf = LEAFNODE(node.lbound); \n            rightleaf = LEAFNODE(node.rbound); \n \n            lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, isect->uvwt.w); \n            righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, isect->uvwt.w); \n \n            if (leftleaf) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node.lbound), r, isect); \n            } \n \n            if (rightleaf) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node.rbound), r, isect); \n            } \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = (int)node.rbound.pmax.w; \n                    deferred = (int)node.lbound.pmax.w;; \n                } \n                else \n                { \n                    idx = (int)node.lbound.pmax.w; \n                    deferred = (int)node.rbound.pmax.w; \n                } \n \n                if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                { \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        gsptr[i] = ldsstack[i * 64]; \n                    } \n \n                    gsptr += SHORT_STACK_SIZE; \n                    lsptr = ldsstack + 64; \n                } \n \n                *lsptr = deferred; \n                lsptr += 64; \n \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = (int)node.lbound.pmax.w; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = (int)node.rbound.pmax.w; \n                continue; \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return isect->shapeid >= 0; \n} \n#else \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    if (r->o.w < 0.f) \n        return false; \n     \n    int stack[32]; \n \n    int* sptr = stack; \n    *sptr++ = -1; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        leftleaf = LEAFNODE(node.lbound); \n        rightleaf = LEAFNODE(node.rbound); \n \n        lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, isect->uvwt.w); \n        righthit
am\r<R
america
american
american english
american-english
amfrt64.dll
an;̴Q
anonymous namespace
anx;[I
any(valid
aoإ\afȦ\a
apU;\v
api-ms
api-ms-win-appmodel-runtime-l1-1-1
api-ms-win-core-datetime-l1-1-1
api-ms-win-core-fibers-l1-1-1
api-ms-win-core-file-l2-1-1
api-ms-win-core-localization-l1-2-1
api-ms-win-core-localization-obsolete-l1-2-0
api-ms-win-core-processthreads-l1-1-2
api-ms-win-core-string-l1-1-0
api-ms-win-core-synch-l1-2-0
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-2-1
api-ms-win-core-winrt-l1-1-0
api-ms-win-core-xstate-l2-1-0
api-ms-win-rtcore-ntuser-window-l1-1-0
api-ms-win-security-systemfunctions-l1-1-0
applyIIRFilter
apy<S@n
aq6;~t
aq=)R
ar:X}E7
ar;\aR4
arFileInfo
area(left.geomBounds) >= 0.0f
area(lset.geomBounds) >= 0.0f
area(right.geomBounds) >= 0.0f
area(rset.geomBounds) >= 0.0f
argument list too long
argument out of bounds
argument out of domain
as:7Ձ9
asQ=1wU
as|:p\a
at=L;\r
at\n:g<F
atp:T~P
au\b=0
audioBuffer
audioSettings
audioSettings->frameSize
audioSettings->samplingRate
australian
aut;\eF
av/;J
av;\v
av\v=H7
avf;wOu
avx2::BVH4IntersectorStreamPacketFallback
avx2::BVH4Triangle4Intersector1Moeller
avx2::BVH4Triangle4Intersector4HybridMoeller
avx2::BVH4Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH4Triangle4Intersector8HybridMoeller
avx2::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH4Triangle4IntersectorStreamMoeller
avx2::BVH4Triangle4IntersectorStreamMoellerNoFilter
avx2::BVH4Triangle4iIntersector1Moeller
avx2::BVH4Triangle4iIntersector1Pluecker
avx2::BVH4Triangle4iIntersector4HybridMoeller
avx2::BVH4Triangle4iIntersector4HybridPluecker
avx2::BVH4Triangle4iIntersector8HybridMoeller
avx2::BVH4Triangle4iIntersector8HybridPluecker
avx2::BVH4Triangle4iIntersectorStreamMoeller
avx2::BVH4Triangle4iIntersectorStreamPluecker
avx2::BVH4Triangle4iMBIntersector1Moeller
avx2::BVH4Triangle4iMBIntersector1Pluecker
avx2::BVH4Triangle4iMBIntersector4HybridMoeller
avx2::BVH4Triangle4iMBIntersector4HybridPluecker
avx2::BVH4Triangle4iMBIntersector8HybridMoeller
avx2::BVH4Triangle4iMBIntersector8HybridPluecker
avx2::BVH4Triangle4vIntersector1Pluecker
avx2::BVH4Triangle4vIntersector4HybridPluecker
avx2::BVH4Triangle4vIntersector8HybridPluecker
avx2::BVH4Triangle4vIntersectorStreamPluecker
avx2::BVH4Triangle4vMBIntersector1Moeller
avx2::BVH4Triangle4vMBIntersector1Pluecker
avx2::BVH4Triangle4vMBIntersector4HybridMoeller
avx2::BVH4Triangle4vMBIntersector4HybridPluecker
avx2::BVH4Triangle4vMBIntersector8HybridMoeller
avx2::BVH4Triangle4vMBIntersector8HybridPluecker
avx2::BVH4VirtualIntersector1
avx2::BVH4VirtualIntersector4Chunk
avx2::BVH4VirtualIntersector8Chunk
avx2::BVH4VirtualIntersectorStream
avx2::BVH4VirtualMBIntersector1
avx2::BVH4VirtualMBIntersector4Chunk
avx2::BVH4VirtualMBIntersector8Chunk
avx2::BVH4XfmTriangle4Intersector1Moeller
avx2::BVH8IntersectorStreamPacketFallback
avx2::BVH8Triangle4Intersector1Moeller
avx2::BVH8Triangle4Intersector4HybridMoeller
avx2::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH8Triangle4Intersector8HybridMoeller
avx2::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH8Triangle4IntersectorStreamMoeller
avx2::BVH8Triangle4IntersectorStreamMoellerNoFilter
avx2::BVH8Triangle4iIntersector1Moeller
avx2::BVH8Triangle4iIntersector1Pluecker
avx2::BVH8Triangle4iIntersector4HybridMoeller
avx2::BVH8Triangle4iIntersector4HybridPluecker
avx2::BVH8Triangle4iIntersector8HybridMoeller
avx2::BVH8Triangle4iIntersector8HybridPluecker
avx2::BVH8Triangle4iIntersectorStreamMoeller
avx2::BVH8Triangle4iIntersectorStreamPluecker
avx2::BVH8Triangle4iMBIntersector1Moeller
avx2::BVH8Triangle4iMBIntersector1Pluecker
avx2::BVH8Triangle4iMBIntersector4HybridMoeller
avx2::BVH8Triangle4iMBIntersector4HybridPluecker
avx2::BVH8Triangle4iMBIntersector8HybridMoeller
avx2::BVH8Triangle4iMBIntersector8HybridPluecker
avx2::BVH8Triangle4vIntersector1Pluecker
avx2::BVH8Triangle4vIntersector4HybridPluecker
avx2::BVH8Triangle4vIntersector8HybridPluecker
avx2::BVH8Triangle4vIntersectorStreamPluecker
avx2::BVH8Triangle4vMBIntersector1Moeller
avx2::BVH8Triangle4vMBIntersector1Pluecker
avx2::BVH8Triangle4vMBIntersector4HybridMoeller
avx2::BVH8Triangle4vMBIntersector4HybridPluecker
avx2::BVH8Triangle4vMBIntersector8HybridMoeller
avx2::BVH8Triangle4vMBIntersector8HybridPluecker
avx2::BVH8VirtualIntersector1
avx2::BVH8VirtualIntersector4Chunk
avx2::BVH8VirtualIntersector8Chunk
avx2::BVH8VirtualIntersectorStream
avx2::BVH8VirtualMBIntersector1
avx2::BVH8VirtualMBIntersector4Chunk
avx2::BVH8VirtualMBIntersector8Chunk
avx2::InstanceIntersectorN
avx2::QBVH4Triangle4iIntersector1Pluecker
avx2::QBVH8Triangle4Intersector1Moeller
avx2::QBVH8Triangle4iIntersector1Pluecker
avx512knM9\bu\rA
avx512knl
avx512skH9
avx512skx
avx::BVH
avx::BVH4IntersectorStreamPacketFallback
avx::BVH4Triangle4Intersector1Moeller
avx::BVH4Triangle4Intersector4HybridMoeller
avx::BVH4Triangle4Intersector4HybridMoellerNoFilter
avx::BVH4Triangle4Intersector8HybridMoeller
avx::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx::BVH4Triangle4IntersectorStreamMoeller
avx::BVH4Triangle4IntersectorStreamMoellerNoFilter
avx::BVH4Triangle4iIntersector1Moeller
avx::BVH4Triangle4iIntersector1Pluecker
avx::BVH4Triangle4iIntersector4HybridMoeller
avx::BVH4Triangle4iIntersector4HybridPluecker
avx::BVH4Triangle4iIntersector8HybridMoeller
avx::BVH4Triangle4iIntersector8HybridPluecker
avx::BVH4Triangle4iIntersectorStreamMoeller
avx::BVH4Triangle4iIntersectorStreamPluecker
avx::BVH4Triangle4iMBIntersector1Moeller
avx::BVH4Triangle4iMBIntersector1Pluecker
avx::BVH4Triangle4iMBIntersector4HybridMoeller
avx::BVH4Triangle4iMBIntersector4HybridPluecker
avx::BVH4Triangle4iMBIntersector8HybridMoeller
avx::BVH4Triangle4iMBIntersector8HybridPluecker
avx::BVH4Triangle4vIntersector1Pluecker
avx::BVH4Triangle4vIntersector4HybridPluecker
avx::BVH4Triangle4vIntersector8HybridPluecker
avx::BVH4Triangle4vIntersectorStreamPluecker
avx::BVH4Triangle4vMBIntersector1Moeller
avx::BVH4Triangle4vMBIntersector1Pluecker
avx::BVH4Triangle4vMBIntersector4HybridMoeller
avx::BVH4Triangle4vMBIntersector4HybridPluecker
avx::BVH4Triangle4vMBIntersector8HybridMoeller
avx::BVH4Triangle4vMBIntersector8HybridPluecker
avx::BVH4VirtualIntersector1
avx::BVH4VirtualIntersector4Chunk
avx::BVH4VirtualIntersector8Chunk
avx::BVH4VirtualIntersectorStream
avx::BVH4VirtualMBIntersector1
avx::BVH4VirtualMBIntersector4Chunk
avx::BVH4VirtualMBIntersector8Chunk
avx::BVH4XfmTriangle4Intersector1Moeller
avx::BVH8IntersectorStreamPacketFallback
avx::BVH8Triangle4Intersector1Moeller
avx::BVH8Triangle4Intersector4HybridMoeller
avx::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx::BVH8Triangle4Intersector8HybridMoeller
avx::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx::BVH8Triangle4IntersectorStreamMoeller
avx::BVH8Triangle4IntersectorStreamMoellerNoFilter
avx::BVH8Triangle4iIntersector1Moeller
avx::BVH8Triangle4iIntersector1Pluecker
avx::BVH8Triangle4iIntersector4HybridMoeller
avx::BVH8Triangle4iIntersector4HybridPluecker
avx::BVH8Triangle4iIntersector8HybridMoeller
avx::BVH8Triangle4iIntersector8HybridPluecker
avx::BVH8Triangle4iIntersectorStreamMoeller
avx::BVH8Triangle4iIntersectorStreamPluecker
avx::BVH8Triangle4iMBIntersector1Moeller
avx::BVH8Triangle4iMBIntersector1Pluecker
avx::BVH8Triangle4iMBIntersector4HybridMoeller
avx::BVH8Triangle4iMBIntersector4HybridPluecker
avx::BVH8Triangle4iMBIntersector8HybridMoeller
avx::BVH8Triangle4iMBIntersector8HybridPluecker
avx::BVH8Triangle4vIntersector1Pluecker
avx::BVH8Triangle4vIntersector4HybridPluecker
avx::BVH8Triangle4vIntersector8HybridPluecker
avx::BVH8Triangle4vIntersectorStreamPluecker
avx::BVH8Triangle4vMBIntersector1Moeller
avx::BVH8Triangle4vMBIntersector1Pluecker
avx::BVH8Triangle4vMBIntersector4HybridMoeller
avx::BVH8Triangle4vMBIntersector4HybridPluecker
avx::BVH8Triangle4vMBIntersector8HybridMoeller
avx::BVH8Triangle4vMBIntersector8HybridPluecker
avx::BVH8VirtualIntersector1
avx::BVH8VirtualIntersector4Chunk
avx::BVH8VirtualIntersector8Chunk
avx::BVH8VirtualIntersectorStream
avx::BVH8VirtualMBIntersector1
avx::BVH8VirtualMBIntersector4Chunk
avx::BVH8VirtualMBIntersector8Chunk
avx::InstanceIntersectorN
avx::QBVH
avx::QBVH4Triangle4iIntersector1Pluecker
avx::QBVH8Triangle4Intersector1Moeller
avx::QBVH8Triangle4iIntersector1Pluecker
aw:R)z8f0
aw];C
ax5;T
ax仡iٻ0
ay57u
az-AZ-Cyrl
az-AZ-Latn
az-az-cyrl
az-az-latn
az<hf
az=\t4d
azE:Ty
a{P;u
a}<7v
a~C<7P
aĻs=8
aͼE\nȼL
aμ?sX=IV
aѻ44{0
aѻR\f
aѼV4M
aҹOTO
aּ%7F
aڛ;9k
aܼw-A
aݓ9EЕ9w
aᚼD-D
a㱼ڪL>ti
a꼍Cռs
a빺d`;ZQ
a캅4B:)L
aQzɻ\a
a8\t
b %d %H : %M : %S %Y
b 4;=\tQ
b \b=Uvc
b bB%H6
b ba|\b
b!,HY
b!4HY
b!L@X
b!T@YD
b!THYT
b!THYd
b!V\bY
b!W<2
b!\\HYt
b!d(Y
b!d@Y
b!dHYT
b!lHYt
b!l\bY
b!t@Y
b!t@Yd
b!v\b
b!|HY
b!}Hp
b!}Hp$1b
b!}Hp$±bA
b!}Hp$ڱbA
b!}Hp,1b
b!}Hp,ȱb2MH
b!}Hp,ʱb1LHY
b!}Hp,αb2MH
b!}Hp1b
b!}Hp1batH
b!}Hp4
b!}Hp41
b!}Hp4ȱL
b!}Hp4ȱb
b!}Hp4бb
b!}Hp4ұL
b!}Hp4ұb1}Hp\f
b!}Hp4ڱb
b!}Hp4ڱba}Hp\f
b!}Hp<رba}Hp
b!}Hp\f
b!}Hp\f±b
b!}Hp\fȱb
b!}Hp\fɱb
b!}Hp\fʱb
b!}Hp\fرb
b!}Hp±b
b!}Hpñb
b!}HpǱb
b!}HpǱb1|H
b!}HpǱbA|H
b!}HpǱbq|H
b!}Hpɱb
b!}Hpʱb
b!}Hp˱b
b!}Hp̱ba|H
b!}Hpαb
b!}Hpϱb
b!}HpϱbA|H
b!}HpϱbA|L
b!}Hpбb
b!}Hpұba}Hp
b!}Hpӱb
b!}HpԱb
b!}Hpձb
b!}HpձbA,@YU
b!}HpֱbA,@YU
b!}Hpֱbb}H
b!}HpױbA,@YU
b!}HpٱbQ}Hp
b!}Hpܱb
b!}Hpݱb
b!}Hp߱b
b!}Hp߱bA}HpƱb
b!}Jpбb
b!}Jpұb
b"V<i
b#0<w
b#MBCƱb
b#UBCűb
b#a=TO
b#m\b!4
b#uCCqb
b#}BCбb
b#}BCرb
b%2<7
b&D<q
b&o<9
b';fN
b(V:W
b(l8X
b)A<2
b)A<6fg
b*<4S
b,;wEv
b-;jE
b-;oh
b-R>L1
b09;\v
b0bA|\b
b1,@Y
b1,@YT
b14@Y
b14@YT
b1:2U\t
b1;:wM
b1<;p
b1D@Y
b1LHT
b1dHY
b1dHYt
b1}Hp
b1}Hp$ɱba}Hp4
b1}Hp,1bQ,HY
b1}Hp,ƱbQ4@Y
b1}Hp,ڱb
b1}Hp4
b1}Hp4ȱb
b1}Hp4رbQ\\@Y
b1}Hp<1bA
b1}Hp<ڱb1}Hp\f
b1}Hp\f
b1}Hp\fȱbQ,HY
b1}Hp\fʱba}Hp$ڱbQ4HYU\fH
b1}Hp\fʱba}Hp$ڱbQ4HYU\fbq}Hp\f
b1}Hp±bA$@Y
b1}HpǱba}HpǱb
b1}Hp˱ba}Hp˱b
b1}HpӱbQ,HYU
b1}HpԱbQ,HYU\ab
b1}HpٱB
b1}Hp߱b
b2:ve2
b2=@6
b3D<B\t
b3i>N
b3}C#Јb3uC#وb
b4;hK
b4=YTl
b4źꗢ9P
b58<A
b5K;n
b5\b 0
b6\t;s
b7;6\f
b7<i7a
b8:X*r
b8\a/U:he\v
b8\nR\f
b8w7F
b92|뻮0
b989d
b9G;9
b9I"\b
b9M7Ϲr
b9W8@:\\R
b9i0x
b9p3 :t
b9üCZ<3QC
b: Vw:M
b:!3D
b:6?1
b:Dř8'yr
b:E\tuZH
b:KBV9
b:U;7
b:V\to
b:WlH:l
b:\f4i:褃:t02
b:\vg
b:p\bP
b;'mj
b;'mt
b;0\nN
b;21\r
b;7c\e
b;@Fb;P
b;@Qx
b;@xS
b;CӺ9Y
b;V3Ժk
b;VR\t
b;W\n
b;\nt
b;h68
b;n"V
b;w$t
b;y]L
b;z9\a
b;ռej
b<&vq
b<Iᙼf
b<c3j
b<c\r
b<pgW
b<w$\r=hR
b<z3?9
b<פQ;NX
b=4%1
b=6鏽uJ
b=8Sc
b=?wOj>\e
b=M\tR>08N>Hb
b=\rDU
b=e;\fS
b=z%7
b=zd1
b>,j1
b>9<mI
b>[rC
b>y<K
b?<of
b?Z<c?s
b?\bt\r
b?^Cy\r
b?xCz
b@ :i
b@>ca
bA$@Y
bA$@Yu
bA$HY,\vb
bA,@YM
bA,@YT
bA,HY
bA,HYu\nbQ|H
bA4@YL
bA4@Yu
bA4@Yu\b
bA4@Yu\bb"MH
bA4HY
bA4HYM
bA;u8
bA<@YE
bA<@Ym\fL
bA<HYT
bA<HY\f
bA<HYm
bA>\b
bA@:r
bAD@Y
bAD@YE\fL
bAD@YE\fbA|H
bAD@YU
bAD@Ym\nb
bADHYL
bADHYm
bALHX
bAT@YU
bA\\(XM
bA\\@YE\fb"u
bA\\@YU
bA\\HY
bA\\HYe
bA\\HYe\bb
bA\\HYe\fb
bA\\HYe\nb
bA\\HYe\vb
bA\f@Y
bA\f@YU
bA\v?C
bAd@Y
bAl X
bAl@YM\nb
bAl@Ym\bL
bAl@Ym\bb
bAl@Yu
bAl@Yu\fb
bAt(YU
bAt@YM
bAtHYE
bA|@YE\bbA
bA|@Ym
bA|@Yt
bA}Hp
bA}Hp,ܱbA}Hp
bA}Hp1b
bA}HpT
bA}Hpl
bA}Hpqb
bA}Hp±b
bA}Hpñb
bA}Hpűb
bA}HpǱbB-H
bA}Hpɱb
bA}Hpʱb
bA}Hpϱb
bA}HpѱbA,@YU
bA}Hpұb
bA}HpӱbA,@YU
bA}HpԱb
bA}Hpձb
bA}Hpֱb
bA}Hpױb
bA}HpױbQ}Hp
bA}HpرbQ|H
bA}Hp۱b
bA}Hpݱb
bA}Hpޱb
bA}Hp߱b
bA~(o
bA~(ou
bA~\b
bAջ]ux
bB5@6
bBO:N
bBellevue1
bB~H5
bBƼj\vt
bC 9,o
bC:9Y;Nu
bCM\b
bCP=֙Q
bCZ;=O\n
bD =v
bD8T$1u
bD91t
bD;S\f
bD;\n|Q
bD;\n|U
bD;d$P
bD;l$P
bD;t$P
bDɹmt绨b
bE;e\b
bE;l$\f
bEu:VQ
bEӻ=lv
bF'<s
bF:hʼ9x*%:MAB
bFEMh\f
bFl:z
bG<\ty\v<v
bH"9JJ\n
bH+]\bH
bH;P A
bH;P\b
bHN&n
bHbQ|H
bI+;H
bI;D$\b
bIcI8
bJ7>]b
bJ^<t
bJɻ1P
bK*:dj
bL';m
bL+t$PD
bLcl$pM
bM;x\rx
bMcH 3
bO>BfL
bP";T
bP:\ehG
bQ$@YM
bQ$@Ye
bQ4HY
bQ;mRA;T\n
bQ<@Yu
bQ<HY
bQ<HYu
bQLHY
bQLHYm
bQT@Ym\bb
bQ|\n
bQ}Hp
bQ}Hp1b
bQ}Hp1b"eH
bQ}Hp1bq}Hp
bQ}Hp4ƱI
bQ}Hp4ǱL
bQ}Hp\f
bQ}Hp\fıb
bQ}Hp\fԱbR\r
bQ}Hp\fرbQ
bQ}Hpqb
bQ}HpƱb
bQ}HpɱbA}Hp
bQ}HpɱbQ}Hp
bQ}HpɱbQ}Hp۱b
bQ}Hpʱbq}Hpױba|H
bQ}Hp˱b1|H
bQ}Hp˱bq|H
bQ}Hpͱb
bQ}HpϱbA$@Y
bQ}HpϱbA}HpޱbQTHY
bQ}HpбbQ$HY
bQ}HpбbQ,HYU
bQ}HpшbQ}Hp
bQ}HpѱbQ
bQ}HpѱbQ,HYU
bQ}Hpұb
bQ}HpұbbU
bQ}Hpұbr%H
bQ}HpԱb
bQ}HpֱbA}Hpرb
bQ}Hpڱbr}H
bQ}Hp۱b
bQ}Hp۱b2
bQ}Hp۱b25H
bQ}Hp۱b2M
bQ}Hp۱bq}Hp
bQ}Hp۱brM
bQ}HpޱbA}Hp
bQ}Hp߱b
bR%H6
bREH6
bRF=in
bS;oh
bS;µźxs
bSM>X
bSUH%̖b
bSUH%̖bre
bSܻKP\r
bT:(j6:2\a
bU<.O
bUVWATAUAVAWH
bUVWAUAVH
bUVWAVAWH
bUVWH
bUú+eH
bVWAVH
bWD;q
bWڻufa
bX*9>K4
bX6ba.\bX
bX<$bA
bXD$\tb
bXY@ŪXi
bXY\fŪY
bXa\ab
bXba|\b
bXf:R
bY1:to
bY\\\ad
bY\t;q
bZ <lP
bZ-;H
bZ<tq3
bZR;v
bZW<{c
b[ <A8\a
b\\<LXJ
b\\A\aba
b\\I\abqf
b\a;i
b\a<Q
b\b<VlE
b\bF\n5\v
b\b\b
b\b\b\b
b\b\e9u
b\e<L2A
b\fU;1
b\n8t\t\n
b\n:S4o
b\n;11
b\n;6
b\n\b
b\nba|\b
b\nba~\b
b\r?z]D
b\rb!d(Y
b\rbA
b\t7<j
b\t?s
b\tq?\b\tq
b\v\a9
b\vbb-@6
b\vbb]H6
b]x;I
b`:nA
b`?<0HH
ba$ Y
ba4 Y
ba4@X
ba;\vc1
ba<@Y\f;ba<@YD
baL X
baL@Yt
baLHYِH
baT(W
baT@X
baTHY<9b
baTHYd
baT\bY\r
baT\bY\rl
baV\bY5
ba\\H
ba\f Y
ba\f Y=b
ba\fPY5
bad address
bad allocation
bad array new length
bad cast
bad conversion
bad exception
bad file descriptor
bad function call
bad locale name
bad message
bad(W
bad@Y
bad@Y%2
bad@Y%4
bad@Y\r
bad@Y\r1
bad@Y\r5
bad_weak_ptr
bakePaths
bakeReflections
bal(W
bal@X
bal@Y,/b
balHYA
balHYy\aba|H
barrier_sys_regression_test
based
bat(W
bat(Y
bat@Y
bat@Y-e
bat@Y-g
bav\bY-\e
ba|@Y<7b
ba|@Yd
ba|HY
ba|HY=a
ba|\b
ba|\bW=5T
ba}Hp
ba}Hp$±b
ba}Hp$ȱb
ba}Hp$رb
ba}Hp$رbb]H
ba}Hp,ȱb!}Hp
ba}Hp,ڱb
ba}Hp1b
ba}Hp4
ba}Hp4±b
ba}Hp4ȱb
ba}Hp4ʱbA\f@Ye
ba}Hp4бL
ba}Hp<ȱI
ba}Hp<ʱb
ba}Hp<ʱbA
ba}Hp<ٱb
ba}Hp<ٱb"uH
ba}HpY
ba}Hp\f
ba}Hp\fڱb
ba}Hp\fڱbq}Hp
ba}Hpqb
ba}HpqbA}Hp
ba}Hp±b
ba}Hpñb
ba}Hpıb
ba}Hpűb
ba}HpűbQ|H
ba}HpƱb"M
ba}HpǱb
ba}Hpȱb
ba}Hpɱb!|H
ba}Hpʱb
ba}HpʱbA}Hpݱbq|H
ba}Hp˱b
ba}Hp̱b
ba}Hpͱb
ba}Hpбb
ba}Hpѱb
ba}Hpұb
ba}HpұbA,@YU
ba}Hpӱb
ba}HpԱb
ba}HpԱbA,@YU
ba}Hpձb
ba}Hpֱb
ba}Hpױb
ba}HpرL
ba}Hpرb
ba}Hpٱba}Hp
ba}Hpڱb
ba}HpڱbQ
ba}HpڱbQt
ba}Hpݱb
ba}Hpޱbq|H
ba}Jpűb
ba}Jpͱb
ba}Jpбb
ba}Jpѱb
ba}Jpұb
ba}Jp۱b
ba}Mp
ba~(o
ba~Ho
ba~Ho%D
ba~Ho-s
ba~Ho0bq~HoH
ba~Ho5
ba~Ho=Z
ba~HoI
ba~Ho\r
ba~Hoa
ba~Hoi
ba~Hoq
ba~\bo5n
bb!|H
bb!|IY
bb!}Hp
bb!}Hpٱb
bb1}Hp
bb1}HpױbQt@Y
bb5Hw
bb5Hwh
bbA|H
bbQ|H
bbQ}Hp
bb\r@w
bb\v<D[c
bbaf\bX
bbal@Y
bba}Hpұb
bbq}HpɱbA$@Y
bbq}Hp۱bQ\fHY
bbuH6
bb}HX
bb}HX%N
bb}HX%\r
bb}HX%d
bb}HX%p
bb}HX%y
bb}HX\r
bb}HZ
bb}HZ5
bb}HZ5Mr
bbպ'\as
bcu@%ږbQd
bd',P
bd',pjK
bd;vK3
be9Pl
beginID < BINS
belgian
benchmark
bestSAH != float(inf
bestSAH >= 0.0f
bezier1i
bezier1iH
bezier1v
bezier1vH
bf-;ytZ;\a
bf;E\a
bg*;s31
bh;nݰ8\a
bh<<WDD
bh<V@z
bhP:sQ
bhk;D
binID < BINS
bj=UWi
bjn;\ez
bjӹaE
bjԽXG
bk;S8N
bk]<0
blockSize > 0
bmd;Z
bmt<\e
bmȺLE
bn~<xk
bo:JZ
bo=}qL
boxID < N
bp*<SZ
bpY>GTr
bp\a;u
bp\n:\fi
bq, Y\r
bq<@Y
bq\\HY
bq\\HYt
bqd@Y
bqlHY
bq}Hp
bq}Hp$ʱH
bq}Hp$ʱbQ
bq}Hp$رbQ4@Y
bq}Hp,αbA
bq}Hp,رbA
bq}Hp1bA
bq}Hp4±b
bq}Hp<ڱb
bq}Hp\f
bq}Hp\fȱbQ$@Y
bq}Hp\fӱbrEH
bq}Hp±b
bq}Hpñbr}H
bq}Hpűb
bq}HpɱbA$@Y
bq}Hpαb
bq}HpαbQ}Hp
bq}Hpϱb
bq}HpбbQ4@Y
bq}Hpѱb
bq}HpѱbQ,HYU
bq}HpұbQ
bq}HpӱbQ,HYU
bq}HpӱbQD@Y
bq}HpձbQ
bq}HpձbQ,HYU
bq}HpֱbQT@Y
bq}HpױbQ,HYU
bq}HpױbQt@Y
bq}Hpޱb
bq}HpޱbA}Hp
bq}Hp߱bQ
bq}Hp߱bqTHX
bq~Ho
br<=q
brE@@\r
brR;$j
br\t:H
bref.node.isAlignedNode
britain
broken pipe
br}HX
br}HX5
br}HX=G
br}HX=e
br}HX\r
br}HwX
bs-BA-Latn
bs-P%\r
bs-ba-latn
bsN:7
bs]L#ԈbS
bs|;m\ar
bsܙ_>jj
bt:ۼF
bt\aA\v
bt\f;cfQ
bt\f\bWcr
bu6t<f
buSt[A
bu_tef
buffer >= RTC_VERTEX_BUFFER0 && buffer < RTCBufferType(RTC_VERTEX_BUFFER0 + numTimeSteps)) || (buffer >= RTC_USER_VERTEX_BUFFER0 && buffer <= RTC_USER_VERTEX_BUFFER1
buffer error
buffer is already mapped
buffer is not mapped
build threads
builder
builder_mb
building BVH
buildslave\\phonon_main_win64\\build\\core\\deps-build\\mysofa\\src\\mysofa\\src\\hrtf\\resample.c
buӻ=h\f
bv:C/A
bvh.builder
bvh.force2level
bvh.forceflat
bvh.sah.extra_node_budget
bvh.sah.max_split_depth
bvh.sah.min_overlap
bvh.sah.traversal_cost
bvh.sah.use_splits
bvh.usesplits
bvh4.object
bvh4.triangle4
bvh4.triangle4i
bvh4.triangle4imb
bvh4.triangle4v
bvh4.triangle4vmb
bvh8.object
bvh8.triangle4
bvh8.triangle4i
bvh8.triangle4imb
bvh8.triangle4v
bvh8.triangle4vmb
bvh_builder: branching factor too large
bvĻ\r
bw ;2
bw!;O
bw:/Q
bw;:6
bw<?ZB
bw}:Lb
bx;ąJ
by.<u
bytes
bytes/prim
bz\b:I\r
b|\vD8C
b}Z8 \t
b~3;lI
b»rZͻ\f
bġ*Yt2t
bō;U2
bŻxo%;c
bſ<Z1
bǺ6sZ
bȻT88
bɅ:ITP
bкLNM
bл9JY
bҰ=tH
bԐ9mu89
bںE8ۻM
bھ:\rJ6
bڿ;Rb
bެ;BC
b鍸h+ȸ2D
b벺)ff;5A
c != BVH::emptyNode
c [1>H
c \v=H
c$;dq
c%;j51:l
c)\f=iw
c-;aB
c0 != BVH::emptyNode
c0S<I2
c1 != BVH::emptyNode
c39f욻Sr
c4:|Wz
c5ŽDH
c8YxT9hJA
c8]vo:1
c8z;)D
c9K#\r
c9f癹Y
c:;hz
c:LW99
c;7wR
c;9\ei
c;LL6;N
c;Stz
c;UUUUUU
c;Y[n;C
c;\br
c;b3s
c;nNl
c<CBX
c<\eX
c=Q53
c=iX<\r2
c=u)Q
c>T;4\t
c>uo¾L
c?FA@s
c@S;w\t
cA$;Y
cA$;d
cA;o|q:VC
cC<G读y
cC<j6W
cC}=Hu
cEP=>L
cF+;UH
cG95_E
cG<AE\f
cGy;\r
cIûL\e
cIͺ@09
cK;b=U
cK\a;C
cLk>M\r
cN\ewun
cP7;b"R
cR=flT
cRH;4FQ;\e\r1;d2
cRü'8
cSպD<P
cU>an~o
cUI:ݙy
cV\n;mg
cW+;Ah
cX<8yQ
c\\R<1b
c\bH:TSk
c\b\r;6
c\bba
c\e>Gn
c\eպL\b
c\r;j
c\rJ5e
c\tr;\n
c];T3
c^;0\vQ
c^ٻVg
ca!A8
ca>:C
cache_size
calculateAirAbsorption
calculateDirectivity
calculateDistanceAttenuation
calculateRelativeDirection
canadian
cannot instantiate this geometry
cannot unget that many items
cartesian
cas:0
cb漰"6<w
cd4;]㖺IyF;2\t
cd>,DZ
cdecl
cdֻ+mw
ce$=B
ceS:b
ce\n;K
character
child != BVH::emptyNode
chinese
chinese-hongkong
chinese-simplified
chinese-singapore
chinese-traditional
ciM;D
ci\f;n'O:A
ck:Ug
cl-mad-enable -cl-fast-relaxed-math -cl-std=CL1.2 -I
clBuildProgram
clCompileProgram
clCreateBuffer
clCreateBuffer failed
clCreateCommandQueue
clCreateCommandQueue failed
clCreateContext
clCreateContext failed
clCreateKernel
clCreateKernelsInProgram
clCreateKernelsInProgram failed
clCreateKernelsInProgram return 0 kernels
clCreateProgramWithSource
clCreateProgramWithSource failed
clCreateSubBuffer
clEnqueueCopyBuffer
clEnqueueFillBuffer
clEnqueueMapBuffer
clEnqueueMapBuffer failed
clEnqueueNDRangeKernel
clEnqueueNDRangeKernel failed
clEnqueueReadBuffer
clEnqueueReadBuffer failed
clEnqueueUnmapMemObject
clEnqueueUnmapMemObject failed
clEnqueueWriteBuffer
clEnqueueWriteBuffer failed
clFinish
clFinish failed
clFlush
clFlush failed
clGetCommandQueueInfo
clGetDeviceIDs
clGetDeviceIDs failed
clGetDeviceInfo
clGetDeviceInfo failed
clGetEventInfo
clGetEventInfo failed
clGetKernelInfo
clGetKernelInfo failed
clGetMemObjectInfo
clGetMemObjectInfo failed
clGetPlatformIDs
clGetPlatformIDs failed
clGetPlatformInfo
clGetPlatformInfo failed
clGetProgramBuildInfo
clReleaseCommandQueue
clReleaseContext
clReleaseDevice
clReleaseEvent
clReleaseKernel
clReleaseMemObject
clReleaseProgram
clRetainCommandQueue
clRetainContext
clRetainDevice
clRetainEvent
clRetainKernel
clRetainMemObject
clRetainProgram
clSetKernelArg
clSetKernelArg failed
clWaitForEvents
clWaitForEvents failed
cl_amd_media_ops2
closure stack overflow
clrcall
cmѼ7-\a
co%;hxۻk
coherent
collapsing from
combineBandpassedImpulseResponse
compact
compile time enabled
connection aborted
connection already in progress
connection refused
connection reset
const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n /************************************************************************* \n   EXTENSIONS \n   **************************************************************************/ \n \n \n \n   /************************************************************************* \n    TYPE DEFINITIONS \n    **************************************************************************/ \n#define STARTIDX(x)     (((int)((x).left))) \n#define LEAFNODE(x)     (((x).left) == ((x).right)) \n#define STACK_SIZE 64 \n#define SHORT_STACK_SIZE 16 \n \n \ntypedef struct \n{ \n    int parent; \n    int left; \n    int right; \n    int next; \n} HlbvhNode; \n \ntypedef struct \n{ \n    // BVH structure \n    __global HlbvhNode const* nodes; \n    // Scene bounds \n    __global bbox const* bounds; \n    // Scene positional data \n    __global float3 const* vertices; \n    // Scene indices \n    __global Face const* faces; \n    // Shape IDs \n    __global ShapeData const* shapes; \n    // Extra data \n    __global int const* extra; \n} SceneData; \n \n/************************************************************************* \n HELPER FUNCTIONS \n **************************************************************************/ \n \n \n \n /************************************************************************* \n  BVH FUNCTIONS \n  **************************************************************************/ \n  //  intersect a ray with leaf BVH node \nbool IntersectLeafClosest( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n            return true; \n        } \n    } \n \n    return false; \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r
const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \n/************************************************************************* \n TYPE DEFINITIONS \n **************************************************************************/ \n#define STARTIDX(x)     (((int)(x->pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n \ntypedef struct  \n{ \n    // BVH structure \n    __global BvhNode const*       nodes; \n    // Scene positional data \n    __global float3 const*        vertices; \n    // Scene indices \n    __global Face const*          faces; \n    // Shape data \n    __global ShapeData const*     shapes; \n    // Extra data \n    __global int const*           extra; \n} SceneData; \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nvoid IntersectLeafClosest( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n        } \n    } \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n
context
continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = node.right; \n                continue; \n            } \n        } \n \n        idx = *--ptr; \n    } \n \n    //if (get_global_id(0) == 1) \n    //printf("Exiting %d\\n", get_global_id(0) ); \n \n    return hit; \n} \n \n#else \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            if (LEAFNODE(node)) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node), r, isect); \n            } \n            else \n            { \n                lbox = scenedata->bounds[node.left]; \n                rbox = scenedata->bounds[node.right]; \n \n                lefthit = IntersectBoxF(r, invdir, lbox, isect->uvwt.w); \n                righthit = IntersectBoxF(r, invdir, rbox, isect->uvwt.w); \n \n                if (lefthit > 0.f && righthit > 0.f) \n                { \n                    int deferred = -1; \n                    if (lefthit > righthit) \n                    { \n                        idx = node.right; \n                        deferred = node.left; \n                    } \n                    else \n                    { \n                        idx = node.left; \n                        deferred = node.right; \n                    } \n \n                    if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                    { \n                        for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                        { \n                            gsptr[i] = ldsstack[i * 64]; \n                        } \n \n                        gsptr += SHORT_STACK_SIZE; \n                        lsptr = ldsstack + 64; \n                    } \n \n                    *lsptr = deferred; \n                    lsptr += 64; \n \n                    continue; \n                } \n                else if (lefthit > 0) \n                { \n                    idx = node.left; \n                    continue; \n                } \n                else if (righthit > 0) \n                { \n                    idx = node.right; \n                    continue; \n                } \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n \n    return isect->shapeid >= 0; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            if (LEAFNODE(node)) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node), r)) \n                    return true; \n
convertAmbisonicAudioBuffer
convolutionQueue
copy constructor closure
cr=>U
createAmbisonicsBinauralEffect
createAmbisonicsDecodeEffect
createAmbisonicsEncodeEffect
createAmbisonicsPanningEffect
createAmbisonicsRotationEffect
createBinauralEffect
createContext
createDirectEffect
createEmbreeDevice
createHRTF
createInstancedMesh
createOpenCLDevice
createOpenCLDeviceFromExisting
createOpenCLDeviceList
createPanningEffect
createPathEffect
createProbeArray
createProbeBatch
createRadeonRaysDevice
createReflectionEffect
createReflectionMixer
createScene
createSerializedObject
createSimulator
createSource
createStaticMesh
createTrueAudioNextDevice
createVirtualSurroundEffect
created scene intersector
cross device link
crt_strtox::floating_point_value::as_double
crt_strtox::floating_point_value::as_float
cu:'r\e=BL3
cur != BVH::emptyNode
cur != BVH::invalidNode
cur == node->child(boxID
current.prims.size() == 0) || ((leafSAH >= 0) && (splitSAH >= 0
current.size() == 0) || ((leafSAH >= 0) && (splitSAH >= 0
curves
cuռ]m\r
cvC=Z
cx!:A
cy:1V\b
c~<H5Z
c~ǻkY
cŘ"rY
cƽ\bS
cѕ:Ix
cՄ;1s
cպF2R
d / %m / %y
d"9d l
d$ HcG
d$ UAVAW
d$ UAVAWH
d$ bq|H
d$ fff
d$0A_A^A]A
d$0Hc
d$0]A^A]A
d$4D8l$1u
d$8A_A^A]A
d$8L;x\b
d$8]A
d$;j7\b
d$@D9fD
d$@D;fD
d$@Lc]l
d$@fD
d$@fff
d$@u\vA
d$HL;x\b
d$HM#l$\bt
d$Hfff
d$PHc
d$PLcSl
d$PM#l$\bt
d$PM#l$\btѐA
d$PfD
d$XA8_\t
d$`Ii
d$dD;d$ltY
d$hH;w
d$pH;w
d$pHc
d$pfff
d$x]A
d';aV@9
d'ûdE
d+<0B
d,ܺLMb
d3;H*k
d3K;:[B
d5e<^L
d5ƺsD
d6:yi\a
d79Y\r-8
d84<5k
d8s;i
d93PM
d9<kQ
d9r<A
d:75S
d:<<v4j
d:Cva;z
d:Ei\b
d:b<K
d:b\a
d:hPG
d:o1g<W
d:pǭ;Sr
d;)惼w3f
d;*Zi
d;@AQ
d;_}T9eq2;yX
d;b3ԺS
d;qs5
d;wsj
d<(1T
d<9W\a
d<\bO
d<a<v
d<w|h
d=*X6
d>U"D=z
d?000000
d@Y]\bb
d@Y]\bbBe
d@Y]\fb
d@Y]\fb1DHY
d@Y]\nbBe
dC>@5X
dCºEp
dD:Ckl
dE;iyn
dFb:\n
dG\e:q
dGeve{e
dGk<US
dH+X@I
dHY4\ab
dHYU\ab
dIɻDv
dK;qSH
dL=ܭ7=L
dMڼʥ4
dN:{2N
dP;4e
dP?=MQ
dQH;fdo
dRD;X
dS;Jo3
dS;\v
dS\r<nT
dT fC
dTq<*A
dUK:6
dX4"H
dX\f"H
dX\f<Uy
dXbPR`fdh,j
dY&:k
dYv ŔY
d\aPġRYl\aTĢi
d\a\abQ|H
d\b$;ol
d\b;UḺ4
d\b\f;Oi
d\bʸY0
d\fn:r
d\n9<[yP
d\nO;SO
d\n\abA|H
d\n\fba|H
d\nջM
d\v3=D
d\v;W1*9
d\v\abA|H
d] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n
d^\n<lQ
d_O;.Cz;Z
data error
data must be 4 bytes aligned
data$r
data$rs
db:;9P;H
dbf:CK\t
db};c$v
dc\a;\vn\f
dc_\bA
dd+;P
ddPdudu
ddPdudv
ddPdvdv
dddd, MMMM dd, yyyy
de5:e
de<2f
debug
default
default constructor closure
defaultBlockSize
deinterleaveAudioBuffer
delete
depth
depth limit reached
deque<T> too long
destination address required
device
device or resource busy
deviceDesc
deviceList
df;qye
dg27\f%8
dhr;w
di.<GZ
diag[dim] > 0.0f
didat$2
didat$3
didat$4
didat$5
didat$6
didat$7
directory not empty
disabled
disabled\n
distribute_part_sum_int4
div-MV
div-mv
dk:l]k
dk;qǇ9
dkU<U
dm9\e
dm{>b\bw?q
dm|9xu
do;P-X
downmixAudioBuffer
dst->data
dst->data[iChannel][dst->numSamples - 1
dst->numChannels
dst->numSamples
dst[iArray
dummy_rtcore_ispc___avx
dummy_rtcore_ispc___avx2
dummy_rtcore_ispc___sse2
dummy_rtcore_ispc___sse4
dut;tE
dutch-belgian
dv);P7
dx].pmax.w); \n            // Set topidx \n            topidx = -1; \n            // Restore ray here \n            r->o = topray.o; \n            r->d = topray.d; \n            // Restore invdir \n            invdir = invdirtop; \n        } \n    } \n \n    return isect->shapeid >= 0; \n} \n \n// intersect Ray against the whole BVH2L structure \nbool IntersectSceneAny2L(SceneData* scenedata, ray* r) \n{ \n    // Precompute invdir for bbox testing \n    float3 invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    float3 invdirtop = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    // We need to keep original ray around for returns from bottom hierarchy \n    ray topray = *r; \n \n    // Fetch top level BVH index \n    int idx = scenedata->rootidx; \n    // -1 indicates we are traversing top level \n    int topidx = -1; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, r->o.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                // or containing another BVH (top level hierarhcy) \n                if (topidx != -1) \n                { \n                    // This is bottom level, so intersect with a primitives \n                    if (IntersectLeafAny(scenedata, &node, r)) \n                        return true; \n                    // And goto next node \n                    idx = (int)(node.pmax.w); \n                } \n                else \n                { \n                    // This is top level hierarchy leaf \n                    // Save top node index for return \n                    topidx = idx; \n                    // Get shape descrition struct index \n                    int shapeidx = SHAPEIDX(node); \n \n                    // Get shape mask \n                    int shapemask = scenedata->shapedata[shapeidx].mask; \n                    // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                    // otherwise skip the subtree \n                    if (Ray_GetMask(r) && shapemask) \n                    { \n                        // Fetch bottom level BVH index \n                        idx = scenedata->shapedata[shapeidx].bvhidx; \n \n                        // Fetch BVH transform \n                        float4 wmi0 = scenedata->shapedata[shapeidx].m0; \n                        float4 wmi1 = scenedata->shapedata[shapeidx].m1; \n                        float4 wmi2 = scenedata->shapedata[shapeidx].m2; \n                        float4 wmi3 = scenedata->shapedata[shapeidx].m3; \n \n                        // Apply linear motion blur (world coordinates) \n                        //float4 lmv = scenedata->shapedata[shapeidx].linearvelocity; \n                        //float4 amv = scenedata->shapedata[SHAPEDATAIDX(node)].angularvelocity; \n                        //r->o.xyz -= (lmv.xyz*r->d.w); \n                        // Transfrom the ray \n                        *r = transform_ray(*r, wmi0, wmi1, wmi2, wmi3); \n                        //rotate_ray(r, amv); \n                        // Recalc invdir \n                        invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n                        // And continue traversal of the bottom level BVH \n                        continue; \n                    } \n                    else \n                    { \n                        // Skip the subtree \n                        idx = -1; \n                    } \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                // This is an internal node, proceed to left child (it is at current + 1 index) \n                idx = idx + 1; \n            } \n        } \n        else \n        { \n            // We missed the node, goto next one \n            idx = (int)(node.pmax.w); \n        } \n \n        // Here check if we ended
dynamic
dynamic atexit destructor for
dynamic initializer for
dŮ=AI
dż;4i
dƼCQۼ89
dǘ:44
dʯ;Dz
d̺\vOM
dλQf'<u
dս\nw1=jj\t
dغ\vL
dܺQ#f
d䨹j6D
d濻Euz
e =pKH
e =Ӳf
e ŬT-+9
e ŬT-\v
e ๏4\f
e!<fp
e"2<Z
e"?Dg
e$; \tB;1
e%89z
e%I<\n3
e%c<S1
e&<Nf
e&=4o\t
e'9\t5G;Y
e';YKY
e';gu
e'<lH
e(M#l$\bt
e)X;r
e)e>u
e*;=uo9\n
e*<0b\r
e*k:n
e+:EQ
e+W:F
e,I=waK
e-ǻcZ
e.5;+oB
e/;\vca
e/g<b
e/¼fr
e/ʺHo
e0<dV
e0A_A
e0A_A^A]A
e0M#l$\bt
e0ban\bY1ŊXA
e0ŘY]p
e1>:L
e1G;J{f
e1^;8K\t
e1y;6
e1Ӻoq
e3:gN
e3;Tu
e4,;Tf
e4;Lv
e4="Q
e5;cw3
e5<7 &;z
e5S;T>g:0
e69\r:l
e6:&x
e6;G~G
e7#<X
e7.? bz
e7;B\te
e7;CE
e7<!\v0
e7t;@n3
e8A_A^A]A
e8G;]5
e99<9I
e9;N^J
e9^ä9
e: 涻G
e:Rfx
e:Z/8
e:\n l
e:rM\a9
e:uW{9
e:vCw
e:ΊzWd
e;( O
e;(UI
e;0an
e;YM]9J
e;YY\e
e;\aI
e;`Q5
e;d&i
e;fzp
e;g%H
e;g+C:9
e;oAV
e;ykv
e;ԃV=1Z
e;ޖd;W9
e< t ;C
e<!96
e<[P09o
e<\bl
e<`nH
e<eT\n<HY
e<hq\r
e<k8k
e=-Ke
e=Q0F
e=Q蒽I
e=rAe>U:f
e>+8j
e>K7\a
e>q<0H
e>uik
e>uu=Rp
e? =\rUֽb
e?5t,?d
e@A_A^A
eA1:HYS
eB@=HRS>vR
eBZ>̣m
eBٺ>Aj
eC2<Z
eC<$o
eCNאBO:#Cl
eCŻDX
eD?}\eD
eDigiCert Assured ID Root CA0
eEr;db
eF=9Aټp\f9>s
eFڻXvU
eG<!0
eG\v<}R
eGʻ2l
eH@%FT
eHH:)Z
eH\t=ME
eI ;1
eI<UGW
eI};giW
eIٺb8z
eJ.85
eJ5;WN\b;y5C
eL;6E
eL;swg
eL<<g8G
eN9=3W
eO9ۻ\r
eO;JP\a
eO<dH
eOP9f
eP%;0
eP8RG:\t
ePw:1
ePŰXE0
eQ(>1
eQ*=O
eQD;Q"*;tnt
eQۼ\fT
eR7<g
eRS:T
eS;{HA
eU<Dh
eVW=z
eV˻j6
eW=88z
eX;!7I
eXd;fs
eXܻ"U
eY=ht1=M\f
eYO9m
eY̼Xh
eZn:0
e[;4OV
e\a>8Na
e\a\bd"\a
e\abA|H
e\aͻ\bt
e\b+;NG
e\bX=Tĭ>6
e\bb;x
e\e;脫98tt
e\ebA,(X
e\f:k~z
e\nb1d@T
e\r;eL
e\r>7
e\rbA|H
e\t;Q
e\tz:s
e\v5=%䥾VMx
e\vbA|H
e\vn?c
e^;iRe
e`:G\fb
easy->fir
eaܺͥ6
eb!|H
eb1t Y
ebA}Hpɱb
eba|H
ec;Wa
ec<\r
ed:"e
ed;\fO
ed;\t
ed<9i2
edData[localOffset.w] = val.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    // Now store to memory \n    if (((globalId + 1) << 2) <= numElems) \n    { \n        out_array[globalId] = sharedData4[localId]; \n        out_debug_offset[globalId] = localOffset; \n    } \n    else \n    { \n        if ((globalId << 2) < numElems) out_array[globalId].x = sharedData4[localId].x; \n        if ((globalId << 2) + 1 < numElems) out_array[globalId].y = sharedData4[localId].y; \n        if ((globalId << 2) + 2 < numElems) out_array[globalId].z = sharedData4[localId].z; \n    } \n \n    if (localId == 0) \n    { \n        out_histograms[groupId] = localHistogram.x; \n        out_histograms[groupId + numGroups] = localHistogram.y; \n        out_histograms[groupId + 2 * numGroups] = localHistogram.z; \n        out_histograms[groupId + 3 * numGroups] = localHistogram.w; \n \n        out_local_histograms[groupId] = 0; \n        out_local_histograms[groupId + numGroups] = localHistogram.x; \n        out_local_histograms[groupId + 2 * numGroups] = localHistogram.x + localHistogram.y; \n        out_local_histograms[groupId + 3 * numGroups] = localHistogram.x + localHistogram.y + localHistogram.z; \n    } \n} \n \n#define GROUP_SIZE 64 \n#define NUMBER_OF_BLOCKS_PER_GROUP 8 \n#define NUM_BINS 16 \n \n// The kernel computes 16 bins histogram of the 256 input elements. \n// The bin is determined by (in_array[tid] >> bitshift) & 0xF \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid BitHistogram( \n    // Number of bits to shift \n    int bitshift, \n    // Input array \n    __global int const* restrict in_array, \n    // Number of elements in input array \n    uint numelems, \n    // Output histograms in column layout \n    // [bin0_group0, bin0_group1, ... bin0_groupN, bin1_group0, bin1_group1, ... bin1_groupN, ...] \n    __global int* restrict out_histogram \n    ) \n{ \n    // Histogram storage \n    __local int histogram[NUM_BINS * GROUP_SIZE]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    /// Clear local histogram \n    for (int i = 0; i < NUM_BINS; ++i) \n    { \n        histogram[i*GROUP_SIZE + localid] = 0; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    const int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    const int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        /// Load single int4 value \n        int4 value = safe_load_int4_intmax(in_array, loadidx, numelems); \n \n        /// Handle value adding histogram bins \n        /// for all 4 elements \n        int4 bin = ((value >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.x*GROUP_SIZE + localid]); \n        //bin = ((value.y >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.y*GROUP_SIZE + localid]); \n        //bin = ((value.z >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.z*GROUP_SIZE + localid]); \n        //bin = ((value.w >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.w*GROUP_SIZE + localid]); \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int sum = 0; \n    if (localid < NUM_BINS) \n    { \n        for (int i = 0; i < GROUP_SIZE; ++i) \n        { \n            sum += histogram[localid * GROUP_SIZE + i]; \n        } \n \n        out_histogram[numgroups*localid + groupid] = sum; \n    } \n} \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE
edata
ee2:w
ee:lYF
ef$;TE
ef;|jY
efG;R
effect
effectSettings
effectSettings->hrtf
effectSettings->irSize
effectSettings->maxOrder
effectSettings->numChannels
effectSettings->spatialize
effectSettings->speakerLayout.numSpeakers
effectSettings->speakerLayout.speakers
effectSettings->speakerLayout.speakers[iSpeaker].x
effectSettings->speakerLayout.speakers[iSpeaker].y
effectSettings->speakerLayout.speakers[iSpeaker].z
effectSettings->speakerLayout.type
effectSettings->type
effffff
eg<@s
eh vector constructor iterator
eh vector copy constructor iterator
eh vector destructor iterator
eh vector vbase constructor iterator
eh vector vbase copy constructor iterator
eh:N]\a
eh\f::t
ehttp://www.digicert.com/CPS0
eiX9t
ej;!Lx
el\f;n
el{n0t:e
em,=l
embree2
en097
enable_dc_correction_for_phase_interpolation
enable_paths_from_all_source_probes
enable_reverb_probe_caching_for_missing_probes
enable_selockmemoryprivilege
enabled
enabled (forced)\n
enabled\n
endID < BINS
england
english-american
english-aus
english-belize
english-can
english-caribbean
english-ire
english-jamaica
english-nz
english-south africa
english-trinidad y tobago
english-uk
english-us
english-usa
enn:u
eo/<c
eoI;ef
ep:i9B;4
ep;VX
ep;ak
eph<'c
er*:r
er\a<s
erd:*7W
erp:0
er~;1
es1;<7
es[rayIndex].xyz, 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Sphere Occlusion Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat raySphereIntersect(global const Ray* ray,\n                         float3 center,\n                         float radius)\n{\n    float3 origin = ray->o.xyz;\n    float3 direction = ray->d.xyz;\n\n    float3 v = origin - center;\n    float r = radius;\n\n    float B = 2.0f * dot(v, direction);\n    float C = dot(v, v) - (r * r);\n    float D = (B * B) - (4.0f * C);\n\n    if (D < 0.0f)\n        return FLT_MAX;\n\n    float t = -0.5f * (B + sqrt(D));\n    return t;\n}\n\nkernel void sphereOcclusion(uint numSources,\n                            global const CoordinateSpace* sources,\n                            uint numListeners,\n                            global const CoordinateSpace* listeners,\n                            global Ray* rays,\n                            global Hit* hits)\n{\n    uint numRays = get_global_size(0);\n    uint rayIndex = get_global_id(0);\n\n    for (int i = 0; i < numListeners; ++i)\n    {\n        uint index = i * numRays + rayIndex;\n\n        float listenerSphereHitDistance = raySphereIntersect(&rays[index], listeners[i].origin, LISTENER_RADIUS);\n        if (0.0f <= listenerSphereHitDistance && listenerSphereHitDistance < hits[index].uvwt.s3)\n        {\n            rays[index].extra.y = 0;\n            hits[index].primid = -1;\n            return;\n        }\n\n        for (int j = 0; j < numSources; ++j)\n        {\n            float sourceSphereHitDistance = raySphereIntersect(&rays[index], sources[j].origin, SOURCE_RADIUS);\n            if (0.0f <= sourceSphereHitDistance && sourceSphereHitDistance < hits[index].uvwt.s3)\n            {\n                rays[index].extra.y = 0;\n                hits[index].primid = -1;\n                return;\n            }\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Shading + Shadow/Bounced Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat3 calculateHitPoint(Ray ray,\n                         Hit hit)\n{\n    return ray.o.xyz + hit.uvwt.s3 * ray.d.xyz;\n}\n\nfloat3 calculateHitNormal(Ray ray,\n                          Hit hit,\n                          global float4* normals)\n{\n    float3 hitNormal = normals[hit.primid].xyz;\n    if (dot(hitNormal, ray.d.xyz) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    return hitNormal;\n}\n\nfloat pointSourceIrradiance(float distance,\n                            float minDistance)\n{\n    float attenuation = 1.0f / max(distance, minDistance);\n    float irradiance = (1.0f / (4.0f * PI)) * (attenuation * attenuation);\n    return irradiance;\n}\n\nfloat3 reflect(float3 incident,\n               float3 normal)\n{\n    return normalize(incident - (2.0f * dot(incident, normal) * normal));\n}\n\nkernel void shadeAndBounce(uint numSources,\n                           global const CoordinateSpace* sources,\n                           uint numListeners,\n                           global const CoordinateSpace* listeners,\n                           global const Directivity* directivities,\n                           uint numRays,\n                           uint numBounces,\n                           float irradianceMinDistance,\n                           global const Ray* rays,\n                           global const Hit* hits,\n                           global const float3* normals,\n                           global const int* materialIndices,\n                           global const Material* materials,\n                           uint numDiffuseSamples,\n                           global const float4* diffuseSamples,\n
estimatedSize
es{9Zu
et:5J\t9
et<3lA=M
euCȭU
euJ:52
evC=Eu
evϼg%a
ew:ki6
ew;:x
ewM;3
ex;<d
executable format error
execute_local@TaskQueue@TaskScheduler@embree@@QEAA_NAEAUThread@23@PEAUTask@23@@Z
ext-ms-win-kernel32-package-current-l1-1-0
ext-ms-win-ntuser-dialogbox-l1-1-0
ext-ms-win-ntuser-windowstation-l1-1-0
ext_elements.load() <= set.ext_range_size
ext_end >= range<Ty>::_end
exȺ3 c
ey:HBp
ez<8w
e|ѽ\fEH
e}4=Z
e}<LN3
e~8;o
e»vhq
e¼\vOǼJk
e¼t麼O
eǑ<qg
eɼ8%Y\r
eʻ"A0
e̽NOj>x
eЉD$0tVA
eҔ;b7d
eҢ9nuo
eӖ:s80
eԻqvϺTj
eؼCO\r=|a
eٻ#ur;9
eߨ;KS
e쫼F_G
f %d %d %d\n
f :F'\n
f u:gw
f"<dZ
f#b"eH
f$\e>zI
f$bA~\b
f&ba}Hp<ѱK
f':6J
f';KjX
f(-8y
f(k:0dR
f(ȹvǮ9B
f)\n;tq
f)\r<Gi
f+:qdA
f+bQ|H
f,6:N
f/8o J;;b
f0-<K
f0:;l
f0U808
f0\vP
f0\vP!h
f0\vP!s
f0b!L@X
f0u'H
f1.=y\e
f1L<ͅǻM
f2:!I4
f2\bp\a
f2\bp\aP
f2\n9I
f2b1|H
f2bA|H
f3bBm
f5\f 0
f65;܂G
f6b:s
f8>1x:N
f8?ls7
f8ba\\H
f8ݗV:\fl
f9(t\eL
f9(t\fH
f9)u H
f9)uTH
f9*u\tH
f9,P9
f9.9r
f9/t\tH
f94748
f9GGd9
f9\\$bu\nJ
f9\a=s:bcB
f9\bt\rH
f9\bt\tH
f9\bu3HcH<H
f9b!lH
f9b1|H
f9i@w
f9w=`p
f9wZ~9
f9£i8
f:"Yv:d
f:'SK
f::OS
f:Sw$9
f:WV*;Td
f:YXn9
f:\fe
f:fQ\f
f:iby
f:itd:\t
f:ki{9
f:p\t
f:q;Q
f;)ax;K
f;*Ns
f;.tS
f;0H1
f;2Y}>k
f;8\rH9W
f;<wL
f;>YE
f;H9n
f;O^0
f;S;y
f;X\rM
f;X`e
f;Yt˹3
f;\bd
f;\n@a<RI
f;\nDf;VH
f;\tq1<[4I
f;\vuS
f;bA|H
f;k\nF:j
f;r4U
f;t'4<u
f;v\a
f;x)6
f;{\vq; E
f;~gF
f;Ä\b9 \rA
f<IR\t
f<Ol4
f<[6I
f<\fr6
f<\vzμs
f<]V̹AHP
f<f'f<I
f<mT\nE
f<s42
f=B^l=;or
f=G(H
f=HQ\v
f=dS\v>\n
f=j63
f>0Wy
f>>FN
f>Jd\b
f>\bAV>\f
f>\ncL
f?0UE
f?@9ke
f?R(1
f?T;p
f?br}H
f@A:2
f@HcC(H
f@Ye\nH
f@Ye\nb14HY
f@br}H
fA9,Au
fA9,Qu
fA91t A
fA9<\\u
fA;(t(fA98t
fA;8unI
fA;\at\rI
fB9,$O
fB9,Nu
fB94Ou
fB9<@u
fB9<Bu
fB9<Hu
fB:)Tf
fC\a>8B
fC\r8\e
fD+c\bD
fD9 tMH
fD9 t\a
fD9 t\nH
fD9 t\vH
fD9 u\fH
fD9$Hu
fD9+t
fD9,Au
fD9,Cu
fD9,Ku
fD9,Pu
fD91u\r
fD94Fu
fD98u\fA
fD9;u\a3
fD9<Au
fD9<Cu
fD9<Hu
fD9<Xu
fD9?t
fD9\bt\rH
fD9\fwu
fD9\nt\tH
fD9\tt(I
fD9t$b
fD9|Dhu
fD9|Dhu1
fD9|DhuA
fD9|DhuO
fDigiCert Inc1
fE2;B
fE9,Du
fE9,tu
fE98t
fE9<Au
fE:k\f
fES:헏:D
fE\n;T Z
fE\v\bfA
fEo;N
fF"=\rX5
fF9<qu
fF<Muq
fFs;\e\em
fG9$Ou
fG9,wu
fG;PB
fH:!H
fHL+f@H
fHX\v5c
fHY4\ebA\fHY\\\e
fH}aB
fI;n1
fI;tJ\b
fJ;I@a
fJԻyrg
fM7<Io
fNֺl/b:\v
fO*>V
fO;Qm
fP:zV
fP;?C";UI
fPY%se
fPҺ/X
fQѻ;q
fR <4c\f
fR\bp\a
fR\bp\aP
fRռhg
fRؽ$C\t
fS>p%C
fSԻvyc
fT=O&n=V
fT\r<Zf2
fU\t=c
fV2:i
fV:Rǭ9
fV<\nL
fV=۠Q
fVE`A\v
fVM@A\v
fW;-I
fWo:Js
fX!t5
fXڻOa
fY)9I
fY;7a
fYٻw\e
fZ;6=u
fZK;r
fZy=kJA
f[#9a'g
f[D;\nD
f\a96
f\a<Vhn
f\b!9D
f\b!<8M
f\b;"ep
f\bL:T\tn
f\b\\Q\nb
f\eba~Ho
f\f:|Zk
f\fv:m
f\n=@Z9
f\n>J0
f\nW;`wv
f\n\n;k
f\nba|H
f\nr8J
f\r:D
f\r<\eV
f\r=j}5
f\tn:l
f\v<\tL
f\vT<ӸG
f\vb!|H
f\vba|H
f]<o\af
f]P>uep
f]R=r/X
f]\t:In
f`3;JF
f`;N#O9aU
failed
failed: cylinder
fast_allocator_regression_test
fastcall
fatbvh
fatbvh accelerator can cause stack overflow for this scene, try using bvh instead
fatbvh accelerator can't allocate enough stack memory, try using bvh instead
fb;<Cu
fbQ|H
fb\b0\aP
fba$@X
fba|H
fd;ۖ4
fdY:\f圻68
fdbBm
fe;+GF
feJ<F
feN>(s[>v
ffalse
fffff
ffffff
ffffffJ
fffffff
fg>5Xu
fgƺAyy
fgϻ^9
fic9aaP
file error
file exists
file too large
fileBaseName
filename too long
filled
filter functions not supported for this geometry
finished BVH
first <= last
fiԼ<k\t
fj:mgA
fj;`L
fkU:^o
fkg;m
fl;9c
float expected
float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n
float_exceptions
fmR:\n
fm\v:/t
fn<zɹ;H
fo9@T
fo:GỺl
for BVH4<Bezier1i
for BVH4<Bezier1v
for BVH4<Line4i
for BVH4<Line4iMB
for BVH4<Object
for BVH4<Quad4i
for BVH4<Quad4iMB
for BVH4<Quad4v
for BVH4<Triangle4
for BVH4<Triangle4i
for BVH4<Triangle4iMB
for BVH4<Triangle4v
for BVH4<Triangle4vMB
for BVH4OBB<Bezier1i
for BVH4OBB<Bezier1iMB
for BVH4OBB<Bezier1v
for BVH8<Line4i
for BVH8<Object
for BVH8<Quad4i
for BVH8<Quad4v
for BVH8<Triangle4
for BVH8<Triangle4i
for BVH8<Triangle4iMB
for BVH8<Triangle4v
for BVH8<Triangle4vMB
for BVH8MBOBB<Bezier1iMB
for QBVH8<Quad4i
foȸ%M\v
fp09*$u:\tS
fp\v`\n0
fp\v`\nP
fp\v`\nP\t0
fpx<QFI
fq1<&JF
fq5<1
fq;6nǺg
fq<dm
fqp;E
fq༉匼Cb
fr\bp\a
fr\bp\aP
free blocks
freeAudioBuffer
freeBlocks.load() != nullptr && freeBlocks.load()->getBlockAllocatedBytes() >= bytes
french-belgian
french-canadian
french-luxembourg
french-swiss
fs,:3e
ft==\nT
ft\v;7
fuQ:|vs
function BVH8BuilderTwoLevelTriangleMeshSAH not supported by your CPU
function BVH8BuilderTwoLevelVirtualSAH not supported by your CPU
function BVH8QuantizedTriangle4SceneBuilderSAH not supported by your CPU
function BVH8QuantizedTriangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4MeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4MeshBuilderSAH not supported by your CPU
function BVH8Triangle4MeshRefitSAH not supported by your CPU
function BVH8Triangle4SceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4SceneBuilderSAH not supported by your CPU
function BVH8Triangle4iMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4iMeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4iMeshBuilderSAH not supported by your CPU
function BVH8Triangle4iMeshRefitSAH not supported by your CPU
function BVH8Triangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vMeshBuilderMortonGeneral not supported by your CPU
function BVH8Triangle4vMeshBuilderSAH not supported by your CPU
function BVH8Triangle4vMeshRefitSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderSAH not supported by your CPU
function BVH8VirtualMBSceneBuilderSAH not supported by your CPU
function BVH8VirtualMeshBuilderMortonGeneral not supported by your CPU
function BVH8VirtualMeshBuilderSAH not supported by your CPU
function BVH8VirtualMeshRefitSAH not supported by your CPU
function BVH8VirtualSceneBuilderSAH not supported by your CPU
function not supported
fv8Dd
fvϽjE
fx:_P2
fxº\fm
fxǾ;X2
fy=p:5
f}ͻB碻lC
f~ֺ\f9M
fÈbQ4
fÜ9- w
fżeqD
fǻ4sJ
fȼf\fj
fɐbq|H
fϹk,e:EG1
fӔ;tpw
fջ\tIz
fռ7`s
fغKd̺oU
fܵ;BA
g!3;Rn8
g!T9"d
g#d<'YC
g%H9V
g'L;kd
g(v;\fA
g*?VO
g*U;t
g*k;8
g+m;sOν[3
g+ѻ2PK
g,;wa 9c
g,<\bp3
g->Ra
g0;TQj
g0ܼe_c
g1gDgNgzg~g
g2=ya=A
g2{:Rn
g3>:2w
g3}>Bi
g4o>e
g4v:E
g5=b\nj
g5RҌ<țu
g6H=Co
g6N:B
g8;;\nk
g8B~0GBf
g8ɊúD
g8мFT
g8߰99g
g9@x!8
g9P0\e
g9P[T<Q
g9ھg9
g: kP;O
g:7`U
g:A\n
g:Hǩ;vHO
g:PZP
g:V6s
g:_lu
g:isr9U
g:qmU
g;2zI
g;>\n49
g;G7p
g;G;kyW
g;hD&;E
g;kuG
g;m{5
g<df\t
g<vm2
g<v«9n
g<z(L
g=+8S
g=K\r
g>>wd\r
g@2:9
gB:cc0
gC`;C
gDﻪY1
gGV=pD
gHL+g@H
gHL+g@I
gLV;I3
gM3<Xs
gO;uIg
gQ;'x
gR9>W8
gRC:h
gS;chc;rx
gS<m\vl
gT\\;QYI
gU(:;47
gUD;ZU
gX<FK
gY(<d
gY^8\a
g\\z>RD
g\b:CkK
g\e<fB
g\eL>r
g\fD:\n
g\n<K!G<G
g\t;!LM
g\tC;[P
g\v;KZa:6
g^z:h
g_device
g_j<H_w
gaP=\rH
ga\b;d
gatherEnergyField
gatherImage
gb6=Md
gbѼzQP
general
generateCameraRays
generateListenerRays
generateProbes
generic
geomID
geometries inside group have to be of same type
geometries[i]->getType() == Mesh::geom_type
geometry groups cannot contain other geometry groups
geometry instances only support a single timestep
geometry->intersectionFilterN
geometry->occlusionFilterN
german-austrian
german-lichtenstein
german-luxembourg
german-swiss
getDataSize
getDeviceDesc
getNumDevices
getNumProbes
getOutputs
getProbe
getinfoaH
gfffffff
gfffffffH
gfffffffI
gfffffffL
gffffffff
gg:C\r4<t
gj\f>t
go7H=_;K
gp;:nJ
gr9DH7S
gr:-\rY
great britain
groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    *sum = shmem[groupSize - 1];\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    if (localId == 0){\\ \n    shmem[groupSize - 1] = 0;}\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_PART(type)\\ \n    type group_scan_exclusive_part_##type( int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    type sum = 0;\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (localId == 0)\\ \n    {\\ \n    sum = shmem[groupSize - 1];\\ \n    shmem[groupSize - 1] = 0;\\ \n    }\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    return sum;\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE(type)\\ \n    __kernel void scan_exclusive_##type(__global type const* in_array, __global type* out_array, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    int groupId   = get_group_id(0);\\ \n    shmem[localId] = in_array[2*globalId] + in_array[2*globalId + 1];\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    out_array[2 * globalId + 1] = shmem[localId] + in_array[2*globalId];\\ \n    out_array[2 * globalId] = shmem[localId];\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\\ \n    v2.w += v1.w;\\ \n    shmem[localId] = v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    v2.w = shmem[localId];\\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4_V1(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_##type##4##_v1(__global type##4 const* in_array, __global ty
gu;wI
gvd;>L
gyU:b
g»t\e
gŏ=KG
gŦ:DA
gʼ0;g<o
gͺˇy:2v\n
gκhv付E
gМ;zg
gһuv0
gԺUKL
gۼYVn
h UAVAWH
h VAVAWH
h VWATAVAWH
h WATAUAVAWH
h#:yo
h&2;2r
h-Ѽws
h16;|x
h4:IgZ
h5]:i
h5e>v
h60;kG
h6D;2t;<6
h6ٺڿB8
h7꼫a1
h8o\vo
h9 20
h9*yx:UQ
h9<qah
h9>0˺_N
h9^c89
h:)J\t:AY
h:/1E
h:2hH;z
h:Z磺\vO
h:g+f
h:or^9
h:p.Y
h;Adi;rr
h;NDn
h;XtۼK
h;\fZV;7e
h;fKn;06r
h;yjo;K
h;̤d;\tUl
h<A<w\a7
h<I\b6
h=:"OV9
h=;kSp
h=E.2
h=I?F>I
h=\n;pD
h>2ip
h>^ht>0
h?=vxX
h?tFپLJk
hA;μw
hA_A^A
hA_A^A]A
hB)9Ǯq
hB.<C6F
hB:QN49
hB^T{C
hDº\eTr
hEb>0
hJ8;zl
hKλyp
hL#=x3
hL\a;uP
hMK</u
hMK<sJs
hNh4hhh
hN亦Hy
hP:qk
hQƽ2d
hR>\fpm
hU'>k\b
hU<Ǯo
hU\\;CJ{a
hVC;Lo
hW:_z
hX:3jG;F
hX=^y\e
hYD$0
h\e;x
h\eH99x\n;1
h\f\f
h\rm<hz
h\v\a
h];sT
h_:~xr9b
h`hhh\b\b\axwpwpp\b\b
ha;gRa:r
hair_accel
hair_accel_mb
hair_builder
hair_builder_mb
hair_traverser
hair_traverser_mb
hc;!UR;8
hdK:3
header crc mismatch
hfalse
hfffffff
high_quality
histogram
hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    __global int* numrays,     // Number of rays in the workload \n    int offset,                // Offset in rays array \n    __global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny2L(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n
hk<;n
hl(<2xz
hlbvh accelerator max batch size exceeded
hls:PW4
holland
hong-kong
host unreachable
hpT;U
hrd<O
hrtfSettings
hrtfSettings->normType
hrtfSettings->sofaData
hrtfSettings->sofaDataSize
hrtfSettings->type
hrtfSettings->volume
hs89r
hs:XO
htr<jtb<lt6<tt&<wt
http://ocsp.digicert.com0
http://ocsp.digicert.com0A
http://ocsp.digicert.com0C
http://ocsp.digicert.com0X
https://github.com/ValveSoftware/steam-audio/blob/master/LICENSE.md
hu=?lq
hugepages
hvļTAS
hwc;kY
hypot
hypotf
hyz8^7B
hz!>I
hz;Xz
h|S:\fE
h»A,0;J
hÊD$g
hü rj
hŻ\aO
hʼa䯼\bT
h̼wyP
hӻC\fC;}p
hܽe\a
hޯ<WP
hᗻ\vPD
h⡽7-h
i 3\bA(L
i ;\e
i < geometries.size
i < numRanges
i < size
i < size_active
i B=w5
i"p<F
i# <Q
i#:xYJ
i#F;y
i$baV\bY
i&=tQ\v
i';Ne
i';ecu
i)U;h
i+i<Uj
i,ba~\b
i.;Ws
i.>N5
i0:oȦ9
i1\n;fV8
i3<HO
i4V;\v
i4ۻ?k
i6:\b
i6=uA
i8U,';n
i8g\b2
i8m8@A
i9<S~\r
i9>:\tM
i9B܈9Iw
i9iǋ<Z
i9lzM9
i9v>T\e
i:J+k
i:M)7:^DZ
i:Yoa:\t
i:\bv
i:ik\e
i;LbB
i;Mzu
i;P<5
i;Vv3
i;Zo5
i;\n\fk
i;c+J
i;ku4;iN9
i;l1C
i;oi|:SnO
i;ouJ
i<N && j<N
i<]Cb
i<array2.size
i<tyZ
i=6\nk
i=w?6?T
i>&xO
i>=q8
i>>yo
i>Bsa
i?0@I
i?<Bu-8
iA<p5
iAU;v
iBo<;T
iD2;v\e
iH<QsO
iHȻDee;5
iI=M\t\v
iI=}9
iIĺ8 Q
iK;n~];qe
iM:_R9\r
iM;$LQ
iOA9\t
iS;U,H
iTa;S1\t
iU;GA
iVr9*bn8
iXh<z
i[0] >= 0 && (size_t)i[0] < num
i[1] >= 0 && (size_t)i[1] < num
i[2] >= 0 && (size_t)i[2] < num
i\a:KIz
i\aļVvB?p
i\bH+)H
i\bba~\b
i\eĻ\b2
i\fźXI
i\n;O
i\nW<6
i\r;2
i\r<e3R
i\v7<\r
ib/:u
id < nextID
idata$2
idata$3
idata$4
idata$5
idata$6
identifier
identifier expected
identifier removed
identifier).endpointInfluence.center.x
identifier).endpointInfluence.center.y
identifier).endpointInfluence.center.z
identifier).endpointInfluence.radius
identifier).type
identifier).variation
ie <GG
if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n \n// intersect Ray against the whole BVH structure \nvoid IntersectSceneClosest(SceneData const* scenedata,  ray const* r, Intersection* isect) \n{ \n    const float3 invdir  = make_float3(1.f, 1.f, 1.f)/r->d.xyz; \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    int idx = 0; \n \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        // If this is the leaf try to intersect against contained triangle. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, isect->uvwt.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                IntersectLeafClosest(scenedata, &node, r, isect); \n                idx = (int)(node.pmax.w); \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                ++idx; \n            } \n        } \n        else \n        { \n            idx = (int)(node.pmax.w); \n        } \n    }; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata,  ray const* r) \n{ \n    float3 invdir  = make_float3(1.f, 1.f, 1.f)/r->d.xyz; \n \n    int idx = 0; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        // If this is the leaf try to intersect against contained triangle. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, r->o.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                if (IntersectLeafAny(scenedata, &node, r)) \n                { \n                    return true; \n                } \n                else \n                { \n                    idx = (int)(node.pmax.w); \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                ++idx; \n            } \n        } \n        else \n        { \n            idx = (int)(node.pmax.w); \n        } \n    }; \n \n    return false; \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosestAMD( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process \n__global Intersection* hits, // Hit datas \n__global int*          raycnt  \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id  = get_global_id(0); \n    int local_id  = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    Intersection isect; \n \n    while (ridx < numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            IntersectSceneClosest(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[ridx] = isect; \n        } \n    } \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAnyAMD( \n    // Input \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices
if;#A
ifh;#\n
ignore_config_files
igy;p
iiFi#ii
ii\e?j
iix;Tڈ:w
ikR8qN&9\f
il0<Yl
ilj;S
illegal byte sequence
imb;D
imŻ\ny
in the MXCSR control and status register. This can have a severe
in(:5
in->data
in->data[iChannel][in->numSamples - 1
in->numChannels
in->numSamples
inType
inappropriate io control operation
include "pmmintrin.h
include "xmmintrin.h
incoherent
incompatible version
incorrect data check
incorrect header check
incorrect length check
index < 3
index < 4
index < 8
inflate 1.2.13 Copyright 1995-2022 Mark Adler
inlen == hrtf->N
inputs
inputs->airAbsorptionModel
inputs->airAbsorptionModel)->callback
inputs->airAbsorptionModel)->coefficients
inputs->airAbsorptionModel)->coefficients[iArray
inputs->airAbsorptionModel)->dirty
inputs->airAbsorptionModel)->type
inputs->baked
inputs->bakedDataIdentifier.endpointInfluence.center.x
inputs->bakedDataIdentifier.endpointInfluence.center.y
inputs->bakedDataIdentifier.endpointInfluence.center.z
inputs->bakedDataIdentifier.endpointInfluence.radius
inputs->bakedDataIdentifier.type
inputs->bakedDataIdentifier.variation
inputs->directFlags
inputs->directivity
inputs->directivity)->dipolePower
inputs->directivity)->dipoleWeight
inputs->distanceAttenuationModel
inputs->distanceAttenuationModel)->callback
inputs->distanceAttenuationModel)->dirty
inputs->distanceAttenuationModel)->minDistance
inputs->distanceAttenuationModel)->type
inputs->enableValidation
inputs->findAlternatePaths
inputs->flags
inputs->hybridReverbOverlapPercent
inputs->hybridReverbTransitionTime
inputs->numOcclusionSamples
inputs->numTransmissionRays
inputs->occlusionRadius
inputs->occlusionType
inputs->pathingOrder
inputs->pathingProbes
inputs->reverbScale[iBand
inputs->source.ahead.x
inputs->source.ahead.y
inputs->source.ahead.z
inputs->source.origin.x
inputs->source.origin.y
inputs->source.origin.z
inputs->source.right.x
inputs->source.right.y
inputs->source.right.z
inputs->source.up.x
inputs->source.up.y
inputs->source.up.z
inputs->visRadius
inputs->visRange
inputs->visThreshold
instID
instance
instance@TaskScheduler@embree@@CAPEAU12@XZ
instancedMesh
instancing_block_size
instancing_open_factor
instancing_open_max
instancing_open_max_depth
instancing_open_min
insufficient memory
int4 bin = (localvals >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        if (localid < NUM_BINS) \n        { \n            scanned_histogram[localid] += sum; \n        } \n    } \n} \n \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid ScatterKeysAndValues(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Input values \n    __global int4 const* restrict in_values, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys, \n    // Output values \n    __global int* restrict  out_values \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localkeys = safe_load_int4_intmax(in_keys, loadidx, numelems); \n        int4 localvals = safe_load_int4_intmax(in_values, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localkeys >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LD
integer expected
interleaveAudioBuffer
internal error in ISA selection for BVH4Bezier1iIntersector1
internal error in ISA selection for BVH4Bezier1iIntersector16Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector16Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersector1_OBB
internal error in ISA selection for BVH4Bezier1iIntersector4Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector4Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersector8Hybrid
internal error in ISA selection for BVH4Bezier1iIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Bezier1iIntersectorStream
internal error in ISA selection for BVH4Bezier1vIntersector1
internal error in ISA selection for BVH4Bezier1vIntersector16Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector16Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersector1_OBB
internal error in ISA selection for BVH4Bezier1vIntersector4Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector4Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersector8Hybrid
internal error in ISA selection for BVH4Bezier1vIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Bezier1vIntersectorStream
internal error in ISA selection for BVH4IntersectorStreamPacketFallback
internal error in ISA selection for BVH4Line4iIntersector1
internal error in ISA selection for BVH4Line4iIntersector16
internal error in ISA selection for BVH4Line4iIntersector4
internal error in ISA selection for BVH4Line4iIntersector8
internal error in ISA selection for BVH4Line4iIntersectorStream
internal error in ISA selection for BVH4Line4iMBIntersector1
internal error in ISA selection for BVH4Line4iMBIntersector16
internal error in ISA selection for BVH4Line4iMBIntersector4
internal error in ISA selection for BVH4Line4iMBIntersector8
internal error in ISA selection for BVH4OBBBezier1iMBIntersector16Hybrid_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector1_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector4Hybrid_OBB
internal error in ISA selection for BVH4OBBBezier1iMBIntersector8Hybrid_OBB
internal error in ISA selection for BVH4Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector1Moeller
internal error in ISA selection for BVH4Quad4iIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersectorStreamMoeller
internal error in ISA selection for BVH4Quad4iIntersectorStreamPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH4Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector1Moeller
internal error in ISA selection for BVH4Quad4vIntersector1Pluecker
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersectorStreamMoeller
internal error in ISA selection for BVH4Quad4vIntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersectorStreamPluecker
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector1
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector16
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector4
internal error in ISA selection for BVH4SubdivPatch1CachedIntersector8
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector1
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector16
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector4
internal error in ISA selection for BVH4SubdivPatch1CachedMBIntersector8
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector1
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector16
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector4
internal error in ISA selection for BVH4SubdivPatch1EagerIntersector8
internal error in ISA selection for BVH4SubdivPatch1Intersector1
internal error in ISA selection for BVH4SubdivPatch1Intersector16
internal error in ISA selection for BVH4SubdivPatch1Intersector4
internal error in ISA selection for BVH4SubdivPatch1Intersector8
internal error in ISA selection for BVH4SubdivPatch1MBIntersector1
internal error in ISA selection for BVH4SubdivPatch1MBIntersector16
internal error in ISA selection for BVH4SubdivPatch1MBIntersector4
internal error in ISA selection for BVH4SubdivPatch1MBIntersector8
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector1Moeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4IntersectorStreamMoeller
internal error in ISA selection for BVH4Triangle4IntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH4Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersectorStreamMoeller
internal error in ISA selection for BVH4Triangle4iIntersectorStreamPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersectorStreamPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH4VirtualIntersector1
internal error in ISA selection for BVH4VirtualIntersector16Chunk
internal error in ISA selection for BVH4VirtualIntersector4Chunk
internal error in ISA selection for BVH4VirtualIntersector8Chunk
internal error in ISA selection for BVH4VirtualIntersectorStream
internal error in ISA selection for BVH4VirtualMBIntersector1
internal error in ISA selection for BVH4VirtualMBIntersector16Chunk
internal error in ISA selection for BVH4VirtualMBIntersector4Chunk
internal error in ISA selection for BVH4VirtualMBIntersector8Chunk
internal error in ISA selection for BVH4XfmTriangle4Intersector1Moeller
internal error in ISA selection for BVH8Bezier1iIntersector16Hybrid_OBB
internal error in ISA selection for BVH8Bezier1iIntersector1_OBB
internal error in ISA selection for BVH8Bezier1iIntersector4Hybrid_OBB
internal error in ISA selection for BVH8Bezier1iIntersector8Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector16Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector1_OBB
internal error in ISA selection for BVH8Bezier1vIntersector4Hybrid_OBB
internal error in ISA selection for BVH8Bezier1vIntersector8Hybrid_OBB
internal error in ISA selection for BVH8IntersectorStreamPacketFallback
internal error in ISA selection for BVH8Line4iIntersector1
internal error in ISA selection for BVH8Line4iIntersector16
internal error in ISA selection for BVH8Line4iIntersector4
internal error in ISA selection for BVH8Line4iIntersector8
internal error in ISA selection for BVH8Line4iMBIntersector1
internal error in ISA selection for BVH8Line4iMBIntersector16
internal error in ISA selection for BVH8Line4iMBIntersector4
internal error in ISA selection for BVH8Line4iMBIntersector8
internal error in ISA selection for BVH8OBBBezier1iMBIntersector16Hybrid_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector1_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector4Hybrid_OBB
internal error in ISA selection for BVH8OBBBezier1iMBIntersector8Hybrid_OBB
internal error in ISA selection for BVH8Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector1Moeller
internal error in ISA selection for BVH8Quad4iIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersectorStreamMoeller
internal error in ISA selection for BVH8Quad4iIntersectorStreamPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH8Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector1Moeller
internal error in ISA selection for BVH8Quad4vIntersector1Pluecker
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersectorStreamMoeller
internal error in ISA selection for BVH8Quad4vIntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector1Moeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4IntersectorStreamMoeller
internal error in ISA selection for BVH8Triangle4IntersectorStreamMoellerNoFilter
internal error in ISA selection for BVH8Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersectorStreamMoeller
internal error in ISA selection for BVH8Triangle4iIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersectorStreamPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH8VirtualIntersector1
internal error in ISA selection for BVH8VirtualIntersector16Chunk
internal error in ISA selection for BVH8VirtualIntersector4Chunk
internal error in ISA selection for BVH8VirtualIntersector8Chunk
internal error in ISA selection for BVH8VirtualIntersectorStream
internal error in ISA selection for BVH8VirtualMBIntersector1
internal error in ISA selection for BVH8VirtualMBIntersector16Chunk
internal error in ISA selection for BVH8VirtualMBIntersector4Chunk
internal error in ISA selection for BVH8VirtualMBIntersector8Chunk
internal error in ISA selection for InstanceBoundsFunc
internal error in ISA selection for InstanceIntersectorN
internal error in ISA selection for QBVH4Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for QBVH8Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH8Triangle4Intersector1Moeller
internal error in ISA selection for QBVH8Triangle4iIntersector1Pluecker
internal error in ISA selection for rayStreamFilterFuncs
internal error: AccelN too small
internal_tasking_system
internal_time_splits
interrupted
intersection_filter
intersector1
intersector1.intersect
intersector1.occluded
intersector16
intersector16.intersect
intersector16.occluded
intersector4
intersector4.intersect
intersector4.occluded
intersector8
intersector8.intersect
intersector8.occluded
intersectorN
intersectorN.intersect
intersectors.intersectorN.intersect
intersectors.intersectorN.occluded
invalid argument
invalid bit length repeat
invalid block type
invalid buffer specified
invalid code -- missing end-of-block
invalid code lengths set
invalid destination pointer
invalid distance code
invalid distance too far back
invalid distances set
invalid geometry
invalid geometry ID
invalid geometry flag
invalid literal/length code
invalid literal/lengths set
invalid map<K, T> key
invalid number of threads specified
invalid seek
invalid stored block lengths
invalid string position
invalid thread ID
invalid timestep
invalid window size
io error
ios_base::badbit set
ios_base::eofbit set
ios_base::failbit set
iostream
iostream stream error
ipl::HRTFMap::loadAmbisonicsHRIRs
ipl::HRTFMap::verifyDataHeader
iplAirAbsorptionCalculate
iplAmbisonicsBinauralEffectApply
iplAmbisonicsBinauralEffectCreate
iplAmbisonicsBinauralEffectRelease
iplAmbisonicsBinauralEffectReset
iplAmbisonicsBinauralEffectRetain
iplAmbisonicsDecodeEffectApply
iplAmbisonicsDecodeEffectCreate
iplAmbisonicsDecodeEffectRelease
iplAmbisonicsDecodeEffectReset
iplAmbisonicsDecodeEffectRetain
iplAmbisonicsEncodeEffectApply
iplAmbisonicsEncodeEffectCreate
iplAmbisonicsEncodeEffectRelease
iplAmbisonicsEncodeEffectReset
iplAmbisonicsEncodeEffectRetain
iplAmbisonicsPanningEffectApply
iplAmbisonicsPanningEffectCreate
iplAmbisonicsPanningEffectRelease
iplAmbisonicsPanningEffectReset
iplAmbisonicsPanningEffectRetain
iplAmbisonicsRotationEffectApply
iplAmbisonicsRotationEffectCreate
iplAmbisonicsRotationEffectRelease
iplAmbisonicsRotationEffectReset
iplAmbisonicsRotationEffectRetain
iplAudioBufferAllocate
iplAudioBufferConvertAmbisonics
iplAudioBufferDeinterleave
iplAudioBufferDownmix
iplAudioBufferFree
iplAudioBufferInterleave
iplAudioBufferMix
iplBinauralEffectApply
iplBinauralEffectCreate
iplBinauralEffectRelease
iplBinauralEffectReset
iplBinauralEffectRetain
iplCalculateRelativeDirection
iplContextCreate
iplContextRelease
iplContextRetain
iplContextSetProfilerContext
iplContextSetVariableBool
iplContextSetVariableFloat32
iplContextSetVariableInt32
iplContextSetVariableString
iplConvolutionPartitionerCreate
iplConvolutionPartitionerPartition
iplConvolutionPartitionerRelease
iplConvolutionPartitionerRetain
iplDirectEffectApply
iplDirectEffectCreate
iplDirectEffectRelease
iplDirectEffectReset
iplDirectEffectRetain
iplDirectSimulatorCreate
iplDirectSimulatorRelease
iplDirectSimulatorRetain
iplDirectSimulatorSimulate
iplDirectivityCalculate
iplDistanceAttenuationCalculate
iplDistanceAttenuationGetCorrectionCurve
iplEmbreeDeviceCreate
iplEmbreeDeviceRelease
iplEmbreeDeviceRetain
iplEnergyFieldCopyDeviceToHost
iplEnergyFieldCopyHostToDevice
iplEnergyFieldCreate
iplEnergyFieldGetData
iplEnergyFieldGetNumBins
iplEnergyFieldGetNumChannels
iplEnergyFieldGetSize
iplEnergyFieldRelease
iplEnergyFieldRetain
iplEnergyFieldSetData
iplHRTFCreate
iplHRTFRelease
iplHRTFRetain
iplHybridReverbEstimatorCreate
iplHybridReverbEstimatorEstimate
iplHybridReverbEstimatorRelease
iplHybridReverbEstimatorRetain
iplImpulseResponse2AddChannel
iplImpulseResponse2AddSample
iplImpulseResponse2Create
iplImpulseResponse2Release
iplImpulseResponse2Reset
iplImpulseResponse2Retain
iplImpulseResponse2SetChannel
iplImpulseResponse2SetSample
iplImpulseResponse2Swap
iplImpulseResponse2SwapSource
iplImpulseResponseCopyDeviceToHost
iplImpulseResponseCopyHostToDevice
iplImpulseResponseCreate
iplImpulseResponseGetData
iplImpulseResponseGetNumChannels
iplImpulseResponseGetNumSamples
iplImpulseResponseGetSize
iplImpulseResponseRelease
iplImpulseResponseRetain
iplImpulseResponseSetData
iplIndirectEffectIRCreate
iplIndirectEffectIRRelease
iplIndirectEffectIRRetain
iplInstancedMeshAdd
iplInstancedMeshCreate
iplInstancedMeshRelease
iplInstancedMeshRemove
iplInstancedMeshRetain
iplInstancedMeshUpdateTransform
iplOpenCLDeviceCreate
iplOpenCLDeviceCreateFromExisting
iplOpenCLDeviceListCreate
iplOpenCLDeviceListGetDeviceDesc
iplOpenCLDeviceListGetNumDevices
iplOpenCLDeviceListRelease
iplOpenCLDeviceListRetain
iplOpenCLDeviceRelease
iplOpenCLDeviceRetain
iplPanningEffectApply
iplPanningEffectCreate
iplPanningEffectRelease
iplPanningEffectReset
iplPanningEffectRetain
iplPathBakerBake
iplPathBakerCancelBake
iplPathEffectApply
iplPathEffectCreate
iplPathEffectRelease
iplPathEffectReset
iplPathEffectRetain
iplPathSimulatorCreate
iplPathSimulatorRelease
iplPathSimulatorRetain
iplPathSimulatorSimulate
iplProbeArrayCreate
iplProbeArrayGenerateProbes
iplProbeArrayGetNumProbes
iplProbeArrayGetProbe
iplProbeArrayRelease
iplProbeArrayRetain
iplProbeBatchAddProbe
iplProbeBatchAddProbeArray
iplProbeBatchCommit
iplProbeBatchCreate
iplProbeBatchGetDataSize
iplProbeBatchGetInfluencingProbes
iplProbeBatchGetNumProbes
iplProbeBatchGetProbeArray
iplProbeBatchLoad
iplProbeBatchRelease
iplProbeBatchRemoveData
iplProbeBatchRemoveProbe
iplProbeBatchRetain
iplProbeBatchSave
iplProbeBatchUpdateEndpoint
iplProbeBatchUpdateProbePosition
iplProbeBatchUpdateProbeRadius
iplProbeNeighborhoodCalculateWeights
iplProbeNeighborhoodCheckOcclusion
iplProbeNeighborhoodCreate
iplProbeNeighborhoodFindNearest
iplProbeNeighborhoodGetNumProbes
iplProbeNeighborhoodGetNumValidProbes
iplProbeNeighborhoodRelease
iplProbeNeighborhoodReset
iplProbeNeighborhoodResize
iplProbeNeighborhoodRetain
iplRadeonRaysDeviceCreate
iplRadeonRaysDeviceRelease
iplRadeonRaysDeviceRetain
iplReconstructorCreate
iplReconstructorReconstruct
iplReconstructorRelease
iplReconstructorRetain
iplReflectionEffectApply
iplReflectionEffectCreate
iplReflectionEffectRelease
iplReflectionEffectReset
iplReflectionEffectRetain
iplReflectionMixerApply
iplReflectionMixerCreate
iplReflectionMixerRelease
iplReflectionMixerReset
iplReflectionMixerRetain
iplReflectionSimulatorCreate
iplReflectionSimulatorRelease
iplReflectionSimulatorRetain
iplReflectionSimulatorSimulate
iplReflectionsBakerBake
iplReflectionsBakerCancelBake
iplReflectionsEffect2Apply
iplReflectionsEffect2Create
iplReflectionsEffect2GetFloat
iplReflectionsEffect2GetInt32
iplReflectionsEffect2Release
iplReflectionsEffect2Reset
iplReflectionsEffect2Retain
iplReflectionsEffect2SetBuffer
iplReflectionsEffect2SetFloat
iplReflectionsEffect2SetInt32
iplReflectionsPartitioner2AddTask
iplReflectionsPartitioner2Commit
iplReflectionsPartitioner2Create
iplReflectionsPartitioner2Release
iplReflectionsPartitioner2RemoveTask
iplReflectionsPartitioner2Retain
iplReflectionsPartitioner2RunTasks
iplReverbEstimatorEstimate
iplSceneCommit
iplSceneCreate
iplSceneLoad
iplSceneRelease
iplSceneRetain
iplSceneSave
iplSceneSaveOBJ
iplSerializedObjectCreate
iplSerializedObjectGetData
iplSerializedObjectGetSize
iplSerializedObjectRelease
iplSerializedObjectRetain
iplSimulatorAddProbeBatch
iplSimulatorCommit
iplSimulatorCreate
iplSimulatorRelease
iplSimulatorRemoveProbeBatch
iplSimulatorRetain
iplSimulatorRunDirect
iplSimulatorRunPathing
iplSimulatorRunPathingPerSource
iplSimulatorRunPathingPerSourceForNeighborhood
iplSimulatorRunReflections
iplSimulatorSetScene
iplSimulatorSetSharedInputs
iplSourceAdd
iplSourceCreate
iplSourceGetOutputs
iplSourceGetOutputsAux
iplSourceRelease
iplSourceRemove
iplSourceRetain
iplSourceSetInputs
iplStaticMeshAdd
iplStaticMeshCreate
iplStaticMeshLoad
iplStaticMeshRelease
iplStaticMeshRemove
iplStaticMeshRetain
iplStaticMeshSave
iplTrueAudioNextDeviceAcquireSlot
iplTrueAudioNextDeviceCreate
iplTrueAudioNextDeviceRelease
iplTrueAudioNextDeviceRetain
iplTrueAudioNextReleaseSlot
iplTrueAudioNextSetImpulseResponse
iplTrueAudioNextUpdateIRs
iplVirtualSurroundEffectApply
iplVirtualSurroundEffectCreate
iplVirtualSurroundEffectRelease
iplVirtualSurroundEffectReset
iplVirtualSurroundEffectRetain
ir":r
ir4;D
irUpdateQueue
irish-english
is a directory
isAlignedNode
isAlignedNodeMB() || isAlignedNodeMB4D
isAlignedNodeMB4D
isBarrier
isLeaf
isQuantizedNode
isTransformNode
isZ;f
is_double
isa::Cylinder::verify
italian-swiss
item < size
items<=4
itime < instance->numTimeSteps
itime+1 < numTimeSteps
itime_range.size() == 1
ivK;H
ivariant == IntersectVariant::FAST
ivariant == IntersectVariant::ROBUST
ix;h58
ixn<JtA<v
iy0=*{u
iy;\fb
izL;x
i|ŢXY
iȽutv=\tV
iʄ;Et
iͻo\t
i⺵gI;F
i繇ٱ:WF;dF
i軲j̻CF
j ;=M
j ?;k9
j ba|\b
j"=Np\n
j&9|6
j(L=N
j) \n \n// Find span occupied by internal node with index idx \nint2 FindSpan(__global int* mortoncodes, int numprims, int idx) \n{ \n    // Find the direction of the range \n    int d = sign((float)(DELTA(idx, idx+1) - DELTA(idx, idx-1))); \n \n    // Find minimum number of bits for the break on the other side \n    int deltamin = DELTA(idx, idx-d); \n \n    // Search conservative far end \n    int lmax = 2; \n    while (DELTA(idx,idx + lmax * d) > deltamin) \n        lmax *= 2; \n \n    // Search back to find exact bound \n    // with binary search \n    int l = 0; \n    int t = lmax; \n    do \n    { \n        t /= 2; \n        if(DELTA(idx, idx + (l + t)*d) > deltamin) \n        { \n            l = l + t; \n        } \n    } \n    while (t > 1); \n \n    // Pack span  \n    int2 span; \n    span.x = min(idx, idx + l*d); \n    span.y = max(idx, idx + l*d); \n    return span; \n} \n \n// Find split idx within the span \nint FindSplit(__global int* mortoncodes, int numprims, int2 span) \n{ \n    // Fetch codes for both ends \n    int left = span.x; \n    int right = span.y; \n \n    // Calculate the number of identical bits from higher end \n    int numidentical = DELTA(left, right); \n \n    do \n    { \n        // Proposed split \n        int newsplit = (right + left) / 2; \n \n        // If it has more equal leading bits than left and right accept it \n        if (DELTA(left, newsplit) > numidentical) \n        { \n            left = newsplit; \n        } \n        else \n        { \n            right = newsplit; \n        } \n    } \n    while (right > left + 1); \n \n    return left; \n} \n \n// Set parent-child relationship \n__kernel void BuildHierarchy( \n    // Sorted Morton codes of the primitives \n    __global int* mortoncodes, \n    // Bounds \n    __global bbox* bounds, \n    // Primitive indices \n    __global int* indices, \n    // Number of primitives \n    int numprims, \n    // Nodes \n    __global HlbvhNode* nodes, \n    // Leaf bounds \n    __global bbox* boundssorted \n    ) \n{ \n    int globalid = get_global_id(0); \n \n    // Set child \n    if (globalid < numprims) \n    { \n        nodes[LEAFIDX(globalid)].left = nodes[LEAFIDX(globalid)].right = indices[globalid]; \n        boundssorted[LEAFIDX(globalid)] = bounds[indices[globalid]]; \n    } \n     \n    // Set internal nodes \n    if (globalid < numprims - 1) \n    { \n        // Find span occupied by the current node \n        int2 range = FindSpan(mortoncodes, numprims, globalid); \n \n        // Find split position inside the range \n        int  split = FindSplit(mortoncodes, numprims, range); \n \n        // Create child nodes if needed \n        int c1idx = (split == range.x) ? LEAFIDX(split) : NODEIDX(split); \n        int c2idx = (split + 1 == range.y) ? LEAFIDX(split + 1) : NODEIDX(split + 1); \n \n        nodes[NODEIDX(globalid)].left = c1idx; \n        nodes[NODEIDX(globalid)].right = c2idx; \n        //nodes[NODEIDX(globalid)].next = (range.y + 1 < numprims) ? range.y + 1 : -1; \n        nodes[c1idx].parent = NODEIDX(globalid); \n        //nodes[c1idx].next = c2idx; \n        nodes[c2idx].parent = NODEIDX(globalid); \n        //nodes[c2idx].next = nodes[NODEIDX(globalid)].next; \n    } \n} \n \n// Propagate bounds up to the root \n__kernel void RefitBounds(__global bbox* bounds, \n                          int numprims, \n                          __global HlbvhNode* nodes, \n                          __global int* flags \n                          ) \n{ \n    int globalid = get_global_id(0); \n \n    // Start from leaf nodes \n    if (globalid < numprims) \n    { \n        // Get my leaf index \n        int idx = LEAFIDX(globalid); \n \n        do \n        { \n            // Move to parent node \n            idx = nodes[idx].parent; \n \n            // Check node's flag \n            if (atomic_cmpxchg(flags + idx, 0, 1) == 1) \n            { \n                // If the flag was 1 the second child is ready and  \n                // this thread calculates bbox for the node \n \n                // Fetch kids \n                int
j/ʼn4
j1;m\a
j3K:\e
j7w:Y
j7֏L8
j8L;x
j8b3M
j8ba|\b
j9!I4
j9:jId
j9\b|89
j9n.칣J
j9~ry
j: \n\t
j:( K
j:K+9
j:P7\a
j:nsr
j:p\rE:\a0Y:6
j;-v6
j;2<a
j;>N3=B
j;J5\t
j;V^b
j;YSc
j;d<H
j;nYB<D
j<W;a
j<\nQ
j<gOǼh\n
j<hln
j<s@X
j=GǬ9W
j?Q>c
j?\fKk?X
j@p;2
j@w;U
jAE;\n
jB:kZx
jB<\eR
jB\t=!U
jCZ<U\f
jCӻ\f\en
jD5;Hp
jD<3eW
jE3<4
jF;@N
jFb=\fl
jH:<QT
jH<r6v;K
jJ0>o4㽞X
jK<8kc
jL-; H
jO;GA
jPj;Ȥ4
jQ7:5(u
jQ:X&9;\bP
jQ;%8
jS.9eI(:8I
jTK;5ۡ<S
jU)9`9
jU;kD
jW2;5]Q
jX\a<p
jXa ŲXA
jY>=|ZY
jY\e;~7
jYd\aTĢQ
j[;kM
j\a\f
j\aba|H
j\aba|\b
j\aba~\b
j\ah<5p
j\ah<m3
j\b A
j\b\a:Z 6
j\bbA
j\bbA|\b
j\e=lV
j\e\n<h
j\f\n<lN
j\fbA
j\nͼs[c
j\t<B\fy
j\vba|\b
j\vͼgA
j`4<EV
jc<\r
jd\e<օx
jdɼ!j
jf93A5
jg<=w
jgE;TY
jgr:g
jh\v<5
jj@0HK4
jm%<nv
joC:H7
joL<ha
jrG;&sV
jt":2
jtm}S
jtۺ\e7\t
juD;BK5
jv: t
jxD<,霼U`E
jy:VK
jy=Hܖ=P
j{E>hI
j˂8>GO:}X
jϼ2Qy<C
jѷ<b3s
jֻOM3
jٚ;n3
jݼfB绪j
jސ;Du
jꅽE-I
jﺜܙ80
k VWAVH
k [:Y
k w:f
k!U<k
k"5:*ub
k"<\f4F
k$l9\\8
k+g:Y6
k,=LAZ
k-z>P\a
k.2:x_O
k.;9p
k0;b8\e
k1;qP6
k1ӽVk
k2=)i
k46:!S
k4ݺiTx
k53<HC
k6A;\\x
k7˼\bQɼK
k80qA
k89;~W
k8=ԈĽ5l
k92JX
k:;3P0
k:=4w
k:Dq\t
k:N=h:3
k:мCz
k;FLO;C
k;K#H
k;Lnm;\\a
k;\n\aۻ8Y
k;\tu7
k;bLŻa
k;tޏ:I0
k;}lU
k;~XO
k<*b2
k<9cXN
k<Z9k
k<\b8\e=C
k=t\b
k>p"Q
k>pzf>M
k@b1|H
kB<qeλ\tt
kE{;Kx
kH\v;A39;BUn:8
kJ\f>V
kL:mw\b9y
kL<9mK
kL\f?g
kP<HI <4jv
kPfff
kPffff
kPfffff
kPffffff
kPfffffff
kPջ8u\t
kQQ:I
kQi<\b
kQƼU}S
kQɻ C
kR9;N
kRi;\n
kS;l\a
kT!;>DZ
kT>Lu
kV[8Y
kW\n<|H廀A
kZ;Z}H
kZ<2"N
kZa<jq
k[F<yT
k\a<xl\a3hm\a*t
k\e;wT
k\fb!|HX
k\n;w
k]\t;9N
kaw;Ff
kb:cD
kc3:\e
ke@<uM
kernel32
kernel32.dll
kf<8B
kfH;B]z
kf\e<g
kg;_A
kg=<Zɼy|J
kh;yua;d
kj;\a );K
kl\t<TpC
km\f<O
kok-IN
kok-in
kp漽\f
kq;j\n
krU9\vUy
kt;:\rs
ku;é3:Q
ky\r9E
kyq;]8
k|^Xm
k}<aq
k~*6Q
k~y:K
kļu\r7
kľ<Eg\e
kȻjꦻqkܻFY
kɻ-eQ
kҼf[R
kջWH2<[Q0
kܥ:zfa
l!s;9p
l$ ATAVAWH
l$ UAVAWH
l$ VAVAWH
l$ VWATAVAWH
l$ VWATH
l$ VWAUH
l$ VWAVH
l$ VWAWH
l$ WATAWH
l$ WAVAWH
l$ ba|\b
l$ ba~\b
l$(H9i\bueH
l$(ba
l$0Hc
l$0L9n
l$0Lcy\f
l$0fC
l$8D;l$4s\nH
l$8H9~(v"H
l$@D8W\buIH
l$@LcSl
l$@Lcd$|H
l$@fD
l$@fff
l$HA_A^A]A
l$HL9a
l$HL9i
l$HL9k
l$N=1
l$PD;f
l$PHc
l$PHc\\$LH
l$PM#e\bt
l$Pff
l$Pu\afE
l$Pu\vE
l$XE3\tT$`A
l$`Hc
l$`Ii
l$`Lce
l$`ba|H
l$hH;l
l$pHc
l$pHc\\$LH
l$pHc|$lH
l$pfA
l$pfE
l%ݼN8m
l&:GF
l-;eM
l/:09
l0+:z
l0=h{D
l0\aba|H
l15;RJ
l1ú\ad
l2|X/gGe
l598_r
l6w<H
l7<dV
l8%9\tc
l9<RW
l9\t;!\nW
l9u;.L
l:Xj纨E
l:\b\n\t;gr󹙌A;bYi;DQ
l:g\r\t
l:j\aB;r
l:nZ>:JzH
l:~ou
l; le
l;B8a
l;\tyٺtM\f;F
l<w5Ž\nL\b
l<ǜu=57
l>a|m
l@3=jX
lBL:pj
lB黻n9
lD;LH\e
lD<dq4<K
lE8o]Q
lGo<`m
lH;QS{9
lHYu\rb
lHY|\a\bb
lHY}\abB
lK=$39
lNs:E7
lO5;"S
lP9[В9
lR);ce
lT0fB
lT52ZE
lU ńX
lV;#f
lW2:8
lW?XҶ<M
lWۻ4\fM9
lX\f"H
lY2;\f
lYL @H
lYL0@H
lYL8@H
lZ1<x
lZ=Ru\r
lZ=vI
l\\F żY
l\\G ŌY
l\\G ŬY
l\a<a8):A
l\aPġBYT\a\\L
l\e;Ko\e:b
l\f5;d'P
l\f<< T
l\f<j
l\fI9
l\fx8Ŕe
l\n\v<2
l\t\abA|H
l\vP:7
l\vS9S7
l\v\abA|H
l]U:j
l_Y<K
l_뻗jK
l`I<\eL
lbS;9bU
lc = nodes[idx].left; \n                int rc = nodes[idx].right; \n \n                // Calculate bounds \n                bbox b = bboxunion(bounds[lc], bounds[rc]); \n \n                // Write bounds \n                bounds[idx] = b; \n            } \n            else \n            { \n                // If the flag was 0 set it to 1 and bail out. \n                // The thread handling the second child will \n                // handle this node. \n                break; \n            } \n        } \n        while (idx != 0); \n    } \n} \n
leaves
lf8<E>6
lfW;I
lg;;T
lg\v<DZO
li$<}C0=t
li;4ZD
li=YU˼jn
liF;5F
line segments
line4i
line_accel
line_accel_mb
line_builder
line_builder_mb
line_traverser
line_traverser_mb
list too long
list<T> too long
listTanDevicesAndCaps
listener.x
listener.y
listener.z
listenerAhead.x
listenerAhead.y
listenerAhead.z
listenerPosition.x
listenerPosition.y
listenerPosition.z
listenerUp.x
listenerUp.y
listenerUp.z
ljH;p
lk9(mP
lk;6᤹a\n
llHl$ll
llɻhOx
lm?;DjW
ln;7M\r
loadProbeBatch
loadScene
loadStaticMesh
loat2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n
local static guard
local static thread guard
local vftable
local vftable constructor closure
localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \nvoid group_segmented_scan_exclusive_int_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1
localTimeSegments > 0
log10f
lp:9#\f
lpֹ1yK
lv;u\rR
lvӼUf
lxໝi];w
ly\r;^pB
l~;n25
lúL #8
lŽVĖ<mE
lϻg{G
lعIEz
lܼ)8u
lޡ=eo\t
l嫼G+6
l蠼3\v_< ot
m / %d / %y
m LcT$8I
m b!|\bX
m b1t\b
m ŐXm
m!=\n3A
m"2;lxO
m"K;u
m'=YYY
m(8?TT
m(;tU
m);6\nr
m*k<o
m/:RG
m0ŨXl
m1q;\a
m2<\a'p
m3$;a
m3:@3\n
m5=R.O
m69jlQ9B
m6;]g
m6=FwK
m7;ka
m8(^S80
m8L9c\bt
m8RDu;~d
m8aK:a
m8ԻWw
m9 k;5
m9b25
m9f/\t
m:Dբ9fI
m:cG?;X#W
m:o黹R\n
m;4Ij;qi\a
m;;X4
m;;zmx
m;F|39
m;o1J
m;y\t\a
m<8楼ky
m<>s2
m<[jg
m<\fi
m='\bڽlM8
m=\a9
m>)VF
m?x:o
mAF=:D
mB;G\tH
mD><D
mEA;\a1
mF#ʈb3UF
mH@%RS
mI;g\\U
mJ#;5
mK=lr
mLK:a6t
mLY<F
mOD;7
mPD=I
mPo9"g
mQ<FYr
mQ<^D
mSV;Ux
mU=#si
mWA9o
mWC:1
mX=9\t)C
mXbaT
mY90W
mY9p>o
m[;1NJ
m\abA|H
m\b;w\f
m\bba}HpձbA,@YU\tb
m\e<r
m\fbA$ X
m\fbQ|H
m\fbr}H
m\nE<v
m\nb1}HpֱbQ,HYU\vb
m\rbA|H
m\tQ9
m\t\v
m\tbQ|H
m\vbA|H
m\vbB
m\vbQ|H
m_4:\bN
m_active
m_isec & bits
m_trav_active
m`Hc}(H
ma;Ⱦ1
malloc
managed vector constructor iterator
managed vector copy constructor iterator
managed vector destructor iterator
map/set too long
map/set<T> too long
mask != 0
mask < 16
mask >= 0 && mask < 16
maxGrowSize
max_builder_isa
max_hrtf_normalization_volume_gain_db
max_isa
max_leaf_size
max_spatial_split_replications
maximally 256 floating point values can be interpolated per vertex
mb<\e
mc;|c
mc^:H
md:jgt
me;9*7
memory monitor forced termination
message size
mg<;z\b
mge:p
mi<78f
min_leaf_size
minimally possible
minkernel\\crts\\ucrt\\inc\\corecrt_internal_strtox.h
mix->data
mix->data[iChannel][mix->numSamples - 1
mix->numChannels
mix->numSamples
mixAudioBuffer
mj9Z[9G
mkX>\r+G
mkʻnI\v
ml">Z
mn;$R
mn];A
model->callback
model->coefficients
model->coefficients[iArray
model->dipolePower
model->dipoleWeight
model->dirty
model->minDistance
model->type
morton
morton[j] <= morton[j+1
motion blur hair
motion blur line segments
motion blur quads
motion blur triangles
mpHc},H
mp~9GGW
mq:1kA
mq\e:3N
mr;4i
mr=/\b5
mr>\rw
ms:W6x
msM;W
mscoree.dll
mt^<E
mtllib %s.mtl\n
mv':\eh
mwH9?l\f:@Z`8eTE
mx::dh89mG
myzAn4
m~ҺBT
mÜ8\a
mȣ:ScսEd
mɺDDo;8
m˕9ntH
m˻7\eG;BF
m˻Eg7
mλ8FF
mѸC\e
n            else \n            { \n                lbox = scenedata->bounds[node.left]; \n                rbox = scenedata->bounds[node.right]; \n \n                lefthit = IntersectBoxF(r, invdir, lbox, r->o.w); \n                righthit = IntersectBoxF(r, invdir, rbox, r->o.w); \n \n                if (lefthit > 0.f && righthit > 0.f) \n                { \n                    int deferred = -1; \n                    if (lefthit > righthit) \n                    { \n                        idx = node.right; \n                        deferred = node.left; \n                    } \n                    else \n                    { \n                        idx = node.left; \n                        deferred = node.right; \n                    } \n \n                    if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                    { \n                        for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                        { \n                            gsptr[i] = ldsstack[i * 64]; \n                        } \n \n                        gsptr += SHORT_STACK_SIZE; \n                        lsptr = ldsstack + 64; \n                    } \n \n                    *lsptr = deferred; \n                    lsptr += 64; \n \n                    continue; \n                } \n                else if (lefthit > 0) \n                { \n                    idx = node.left; \n                    continue; \n                } \n                else if (righthit > 0) \n                { \n                    idx = node.right; \n                    continue; \n                } \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return false; \n} \n \n \n#endif \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes, // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef LDS_BUG \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n    // Input \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* ra
n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return false; \n} \n#else \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    if (r->o.w < 0.f) \n        return false; \n     \n    int stack[32]; \n \n    int* sptr = stack; \n    *sptr++ = -1; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    bool found = false; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        leftleaf = LEAFNODE(node.lbound); \n        rightleaf = LEAFNODE(node.rbound); \n \n        lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, r->o.w); \n        righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, r->o.w); \n \n        if (leftleaf) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node.lbound), r)) \n            { \n                found = true; \n                break; \n            } \n        } \n         \n        if (rightleaf) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node.rbound), r)) \n                    { \n                        found = true; \n                        break; \n                    } \n        } \n \n        if (lefthit > 0.f && righthit > 0.f) \n        { \n            int deferred = -1; \n            if (lefthit > righthit) \n            { \n                idx = (int)node.rbound.pmax.w; \n                deferred = (int)node.lbound.pmax.w;; \n            } \n            else \n            { \n                idx = (int)node.lbound.pmax.w; \n                deferred = (int)node.rbound.pmax.w; \n            } \n \n                    *sptr++ = deferred; \n        } \n        else if (lefthit > 0) \n        { \n            idx = (int)node.lbound.pmax.w; \n        } \n        else if (righthit > 0) \n        { \n            idx = (int)node.rbound.pmax.w; \n        } \n \n        if (lefthit <= 0.f && righthit <= 0.f) \n            idx = *--sptr; \n    } \n \n    return found; \n} \n \n#endif \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes, // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n         \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef GLOBAL_STACK  \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData con
n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults,  // Hit results \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    while (ridx < numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[ridx] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRCAMD( \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits, // Hit datas \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    Intersection isect; \n \n    while (ridx < *numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= *numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            IntersectSceneClosest(&scenedata, &r, &isect); \n            // Write data back in case of a hit \n            hits[ridx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRCAMD( \n    // Input \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults,   // Hit results \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    while (ridx < *numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= *numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n
n ;b\e
n <gE
n == 0
n M;B"y
n T:C
n!r<J{R
n"I\vc
n"a;x
n$n.n>n]nennn~n
n$v;b
n&ɻwh\b
n'>RR
n)g;v
n+C;\fK
n,:Ff
n-:LT̹K
n.<Uv
n/ ;l
n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable\n#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n\n// --------------------------------------------------------------------------------------------------------------------\n// Constants\n// --------------------------------------------------------------------------------------------------------------------\n\n#define PI                          3.14159f\n#define SOURCE_RADIUS               0.1f\n#define LISTENER_RADIUS             0.1f\n#define SPEED_OF_SOUND              340.0f\n#define RAY_SURFACE_OFFSET          1e-2f\n#define SPECULAR_EXPONENT           1e+2f\n#define NUM_BANDS                   3\n#define NUM_BINS                    256\n#define BIN_DURATION                0.01f\n#define NUM_LOCAL_HISTOGRAMS        2                     // Number of copies for scrambling (tunable)\n\n// --------------------------------------------------------------------------------------------------------------------\n// CoordinateSpace\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) CoordinateSpace_t\n{\n    float3 right;\n    float3 up;\n    float3 ahead;\n    float3 origin;\n} CoordinateSpace;\n\nCoordinateSpace createCoordinateSpace(float3 normal)\n{\n    CoordinateSpace space;\n    space.ahead = normal;\n\n    if (fabs(normal.x) > fabs(normal.z))\n    {\n        float3 right = (float3) (-normal.y, normal.x, 0.0f);\n        space.right = normalize(right);\n    }\n    else\n    {\n        float3 right = (float3) (0.0f, -normal.z, normal.y);\n        space.right = normalize(right);\n    }\n\n    space.up = cross(space.right, space.ahead);\n\n    return space;\n}\n\nfloat3 transformLocalToWorld(CoordinateSpace space,\n                             float3 direction)\n{\n    return direction.x * space.right + direction.y * space.up - direction.z * space.ahead;\n}\n\nfloat3 transformWorldToLocal(CoordinateSpace space,\n                             float3 direction)\n{\n    float3 transformedDirection;\n    transformedDirection.x = dot(direction, space.right);\n    transformedDirection.y = dot(direction, space.up);\n    transformedDirection.z = -dot(direction, space.ahead);\n    return transformedDirection;\n}\n\nfloat3 transformHemisphereSample(float3 direction,\n                                 float3 normal)\n{\n    CoordinateSpace tangentSpace = createCoordinateSpace(normal);\n    return normalize(transformLocalToWorld(tangentSpace, direction));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Random Sampling\n// --------------------------------------------------------------------------------------------------------------------\n\n// The following code is from the Radeon Rays / Baikal GitHub repository. It can be found at:\n//      https://github.com/GPUOpen-LibrariesAndSDKs/RadeonProRender-Baikal/blob/master/Baikal/Kernels/CL/sampling.cl\n\ntypedef struct RNG_t\n{\n    uint    value;\n} RNG;\n\nuint wangHash(uint seed)\n{\n    seed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nuint randUint(local RNG* rng)\n{\n    rng->value = wangHash(1664525U * rng->value + 1013904223U);\n    return rng->value;\n}\n\nfloat randFloat(local RNG* rng)\n{\n
n/97vO
n/C;7
n0,;P0
n03>Pu
n0<)w
n0A:c
n0ƻAsm
n1#<OP8
n1=L88
n1i>u
n2:Nu
n4,;E
n5:\n
n5\n 0
n6:!H
n7!;i
n76OL;\nq
n7;XPF
n7T7H
n8=]H
n9%HL
n99%ŻSbǻK
n9FѬ:r
n9\f˜9
n9ofi96
n:/9h
n:/QY
n:3;T
n:3sA
n:VT%;Z
n:\b$o8c
n:\b=5a
n:\bRs
n:\eoe9
n:l)s
n:m~a
n;5Yٺ3w
n;@ d:I
n;A^L
n;C4d<n
n;Ja[;Y
n;Q+f
n;V\fw;\f
n;\r5
n;\v0t;W
n;ai;X
n;b92
n;i|y
n;ku\b;0\nz
n;lvT8\fgM
n;r\b9
n;r\eW9
n;y[f
n<*ki
n</N9
n<4\ro
n<F\rh
n<O}w<p
n<\e4
n<\vzV
n<f8\r
n<s]7
n<uyN
n<vǨ8
n<z4ٻi
n=25b=v
n=4~y
n=9rD
n=TEԼYt
n=e}Q>p
n=fZȼ4u
n=jn\f
n=xnd
n>&CS
n>&S4
n>6<8
n><oF>d
n>Hsk=Q
n>J9H
n>L<Zse
n>Y\n\n>0
n>\e4E
n>log2
n>w%n
n>ֻ6zW
n?0ho?s
n?6\e
n?:Da\t
n?P;H
n?arh
nA>;b4L
nA>Spz
nB/:m
nBϺُt
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n /************************************************************************* \n  INCLUDES \n  **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable \n#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable \n \n \n// --------------------- HELPERS ------------------------ \n//#define INT_MAX 0x7FFFFFFF \n \n// -------------------- MACRO -------------------------- \n// Apple OCL compiler has this by default,  \n// so embrace with #ifdef in the future \n#define DEFINE_MAKE_4(type)\\ \n    type##4 make_##type##4(type x, type y, type z, type w)\\ \n{\\ \n    type##4 res;\\ \n    res.x = x;\\ \n    res.y = y;\\ \n    res.z = z;\\ \n    res.w = w;\\ \n    return res;\\ \n} \n \n// Multitype macros to handle parallel primitives \n#define DEFINE_SAFE_LOAD_4(type)\\ \n    type##4 safe_load_##type##4(__global type##4* source, uint idx, uint sizeInTypeUnits)\\ \n{\\ \n    type##4 res = make_##type##4(0, 0, 0, 0);\\ \n    if (((idx + 1) << 2)  <= sizeInTypeUnits)\\ \n    res = source[idx];\\ \n    else\\ \n    {\\ \n    if ((idx << 2) < sizeInTypeUnits) res.x = source[idx].x;\\ \n    if ((idx << 2) + 1 < sizeInTypeUnits) res.y = source[idx].y;\\ \n    if ((idx << 2) + 2 < sizeInTypeUnits) res.z = source[idx].z;\\ \n    }\\ \n    return res;\\ \n} \n \n#define DEFINE_SAFE_STORE_4(type)\\ \n    void safe_store_##type##4(type##4 val, __global type##4* dest, uint idx, uint sizeInTypeUnits)\\ \n{\\ \n    if ((idx + 1) * 4  <= sizeInTypeUnits)\\ \n    dest[idx] = val;\\ \n    else\\ \n    {\\ \n    if (idx*4 < sizeInTypeUnits) dest[idx].x = val.x;\\ \n    if (idx*4 + 1 < sizeInTypeUnits) dest[idx].y = val.y;\\ \n    if (idx*4 + 2 < sizeInTypeUnits) dest[idx].z = val.z;\\ \n    }\\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE(type)\\ \n    void group_scan_exclusive_##type(int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n    if (localId == 0)\\ \n    shmem[groupSize - 1] = 0;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        type temp = shmem[(2*localId + 1)*stride-1];\\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_SUM(type)\\ \n    void group_scan_exclusive_sum_##type(int localId, int groupSize, __local type* shmem, type* sum)\\ \n{\\ \n    for (int stride = 1; stride
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \n INCLUDES \n **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_f
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_floa
nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \ntypedef struct \n{ \n    float3 pmin; \n    float3 pmax; \n} bbox; \n \n// The following two functions are from \n// http://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/ \n// Expands a 10-bit integer into 30 bits \n// by inserting 2 zeros after each bit. \nstatic unsigned int ExpandBits(unsigned int v) \n{ \n    v = (v * 0x00010001u) & 0xFF0000FFu; \n    v = (v * 0x00000101u) & 0x0F00F00Fu; \n    v = (v * 0x00000011u) & 0xC30C30C3u; \n    v = (v * 0x00000005u) & 0x49249249u; \n    return v; \n} \n \n// Calculates a 30-bit Morton code for the \n// given 3D point located within the unit cube [0,1]. \nunsigned int CalculateMortonCode(float3 p) \n{ \n    float x = min(max(p.x * 1024.0f, 0.0f), 1023.0f); \n    float y = min(max(p.y * 1024.0f, 0.0f), 1023.0f); \n    float z = min(max(p.z * 1024.0f, 0.0f), 1023.0f); \n    unsigned int xx = ExpandBits((unsigned int)x); \n    unsigned int yy = ExpandBits((unsigned int)y); \n    unsigned int zz = ExpandBits((unsigned int)z); \n    return xx * 4 + yy * 2 + zz; \n} \n \n// Assign Morton codes to each of positions \n__kernel void CalcMortonCode( \n    // Centers of primitive bounding boxes \n    __global bbox const* bounds, \n    // Number of primitives \n    int numpositions, \n    // Morton codes \n    __global int* mortoncodes \n    ) \n{ \n    int globalid = get_global_id(0); \n \n    if (globalid < numpositions) \n    { \n        bbox bound = bounds[globalid]; \n        float3 center = 0.5f * (bound.pmax + bound.pmin); \n        mortoncodes[globalid] = CalculateMortonCode(center); \n    } \n} \n \n \nbbox bboxunion(bbox b1, bbox b2) \n{ \n    bbox res; \n    res.pmin = min(b1.pmin, b2.pmin); \n    res.pmax = max(b1.pmax, b2.pmax); \n    return res; \n} \n \ntypedef struct \n{ \n        int parent; \n        int left; \n        int right; \n        int next; \n} HlbvhNode; \n \n#define LEAFIDX(i) ((numprims-1) + i) \n#define NODEIDX(i) (i) \n \n// Calculates longest common prefix length of bit representations \n// if  representations are equal we consider sucessive indices \nint delta(__global int* mortoncodes, int numprims, int i1, int i2) \n{ \n    // Select left end \n    int left = min(i1, i2); \n    // Select right end \n    int right = max(i1, i2); \n    // This is to ensure the node breaks if the index is out of bounds \n    if (left < 0 || right >= numprims)  \n    { \n        return -1; \n    } \n    // Fetch Morton codes for both ends \n    int leftcode = mortoncodes[left]; \n    int rightcode = mortoncodes[right]; \n \n    // Special handling of duplicated codes: use their indices as a fallback \n    return leftcode != rightcode ? clz(leftcode ^ rightcode) : (32 + clz(left ^ right)); \n} \n \n// Shortcut for delta evaluation \n#define DELTA(i,j) delta(mortoncodes,numprims,i
nD"PHc
nD8)\bP
nD9Q$t
nEl:c3
nEȾ1l8
nGM;$i
nG۽-F0
nH9G\btsH
nH;A\bu
nH;Q\bu
nH;Q\bu\rL
nHL+n@H
nHȻ=59
nI7;7W
nIr;15\e<[g
nJ:A+5
nJ|;6v5
nK7:v8
nL!PLc
nL\fPLc
nMcL$lM
nNANאB
nNq:RuY
nO;HbK
nO<u\a\e
nO}R7V
nOƼ!b\r
nP-<9
nP_=bw
nQ :oV
nR#;4
nR;SdH
nS:](1;m2
nS;GP
nSa=d
nS|;1
nT9Aq̼H
nThreads
nUp<J
nV5> 8
nV;\e\e
nVl<TJG
nVǺciºD
nW:n$Z;K5J
nW\a;O
nWashington1
nX;O냻R
nXY8Ŋ\\a8łXY
nY<*y1
nYD\alġ*Y
nZ<vSk
nZ`<3g
n[:O9d
n\\8z
n\\q łX
n\a9SB;:9
n\a\a;A\e
n\abA|H
n\ay<{c
n\b:A枻y
n\b=jv8
n\bI+.H
n\bJ<I
n\bf\fn\n
n\e>BJb
n\e\n=U|O
n\es=]T
n\fּI
n\n<L6
n\n\f
n\nbq|H
n\nҼR
n\rba|H
n\t$;AW
n\t;ud
n\tbQ|H
n\v>c
n\vR<q
n\vb<c\e
n]8-Qz
n]\r\bd\f
n]s9P
n]ͺX0
n^r;R4
n`q<D9Q
na\e>i
nan(ind
nan(snan
naۼyt
nb!\fHY
nb!|H
nb\a<\n
nbaL X
nba~\b
nbb}XB
nbu;T
nc:\ba
nc<\e"7
ncd>0
ncڼY\a
nd'<T\f
nd1;,A
nd8<D1
ndC;D
ndN9^5
nda:h\b
ne::v
ne;=wgU
need dictionary
network down
network reset
network unreachable
new-zealand
newNumThreads
newmtl material_%d\n
nextafter
nfA>MI\f
nfD9\nt\tH
nfe;h
nfffff
ng:2p5
ngN;1
ngf>ZL
ngo<E
nh0;7F
nh;R\b
nh;xl
nh<Spz
nhԼwc
ni#<v\a
ni&<5
ni/=4M
niø>2i
niۺ\e
nj;\rIe9
nk;\b$d
nkB;z
nm9C1
nmȻ/n
nn=<AI
nnu;Sl
no buffer space
no child process
no link
no lock available
no message
no message available
no protocol option
no space on device
no stream resources
no such device
no such device or address
no such file or directory
no such process
no9yaa
no:%\nO<dA
no;\t
no;o3\e
noJ;1
node.isAlignedNode
nodes
norwegian
norwegian-bokmal
norwegian-nynorsk
not a directory
not a socket
not a stream
not all buffers are unmapped
not connected
not enough memory
not supported
not supported node type in bvh_statistics
not:݊n
npA<0
npJ:4
np\t0\bP
np\t`\b0\b
np\t`\bP
np\t`\bP\a0\b
np\t`\bP\b
npɺL+\e
nq:\bx0
nqS<r
nr7;T
nr;r$\a
nr<UV
nre;X,K
ns<\r
nt91b\f:뜈94
nt=Ac
nu>mo
num <= maxLeafBlocks
num >= 1
numChannels
numMisplacedItemsLeft == numMisplacedItemsRight
numOctantRays
numOctantRays <= 32
numOctantRays <= MAX_INTERNAL_STREAM_SIZE
numSamples
numTimeSteps > 1
nv?:Fx
nvdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    float3 invdirtop = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    // We need to keep original ray around for returns from bottom hierarchy \n    ray topray = *r; \n \n    // Fetch top level BVH index \n    int idx = scenedata->rootidx; \n    // -1 indicates we are traversing top level \n    int topidx = -1; \n    // Current shape id \n    int shapeid = -1; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, isect->uvwt.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                // or containing another BVH (top level hierarhcy) \n                if (topidx != -1) \n                { \n                    // This is bottom level, so intersect with a primitives \n                    if (IntersectLeafClosest(scenedata, &node, r, isect)) \n                    { \n                        // Adjust shapeid as it might be instance \n                        isect->shapeid = shapeid; \n                    } \n \n                    // And goto next node \n                    idx = (int)(node.pmax.w); \n                } \n                else \n                { \n                    // This is top level hierarchy leaf \n                    // Save top node index for return \n                    topidx = idx; \n                    // Get shape descrition struct index \n                    int shapeidx = SHAPEIDX(node); \n                    // Get shape mask \n                    int shapemask = scenedata->shapedata[shapeidx].mask; \n                    // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                    // otherwise skip the subtree \n                    if (Ray_GetMask(r) && shapemask) \n                    { \n                        // Fetch bottom level BVH index \n                        idx = scenedata->shapedata[shapeidx].bvhidx; \n                        shapeid = scenedata->shapedata[shapeidx].id; \n \n                        // Fetch BVH transform \n                        float4 wmi0 = scenedata->shapedata[shapeidx].m0; \n                        float4 wmi1 = scenedata->shapedata[shapeidx].m1; \n                        float4 wmi2 = scenedata->shapedata[shapeidx].m2; \n                        float4 wmi3 = scenedata->shapedata[shapeidx].m3; \n \n                        // Apply linear motion blur (world coordinates) \n                        //float4 lmv = scenedata->shapedata[shapeidx].linearvelocity; \n                        //float4 amv = scenedata->shapedata[SHAPEDATAIDX(node)].angularvelocity; \n                        //r->o.xyz -= (lmv.xyz*r->d.w); \n                        // Transfrom the ray \n                        *r = transform_ray(*r, wmi0, wmi1, wmi2, wmi3); \n                        // rotate_ray(r, amv); \n                        // Recalc invdir \n                        invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n                        // And continue traversal of the bottom level BVH \n                        continue; \n                    } \n                    else \n                    { \n                        idx = -1; \n                    } \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                // This is an internal node, proceed to left child (it is at current + 1 index) \n                idx = idx + 1; \n            } \n        } \n        else \n        { \n            // We missed the node, goto next one \n            idx = (int)(node.pmax.w); \n        } \n \n        // Here check if we ended up traversing bottom level BVH \n        // in this case idx = -1 and topidx has valid value \n        if (idx == -1 && topidx != -1) \n        { \n            //  Proceed to next top level node \n            idx = (int)(scenedata->nodes[topi
nv}:gn
nv¼\f6
nx:V"3
nxm;n
nzW;soi
nzԉY9
n{;DX
n½<FM
nĻljs9
nƉ;8XB
nɍ\f8fD
nʈL$Wba
n˺Zu3
n̼myƼN
nϬ;DD
nӽoZ\r
nֺ]Gc;oq
nۺc{k
nܺ#9Z8\rx
nߋ:qZk
nDkt
o ;^Y
o one of the local-memory histograms for the work-group. These adds need to be atomic, since multiple rays\n\t// being processed in the same work-group may write to the same bin of the same histogram. The contention\n\t// due to atomic_adds can be reduced by increasing NUM_LOCAL_HISTOGRAMS, at the cost of increased local memory\n\t// usage.\n    if (!isOccluded)\n    {\n\t\t// Adjacent work-items in a work-group do not use the same local-memory histogram. A work-item with local\n\t\t// index i writes to local-memory histogram (i % NUM_LOCAL_HISTOGRAMS).\n\t\t// When calculating the bin index, bin index i is mapped to index  NUM_LOCAL_HISTOGRAMS * i in the\n\t\t// local-memory buffer. This is because the histograms are interleaved.\n        local int* shiftedLocalEnergy = localEnergy + localIndex % NUM_LOCAL_HISTOGRAMS;\n\n        global float* rayEnergy = (global float*) (&totalEnergy[offset + rayIndex]);\n\n        float time = totalEnergy[offset + rayIndex].w;\n        uint bin = convert_uint_sat(floor(time / BIN_DURATION)) * NUM_LOCAL_HISTOGRAMS;\n\n        if (bin < NUM_BINS)\n        {\n            float energyValue = scale * rayEnergy[band] * shCoefficients[channel * numRays + rayIndex];\n            int quantizedEnergyValue = convert_int_sat(floor(energyValue));\n            atomic_add(shiftedLocalEnergy + bin, quantizedEnergyValue);\n        }\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 2\n\t// Each work-item processes one bin. The corresponding bins for all local-memory histograms are added, and the\n\t// result is stored in a private variable. No atomic operations or barriers are required here, since each work-item\n\t// operates on independent data.\n    int accumulatedEnergy = 0;\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++)\n    {\n        accumulatedEnergy += workItemEnergy[i];\n    }\n\n\t// Stage 3\n\t// Each work-item processes one bin. The summed values from the local-memory histograms are added to the corresponding\n\t// bin in a global-memory histogram. Here, atomic_adds must be used, because multiple work-groups may be trying to\n\t// write to the same global-memory bin at the same time.\n    atomic_add(energy + channel * NUM_BANDS * NUM_BINS + band * NUM_BINS + localIndex, accumulatedEnergy);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Reconstruction Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\n#define ENERGY_THRESHOLD            1e-7f\n#define MIN_VARIANCE                1e-5f\n#define NUM_WORK_ITEM_SAMPLES       32\n#define WORK_GROUP_SIZE\t\t\t\t64\n\nkernel void applyIIRFilter(global IIR* filters,\n                           global float* impulseResponse,\n\t\t\t\t\t\t   uint numBins,\n\t\t\t\t\t\t   uint samplesPerBin,\n\t\t\t\t\t\t   uint numSamples)\n{\n    size_t band = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t numBands = get_global_size(0);\n    size_t numChannels = get_global_size(1);\n    size_t batch = get_global_id(2);\n\n\tlocal float localSamples[(NUM_WORK_ITEM_SAMPLES * WORK_GROUP_SIZE) + NUM_WORK_ITEM_SAMPLES];\n\n\tconst int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\tlocal float* workItemSamples = &localSamples[localIndex * NUM_WORK_ITEM_SAMPLES];\n\n    global float* signal = &impulseResponse[(batch * numChannels * numBands * numSamples) + (channel * numBands * numSamples) + (band * numSamples)];\n\n\tfloat xm1 = 0.0f;\n\tfloat xm2 = 0.0f;\n\tfloat ym1 = 0.0f;\n\tfloat ym2 = 0.0f;\n\n    global IIR* filter = &filters[band];\n\n    float a1 = filter->a1;\n    float a2 = filter->a2;\n    float b0 = filter->b0;\n    float b1 = filter->b1;\n    float b2 = filter->b2;\n\n\tfor (uint i = 0; i < (numBins * samplesPerBin); i += NUM_WORK_ITEM_SAMPLES)\n    {\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tworkItemSamples[j] = signal[i + j];\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tfloat x
o!:5V
o"I=q
o"j=9
o#r;5C
o%{IiO
o&;Ts\n9
o):8tR\e
o-5YA
o-GjA
o-jlA
o-q=3j
o0;\acL;&1
o0ŰXUp
o1H:\r
o2;ht7
o2R<e
o4;"Q\r
o5IEI
o5l\e
o7:n>L:F
o8%;n
o9?PI
o9JBD
o9YL軧w
o9\nAܹᆆ9
o9vI!9
o:!ＺU5p
o:=ds
o:CD0
o:Md\n:0
o:cPO
o:ˊV9T
o;0>r
o;7 X9
o;A;k
o;So4
o;a\a_:Hrb
o;n2;F2r;P
o;u ѺR
o;xXq
o<D<c
o<g~1
o<m7¼S
o<}ug
o=\e 2=QO
o=csA
o=v\e
o=z(J
o>3j\r?\f
o>p-I
o@e:z4
oAJ;o
oB);B
oB)>z
oB<P\b
oC;@cB
oD$\bfD
oD$`fE
oD>Kg
oEb;CK
oHL+o@H
oHL+o@I
oI\\$Hf
oJ;I\am;8
oK.;\vN
oL$ fD
oL$0fD
oL$`fD
oL$pfD
oM̹r0
oO\vbQ
oO{Jw
oQ <]\b
oQ;Bs
oR<X\b
oRۼƿc
oSüoV
oT$ fD
oT$PfD
oT$`fD
oT<cQ˼Ի\t
oV<o6o
oW\v<kD
oZs=s_d
o\\$PfA
o\\$PfD
o\\$pfD
o\e;L
o\f;H
o\f;Wtv8
o\r >w
o\rr1K
o\rzR0
o\t>j
o\t\r
o\te:xD
o\tĺ\fZ
o]X:C
o`U<R
ob!?K
object
objectID < builders.size() && builders[objectID] == nullptr
objectID < objects.size () && objects[objectID] == nullptr
object_accel
object_accel_max_leaf_size
object_accel_mb
object_accel_mb_max_leaf_size
object_accel_mb_min_leaf_size
object_accel_min_leaf_size
object_builder
object_builder_mb
octantID < 8
oc̻P[b
od ;S
od$0fD
od$@fD
od$PfD
od$`fD
oe);h
oe;\a{H
ofܺ\n
og 9P
oiκHT
oj<WD
oj>OP
oj?;78
ol$ fD
ol$0fD
ol$PfD
ol$`fA
ole32.dll
omni callsig
onst float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n \n \n \n#define STARTIDX(x)     (((int)(x->pmin.w))) \n#define SHAPEIDX(x)     (((int)(x.pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n \ntypedef struct \n{ \n    // BVH structure \n    __global BvhNode*       nodes; \n    // Scene positional data \n    __global float3*        vertices; \n    // Scene indices \n    __global Face*          faces; \n    // Transforms \n    __global ShapeData*     shapedata; \n    // Root BVH idx \n    int rootidx; \n} SceneData; \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nbool IntersectLeafClosest( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n    if (IntersectTriangle(r, v1, v2, v3, isect)) \n    { \n        isect->primid = face.id; \n        return true; \n    } \n \n    return false; \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r                      // ray to instersect \n) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n    if (IntersectTriangleP(r, v1, v2, v3)) \n    { \n        return true; \n    } \n \n    return false; \n} \n \n \n// intersect Ray against the whole BVH2L structure \nbool IntersectSceneClosest2L(SceneData* scenedata, ray* r, Intersection* isect) \n{ \n    // Init intersection \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    // Precompute invdir for bbox testing \n    float3 i
onst float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n#define STARTIDX(x)     (((int)((x).pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n#define SHORT_STACK_SIZE 16 \n \n \ntypedef struct \n{ \n    bbox lbound; \n    bbox rbound; \n} FatBvhNode; \n \ntypedef struct \n{ \n    // BVH structure \n    __global FatBvhNode const*     nodes; \n    // Scene positional data \n    __global float3 const*         vertices; \n    // Scene indices \n    __global Face const*         faces; \n    // Shape IDs \n    __global ShapeData const*     shapes; \n    // Extra data \n    __global int const*             extra; \n} SceneData; \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nvoid IntersectLeafClosest( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n        } \n    } \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return f
ontext
ook:e
ooq:w
operation canceled
operation in progress
operation not permitted
operation not supported
operation not supported for this geometry
operation would block
operator
operator co_await
or>P>M
os<`M
ot$ fD
ot$@fD
ot:Kh
ou;d%w
out of memory
out->data
out->data[iChannel][out->numSamples - 1
out->numChannels
out->numSamples
outType
outlen == newN
outputs
outputs->direct)->airAbsorption[iBand
outputs->direct)->directivity
outputs->direct)->distanceAttenuation
outputs->direct)->flags
outputs->direct)->occlusion
outputs->direct)->transmissionType
outputs->direct)->transmission[iBand
outputs->pathing
outputs->pathing)->binaural
outputs->pathing)->eqCoeffs[iBand
outputs->pathing)->hrtf
outputs->pathing)->listener.ahead.x
outputs->pathing)->listener.ahead.y
outputs->pathing)->listener.ahead.z
outputs->pathing)->listener.origin.x
outputs->pathing)->listener.origin.y
outputs->pathing)->listener.origin.z
outputs->pathing)->listener.right.x
outputs->pathing)->listener.right.y
outputs->pathing)->listener.right.z
outputs->pathing)->listener.up.x
outputs->pathing)->listener.up.y
outputs->pathing)->listener.up.z
outputs->pathing)->order
outputs->pathing)->shCoeffs[iCoeff
outputs->reflections
outputs->reflections)->delay
outputs->reflections)->eq[iBand
outputs->reflections)->ir
outputs->reflections)->irSize
outputs->reflections)->numChannels
outputs->reflections)->reverbTimes[iBand
outputs->reflections)->tanDevice
outputs->reflections)->tanSlot
outputs->reflections)->type
ov<v\e1
ovһwB
ow\nbQ
owner dead
owq:Bsb
owʹ12
oxp;O
oy[:Q
oz:Ŷ%;nUr
o|$0fD
o|:zJC
o~7:95\b
oÍ9ChM
oƺ<t\tv
o˼rә=wqb
oߏ;2Wf
p UATAUAVAWH
p UWATAVAWH
p UWAVH
p WATAUAVAWH
p WAVAWH
p }8GQ
p!u;w;K
p"<C1
p&7]u
p&Ϻz\vƺ5u
p,m;\eQF
p/C<Dn
p1X>{C
p3L:B
p3ֹVBR
p4+<4
p7M}f
p7N<Bw
p7ǹzRa
p8H:d
p8W+B
p8^|S
p8墀9}\eT8
p9OBc
p9ݘX:2
p:4ߗ8z
p:KF\v
p:\vH\a
p:r\t
p:Ͳ7;9O
p:зٺ]Wr9L
p;5\b6
p;5qm
p;=AH
p;FpR
p;LFS
p;_8C
p;e8i
p<Q=7
p<W:sbI
p<\ba
p<gX\a
p=BAr
p=L\b
p=eaj
p=yO1
p>8MdF
p?<Ap
p?\b\tq?W
p@ݼoI
pA:sE
pA_A^A
pA_A^A]A
pC:\e
pD;#O
pDf;~I
pF<h:d
pG9;Dw
pGA:CH
pH+A0L
pHH+p
pHI+p@A
pHL+p@3
pK\e;E
pL;t$HH
pMٹ2qh
pOE=e
pOߺthM
pS;뮀66
pT$PNf
pT\rVOe
pT|\a
pU\v;j
pVֺ\t'F
pW\v=Z
pXD\v
pYE Š\\M
pYE0Š\\MP
pYEPŠ\\Mp
pY_PŰY
p[:I54
p\aIB
p\abA
p\aj;{s
p\b<I\v
p\bH+0H
p\f<TyQ
p\n|屮uO
p\r6;,E
p\r`\f0\vP
p\r`\f0\vP!l
p\r`\f0\vP!s
p\r`\f0\vP!t
p\r`\f0\vP\b
p\r`\fP
p\r`\fP!j
p\r`\fP\b
p\r`\fP\v0
p\r`\fP\v0\b
p\rk<\t
p\t:lϏ9
p\t<lt)<8
p\tL<dd\a
p\v";LG
p]:ql
p]A_A
p]A_A^A
p^<DGn
pa; V
pa;CT
pa;\f\e5
params
params->airAbsorption[iBand
params->bakeBatchSize
params->bakeFlags
params->binaural
params->delay
params->direction.x
params->direction.y
params->direction.z
params->directivity
params->distanceAttenuation
params->eqCoeffs[iBand
params->eq[iBand
params->flags
params->height
params->hrtf
params->identifier.endpointInfluence.center.x
params->identifier.endpointInfluence.center.y
params->identifier.endpointInfluence.center.z
params->identifier.endpointInfluence.radius
params->identifier.type
params->identifier.variation
params->interpolation
params->ir
params->irSize
params->irradianceMinDistance
params->listener.ahead.x
params->listener.ahead.y
params->listener.ahead.z
params->listener.origin.x
params->listener.origin.y
params->listener.origin.z
params->listener.right.x
params->listener.right.y
params->listener.right.z
params->listener.up.x
params->listener.up.y
params->listener.up.z
params->numBounces
params->numChannels
params->numDiffuseSamples
params->numRays
params->numSamples
params->numThreads
params->occlusion
params->openCLDevice
params->order
params->orientation.ahead.x
params->orientation.ahead.y
params->orientation.ahead.z
params->orientation.origin.x
params->orientation.origin.y
params->orientation.origin.z
params->orientation.right.x
params->orientation.right.y
params->orientation.right.z
params->orientation.up.x
params->orientation.up.y
params->orientation.up.z
params->pathRange
params->probeBatch
params->radeonRaysDevice
params->radius
params->rayBatchSize
params->reverbTimes[iBand
params->savedDuration
params->scene
params->sceneType
params->shCoeffs[iCoeff
params->simulatedDuration
params->spacing
params->spatialBlend
params->tanDevice
params->tanSlot
params->threshold
params->transform.elements[iRow][iColumn
params->transmissionType
params->transmission[iBand
params->type
params->visRange
pascal
paλ-h
pb{>m
pc=i9
pd^=R
pdata
pe##4* out_array, uint numElems, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    shmem[localId] = v1.x + v1.y + v1.z + v1.w + v2.x + v2.y + v2.z + v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\\ \n    type offset = shmem[localId];\\ \n    type t = v1.x; v1.x = offset; offset += t;\\ \n    t = v1.y; v1.y = offset; offset += t;\\ \n    t = v1.z; v1.z = offset; offset += t;\\ \n    t = v1.w; v1.w = offset; offset += t;\\ \n    t = v2.x; v2.x = offset; offset += t;\\ \n    t = v2.y; v2.y = offset; offset += t;\\ \n    t = v2.z; v2.z = offset; offset += t;\\ \n    v2.w = offset;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_PART_4(type)\\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\\ \n    __kernel void scan_exclusive_part_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __global type* out_sums, __local type* shmem)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int localId   = get_local_id(0);\\ \n    int groupId   = get_group_id(0);\\ \n    int groupSize = get_local_size(0);\\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\\ \n    v2.w += v1.w;\\ \n    shmem[localId] = v2.w;\\ \n    barrier(CLK_LOCAL_MEM_FENCE);\\ \n    type sum = group_scan_exclusive_part_##type(localId, groupSize, shmem);\\ \n    if (localId == 0) out_sums[groupId] = sum;\\ \n    v2.w = shmem[localId];\\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\\ \n} \n \n#define DEFINE_GROUP_REDUCE(type)\\ \n    void group_reduce_##type(int localId, int groupSize, __local type* shmem)\\ \n{\\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\\ \n    {\\ \n    if (localId < groupSize/(2*stride))\\ \n        {\\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\\ \n        }\\ \n        barrier(CLK_LOCAL_MEM_FENCE);\\ \n    }\\ \n} \n \n#define DEFINE_DISTRIBUTE_PART_SUM_4(type)\\ \n    __kernel void distribute_part_sum_##type##4( __global type* in_sums, __global type##4* inout_array, uint numElems)\\ \n{\\ \n    int globalId  = get_global_id(0);\\ \n    int groupId   = get_group_id(0);\\ \n    type##4 v1 = safe_load_##type##4(inout_array, globalId, numElems);\\ \n    type    sum = in_sums[groupId >> 1];\\ \n    v1.xyzw += sum;\\ \n    safe_store_##type##4(v1, inout_array, globalId, numElems);\\ \n} \n \n \n// These are already defined in Apple OCL runtime \n#ifndef APPLE \nDEFINE_MAKE_4(int) \nDEFINE_MAKE_4(float) \n#endif \n \nDEFINE_SAFE_LOAD_4(int) \nDEFINE_SAFE_LOAD_4(float) \n \nDEFINE_SAFE_STORE_4(int) \nDEFINE_SAFE_STORE_4(float) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE(uint) \nDEFINE_GROUP_SCAN_EXCLUSIVE(float) \nDEFINE_GROUP_SCAN_EXCLUSIVE(short) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_SUM(uint) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(float) \n \nDEFINE_SCAN_EXCLUSIVE(int) \nDEFINE_SCAN_EXCLUSIVE(float) \n \nDEFINE_SCAN_EXCLUSIVE_4(int) \nDEFINE_SCAN_EXCLUSIVE_4(float) \n \nDEFINE_SCAN_EXCLUSIVE_PART_4(int) \nDEFINE_SCAN_EXCLU
pej;0
performance impact. Please enable these modes for each application
permission denied
pf:6K
pf<^n
pgL:vt
pg\n?pg\n
pgݻDv
ph:t4-;c
phonon.dll
phonon_itest.exe
phonon_perf.exe
phonon_test.exe
piٻCb\t
pk9e\\V
pk;{ZR
pl':U!y:JW
placement delete closure
placement delete[] closure
pmg;xz?9}\a
pn9II0:SfR9Z
pn<dó<H
pn>6ނB
poh=qO
portuguese-brazilian
pp9* \n
pp;0E
pr china
pr-china
prim.lower.a & 0xFF000000) == 0
primID
primitives
probe.center.x
probe.center.y
probe.center.z
probe.radius
probeArray
probeBatch
profilerContext
program name unknown
progress monitor forced termination
protocol error
protocol not supported
provided geometry ID already assigned to a geometry
ptr & (size_t)align_mask) == 0
ptr64
puerto-rico
pv<gX
pw8;;\v
pw<dqs
pz9<\nT
pz<\ta
p{h2Һi
p}Dsubdivpatch1
pňX}P
pƻ8XN
pǄ:5j
p˔;yS
pͼ#BмKg\b
pΥ<03
pф;e6M
pӅ=T\nM
pԡ9j3
pؼWl9
q bR%H6
q!:F A:3
q!; s7
q!c;BF
q"L P
q"L"P
q#>;Wqc
q'h96
q)9wa
q*;0X
q+:3MyX+z8
q+۽Rzt
q0@80u\n
q0Ȼi(j
q1<k\r
q2';m26:D2J
q35;bK
q3h;r
q5-;fW
q8,PF
q8\aX
q8ŒXa
q9:w8;;Q
q9<l'\r
q9d>W9
q:5Cߺ\ewt
q:9I\t;8V
q:Rj\r;Gt5
q:Y\f
q:d/κQsW
q;0Tz
q;39\a
q;R>b
q;Tl\f
q;WkE
q;h1v
q;i\eP
q<TJ"=k4
q=.Ca
q=Ҳ9>BF
q?V<b
qB9/^o
qB>kjg
qBǻtOA
qCm=>\av
qGL="l~=M\f3
qGS9w?z
qH=}c
qJ;\e
qJ<W%A
qJT$pp
qJT$ppH
qMX:Jj
qP:eAлz
qQQ:*5ʺa
qRG;Q
qS>g?h3
qTŊ\\I4
qTŢ\\I4
qU~;e
qW$;\eJg
qX=˱j
qX\a;Zu
qZ:aߺ9m
qZ;"9M;l
q[ݹWvɺa
q\a;Le
q\b7;(wV
q\b;6RֺF
q\b;j
q\bL+1H
q\bba~\b
q\e\e
q\nba|H
q\rչt
q\t;e7r
q\t\a=Ezz
q\tba~\b
q\vba~\b
q`k:c
qb!}Hp$ٱbA
qbvh4.triangle4i
qbvh8.triangle4
qbvh8.triangle4i
qbڻŤl9
qe-<L}g
qeB<FAE
qg<s%w
qgY=EG
qgw=(\a\t
qiT;B
qiX:S
qj/9;E
qj:axY9l
qjļDw
qot:׀X
qp2:R
qt5<-r
quad4i
quad4v
quad_accel
quad_accel_mb
quad_builder
quad_builder_mb
quad_traverser
quad_traverser_mb
quads
quantizedNodes
quz-BO
quz-EC
quz-PE
quz-bo
quz-ec
quz-pe
qw+=k5R
qxs?qxs
qxs?qxs?qxs?qxs?qxs?qxs
qyb:O2
q{3摻T
qƷ;coM
qǺu!w
qȽJ30
qںOKm:t
r %:Aj
r";Xb
r#=lRr
r$>9L
r%:y6
r'<Ms
r'=dB
r'X9|b
r'j=Zf
r(H=ja
r(T;Fh
r)7<'H9
r);DBX
r*:v5
r+w2L
r,2:n
r.'>Xft
r.9pR\n
r.size() == 1
r/d=rH
r0 < 8
r0;sƐ9
r0\fP
r0\fP\b
r1 < 8
r130801120000Z
r1;D t
r1<%h
r1ֺB :9
r210429000000Z
r211007000000Z
r220323000000Z
r220801000000Z
r230714000000Z
r240506185943Z0
r241009235959Z0a1\v0\t
r2:bO
r2<u4һq
r2=Iz
r2l2fHT2R2F:t
r311109235959Z0b1\v0\t
r341013235959Z0H1\v0\t
r360428235959Z0i1\v0\t
r370322235959Z0c1\v0\t
r380115120000Z0b1\v0\t
r3>l`ݽK
r3Ӽ_t
r42:n2F
r5:D/z
r5:zp58z\ff
r6ƻ\t\nĻD
r6ǼHY
r7;&v
r7<}ZԼ}8j
r8,;5
r8\\=rd
r8\v:WO
r8q:Q
r9=)K\v
r9=gD2
r9>Hߺ5
r9IT\v
r9N8y9
r9Rǳ:y
r9mpe;Dk":\b
r9obֺޟm
r9z6;\tQg
r:%h4
r:'X̻yn
r:,Ul
r:Q\a89
r:S(ڻlq
r:Yoa
r:\f;L94
r:eSĺ A
r:gom:fp
r;0 h
r;0=MIA
r;81\t=\t
r;9>\t:R6
r;9D2
r;9Tr
r;:CQ
r;;bIE
r;;쇻05r
r;A\vx;w2
r;C"7
r;E%4
r;FG{8
r;GHM
r;I,w:GoQ:W
r;K%n9
r;N2<v
r;Q\e@9
r;XE]:N
r;\n9V
r;`kD
r;`sD
r;d$c
r;d|d
r;pBL
r;q=t:0s
r;q>Q
r;usb;_i
r;wH@<m
r<25A
r<2wg
r<FO.<X
r<T9a
r<Z^6
r<dKļGB
r<v;f
r="rD=bx
r='DN
r=2uz
r=;3Kh
r=O>m
r=\tSD>\t
r=kB\e
r=on5=D
r=u8\b
r>3;caN
r><7ag
r>KQA>x
r>P\n
r>Rq=>2
r>\fB
r>e4F
r>e\n
r?fQ3
r?ѻTS
r@0:WI
rAwHL
rB;ިL
rB\v;v
rC<RE
rCCޱb#UCC
rE\b=6yM
rF 9d
rFV:J
rH :P
rH6;3
rH;~r
rHR=w
rH\e;!A
rJ;\e\n
rK<ldC
rLc]lI
rLg<qr
rM?\t7\a
rMI+\nN
rMe;u
rM»\f"W
rN*;D
rO|:wv
rP%=K\b
rP\f0\b
rPܺr嬻y
rR\\;eV
rSಸCd9
rT%>2
rT1<3e
rUC:ºf;a
rW;(F
rX"<6
rX6:;z
rX;pf
rX<)E
rX[;X
rXy`łY
rXypŚXyt
rXϻ(\nF
rY;\tbC
rY<}S
rY>P/1
rYI<\bK
rYL<\fXC
rZ2;nvܺt
rZ8>\v
rZ98r
rZ>"n
rZ\a<Yeûk
rZk;\fj
r[k8B
r\\y4łY
r\a(:Kb
r\abbmH
r\b<5
r\b<gAt
r\bSA|X=G
r\b\a>4hl
r\bb"e@6
r\bbA
r\bba|\b
r\bba~\b
r\br><A
r\e\f
r\ebA|\b
r\f;[w6
r\f<(DF
r\fbA
r\fl<\tFU
r\fp\v`\n0\b
r\n$;T4t8
r\n0\tP\bp\a
r\n;r@5
r\n<\eqǻm0
r\r:NB
r\rbA
r\t9,g0
r\tVr.>T
r\ta<1G
r\ta<؆e
r\tbA
r\tba
r\tba|\b
r\vba|H
r\vw<?hG
r`\f0!V
r`\f0!l
r`\f0\vP
r`\fP\v0
r`j9ϹI
rae:m2R;B
range.size() == 1
ray.tnear >= 0.0f
ray.valid
rayID < MAX_INTERNAL_STREAM_SIZE
rb!4@Yt
rb!\f@Yt
rb,9J
rbA|H
rbQ|H
rba$@X
rcalculating laplacian: %.2f
rcp(min_rcp_input)*FLT_LARGE+FLT_LARGE < 0.01f*FLT_MAX
rdata
rdata$T
rdata$r
rdata$voltmd
rdata$zzzdbg
re;0w8
reU>\v
read only file system
reconstructImpulseResponse
reloc
remove
remove@ThreadPool@TaskScheduler@embree@@QEAAXAEBV?$Ref@UTaskScheduler@embree@@@3@@Z
removeData
removeProbe
removeProbeBatch
removeScheduler@TaskScheduler@embree@@CAXAEBV?$Ref@UTaskScheduler@embree@@@2@@Z
resource deadlock would occur
resource unavailable try again
restrict
result
result out of range
result.center.x
result.center.y
result.center.z
result.radius
result.x
result.y
result.z
return ((float)randUint(rng)) / 0xffffffffU;\n}\n\nvoid initRNG(uint seed, local RNG* rng)\n{\n    rng->value = wangHash(seed);\n}\n\nfloat2 uniformRandom2d(local RNG* rng)\n{\n    return (float2) (randFloat(rng), randFloat(rng));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Directivity\n// --------------------------------------------------------------------------------------------------------------------\n\n// NOTE: Custom directivity callbacks are not supported at this time.\ntypedef struct __attribute__((packed)) Directivity_t\n{\n    float dipoleWeight;\n    float dipolePower;\n} Directivity;\n\nfloat evaluateDirectivity(float3 point,\n                          CoordinateSpace coordinates,\n                          Directivity directivity)\n{\n    float3 worldSpaceDirection = normalize(point - coordinates.origin);\n    float3 localSpaceDirection = transformWorldToLocal(coordinates, worldSpaceDirection);\n\n    float cosine = -localSpaceDirection.z;\n    return pow(fabs((1.0f - directivity.dipoleWeight) + directivity.dipoleWeight * cosine), directivity.dipolePower);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Material\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) Material_t\n{\n    float  absorptionLow;\n    float  absorptionMid;\n    float  absorptionHigh;\n    float  scattering;\n    float  transmissionLow;\n    float  transmissionMid;\n    float  transmissionHigh;\n} Material;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Radeon Rays Helpers\n// --------------------------------------------------------------------------------------------------------------------\n\n// This must exactly match the ray data structure (struct ray) used by Radeon Rays.\ntypedef struct Ray_t\n{\n    float4  o;\n    float4  d;\n    int2    extra;\n    int2    padding;\n} Ray;\n\n// This must exactly match the hit data structure (struct Intersection) used by Radeon Rays.\ntypedef struct Hit_t\n{\n    int       shapeid;\n    int       primid;\n    int       padding0;\n    int       padding1;\n    float4    uvwt;\n} Hit;\n\n// --------------------------------------------------------------------------------------------------------------------\n// IIR Filtering\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct IIR_t\n{\n    float a1, a2;\n    float b0, b1, b2;\n} IIR;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void generateCameraRays(global CoordinateSpace* camera,\n                               global Ray* rays)\n{\n    uint width = get_global_size(0);\n    uint height = get_global_size(1);\n    uint u = get_global_id(0);\n    uint v = get_global_id(1);\n    uint index = v * width + u;\n\n    float du = ((u / (float) width) - 0.5f) * 2.0f;\n    float dv = ((v / (float) height) - 0.5f) * 2.0f;\n\n    rays[index].o = (float4) (camera->origin, FLT_MAX);\n    rays[index].d = (float4) (normalize(du * camera->right + dv * camera->up - camera->ahead), 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\nkernel void generateListenerRays(global CoordinateSpace* listeners,\n                                 global float4* sphereSamples,\n                                 global Ray* rays)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t listenerIndex = get_global_id(1);\n    size_t index = listenerIndex * get_global_size(0) + rayIndex;\n\n    rays[index].o = (float4) (listeners[listenerIndex].origin, FLT_MAX);\n    rays[index].d = (float4) (sphereSampl
rf;2Py
rfJBGo
rfffff
rg<<e
rh.;s
rh\t;<Q
ri/=q
ri4<wb
riP<d3
rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, isect->uvwt.w); \n \n        if (leftleaf) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node.lbound), r, isect); \n        } \n \n        if (rightleaf) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node.rbound), r, isect); \n        } \n \n        if (lefthit > 0.f && righthit > 0.f) \n        { \n            int deferred = -1; \n            if (lefthit > righthit) \n            { \n                idx = (int)node.rbound.pmax.w; \n                deferred = (int)node.lbound.pmax.w;; \n            } \n            else \n            { \n                idx = (int)node.lbound.pmax.w; \n                deferred = (int)node.rbound.pmax.w; \n            } \n \n                    *sptr++ = deferred; \n            continue; \n        } \n        else if (lefthit > 0) \n        { \n            idx = (int)node.lbound.pmax.w; \n            continue; \n        } \n        else if (righthit > 0) \n        { \n            idx = (int)node.rbound.pmax.w; \n            continue; \n        } \n \n                idx = *--sptr; \n    } \n \n    return isect->shapeid >= 0; \n} \n#endif \n \n#ifndef GLOBAL_STACK \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    if (r->o.w < 0.f) \n        return false; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            leftleaf = LEAFNODE(node.lbound); \n            rightleaf = LEAFNODE(node.rbound); \n \n            lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, r->o.w); \n            righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, r->o.w); \n \n            if (leftleaf) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node.lbound), r)) \n                                    return true; \n            } \n \n            if (rightleaf) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node.rbound), r)) \n                                return true; \n            } \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = (int)node.rbound.pmax.w; \n                    deferred = (int)node.lbound.pmax.w;; \n \n                } \n                else \n                { \n                    idx = (int)node.lbound.pmax.w; \n                    deferred = (int)node.rbound.pmax.w; \n                } \n \n                if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                { \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        gsptr[i] = ldsstack[i * 64]; \n                    } \n \n                    gsptr += SHORT_STACK_SIZE; \n                    lsptr = ldsstack + 64; \n                } \n \n                *lsptr = deferred; \n                lsptr += 64; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = (int)node.lbound.pmax.w; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = (int)node.rbound.pmax.w; \n                continue; \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n
rj$:o\b
rj9=Q
rjQ9u3
rk9Bi
rk<<p
rkV<M
rk_;bt
rl7=V
rlԻDJ
rm;8m^9
rmarking potentially diffracting voxels: %.2f
ro:?f
ro:xPG
roU;i
robust
roup_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n} \n \n__kernel void compact_int_1(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output, \n    __global int* out_size) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_group_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n \n    if (global_id == 0) \n    { \n        *out_size = in_address[in_size - 1] + in_predicate[in_size - 1]; \n    } \n} \n \n__kernel void copy(__global int4* in_input, \n    uint  in_size, \n    __global int4* out_output) \n{ \n    int global_id = get_global_id(0); \n    int4 value = safe_load_int4(in_input, global_id, in_size); \n    safe_store_int4(value, out_output, global_id, in_size); \n} \n \n \n#define FLAG(x) (flags[(x)] & 0x1) \n#define FLAG_COMBINED(x) (flags[(x)]) \n#define FLAG_ORIG(x) ((flags[(x)] >> 1) & 0x1) \n \nvoid group_segmented_scan_exclusive_int( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2
rp;Kv
rp;bB
rp\f0\vP
rp\f0\vP!l
rp\fP!c
rp\fP\v0
rp\f`\v0
rp\f`\v0\b
rp\f`\v0\nP
rp\f`\vP
rp\f`\vP\b
rp\f`\vP\n0
rpb<2
rq<NuW
rqp:J
rr:K\r\v
rrA<l
rs\b:B^B;c
rset.ext_end() + left_ext_range_size == set.ext_end
rsrc$01
rsrc$02
rt8lS
rt<1k
rtc$IAA
rtc$IZZ
rtc$TAA
rtc$TZZ
rtcCommit
rtcCommitJoin
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcCommitJoin___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcCommitThread
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcCommitThread___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcCommit___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcDebug
rtcDebug___avx
rtcDebug___avx2
rtcDebug___sse2
rtcDebug___sse4
rtcDeleteDevice
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_avx
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_avx2
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_sse2
rtcDeleteDevice___un_3C_s_5B_un__RTCDevice_5D__3E_sse4
rtcDeleteGeometry
rtcDeleteGeometry cannot get called in static scenes
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcDeleteGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcDeleteScene
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcDeleteScene___un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcDeviceGetError
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_avx
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_avx2
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_sse2
rtcDeviceGetError___un_3C_s_5B_un__RTCDevice_5D__3E_sse4
rtcDeviceGetParameter1i
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_avx
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_avx2
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_sse2
rtcDeviceGetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_sse4
rtcDeviceNewScene
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx2
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse2
rtcDeviceNewScene___un_3C_s_5B_un__RTCDevice_5D__3E_unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse4
rtcDeviceSetErrorFunction
rtcDeviceSetErrorFunction2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_avx
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_avx2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_sse2
rtcDeviceSetErrorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_un_3C_unv_3E_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_un_3C_unv_3E_sse4
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx2
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse2
rtcDeviceSetErrorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse4
rtcDeviceSetMemoryMonitorFunction
rtcDeviceSetMemoryMonitorFunction2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_avx
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_avx2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_sse2
rtcDeviceSetMemoryMonitorFunction2___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_un_3C_unv_3E_sse4
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_avx
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_avx2
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_sse2
rtcDeviceSetMemoryMonitorFunction___un_3C_s_5B_un__RTCDevice_5D__3E_un_3C____CunUCunb_3E_sse4
rtcDeviceSetParameter1i
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unuavx
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unuavx2
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unusse2
rtcDeviceSetParameter1i___un_3C_s_5B_un__RTCDevice_5D__3E_Cunenum_5B_RTCParameter_5D_unusse4
rtcDisable
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcDisable___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcEnable
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcEnable___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcExit
rtcExit___avx
rtcExit___avx2
rtcExit___sse2
rtcExit___sse4
rtcGetBounds
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_avx
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_avx2
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_sse2
rtcGetBounds___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCBounds_5D_sse4
rtcGetError
rtcGetError___avx
rtcGetError___avx2
rtcGetError___sse2
rtcGetError___sse4
rtcGetLinearBounds
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcGetLinearBounds___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcGetParameter1i
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_avx
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_avx2
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_sse2
rtcGetParameter1i___Cunenum_5B_RTCParameter_5D_sse4
rtcGetUserData
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcGetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcInit
rtcInit has to get called before rtcExit
rtcInit___un_3C_Cunt_3E_avx
rtcInit___un_3C_Cunt_3E_avx2
rtcInit___un_3C_Cunt_3E_sse2
rtcInit___un_3C_Cunt_3E_sse4
rtcInterpolate
rtcInterpolate2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse2
rtcInterpolate2___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse4
rtcInterpolateN
rtcInterpolateN2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unuavx2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse2
rtcInterpolate___un_3C_s_5B_un__RTCScene_5D__3E_unuvyuvyfvyfunenum_5B_RTCBufferType_5D_un_3C_vyf_3E_un_3C_vyf_3E_un_3C_vyf_3E_unusse4
rtcIntersect
rtcIntersect and rtcOccluded not enabled
rtcIntersect16
rtcIntersect16 and rtcOccluded16 not enabled
rtcIntersect16 not supported
rtcIntersect16Ex
rtcIntersect16Ex not supported
rtcIntersect1Ex
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcIntersect1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcIntersect1M
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse4
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse2
rtcIntersect1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse4
rtcIntersect1Mp
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcIntersect1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcIntersect4
rtcIntersect4 and rtcOccluded4 not enabled
rtcIntersect4Ex
rtcIntersect8
rtcIntersect8 and rtcOccluded8 not enabled
rtcIntersect8Ex
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcIntersectEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcIntersectN and rtcOccludedN not enabled
rtcIntersectNM
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx2
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse2
rtcIntersectNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse4
rtcIntersectNp
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx2
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse2
rtcIntersectNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse4
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx2
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse2
rtcIntersectVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse4
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcIntersect___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcMapBuffer
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcMapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcNewBSplineCurveGeometry
rtcNewBSplineCurveGeometry is not supported
rtcNewBSplineCurveGeometry2
rtcNewBSplineHairGeometry
rtcNewBSplineHairGeometry is not supported
rtcNewBSplineHairGeometry2
rtcNewBezierCurveGeometry
rtcNewBezierCurveGeometry is not supported
rtcNewBezierCurveGeometry2
rtcNewBezierHairGeometry
rtcNewBezierHairGeometry is not supported
rtcNewBezierHairGeometry2
rtcNewCurveGeometry
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewCurveGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewDevice
rtcNewDevice___un_3C_Cunt_3E_avx
rtcNewDevice___un_3C_Cunt_3E_avx2
rtcNewDevice___un_3C_Cunt_3E_sse2
rtcNewDevice___un_3C_Cunt_3E_sse4
rtcNewGeometryGroup
rtcNewGeometryInstance
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewGeometryInstance___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcNewHairGeometry
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewHairGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewInstance
rtcNewInstance2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewInstance2___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcNewInstance3
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcNewInstance3___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_avx
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_avx2
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_sse2
rtcNewInstance___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B_un__RTCScene_5D__3E_sse4
rtcNewLineSegments
rtcNewLineSegments is not supported
rtcNewLineSegments2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewLineSegments___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewQuadMesh
rtcNewQuadMesh is not supported
rtcNewQuadMesh2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewQuadMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewQuadMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewScene
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_avx2
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse2
rtcNewScene___unenum_5B_RTCSceneFlags_5D_unenum_5B_RTCAlgorithmFlags_5D_sse4
rtcNewSubdivisionMesh
rtcNewSubdivisionMesh is not supported
rtcNewSubdivisionMesh2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuavx
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuavx2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunusse2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunusse4
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunuavx
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunuavx2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunusse2
rtcNewSubdivisionMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuunuunuunuunusse4
rtcNewTriangleMesh
rtcNewTriangleMesh2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunuavx2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse2
rtcNewTriangleMesh2___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuunusse4
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewTriangleMesh___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewUserGeometry
rtcNewUserGeometry2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunuavx2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse2
rtcNewUserGeometry2___un_3C_s_5B_un__RTCScene_5D__3E_unuunusse4
rtcNewUserGeometry3
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuavx
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuavx2
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunusse2
rtcNewUserGeometry3___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunusse4
rtcNewUserGeometry4
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunuavx2
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse2
rtcNewUserGeometry4___un_3C_s_5B_un__RTCScene_5D__3E_unenum_5B_RTCGeometryFlags_5D_unuunuunusse4
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcNewUserGeometry___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
rtcOccluded
rtcOccluded16
rtcOccluded16 not supported
rtcOccluded16Ex
rtcOccluded16Ex not supported
rtcOccluded1Ex
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcOccluded1Ex___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcOccluded1M
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunuavx2
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse2
rtcOccluded1M___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRay1_5D__3E_CunuCunusse4
rtcOccluded1Mp
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunuavx2
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse2
rtcOccluded1Mp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_CunuCunusse4
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_avx2
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse2
rtcOccluded1___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_unRTCRay1_5D_sse4
rtcOccluded4
rtcOccluded4Ex
rtcOccluded8
rtcOccluded8Ex
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcOccludedEx___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcOccludedNM
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunuavx2
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse2
rtcOccludedNM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_CunuCunuCunusse4
rtcOccludedNp
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunuavx2
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse2
rtcOccludedNp___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_REFs_5B__c_unRTCRayNp_5D_Cunusse4
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunuavx2
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse2
rtcOccludedVM___un_3C_s_5B_un__RTCScene_5D__3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_vyRTCRay_5D__3E_CunuCunusse4
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_avx2
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse2
rtcOccluded___un_3C_s_5B_un__RTCScene_5D__3E_REFs_5B_vyRTCRay_5D_sse4
rtcSetBoundaryMode
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_avx
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_avx2
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_sse2
rtcSetBoundaryMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBoundaryMode_5D_sse4
rtcSetBoundsFunction
rtcSetBoundsFunction2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_avx
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_avx2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_sse2
rtcSetBoundsFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUun_3C_s_5B_unRTCBounds_5D__3E__3E_un_3C_unv_3E_sse4
rtcSetBoundsFunction3
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_avx
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_avx2
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_sse2
rtcSetBoundsFunction3___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_unv_3E_unUunUREFs_5B_unRTCBounds_5D__3E_un_3C_unv_3E_sse4
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_avx
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_avx2
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_sse2
rtcSetBoundsFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unUREFs_5B_unRTCBounds_5D__3E_sse4
rtcSetBuffer
rtcSetBuffer2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunuavx
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunuavx2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunusse2
rtcSetBuffer2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuunusse4
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuavx
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunuavx2
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunusse2
rtcSetBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_un_3C_Cunv_3E_unuunusse4
rtcSetDisplacementFunction
rtcSetDisplacementFunction2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcSetDisplacementFunction2___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_avx2
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse2
rtcSetDisplacementFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_unuunuun_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_Cunf_3E_un_3C_unf_3E_un_3C_unf_3E_un_3C_unf_3E_unU_3E_un_3C_s_5B_unRTCBounds_5D__3E_sse4
rtcSetErrorFunction
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_avx2
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse2
rtcSetErrorFunction___un_3C____UM_Cunenum_5B_RTCError_5D_un_3C_Cunt_3E__3E_sse4
rtcSetIndexBuffer
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_avx
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_avx2
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_sse2
rtcSetIndexBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_unenum_5B_RTCBufferType_5D_sse4
rtcSetIntersectFunction
rtcSetIntersectFunction16
rtcSetIntersectFunction1Mp
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx2
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse2
rtcSetIntersectFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse4
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx2
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse2
rtcSetIntersectFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse4
rtcSetIntersectFunction4
rtcSetIntersectFunction8
rtcSetIntersectFunctionN
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx2
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse2
rtcSetIntersectFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse4
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx2
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse2
rtcSetIntersectFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse4
rtcSetIntersectionFilterFunction
rtcSetIntersectionFilterFunction16
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx2
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse2
rtcSetIntersectionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse4
rtcSetIntersectionFilterFunction4
rtcSetIntersectionFilterFunction8
rtcSetIntersectionFilterFunctionN
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx2
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse2
rtcSetIntersectionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse4
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx2
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse2
rtcSetIntersectionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse4
rtcSetMask
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuuniavx
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuuniavx2
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuunisse2
rtcSetMask___un_3C_s_5B_un__RTCScene_5D__3E_unuunisse4
rtcSetMemoryMonitorFunction
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_avx
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_avx2
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_sse2
rtcSetMemoryMonitorFunction___un_3C____CunUCunb_3E_sse4
rtcSetOccludedFunction
rtcSetOccludedFunction16
rtcSetOccludedFunction1Mp
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_avx2
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse2
rtcSetOccludedFunction1Mp___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_un_3C_s_5B_unRTCRay1_5D__3E__3E_unUunU_3E_sse4
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_avx2
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse2
rtcSetOccludedFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D_unU_3E_sse4
rtcSetOccludedFunction4
rtcSetOccludedFunction8
rtcSetOccludedFunctionN
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_avx2
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse2
rtcSetOccludedFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_Cuni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_unUunU_3E_sse4
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_avx2
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse2
rtcSetOccludedFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D_unU_3E_sse4
rtcSetOcclusionFilterFunction
rtcSetOcclusionFilterFunction16
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_avx2
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse2
rtcSetOcclusionFilterFunction1___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_unv_3E_REFs_5B_unRTCRay1_5D__3E_sse4
rtcSetOcclusionFilterFunction4
rtcSetOcclusionFilterFunction8
rtcSetOcclusionFilterFunctionN
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_avx2
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse2
rtcSetOcclusionFilterFunctionN___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____UM_un_3C_uni_3E_un_3C_unv_3E_un_3C_s_5B__c_unRTCIntersectContext_5D__3E_un_3C_s_5B_unRTCRayN_5D__3E_un_3C_s_5B__c_unRTCHitN_5D__3E_CunU_3E_sse4
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_avx2
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse2
rtcSetOcclusionFilterFunction___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C____un_3C_unv_3E_REFs_5B_vyRTCRay_5D__3E_sse4
rtcSetParameter1i
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unuavx
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unuavx2
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unusse2
rtcSetParameter1i___Cunenum_5B_RTCParameter_5D_unusse4
rtcSetProgressMonitorFunction
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_avx
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_avx2
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_sse2
rtcSetProgressMonitorFunction___un_3C_s_5B_un__RTCScene_5D__3E_un_3C____UM_un_3C_unv_3E_Cund_3E_un_3C_unv_3E_sse4
rtcSetSubdivisionMode
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_avx
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_avx2
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_sse2
rtcSetSubdivisionMode___un_3C_s_5B_un__RTCScene_5D__3E_unuunuunenum_5B_RTCSubdivisionMode_5D_sse4
rtcSetTessellationRate
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfavx
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfavx2
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfsse2
rtcSetTessellationRate___un_3C_s_5B_un__RTCScene_5D__3E_unuunfsse4
rtcSetTransform
rtcSetTransform2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unuavx
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unuavx2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unusse2
rtcSetTransform2___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_unusse4
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_avx
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_avx2
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_sse2
rtcSetTransform___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCMatrixType_5D_un_3C_Cunf_3E_sse4
rtcSetUserData
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_avx
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_avx2
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_sse2
rtcSetUserData___un_3C_s_5B_un__RTCScene_5D__3E_unuun_3C_unv_3E_sse4
rtcUnmapBuffer
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcUnmapBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcUpdate
rtcUpdateBuffer
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_avx2
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse2
rtcUpdateBuffer___un_3C_s_5B_un__RTCScene_5D__3E_unuunenum_5B_RTCBufferType_5D_sse4
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unuavx
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unuavx2
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unusse2
rtcUpdate___un_3C_s_5B_un__RTCScene_5D__3E_unusse4
ru6:2
run@Task@TaskScheduler@embree@@QEAAXAEAUThread@23@@Z
rv;Ovg
rw*<y\a
rw5<Rh
rx<]Im
rxt:3
ry \rG
ry6rcI
ry=4Ы=\b7
r}R9N,N
rǼExd
rȺd#4
rȻhf\r
rɋL$PH
rː;Nu
r̍Avf
r̻de8;L9\n;U
r̻hiK
rЯ:G8s
rҺEe0
rԼYvI=\f
rػfK\f
rںmY`:ry
rڻX1ĹQ
rݻXt9
rݼ+QӼHh
rߺF)0
rᇺJ2};S
r辽ICA
r깺\bn
r엺o\b5<\e 8
rY4t
s ;Pr/;G
s WATAUAVAWH
s WAVAWH
s!< N
s$W<M\b
s%9"Ue
s%O:bLE
s'b;sy
s(D+s0
s)3:l
s0;;O
s0C;yd
s1;ʭ0
s3:?L
s4+sP
s59=p}Խm
s5ͼ\vpi
s6}:g
s6߹PtG
s82٫9v
s: HRTF data contains Ambisonic HRIRs of unsupported order: %d
s: Unsupported HRTF data format version: %d
s: invalid %s: %s = %s
s:0xS
s:DYa9
s:Ja)<K
s:qn\r
s:s梺t7
s;3!G
s;7dE
s;8|p
s;^o6
s;rYO<4
s;t\v
s;whk
s<MBs
s<\tk
s<pD[<l
s<yln
s<zde
s>P=6z
s>\bE
s@=aa0
sBȻQ8
sEӺHMM
sFȺi0
sFҺ\a
sFں2f
sHH;sHs
sI"9_R\n
sI:59
sI\e;t1
sJ:v6
sJt<9\n
sK:&r
sL:rq
sL;20~<d
sLݺmvH
sM:\e\t
sN:\e
sNL9~\btxH
sP=Ywżi+J
sRA; J
sT`>y1
sUN;y
sV< Mp
sV\t<Ax㻞j
sXX:*q
sZֻVt
s\a;1i
s\a<Xy
s\aA\v
s\eֺn
s\n;E
s\nF;R5
s\t>9
s\v8>\t4
s\v@9
s\vD88w
s\vHcҋD
s\v\r=L
s_<d2
s`3;Y
sa_<z
sah_fast_spatial
sah_presplit
saveOBJ
sc\r;rά;a
scalar deleting destructor
scan_exclusive_int4
scan_exclusive_part_int4
scene got not committed
scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n
scenes do not belong to the same device
segments
selected scene intersector
serializedObject
set.end()+numExtElements<=set.ext_end
set.ext_range_size() > 0
set.has_ext_range
set.object_range.size() > 0
setInputs
setProfilerContext
setScene
setSharedInputs
set_affinity
settings
settings->anyHitCallback
settings->closestHitCallback
settings->data
settings->embreeDevice
settings->flags
settings->fractionCUsForIRUpdate
settings->frameSize
settings->freeCallback
settings->irSize
settings->materialIndices
settings->materialIndices[iTriangle
settings->materials
settings->materials[iMaterial].absorption[iBand
settings->materials[iMaterial].scattering
settings->materials[iMaterial].transmission[iBand
settings->maxDuration
settings->maxNumOcclusionSamples
settings->maxNumRays
settings->maxNumSources
settings->maxOrder
settings->maxSources
settings->numCUsToReserve
settings->numDiffuseSamples
settings->numMaterials
settings->numThreads
settings->numTriangles
settings->numVertices
settings->numVisSamples
settings->openCLDevice
settings->order
settings->radeonRaysDevice
settings->rayBatchSize
settings->reflectionType
settings->requiresTAN
settings->samplingRate
settings->sceneType
settings->simdLevel
settings->subScene
settings->tanDevice
settings->transform.elements[iRow][iColumn
settings->triangles
settings->triangles[iTriangle].indices[iTriangleVertex
settings->type
settings->vertices
settings->vertices[iVertex].x
settings->vertices[iVertex].y
settings->vertices[iVertex].z
sf\n>Y0
sg@;m
sh9w3I
shadeAndBounce
shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n#define LDS_BUG \n \n#ifdef LDS_BUG \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    int stack[STACK_SIZE]; \n    int* ptr = stack; \n \n    *ptr++ = -1; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        if (LEAFNODE(node)) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node), r, isect); \n        } \n        else \n        { \n            lbox = scenedata->bounds[node.left]; \n            rbox = scenedata->bounds[node.right]; \n \n            lefthit = IntersectBoxF(r, invdir, lbox, isect->uvwt.w); \n            righthit = IntersectBoxF(r, invdir, rbox, isect->uvwt.w); \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = node.right; \n                    deferred = node.left; \n                } \n                else \n                { \n                    idx = node.left; \n                    deferred = node.right; \n                } \n \n                *ptr++ = deferred; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = node.left; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = node.right; \n                continue; \n            } \n        } \n \n        idx = *--ptr; \n    } \n \n \n    return isect->shapeid >= 0; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r) \n{ \n    //return false; \n \n    const float3 invdir = native_recip(r->d.xyz); \n \n    //if (get_global_id(0) == 0) \n    //{ \n \n    //} \n \n    int stack[STACK_SIZE]; \n    int* ptr = stack; \n \n    *ptr++ = -1; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    bool hit = false; \n \n    int step = 0; \n    //if (get_global_id(0) == 1) \n        //printf("Starting %d\\n", get_global_id(0) ); \n    while (idx > -1) \n    { \n        //printf("%d", get_global_id(0)); \n        step++; \n        //if (get_global_id(0) == 1) \n        //{ \n            //printf("Node %d %d\\n", idx, step ); \n        //} \n \n        if (step > 10000) \n            return false; \n \n        node = scenedata->nodes[idx]; \n \n        if (LEAFNODE(node)) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node), r)) \n            { \n                hit = true; \n                break; \n            } \n        } \n        else \n        { \n            lbox = scenedata->bounds[node.left]; \n            rbox = scenedata->bounds[node.right]; \n \n            lefthit = IntersectBoxF(r, invdir, lbox, r->o.w); \n            righthit = IntersectBoxF(r, invdir, rbox, r->o.w); \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = node.right; \n                    deferred = node.left; \n                } \n                else \n                { \n                    idx = node.left; \n                    deferred = node.right; \n                } \n \n                *ptr++ = deferred; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = node.left; \n
shared
sharedInputs
sharedInputs->duration
sharedInputs->irradianceMinDistance
sharedInputs->listener.ahead.x
sharedInputs->listener.ahead.y
sharedInputs->listener.ahead.z
sharedInputs->listener.origin.x
sharedInputs->listener.origin.y
sharedInputs->listener.origin.z
sharedInputs->listener.right.x
sharedInputs->listener.right.y
sharedInputs->listener.right.z
sharedInputs->listener.up.x
sharedInputs->listener.up.y
sharedInputs->listener.up.z
sharedInputs->numBounces
sharedInputs->numRays
sharedInputs->order
si)<ZO
simulator
size_t)&data[0]) & (maxAlignment-1)) == 0
size_t)node & align_mask
size_t)tri & align_mask
siںGC
sl;܀F
slotMask
slotMutex[i].isLocked
slovak
sma-NO
sma-SE
sma-no
sma-se
smj-NO
smj-SE
smj-no
smj-se
smn-FI
smn-fi
sms-FI
sms-fi
sn$:p
source
source.ahead.x
source.ahead.y
source.ahead.z
source.origin.x
source.origin.y
source.origin.z
source.right.x
source.right.y
source.right.z
source.up.x
source.up.y
source.up.z
source.x
source.y
source.z
sourcePosition.x
sourcePosition.y
sourcePosition.z
south africa
south korea
south-africa
south-korea
spW;w
spanish-argentina
spanish-bolivia
spanish-chile
spanish-colombia
spanish-costa rica
spanish-dominican republic
spanish-ecuador
spanish-el salvador
spanish-guatemala
spanish-honduras
spanish-mexican
spanish-modern
spanish-nicaragua
spanish-panama
spanish-paraguay
spanish-peru
spanish-puerto rico
spanish-uruguay
spanish-venezuela
sphereOcclusion
spherical
sptr_node < stackEnd
sptr_node == stack_node
sptr_node > stack_node
sr-BA-Cyrl
sr-BA-Latn
sr-SP-Cyrl
sr-SP-Latn
sr-ba-cyrl
sr-ba-latn
sr-sp-cyrl
sr-sp-latn
src->data
src->data[iChannel][src->numSamples - 1
src->numChannels
src->numSamples
src[iArray
ssM+\nH
sse2::BVH
sse2::BVH4IntersectorStreamPacketFallback
sse2::BVH4Triangle4Intersector1Moeller
sse2::BVH4Triangle4Intersector4HybridMoeller
sse2::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse2::BVH4Triangle4IntersectorStreamMoeller
sse2::BVH4Triangle4IntersectorStreamMoellerNoFilter
sse2::BVH4Triangle4iIntersector1Moeller
sse2::BVH4Triangle4iIntersector1Pluecker
sse2::BVH4Triangle4iIntersector4HybridMoeller
sse2::BVH4Triangle4iIntersector4HybridPluecker
sse2::BVH4Triangle4iIntersectorStreamMoeller
sse2::BVH4Triangle4iIntersectorStreamPluecker
sse2::BVH4Triangle4iMBIntersector1Moeller
sse2::BVH4Triangle4iMBIntersector1Pluecker
sse2::BVH4Triangle4iMBIntersector4HybridMoeller
sse2::BVH4Triangle4iMBIntersector4HybridPluecker
sse2::BVH4Triangle4vIntersector1Pluecker
sse2::BVH4Triangle4vIntersector4HybridPluecker
sse2::BVH4Triangle4vIntersectorStreamPluecker
sse2::BVH4Triangle4vMBIntersector1Moeller
sse2::BVH4Triangle4vMBIntersector1Pluecker
sse2::BVH4Triangle4vMBIntersector4HybridMoeller
sse2::BVH4Triangle4vMBIntersector4HybridPluecker
sse2::BVH4VirtualIntersector1
sse2::BVH4VirtualIntersector4Chunk
sse2::BVH4VirtualIntersectorStream
sse2::BVH4VirtualMBIntersector1
sse2::BVH4VirtualMBIntersector4Chunk
sse2::BVH4XfmTriangle4Intersector1Moeller
sse2::InstanceIntersectorN
sse2::QBVH
sse2::QBVH4Triangle4iIntersector1Pluecker
sse4.1
sse4.2
sse42::BVH4IntersectorStreamPacketFallback
sse42::BVH4Triangle4Intersector1Moeller
sse42::BVH4Triangle4Intersector4HybridMoeller
sse42::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse42::BVH4Triangle4IntersectorStreamMoeller
sse42::BVH4Triangle4IntersectorStreamMoellerNoFilter
sse42::BVH4Triangle4iIntersector1Moeller
sse42::BVH4Triangle4iIntersector1Pluecker
sse42::BVH4Triangle4iIntersector4HybridMoeller
sse42::BVH4Triangle4iIntersector4HybridPluecker
sse42::BVH4Triangle4iIntersectorStreamMoeller
sse42::BVH4Triangle4iIntersectorStreamPluecker
sse42::BVH4Triangle4iMBIntersector1Moeller
sse42::BVH4Triangle4iMBIntersector1Pluecker
sse42::BVH4Triangle4iMBIntersector4HybridMoeller
sse42::BVH4Triangle4iMBIntersector4HybridPluecker
sse42::BVH4Triangle4vIntersector1Pluecker
sse42::BVH4Triangle4vIntersector4HybridPluecker
sse42::BVH4Triangle4vIntersectorStreamPluecker
sse42::BVH4Triangle4vMBIntersector1Moeller
sse42::BVH4Triangle4vMBIntersector1Pluecker
sse42::BVH4Triangle4vMBIntersector4HybridMoeller
sse42::BVH4Triangle4vMBIntersector4HybridPluecker
sse42::BVH4VirtualIntersector1
sse42::BVH4VirtualIntersector4Chunk
sse42::BVH4VirtualIntersectorStream
sse42::BVH4VirtualMBIntersector1
sse42::BVH4VirtualMBIntersector4Chunk
sse42::BVH4XfmTriangle4Intersector1Moeller
sse42::QBVH4Triangle4iIntersector1Pluecker
sso;2b
st* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults  // Hit results \n    , __global int* stack \n    ) \n{ \n \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef GLOBAL_STACK  \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef GLOBAL_STACK  \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults   // Hit results \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef GLOBAL_STACK  \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny
st:PM
stackPtr < stackEnd
startThreads@TaskScheduler@embree@@CAXXZ
startThreads@ThreadPool@TaskScheduler@embree@@QEAAXXZ
start_threads
state not recoverable
static
static scenes can only contain static geometries
static scenes cannot get modified
staticMesh
stdcall
stream buffer empty
stream end
stream error
stream timeout
stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \n__kernel void segmented_scan_exclusive_int_nocut(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_nocut_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n \n__kernel void segmented_distribute_part_sum_int( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    //inout_array[globalId
stride <= unsigned(inf
stride of vertex buffers have to be identical for each time step
string
string too long
stλ$oZ
subTrees[subtrees] == ref
subdiv_accel
subdiv_accel_mb
subdivision surfaces
subdivpatch1cached
subdivs
subtrees < MAX_NUM_SUB_TREES
success
sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; in_flags[globalId + i] == 0 && i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                inout_array[globalId + i] += sum; \n            } \n        } \n    } \n} \n \n__kernel void segmented_distribute_part_sum_int_nocut( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    bool stop = false; \n    //inout_array[globalId] += sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                if (in_flags[globalId + i] == 0) \n                { \n                    inout_array[globalId + i] += sum; \n                } \n                else \n                { \n                    if (stop) \n                    { \n                        break; \n                    } \n                    else \n                    { \n                        inout_array[globalId + i] += sum; \n                        stop = true; \n                    } \n                } \n            } \n        } \n    } \n} \n
supported
sw@;E
swapThread@TaskScheduler@embree@@CAPEAUThread@12@PEAU312@@Z
swedish-finland
swift_1
swift_2
sy\v:6
syr-SY
syr-sy
s|@9l
sºJlֺM
s»;6P
sǙ=di
s͛=Ei
sϺu`M9
sݹsQM
s移\erH
s躭\te
t $;c
t ]9p
t!+V\bH
t!1;zP
t!:6C
t!Hc\vH
t!s99\v3
t" fC
t#B;o
t#k:M
t$ ATAUAVAWE3
t$ AUAVAWH
t$ AVH
t$ AWH
t$ L;p\b
t$ L;r\b
t$ M#f\bt
t$ UATAUAVAWH
t$ UWATAVAWH
t$ UWAVH
t$ UWAWH
t$ WATAUAVAWH
t$ WATAVH
t$ WAVAWH
t$ ba|H
t$(A2
t$(ba|H
t$0L;p\b
t$0fff
t$0ŸX
t$48_\bu?H
t$@HcD
t$@IcD
t$@M#f\bt
t$@fff
t$HA_A^A]A
t$HHǅp
t$HL9{0
t$HL;x\b
t$HM+t$@I
t$O7:\a
t$PHc
t$PIcD
t$PfE
t$PfH
t$Pu!A
t$PňT5
t$PňT5n
t$XH;t$P
t$XIcD
t$XIcmlC
t$\bM+4$L
t$`fB
t$`v&Ncd
t$`ňTEP
t$dI91
t$ht\fH
t$pD;nD
t$pHc
t$pňXD$P
t$pňYE
t$pŠT5
t$pŨXM
t$x3\tD$HH
t$xE3
t$xHcOH
t$xLc
t%TvZ
t%fE9\bt
t&b;Ab
t'HcG
t'L;\rQA
t'j=2\fB
t'ѹm3
t(9Z\ae
t(:dIf
t(c<@_j9aE
t)D8l$@t\fH
t)IcV\bH
t* fC
t+;RU
t+z:X
t,D8p0t
t,D8x0t
t-Z;anJ
t-s;D
t.;bzZ
t.C<p
t.k:H9
t.ۺubL
t/D8p0t
t/D8x0t
t/̺Ttz
t0 fff
t099\t
t0<Yi
t0@fff
t0\e:R
t0t1.size() > 0.0f
t0t1i.empty
t1?"t1?"t1?"t1
t1p;ˣ\b
t2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    c
t2V<Ϛ0
t3 b1
t38C0t
t3<S-a
t3ܻA\a
t4;ExF
t4N;V
t4\b\bd<\b
t4\e;9V
t4z;@;k
t5\b\bd<\b
t5\t 0
t5ƺO/M
t6$:N
t6B<g
t6P=H\f
t6p7MOf
t7A8@0t1A
t7A8A0t1A
t7t9]9m
t7ݹIMj
t8<Q.I
t8=j&꼪o
t8=tD
t8B: \b
t8M<TTs
t8Tڿ:baK
t8d<xvt
t8r<G
t95:B
t9Cʈ8
t9Oa0
t9q x
t:!xC
t:1iV
t:3]T
t:B0\r
t:DkL
t:\at
t:_Li
t:c\a\e
t:dS\a9
t:lyY
t:o[4
t:uEZ
t;.9t9
t;8F|:G
t;:ZM
t;GR4;KKY
t;J479
t;O\av
t;TXQ9
t;\aJt
t;\e5f
t;\vw\n:sT\r
t;eAK
t;hR\f
t;ig4
t;pcl:V
t;qs\r
t;y8z
t;ܣɻGcA
t< >M
t<$6C
t<%fH
t<*dK<7
t<:r8
t<;FP
t<@cO
t<Fer
t<J"˻3O
t<R8u
t<\e3
t<\rN\e9
t<\tFU
t<b8o9Hu
t<jeܻ6
t<u<Y
t<u=4<I
t<wTj
t<zTa9b
t=8dE
t=A8@0t7A
t=A8A0t7A
t=UWټi
t=\aMf>,u
t=\fO
t=cl;=L
t=gW켼\fg
t>&EF
t>QW2
t>Yj >h~5
t>\bU
t>n;r
t>u}9
t>͛g<4F
t?@b1
t?L;YᴻL
t?X5I
t@)fLL
t@HcS\bH
t@REF%08lX
t@\b\bdH\b
tA<DF
tA@8s)u2H
tAO:q
tA\v9
tB9\a4
tB:,NR
tB<#b
tCI9I
tCU:Y
tD='sC
tDA;m$t>H
tDH9\nu
tDĻ&cS
tE=@8
tF*<ZIj
tF;^d
tF=A䴼th
tG<zmZ
tGѻ.N
tH#:P
tH+X@I
tH696d
tH;\r2U
tH;\rVU
tH;\rY
tHкKY
tI@8{:t
tJ:4zs
tJ>\a
tJR>8o
tK9_\bt
tK@8{:t
tKI=dXW
tL$@fD
tL:\t0
tL;!lD
tLg:C
tLջJ0
tM99WC
tM:>V|;mB
tMF<TV
tM\e;>m
tN:;\fP
tNear[index] >= 0.0f
tNear[r0] >= 0.0f
tNear[r1] >= 0.0f
tO,>f
tO;7Q
tP@;r
tPH951
tPϹƃg
tQ:|nG
tQD8c:u0M
tQX<sF
tQfD9 tK
tQg;l
tR$;9p
tRV=\v
tR躽1ݹY
tSf91tNH
tT-:Ch
tT-L7e
tT:V05
tT\r%Nf
tTػRa
tV9;\v\e
tV;#4
tVf91tQH
tVݻr\r
tW=1¬=n
tWt:ttt
tX+>a
tX-< Gd
tXF:OPͺo
tX\b%dW\b%4V\b
tZ<eGv<\b4
t\a-<jv
t\a:Z
t\a?GY\r
t\aA\v
t\aH9D$PuCH
t\f;e
t\fH;Q@s
t\fO;l¯:Y
t\n<0u
t\n<0uC
t\nF?s
t\nH9P A
t\nI9Jhs
t\nL9Qhs
t\nbatH
t\r98t\fH
t\r; iҼn
t\r;vW
t\r@88t\vH
t\rL#\r
t\rL#\rk
t\rL#\rkE
t\rfD9\nu\a
t\t\n:9
t\v>\fw
t\vK9D'\b
t`:MK
ta97zX
ta;e,F
ta<pN
taL9Chu
tail[BUCKETS-1] == head[BUCKETS-1] + count[BUCKETS-1
tail[BUCKETS-1] == num
task cancelled
task stack overflow
tb!T@Yt\t
tb!|H
tbA\\HYe\ab
tbA|H
tbI<XO
tbQ|H
tbad(W
tba|H
tba|\b
tba}Hp
tbq}HpɱbA
tbq}HpбbA
tc7=P
tc;7!C
tc蹇k9
tdm;O1h
te=\tGR
tessellation_cache_size
text file busy
text$di
text$mn
text$mn$00
text$x
text$yd
tf/<LP
tf<KN
tfffffff
tg;iY
th*;073
th/;On
th9@p
th<V3̻I
thiscall
thread the following way
thread@TaskScheduler@embree@@CAPEAUThread@12@XZ
threadCount@TaskScheduler@embree@@SA_KXZ
threadCounter == 0
threadID@TaskScheduler@embree@@SA_KXZ
threadIndex < threadLocal.size
threadIndex@TaskScheduler@embree@@SA_KXZ
threadLocal[threadIndex].load() == nullptr
threads
thy<F
ti;?z$9
ti;ڣ0;M
tiY:SV
ti\e>I
timed out
tj;+Z
tj;5R
tjL;@(H
tk<\vD
tkE>fvw
tk\a=W
tl;\bGE
tlT9t
tl\v*dk\v*4j\v
tls$ZZZ
tm\f;q
tn$;Wc
tn)=0O
tn,<w7
tnM;:Lf
tn\v*dm\v*4l\v
tny<l\nB
to:\taع4
to;6O
too many files open
too many files open in system
too many length or distance symbols
too many links
too many symbolic link levels
total
total            : sah
tp;GJl
tp;bJ̺j
tp<\nZ3
tpH91uk
tp[9\aO
tp\b`\a0
tp\b`\aP
tpɼy\tw
tr%<.Om
tr:b51
tr\v>l(C
transform.elements[iRow][iColumn
transformNodes
traverser
traverser_mb
tri_accel
tri_accel_mb
tri_builder
tri_builder_mb
tri_traverser
tri_traverser_mb
triangle4
triangle4i
triangle4v
triangle4vmb
triangles
trinidad & tobago
ts,<aM
ts;Hj
tsg:B
ts̸pv
tt$xD
tv;<D~G
tv>`I6=yW
tvL<U
tvûY`ԻA
twx\\w
tx<w]Y
tx\a*dw\a*4v\a
txмkn
ty<Geometry::NUM_TYPES
tyfD9 tsH
typeof
types & BVH_MB) || (ray.time >= 0.0f && ray.time <= 1.0f
types & BVH_MB) || all(valid, (ray.time >= 0.0f) & (ray.time <= 1.0f
tz/9u1
tz\a>yI5
t{757
t{<j4
t}9;p
t}һO\r0
t~; Q
t~E;C
t»Wv̻Hu
t¼!8W
tƻCrb8"q
tʊD$8
tл\tm
tѣ<EW
tӎ;3u
tӺP\e\r
t۹>WJ
tۺ$4f
t⻲x\n
t焹G!y
t蝼^Pf
t뾖2j<C
u HcA<H
u ba|H
u }<w88
u!bA|H
u%A8x,u
u(;3EV
u(k:9
u+L=B
u. ;BS0
u.>:wSG
u0H;u
u0I;]8
u1!D$0H
u1D9{\bu+M
u4L;] t.L
u4\f<$v
u6ɸNGq
u7;otR;U
u7n;w7
u7t=fD
u8;-h
u8@8t$pu1H
u8@8{,u2L
u8M9\av3I
u8U\e
u9<%F
u::wG
u:B\tP
u:R$h
u:h[0:U
u;2*m
u;5tg
u;;UsK
u;H"n
u;Lx9P쉺c
u;UȪ9
u;seؼr
u<>xg
u<K\nQ<f
u<\rDk
u<ջiR
u=K,J
u>2jh
u@:SG
uA8D$`t\bH
uA;=Ne`=aE
uB<_Kt
uBa|)CG
uC<Y3V
uD=W2
uDx;!\e
uE:4Z
uF<xXߺR
uHI9U8v
uHI9U8v(I
uJA:4a
uJ\rBTA
uK8o-\a
uK;xXL
uMcσ~\b
uN:w\n*9T
uN漘\e
uOɼ3\r
uP96K\v9
uQ8G\buAH
uQr;s
uV;U\n
uWh<Z
uX뼔y\t<\b
uY<opx<c
uY\v:A
uZ;u{\v
uZEeu\b
u\abA
u\b< t;<\tt7
u\b<oel
u\bM;h\b
u\bM;i\b
u\bM;n\b
u\bbA|H
u\bbA|I
u\bbQ|H
u\bh;I
u\ee<XT
u\f9\r
u\fbQ|H
u\nA8
u\nA84
u\nA8_P
u\nD8AP
u\rb>g
u\rba,HY
u\rba|H
u\rfD9d$0
u\rw=Uf
u\t<BFb
u\tb"-H
u\tbA
u\tbA4HYM
u\v>W
u]D8O\buIH
u^8G\buGH
u^n=Zn
u_H:dB
ua;'W
uaA8_\buEI
ub'vb'v
ucF:\\T
ucO;oO09
udt returning
uf!T$(H!T
uf\v:5n
uh4;E9u
uh{:8
ui="jf
uiA8_\buEI
uint randomNumber,\n                           float scalar,\n                           global Ray* shadowRays,\n                           global Ray* reflectedRays,\n                           global float4* energyDelay,\n                           global float4* accumEnergyDelay)\n{\n    size_t numChunks = max(numListeners, numSources);\n    size_t numPrimaryRays = get_global_size(0) / numChunks;\n    size_t numShadowRays = get_global_size(0);\n\n    uint rayIndex = (numListeners > 1) ? get_global_id(0) : (get_global_id(0) % numPrimaryRays);\n    uint chunkIndex = get_global_id(0) / numPrimaryRays;\n    uint listenerIndex = (numListeners > 1) ? chunkIndex : 0;\n    uint sourceIndex = (numSources > 1) ? chunkIndex : 0;\n    uint shadowRayIndex = get_global_id(0);\n\n    // If this ray is disabled, don't do anything.\n    if (rays[rayIndex].extra.y == 0 || hits[rayIndex].primid < 0)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        reflectedRays[rayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n        return;\n    }\n\n    // Random number generation for work group.\n    local RNG rng;\n    local float randomFloat;\n    local uint randomUint;\n    if (get_local_id(0) == 0)\n    {\n        initRNG(randomNumber + rayIndex, &rng);\n        randomFloat = randFloat(&rng);\n        randomUint = randUint(&rng);\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    // Calculate hit point.\n    float3 rayDirection = rays[rayIndex].d.xyz;\n    int triangleIndex = hits[rayIndex].primid;\n    float hitDistance = hits[rayIndex].uvwt.s3;\n    float3 hitPoint = rays[rayIndex].o.xyz + hitDistance * rayDirection;\n\n    // Calculate hit normal.\n    float3 hitNormal = normals[triangleIndex].xyz;\n    if (dot(hitNormal, rayDirection) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    // Calculate hit material.\n    Material hitMaterial = materials[materialIndices[triangleIndex]];\n    float3 hitMaterialAbsorption = (float3) (hitMaterial.absorptionLow, hitMaterial.absorptionMid, hitMaterial.absorptionHigh);\n\n    // Calculate shadow ray direction.\n    float3 source = sources[sourceIndex].origin;\n    float hitToSourceDistance = distance(hitPoint, source);\n    float4 hitToSource = (float4) (normalize(source - hitPoint), 0.0f);\n\n    // Skip the ray if:\n    //  a) the hit point is inside the listener, or\n    //  b) the hit point is too close to the source, or\n    //  c) the ray hit a backfacing triangle.\n    if (hitDistance <= LISTENER_RADIUS ||\n        hitToSourceDistance <= irradianceMinDistance ||\n        dot(hitToSource.xyz, hitNormal) < 0.0f)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n    }\n    else\n    {\n        // Generate the shadow ray.\n        shadowRays[shadowRayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * hitToSource.xyz, hitToSourceDistance);\n        shadowRays[shadowRayIndex].d = hitToSource;\n        shadowRays[shadowRayIndex].extra = (int2) (0xffffffff, 1);\n\n        // Calculate shading values.\n        float3 energy = (1.0f / PI) * hitMaterial.scattering * max(0.0f, dot(hitNormal, hitToSource.xyz));\n        energy += ((SPECULAR_EXPONENT + 2.0f) / (8.0f * PI)) * (1.0f - hitMaterial.scattering) * pow(fabs(dot(normalize(hitToSource.xyz - rayDirection), hitNormal)), SPECULAR_EXPONENT);\n        energy *= scalar;\n        energy *= evaluateDirectivity(hitPoint, sources[sourceIndex], directivities[sourceIndex]);\n        energy *= pointSourceIrradiance(hitToSourceDistance, irradianceMinDistance);\n        energy *= accumEnergyDelay[rayIndex].xyz * ((float3) 1.0f - hitMaterialAbsorption);\n\n        float delay = (hitDistance + hitToSourceDistance) / SPEED_OF_SOUND;\n        delay += accumEnergyDelay[rayIndex].w - (distance(source, listeners[listenerIndex].origin) / SPEED_OF_SOUND);\n\n        energyDelay[shadowRayIndex] = (float4) (energy, delay);\n    }\n\n    barrier(CLK_GLOBAL_MEM_FENCE);\n\n    // Generate the bounced ray.\n    if (numListeners > 1 || sourceIndex == 0)\n    {\n
um;o(k
umٺ\bC
un;DW
unaligned
unalignedNodes
unalignedNodesMB
united-kingdom
united-states
unknown
unknown buffer type
unknown builder
unknown compression method
unknown error
unknown exception caught
unknown header flags set
unknown motion blur triangle acceleration structure
unknown readable parameter
unknown traverser
unknown triangle acceleration structure
unknown user geometry accel
unknown user geometry mblur accel
unknown writable parameter
unsigned int)timesegments < max_time_steps
unsigned(morton[j]) >> shift) & (BUCKETS-1)) == i
unsigned(v) >> shift & (BUCKETS-1)) == i
uoA8]\buMI
up traversing bottom level BVH \n        // in this case idx = 0xFFFFFFFF and topidx has valid value \n        if (idx == -1 && topidx != -1) \n        { \n            //  Proceed to next top level node \n            idx = (int)(scenedata->nodes[topidx].pmax.w); \n            // Set topidx \n            topidx = -1; \n            // Restore ray here \n            *r = topray; \n            // Restore invdir \n            invdir = invdirtop; \n        } \n    } \n \n    return false; \n} \n \n \n// 2 level variants \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n) \n{ \n \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest2L(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny2L(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    __global int* numrays,     // Number of rays in the workload \n    int offset,                // Offset in rays array \n    __global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest2L(&scenedata, &r, &isect); \n \n
up;Ijf
updateTransform
upŸYMp
upƺ%W
uq`:)SK
us=;aI
usE8E\buQI
use_single_mode
used blocks
usemtl material_%d\n
user32
usergeom
using
uuNu'uu
uv+:t
uv\r;DF
uwo;Pw
uxHc\r
uz-UZ-Cyrl
uz-UZ-Latn
uz-uz-cyrl
uz-uz-latn
uɊ9Rbj9
uɺ=z8
uδ;cf
uϋD$$LcL$(Hcl
uԋ<8Q
uݼ,Jn
v %f %f %f\n
v ><W
v Lc\\$8I
v ɺM119
v";jd
v#9Lo_9
v#S;Pe
v$G<@A4
v%m=k
v(D+v0D
v)0;Px
v)9%4o
v)\a=Q2
v-;bG6
v-Y:\ev
v-o;~z7
v.<zBA
v0,<\nTF
v0<a_\n
v1d-v0d) != 0.0f
v1ͻ&e
v2!L.2
v2;[8e
v2Z;s\f
v4#:0
v4.x = v4.y; v4.y += t; \n    t = v4.z; v4.z = v4.w; v4.w += t; \n    *offset3 = v4; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    *histogram = total; \n} \n \n// Calculate bool radix mask \nshort4 radix_mask(int offset, uchar digit, int4 val) \n{ \n    short4 res; \n    res.x = ((val.x >> offset) & 3) == digit ? 1 : 0; \n    res.y = ((val.y >> offset) & 3) == digit ? 1 : 0; \n    res.z = ((val.z >> offset) & 3) == digit ? 1 : 0; \n    res.w = ((val.w >> offset) & 3) == digit ? 1 : 0; \n    return res; \n} \n \n// Choose offset based on radix mask value  \nshort offset_4way(int val, int offset, short offset0, short offset1, short offset2, short offset3, short4 hist) \n{ \n    switch ((val >> offset) & 3) \n    { \n    case 0: \n        return offset0; \n    case 1: \n        return offset1 + hist.x; \n    case 2: \n        return offset2 + hist.x + hist.y; \n    case 3: \n        return offset3 + hist.x + hist.y + hist.z; \n    } \n \n    return 0; \n} \n \n \n \n// Perform group split using 2-bits pass \nvoid group_split_radix_2bits( \n    int localId, \n    int groupSize, \n    int offset, \n    int4 val, \n    __local short* shmem, \n    int4* localOffset, \n    short4* histogram) \n{ \n    /// Pointers to radix flag arrays \n    __local short* shmem0 = shmem; \n    __local short* shmem1 = shmem0 + groupSize; \n    __local short* shmem2 = shmem1 + groupSize; \n    __local short* shmem3 = shmem2 + groupSize; \n \n    /// Radix masks for each digit \n    short4 mask0 = radix_mask(offset, 0, val); \n    short4 mask1 = radix_mask(offset, 1, val); \n    short4 mask2 = radix_mask(offset, 2, val); \n    short4 mask3 = radix_mask(offset, 3, val); \n \n    /// Resulting offsets \n    short4 offset0; \n    short4 offset1; \n    short4 offset2; \n    short4 offset3; \n \n    group_scan_short_4way(localId, groupSize, \n        mask0, mask1, mask2, mask3, \n        shmem0, shmem1, shmem2, shmem3, \n        &offset0, &offset1, &offset2, &offset3, \n        histogram); \n \n    (*localOffset).x = offset_4way(val.x, offset, offset0.x, offset1.x, offset2.x, offset3.x, *histogram); \n    (*localOffset).y = offset_4way(val.y, offset, offset0.y, offset1.y, offset2.y, offset3.y, *histogram); \n    (*localOffset).z = offset_4way(val.z, offset, offset0.z, offset1.z, offset2.z, offset3.z, *histogram); \n    (*localOffset).w = offset_4way(val.w, offset, offset0.w, offset1.w, offset2.w, offset3.w, *histogram); \n} \n \nint4 safe_load_int4_intmax(__global int4* source, uint idx, uint sizeInInts) \n{ \n    int4 res = make_int4(INT_MAX, INT_MAX, INT_MAX, INT_MAX); \n    if (((idx + 1) << 2) <= sizeInInts) \n        res = source[idx]; \n    else \n    { \n        if ((idx << 2) < sizeInInts) res.x = source[idx].x; \n        if ((idx << 2) + 1 < sizeInInts) res.y = source[idx].y; \n        if ((idx << 2) + 2 < sizeInInts) res.z = source[idx].z; \n    } \n    return res; \n} \n \nvoid safe_store_int(int val, __global int* dest, uint idx, uint sizeInInts) \n{ \n    if (idx < sizeInInts) \n        dest[idx] = val; \n} \n \n// Split kernel launcher \n__kernel void split4way(int bitshift, __global int4* in_array, uint numElems, __global int* out_histograms, __global int4* out_array, \n    __global int* out_local_histograms, \n    __global int4* out_debug_offset, \n    __local short* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n    int numGroups = get_global_size(0) / groupSize; \n \n    /// Load single int4 value \n    int4 val = safe_load_int4_intmax(in_array, globalId, numElems); \n \n    int4 localOffset; \n    short4 localHistogram; \n    group_split_radix_2bits(localId, groupSize, bitshift, val, shmem, &localOffset, \n        &localHistogram); \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    __local int* sharedData = (__local int*)shmem; \n    __local int4* sharedData4 = (__local int4*)shmem; \n \n    sharedData[localOffset.x] = val.x; \n    sharedData[localOffset.y] = val.y; \n    sharedData[localOffset.z] = val.z; \n    shar
v4:6ݸ;f
v5?:7IN;\e
v5\v 0
v5~:P
v6:Gq\n
v8F9\n
v9&;D
v9+M=9
v9A^5
v9d[z
v9o{W
v:+YC
v:5Il;˅N
v:;C5\n
v:<mF2;T,\b<uNV
v:JzK
v:M:3
v:X$T
v:ZQS
v:\br\t:H
v:kaH:l
v:lP :TFt82
v:պH\aa8
v;)mM9
v;0^8
v;509;4
v;:Pl
v;D\v
v;S\r
v;Us3;G
v;Zy\e
v;\tLr;{tb
v;\tnʺSF
v;`n5
v;dW><K
v;oOc:L
v;reO
v;s}p
v;w0N
v;x;K
v<Aj\n
v<F㴻JV
v<eiƼ1
v<er󻗇\t
v<n$b;L\r
v<~0p
v=#hD
v=Qeh
v=Y]Bv
v=YiZ
v>'5C
v>P9#>nV
v>x掾2
v>yE\v
v>{Ed=o
v>Ĩ\f>JfJ>MM
v?,\tm2
v?PDt?a
v@DIMENSION_SCALE
v@L:qY
vA03>A
vA;b\n
vBF:\r
vC<RDJ<s
vCք\tes\vC
vDN<V
vD\v$H
vF;6S8
vF<a5L
vG|HO
vH9y\bu
vH;A\bu
vH;Q\bu
vH;Q\bu\rL
vHȻd(5
vK;A\fL
vL77㉼Q
vL9u O
vL<2N
vL{j\t\f
vLûbSv:̦I
vM8¶R
vM>TYӾI
vMW;q#6=2
vM~;Av
vN;\fLu
vNcD\b
vNr:oU
vO,;Y2
vO<lCF
vPE;E
vQ;7&N
vQ츟Xc
vR!;0
vSc<bAӽy
vT$9f
vT;nur;W
vT;|j
vTv<F
vU˻=nT
vValve Corp.0
vValve Corp.1
vWf;Ob\e
vX:s,\e
vX廑|Q;K
v[;\r6s
v[GbO\b
v\\8E5
v\a4:n
v\bD;3
v\f(<BI
v\f>GvS
v\f̺e\t
v\n\f;C4
v\nbatH
v\t;~y0
v\t<8Rj
v\t>k
v\tL;Y
v\tbQ|H
v\tcvo
v\tݺEx\v
v\v_;VYf:UPH
v\vɻz
v^>\nhh
validi == -1
value too large
vaw</i
vaݺ\nkt
vb"5H
vb-;R
vb:<I
vb:o\t
vb<PK
vbA|H
vbA|\b
vbB5H
vbQ|H
vban\bX
vbase destructor
vba|H
vbqLHX
vbtable
vc<PM?;l
vcall
vde=s
vd˺;U
ve;;w
vector constructor iterator
vector copy constructor iterator
vector deleting destructor
vector destructor iterator
vector too long
vector vbase constructor iterator
vector vbase copy constructor iterator
vector<T> too long
vectorcall
verbose
verbosity
vertex buffer can be at most 16GB large
vertices
veɹt쵺5
vf;2yt
vf=;,UG;e
vf?;A@F
vftable
vg\v;.JB;N
vh:L=9
vh;Am
vhT;m$k
virtual displacement map
vj&<SS
vj8jB49
vla;"Y
vm:ay
vm:ay̺K\n
vm;9)t
vm<R\b
vn;\b
vo$;E
vp$;V/A
vp\nP!\r
vp\n`\tP\b0
vp\n`\tP\b0\b
vq9xk
vq;?7\t
vq;p\n
vq<<3
vqJ=C
vs:'cl
vsd=\fJ
vt;\vqi
vt\r<x
vt}<x
vu:XXR
vvܻOs
vwFHcN
vw˼R識4
vx=-o
vx\r=YG
vy;."w9\b
vy}:\nD
vz̻UWC
vzټw2D
v{;9I&9
v|G9RT
v}8<\bo
v}ŹWl#9!L
v~9;UF
v~:oe
v~o<gS
vä;OH
vĎ:Hf
vʉL;\fH
v̺B8c
vΉL;\fH
vӽ9NB\n:3
vԥ;aY
vܻh+G;0I
vߔ<Av
v↻vhW
w"ʻvbV
w$j:3\n
w%7;9Q
w':UlO
w(A+w0A
w+=P8
w+\r<s\no
w,a;Yk
w.:IQ
w/:3\aw
w0<s4
w0<y6\n
w0\t<3u
w0Ӻo)9
w11:c
w2&:sx
w29iN\t
w4;\tp
w4G;\r\f
w4_;W
w5<;V
w9T\rM
w9\r쭺>zr
w:RΙ;P9
w;"Nd
w;7aٻ7r
w;G9\a
w;W:2
w;\nJ
w;\t㊽xY
w;oC?<4
w;rWz;5
w;sG\n
w;tGB
w;w"L
w;y?J
w<0|H
w<v0c
w<wB\f
w=^eI
w=wSN
w>B7c
wA]A\\]_^[ÐSVWUATAUH
wA^A]A
wA_A^A]A
wB;9ٳ;S
wB<1\a
wBE9)t
wD:ę\t7
wF7=1D
wF;wk绢J
wF\\:Pjb
wF\e;Vf
wG0:\a
wGB:Jρ:F
wH:|7
wH;S\b
wH;\rVN
wH;\rWQ
wH;\rwT
wIE9)tD
wIz<=Ug
wJ\r9
wJ\v<$p
wLC<ɬ\e
wLD9`HtF
wM;GI
wNM:>Vk9M
wOb:mj
wQ<:\nT
wQ?;g
wSԼD\n
wT:;dsp
wT:Fv\e
wT\t=\a
wY:%E\n
wZ:Wv
wZw=www w
w\\K:pz
w\a9xx\a0hy\a'4
w\a<I
w\a\t
w\b:E\auj
w\bUUUU
w\bf;E\auuA
w\eu;\e
w\f;˪k9
w\fS:hC
w\t9\v/};xrb
w]A_A
w]A_A^A
w^;5aD
w_*<GaQ
w_F;P
wait@TaskScheduler@embree@@SA_NXZ
wasted
wb9X-s
we;\nS8
weV=Fq
wgQ=]h
wgj;p49
wh?9nMW
wi_<a
wiںSys
wl989d
wlY>s
wlԼ\r
wn>Jj
wn_;Ysڻs
workItemSamples[j];\n\t\t\tfloat y = (b0 * x) + (b1 * xm1) + (b2 * xm2) - (a1 * ym1) - (a2 * ym2);\n\n\t\t\txm2 = xm1;\n\t\t\txm1 = x;\n\t\t\tym2 = ym1;\n\t\t\tym1 = y;\n\n\t\t\tworkItemSamples[j] = y;\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tsignal[i + j] = workItemSamples[j];\n\t\t}\n    }\n}\n\n// todo: linear reconstruction?\nkernel void reconstructImpulseResponse(global int* energy,\n\t\t\t\t\t\t\t\t\t   uint samplingRate,\n                                       uint samplesPerBin,\n\t\t\t\t\t\t\t\t\t   uint numSamples,\n\t\t\t\t\t\t\t\t\t   global float* airAbsorption,\n\t\t\t\t\t\t\t\t\t   global IIR* filters,\n                                       global float* whiteNoise,\n                                       global float* impulseResponse,\n                                       uint offset,\n\t\t\t\t\t\t\t\t\t   float scale)\n{\n    size_t bin = get_global_id(0);\n    size_t band = get_global_id(1);\n    size_t channel = get_global_id(2);\n\tsize_t numBins = get_global_size(0);\n    size_t numBands = get_global_size(1);\n    size_t numChannels = get_global_size(2);\n\n    global float* impulseResponseBin = &impulseResponse[offset + (channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n    global float* whiteNoiseBin = &whiteNoise[(channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n\n    float e0 = (float)energy[0*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n    float e = (float)energy[channel*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n\n    if (fabs(e) < ENERGY_THRESHOLD || fabs(e0) < ENERGY_THRESHOLD)\n    {\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = 0.0f;\n        }\n    }\n    else\n    {\n        float tMean = ((bin + 0.5f) * samplesPerBin) / samplingRate;\n        float tVariance = MIN_VARIANCE;\n\n        int sample = bin * samplesPerBin;\n        float binEnergy = 0.0f;\n\n        float t = sample / (float) samplingRate;\n        float dt = 1.0f / (float) samplingRate;\n\n        float g = exp(-((t - tMean) * (t - tMean)) / (2.0f * tVariance));\n        float dg = exp(-(dt * ((2.0f * (t - tMean)) + dt)) / (2.0f * tVariance));\n        float ddg = exp(-(dt * dt) / tVariance);\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = g * whiteNoiseBin[i];\n            binEnergy += impulseResponseBin[i] * impulseResponseBin[i];\n            g *= dg;\n            dg *= ddg;\n        }\n\n        float normalization = e / sqrt(e0 * sqrt(4.0f * PI));\n\n        normalization *= exp(-0.5f * airAbsorption[band] * SPEED_OF_SOUND * ((bin + 0.5f) * samplesPerBin * (1.0f / samplingRate)));\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] *= normalization;\n        }\n    }\n}\n\nkernel void combineBandpassedImpulseResponse(uint numSamples,\n                                             global float* bandImpulseResponses,\n\t\t\t\t\t\t\t\t\t\t\t global float* impulseResponse)\n{\n    size_t sample = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t batch = get_global_id(2);\n\tsize_t numChannels = get_global_size(1);\n\n\tfloat value = 0.0f;\n\n    for (int i = 0; i < NUM_BANDS; ++i)\n    {\n        value += bandImpulseResponses[(batch * numChannels * NUM_BANDS * numSamples) + (channel * NUM_BANDS * numSamples) + (i * numSamples) + sample];\n    }\n\n\timpulseResponse[(batch * numChannels * numSamples) + (channel * numSamples) + sample] = value;\n}\n
wp\b>\tX
wqu:B
wrong protocol type
wrɼCk
ws1:Mt
ws;PXR
wt4:M
wv;\r\f\r
www.digicert.com1!0
www.digicert.com1$0
wxԺ\r/7
wy:-hs9
wyh;\b
wz@7\n
wzT<\f
wz\n=#qn
w{9YM
w|y<Q
w};b7\f
w¹Sg̺n
wÐUAWAVAUATVWS
wĢ<EC
w˼QPü`V
w̺MK}<6
wξ\fZD>L
wϼ{Tl
wԹ3\aB9
wպOY2
wڗ:GY
w۹qVO
w㔻97\b
w挽\b8
x :\e)K
x ATAVAWH
x AUAVAWH
x AVHcA
x UATAUAVAWH
x(D$pH
x(L$ H
x(L$0H
x(L$0L
x(L$PH
x(L$PL
x(T$ H
x(d$0I
x(l$ H
x(t$PL
x(t$pL
x)L$PH
x)L$PI
x)T$`Hc
x)d$0I
x)d$`Hc
x)d$pH
x)l$ H
x)t$PL
x+9- G8
x+:xb
x+<efI
x-;CT0
x.>5bF
x.S9L
x/L\n(v
x2;\rTS
x4:sS
x4D>qI
x8:Sb(8h
x8}0\t9
x9:\nV
x9;Fu
x:;dH\e
x:P5Q:Zx
x:U8ǻi
x:\fd2
x:\rhN
x:f#9
x:ۚ\e9Fl
x;)Li
x;<a 9p
x;CaR
x;Er\v
x;MҠ9
x;R7̻1
x;\eI\a
x;hKR
x;q_x9
x;uLO
x;|8O
x<$OV
x<1f켹c
x<EHv
x<J\r
x<qio
x=&UǽWN4
x>0\n
x>Q<\aQ
x>V6'?C
x?;1BN
x?S;3
x@bB%H6
xA_A^A]A
xB-zC\f
xC<@x
xEV<V
xFG;vMV
xG :*魹h
xG)=p
xH<jc
xHY9#yn
xJ>Hf
xJF;E6
xM;\\YU
xN.<S
xN\v<>,l6
xP:Ed\r
xQ*;A
xQ4:\fF
xR;[SA:L
xRZ;U
xS69:yX
xU";c
xU9:O
xU:b~\a
xU;qGK
xWI96tRI
xWؽX"K
xX'>ubW<]1
xX8:ՄJ
xXL& ġHY
xXL+ ġ@Y
xXL. āHY
xXL. ġHY
xXL0 L
xXL0 ġHY
xXL1 āHY
xXL2 āHY
xXL2 ġHY
xXL4 ġHY
xX\r<Xx
xXs<S
xYD$0ŨY
xYD$`H
xYT  H
xYl$PŰY
xYnPŸY
xYoPŸY
xZ\n:2
x[9[xE
x[Q:xJx
x\\g:cH
x\aH;m
x\bH+8H
x\bntelu
x\f=9Z\a
x\nIcL$l
x\n|\fX\n
x\v;f#C
x\vD$0H
x\vL;0
x]A_A^A]A
x]L$pH
x_x;5
x`D<7J
xa9;EJ
xbػ(Ri
xdata
xdata$x
xdp>n
xe;&j
xeq<H
xf;}ws
xh"9A
xjͻKQs
xk]:45R
xl;!\r5
xn5;|:A
xo78$E
xoM=6
xoؾvK
xpxxxx\b\a\b\a
xr<Ir
xs;6y
xuĻv\fx
xw;^n
xwg=.,f
xwֻ\an
xxJ;*\f
xxJ<&X
xy<Aq9
xǊ:2C
xϻ8go
xؙ9eUl
xݻhṻI
y ba~\b
y º KI
y!A 0H
y!A@0H
y!X8 H
y!`8 I
y!p8 H
y!x8 H
y!x8 I
y"D!P
y"D"P
y"D\fP
y&:kw
y(J9h1
y+Y<w
y+{YB
y-N:Pv
y.<Hm
y.K91\aZ:-E
y/8Qv
y0G=XM
y1d<0
y2@\e
y2o9,p\b
y2úڪZ
y3H:wO
y4<G3
y5zo1
y63˼}l
y67;\eq
y9.9W
y9<wh
y9\r`y
y9`;S
y9k>":0
y9x0C;\n
y:)Jp
y:< 6K
y:@FO
y:Bm(:t
y:\rz
y:oSj
y;-y5
y;;vV
y;aAڻeD
y;cev:V
y;ƗJ:Vt
y;ƼPDx
y<;TDf
y<L9{0
y<W%7
y<l:lEV
y=F:LO
y=e;q\t
y=uYX
y=u\n3
y=ľS=jz
y>(0r
y?Nny
yA9TYi
yA<\fM
yEٺn3
yI!<o;P
yJ=0xN>7
yKc:\n
yM:'S`9
yM<pIл[!j
yM>ȞI
yN<qyC
yNӻ!n{bk
yO>;g
yQ&<C7
yTw:Nr
yU;J\vǻty
yY;rY8
yZy;ᴀ:t
y\\PD
y\a\b
y\b< Dn9
y\bH+9H
y\bL+9H
y\bW;,l
y\bba~\b
y\eq;d
y\fúbM
y\r<o
y\r=5
y\rk;b\b
y\tV<&h
y\v;\vNX
y^O;T
y_U;O\t
ya=OYY
yb;\rA
ycI<p
ycO:"K
yd=Oi
ygV:J(6
yj';f
yl苼$P\r
yn->l7
ynD#PHc
ynL'Pģq"L#P
yni;t
you can use rtcSetIntersectFunctionN only in stream mode
you can use rtcSetIntersectionFilterFunctionN only in stream mode
you can use rtcSetOccludedFunctionN only in stream mode
you can use rtcSetOcclusionFilterFunctionN only in stream mode
you have to use rtcSetIntersectFunctionN (and optionally rtcSetIntersectFunction1Mp) in stream mode
you have to use rtcSetIntersectionFilterFunctionN in stream mode
you have to use rtcSetOccludedFunctionN (and optionally rtcSetOccludedFunction1Mp) in stream mode
you have to use rtcSetOcclusionFilterFunctionN in stream mode
you have to wait for spawned subtasks
yp; \eA
ypg<9M
ypm;pR
yrL9JT
ys,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults  // Hit results \n    , __global int* stack \n    ) \n{ \n \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef LDS_BUG \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef LDS_BUG \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults   // Hit results \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef LDS_BUG \n            hitresults[global_i
ytV;D
yuϻ%NX
yv;\v
yzC<Z
y~;8J
yȺ\nY
yɻP.K
y̺4\e6
yͺ:rN-7
yϻ/Z0
y耺SC\a
z <tHm
z v"z$\t
z!U:I
z";WF
z&:RC
z*Y9Pw
z+R<4T
z,;EAI
z096?\a
z0=|Q
z0U;6x
z0\f>L
z1=<D
z2v;Ns
z4:(lk
z4:NA
z4\f<Elf
z4v?\f\b
z7:hv¹p_v
z7<Gi
z7H<ur
z8J:X
z8W;r=A;ATB
z8\axغB
z8v>\r
z8ڻad
z9>z\rf
z9MdU;\nV
z9ں;u
z: SR
z:2\v
z:3:D8a0
z:3{g:xp
z:> R9f
z:bIm
z:c夺Q
z:jPj
z:o4.;E
z:vhT
z;7WH
z;GRt
z;\tOg<K
z;bhD
z;g<p
z;qbC
z;ѲI;7I
z<62P
z<;<fvu
z<rc+;\al9<gn
z<t\f
z=;NSH
z=T/P=tA
z=l4ݽw
z>W\f
z>h4Ժ/so
z?<5T
z?ƽA\t3
zA*=c
zA7<EU
zF;u+\f
zGf:XV
zH\t=p
zJ6;[O
zJ;߸89
zL<&Cs;2
zL\r;N
zQv<>8
zR>_OB
zRB:5
zRc;>E
zUżL^Q
zWM;L
zX\a;N
zXq ŊY
zX|Dz
zY0v;C
zY6;j
zY;>u:m\t
zYt\a
z\aGl
z\aba|\b
z\bH+:H
z\e3<,S
z\fba~\b
z\r=t
z\rba|\b
z\t:|FO
z\tb"u\b
z\tbA
z\tba|\b
z\tba~\b
z\tƼ\a켭 w
z\v2;\a
z\vba~\b
z\vܺ78
z^\r;hU
zb2:E
ze<58\e
zg;9_ûc
zh-CHS
zh-CHT
zh-chs
zh-cht
zh:8n
zh\f:\n
zhb>f
zi3==\aR
zi9uMe
zi<g)C
ziS<D
zjS:6>Q:aph
zk3:\t(5
zkD;=N
zm?9CD
zmϼ`8r
zn==bR
znӺWT
zo% pj
zo%$Hh
zo%+ H
zo%+Qj
zo%,UH
zo%-BH
zo%51I
zo%@\fh
zo%Kz
zo%NGj
zo%Xfh
zo%\fx
zo%\v{j
zo%_9h
zo%aEI
zo%gs
zo%h'H
zo%h(U
zo%k\bf
zo%knJ
zo%n:U
zo%n\aL
zo-.QW
zo-QdW
zo-R@W
zo562X
zo56KU
zo5\tQU
zo5d$K
zo5~&Q
zo=!4f
zo=5+K
zo=H\aW
zo=M+n
zo=N2X
zo=a<X
zo=bEK
zo=i\nN
zo=jOh
zo=lxf
zo=smh
zo=tIX
zoD$\bMc
zoG\bMc
zoL$pH
zoT$pL
zo\r8\tf
zo\rD^T
zo\rVSe
zo\r\v|T
zo\r_YG
zo\ra"f
zo\rt0M
zo\rz,W
zo\r|RK
zq<gCn
zqz:r
zr`:o
zsX<\r
zt;\ar
ztߺv\a4
zut<[H
zwc΅]E
zx ;ɾn
zx%ܻK
zz1;j1
zzp;lQ
z~4\bġz
z~=gC
z˺jwx:c
z̓;9WG
zͻyp˻\aL
zѻ>\tCp
zּNDf
z߳;Rk
z㹭6/:oĤ6q
